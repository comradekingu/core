
/**
 * Client
**/

import * as runtime from './runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model subscription
 * 
 */
export type subscription = $Result.DefaultSelection<Prisma.$subscriptionPayload>
/**
 * Model abonnements_sorties
 * 
 */
export type abonnements_sorties = $Result.DefaultSelection<Prisma.$abonnements_sortiesPayload>
/**
 * Model purchase
 * 
 */
export type purchase = $Result.DefaultSelection<Prisma.$purchasePayload>
/**
 * Model authorUser
 * 
 */
export type authorUser = $Result.DefaultSelection<Prisma.$authorUserPayload>
/**
 * Model bibliotheque_contributeurs
 * 
 */
export type bibliotheque_contributeurs = $Result.DefaultSelection<Prisma.$bibliotheque_contributeursPayload>
/**
 * Model bookcasePublicationOrder
 * 
 */
export type bookcasePublicationOrder = $Result.DefaultSelection<Prisma.$bookcasePublicationOrderPayload>
/**
 * Model bookstore
 * 
 */
export type bookstore = $Result.DefaultSelection<Prisma.$bookstorePayload>
/**
 * Model bookstoreComment
 * 
 */
export type bookstoreComment = $Result.DefaultSelection<Prisma.$bookstoreCommentPayload>
/**
 * Model demo
 * 
 */
export type demo = $Result.DefaultSelection<Prisma.$demoPayload>
/**
 * Model magazines
 * 
 */
export type magazines = $Result.DefaultSelection<Prisma.$magazinesPayload>
/**
 * Model issue
 * 
 */
export type issue = $Result.DefaultSelection<Prisma.$issuePayload>
/**
 * Model issuePopularity
 * 
 */
export type issuePopularity = $Result.DefaultSelection<Prisma.$issuePopularityPayload>
/**
 * Model tranches_doublons
 * 
 */
export type tranches_doublons = $Result.DefaultSelection<Prisma.$tranches_doublonsPayload>
/**
 * Model edge
 * 
 */
export type edge = $Result.DefaultSelection<Prisma.$edgePayload>
/**
 * Model tranches_pretes_contributeurs
 * 
 */
export type tranches_pretes_contributeurs = $Result.DefaultSelection<Prisma.$tranches_pretes_contributeursPayload>
/**
 * Model tranches_pretes_contributions
 * 
 */
export type tranches_pretes_contributions = $Result.DefaultSelection<Prisma.$tranches_pretes_contributionsPayload>
/**
 * Model edgeSprite
 * 
 */
export type edgeSprite = $Result.DefaultSelection<Prisma.$edgeSpritePayload>
/**
 * Model edgeSpriteSize
 * 
 */
export type edgeSpriteSize = $Result.DefaultSelection<Prisma.$edgeSpriteSizePayload>
/**
 * Model edgeSpriteUrl
 * 
 */
export type edgeSpriteUrl = $Result.DefaultSelection<Prisma.$edgeSpriteUrlPayload>
/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>
/**
 * Model userContribution
 * 
 */
export type userContribution = $Result.DefaultSelection<Prisma.$userContributionPayload>
/**
 * Model userOption
 * 
 */
export type userOption = $Result.DefaultSelection<Prisma.$userOptionPayload>
/**
 * Model userPasswordToken
 * 
 */
export type userPasswordToken = $Result.DefaultSelection<Prisma.$userPasswordTokenPayload>
/**
 * Model userPermission
 * 
 */
export type userPermission = $Result.DefaultSelection<Prisma.$userPermissionPayload>
/**
 * Model users_points
 * 
 */
export type users_points = $Result.DefaultSelection<Prisma.$users_pointsPayload>
/**
 * Model userSuggestionNotification
 * 
 */
export type userSuggestionNotification = $Result.DefaultSelection<Prisma.$userSuggestionNotificationPayload>
/**
 * Model requestedIssue
 * 
 */
export type requestedIssue = $Result.DefaultSelection<Prisma.$requestedIssuePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const issue_condition: {
  mauvais: 'mauvais',
  moyen: 'moyen',
  bon: 'bon',
  indefini: 'indefini'
};

export type issue_condition = (typeof issue_condition)[keyof typeof issue_condition]


export const tranches_pretes_contributeurs_contribution: {
  photographe: 'photographe',
  createur: 'createur'
};

export type tranches_pretes_contributeurs_contribution = (typeof tranches_pretes_contributeurs_contribution)[keyof typeof tranches_pretes_contributeurs_contribution]


export const tranches_pretes_contributions_contribution: {
  photographe: 'photographe',
  createur: 'createur'
};

export type tranches_pretes_contributions_contribution = (typeof tranches_pretes_contributions_contribution)[keyof typeof tranches_pretes_contributions_contribution]


export const userOptionType: {
  suggestion_notification_country: 'suggestion_notification_country',
  sales_notification_publications: 'sales_notification_publications',
  marketplace_contact_methods: 'marketplace_contact_methods'
};

export type userOptionType = (typeof userOptionType)[keyof typeof userOptionType]


export const users_permissions_privilege: {
  Admin: 'Admin',
  Edition: 'Edition',
  Affichage: 'Affichage'
};

export type users_permissions_privilege = (typeof users_permissions_privilege)[keyof typeof users_permissions_privilege]


export const userContributionType: {
  photographe: 'photographe',
  createur: 'createur',
  duckhunter: 'duckhunter'
};

export type userContributionType = (typeof userContributionType)[keyof typeof userContributionType]

}

export type issue_condition = $Enums.issue_condition

export const issue_condition: typeof $Enums.issue_condition

export type tranches_pretes_contributeurs_contribution = $Enums.tranches_pretes_contributeurs_contribution

export const tranches_pretes_contributeurs_contribution: typeof $Enums.tranches_pretes_contributeurs_contribution

export type tranches_pretes_contributions_contribution = $Enums.tranches_pretes_contributions_contribution

export const tranches_pretes_contributions_contribution: typeof $Enums.tranches_pretes_contributions_contribution

export type userOptionType = $Enums.userOptionType

export const userOptionType: typeof $Enums.userOptionType

export type users_permissions_privilege = $Enums.users_permissions_privilege

export const users_permissions_privilege: typeof $Enums.users_permissions_privilege

export type userContributionType = $Enums.userContributionType

export const userContributionType: typeof $Enums.userContributionType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Subscriptions
 * const subscriptions = await prisma.subscription.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Subscriptions
   * const subscriptions = await prisma.subscription.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.subscription`: Exposes CRUD operations for the **subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.subscriptionDelegate<ExtArgs>;

  /**
   * `prisma.abonnements_sorties`: Exposes CRUD operations for the **abonnements_sorties** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Abonnements_sorties
    * const abonnements_sorties = await prisma.abonnements_sorties.findMany()
    * ```
    */
  get abonnements_sorties(): Prisma.abonnements_sortiesDelegate<ExtArgs>;

  /**
   * `prisma.purchase`: Exposes CRUD operations for the **purchase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Purchases
    * const purchases = await prisma.purchase.findMany()
    * ```
    */
  get purchase(): Prisma.purchaseDelegate<ExtArgs>;

  /**
   * `prisma.authorUser`: Exposes CRUD operations for the **authorUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuthorUsers
    * const authorUsers = await prisma.authorUser.findMany()
    * ```
    */
  get authorUser(): Prisma.authorUserDelegate<ExtArgs>;

  /**
   * `prisma.bibliotheque_contributeurs`: Exposes CRUD operations for the **bibliotheque_contributeurs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bibliotheque_contributeurs
    * const bibliotheque_contributeurs = await prisma.bibliotheque_contributeurs.findMany()
    * ```
    */
  get bibliotheque_contributeurs(): Prisma.bibliotheque_contributeursDelegate<ExtArgs>;

  /**
   * `prisma.bookcasePublicationOrder`: Exposes CRUD operations for the **bookcasePublicationOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookcasePublicationOrders
    * const bookcasePublicationOrders = await prisma.bookcasePublicationOrder.findMany()
    * ```
    */
  get bookcasePublicationOrder(): Prisma.bookcasePublicationOrderDelegate<ExtArgs>;

  /**
   * `prisma.bookstore`: Exposes CRUD operations for the **bookstore** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookstores
    * const bookstores = await prisma.bookstore.findMany()
    * ```
    */
  get bookstore(): Prisma.bookstoreDelegate<ExtArgs>;

  /**
   * `prisma.bookstoreComment`: Exposes CRUD operations for the **bookstoreComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookstoreComments
    * const bookstoreComments = await prisma.bookstoreComment.findMany()
    * ```
    */
  get bookstoreComment(): Prisma.bookstoreCommentDelegate<ExtArgs>;

  /**
   * `prisma.demo`: Exposes CRUD operations for the **demo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Demos
    * const demos = await prisma.demo.findMany()
    * ```
    */
  get demo(): Prisma.demoDelegate<ExtArgs>;

  /**
   * `prisma.magazines`: Exposes CRUD operations for the **magazines** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Magazines
    * const magazines = await prisma.magazines.findMany()
    * ```
    */
  get magazines(): Prisma.magazinesDelegate<ExtArgs>;

  /**
   * `prisma.issue`: Exposes CRUD operations for the **issue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Issues
    * const issues = await prisma.issue.findMany()
    * ```
    */
  get issue(): Prisma.issueDelegate<ExtArgs>;

  /**
   * `prisma.issuePopularity`: Exposes CRUD operations for the **issuePopularity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IssuePopularities
    * const issuePopularities = await prisma.issuePopularity.findMany()
    * ```
    */
  get issuePopularity(): Prisma.issuePopularityDelegate<ExtArgs>;

  /**
   * `prisma.tranches_doublons`: Exposes CRUD operations for the **tranches_doublons** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tranches_doublons
    * const tranches_doublons = await prisma.tranches_doublons.findMany()
    * ```
    */
  get tranches_doublons(): Prisma.tranches_doublonsDelegate<ExtArgs>;

  /**
   * `prisma.edge`: Exposes CRUD operations for the **edge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Edges
    * const edges = await prisma.edge.findMany()
    * ```
    */
  get edge(): Prisma.edgeDelegate<ExtArgs>;

  /**
   * `prisma.tranches_pretes_contributeurs`: Exposes CRUD operations for the **tranches_pretes_contributeurs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tranches_pretes_contributeurs
    * const tranches_pretes_contributeurs = await prisma.tranches_pretes_contributeurs.findMany()
    * ```
    */
  get tranches_pretes_contributeurs(): Prisma.tranches_pretes_contributeursDelegate<ExtArgs>;

  /**
   * `prisma.tranches_pretes_contributions`: Exposes CRUD operations for the **tranches_pretes_contributions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tranches_pretes_contributions
    * const tranches_pretes_contributions = await prisma.tranches_pretes_contributions.findMany()
    * ```
    */
  get tranches_pretes_contributions(): Prisma.tranches_pretes_contributionsDelegate<ExtArgs>;

  /**
   * `prisma.edgeSprite`: Exposes CRUD operations for the **edgeSprite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EdgeSprites
    * const edgeSprites = await prisma.edgeSprite.findMany()
    * ```
    */
  get edgeSprite(): Prisma.edgeSpriteDelegate<ExtArgs>;

  /**
   * `prisma.edgeSpriteSize`: Exposes CRUD operations for the **edgeSpriteSize** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EdgeSpriteSizes
    * const edgeSpriteSizes = await prisma.edgeSpriteSize.findMany()
    * ```
    */
  get edgeSpriteSize(): Prisma.edgeSpriteSizeDelegate<ExtArgs>;

  /**
   * `prisma.edgeSpriteUrl`: Exposes CRUD operations for the **edgeSpriteUrl** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EdgeSpriteUrls
    * const edgeSpriteUrls = await prisma.edgeSpriteUrl.findMany()
    * ```
    */
  get edgeSpriteUrl(): Prisma.edgeSpriteUrlDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs>;

  /**
   * `prisma.userContribution`: Exposes CRUD operations for the **userContribution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserContributions
    * const userContributions = await prisma.userContribution.findMany()
    * ```
    */
  get userContribution(): Prisma.userContributionDelegate<ExtArgs>;

  /**
   * `prisma.userOption`: Exposes CRUD operations for the **userOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserOptions
    * const userOptions = await prisma.userOption.findMany()
    * ```
    */
  get userOption(): Prisma.userOptionDelegate<ExtArgs>;

  /**
   * `prisma.userPasswordToken`: Exposes CRUD operations for the **userPasswordToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPasswordTokens
    * const userPasswordTokens = await prisma.userPasswordToken.findMany()
    * ```
    */
  get userPasswordToken(): Prisma.userPasswordTokenDelegate<ExtArgs>;

  /**
   * `prisma.userPermission`: Exposes CRUD operations for the **userPermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPermissions
    * const userPermissions = await prisma.userPermission.findMany()
    * ```
    */
  get userPermission(): Prisma.userPermissionDelegate<ExtArgs>;

  /**
   * `prisma.users_points`: Exposes CRUD operations for the **users_points** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users_points
    * const users_points = await prisma.users_points.findMany()
    * ```
    */
  get users_points(): Prisma.users_pointsDelegate<ExtArgs>;

  /**
   * `prisma.userSuggestionNotification`: Exposes CRUD operations for the **userSuggestionNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSuggestionNotifications
    * const userSuggestionNotifications = await prisma.userSuggestionNotification.findMany()
    * ```
    */
  get userSuggestionNotification(): Prisma.userSuggestionNotificationDelegate<ExtArgs>;

  /**
   * `prisma.requestedIssue`: Exposes CRUD operations for the **requestedIssue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestedIssues
    * const requestedIssues = await prisma.requestedIssue.findMany()
    * ```
    */
  get requestedIssue(): Prisma.requestedIssueDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.2.0
   * Query Engine version: 2804dc98259d2ea960602aca6b8e7fdc03c1758f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    subscription: 'subscription',
    abonnements_sorties: 'abonnements_sorties',
    purchase: 'purchase',
    authorUser: 'authorUser',
    bibliotheque_contributeurs: 'bibliotheque_contributeurs',
    bookcasePublicationOrder: 'bookcasePublicationOrder',
    bookstore: 'bookstore',
    bookstoreComment: 'bookstoreComment',
    demo: 'demo',
    magazines: 'magazines',
    issue: 'issue',
    issuePopularity: 'issuePopularity',
    tranches_doublons: 'tranches_doublons',
    edge: 'edge',
    tranches_pretes_contributeurs: 'tranches_pretes_contributeurs',
    tranches_pretes_contributions: 'tranches_pretes_contributions',
    edgeSprite: 'edgeSprite',
    edgeSpriteSize: 'edgeSpriteSize',
    edgeSpriteUrl: 'edgeSpriteUrl',
    user: 'user',
    userContribution: 'userContribution',
    userOption: 'userOption',
    userPasswordToken: 'userPasswordToken',
    userPermission: 'userPermission',
    users_points: 'users_points',
    userSuggestionNotification: 'userSuggestionNotification',
    requestedIssue: 'requestedIssue'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'subscription' | 'abonnements_sorties' | 'purchase' | 'authorUser' | 'bibliotheque_contributeurs' | 'bookcasePublicationOrder' | 'bookstore' | 'bookstoreComment' | 'demo' | 'magazines' | 'issue' | 'issuePopularity' | 'tranches_doublons' | 'edge' | 'tranches_pretes_contributeurs' | 'tranches_pretes_contributions' | 'edgeSprite' | 'edgeSpriteSize' | 'edgeSpriteUrl' | 'user' | 'userContribution' | 'userOption' | 'userPasswordToken' | 'userPermission' | 'users_points' | 'userSuggestionNotification' | 'requestedIssue'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      subscription: {
        payload: Prisma.$subscriptionPayload<ExtArgs>
        fields: Prisma.subscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.subscriptionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.subscriptionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>
          }
          findFirst: {
            args: Prisma.subscriptionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.subscriptionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>
          }
          findMany: {
            args: Prisma.subscriptionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>[]
          }
          create: {
            args: Prisma.subscriptionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>
          }
          createMany: {
            args: Prisma.subscriptionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.subscriptionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>
          }
          update: {
            args: Prisma.subscriptionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>
          }
          deleteMany: {
            args: Prisma.subscriptionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.subscriptionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.subscriptionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.subscriptionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.subscriptionCountArgs<ExtArgs>,
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      abonnements_sorties: {
        payload: Prisma.$abonnements_sortiesPayload<ExtArgs>
        fields: Prisma.abonnements_sortiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.abonnements_sortiesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$abonnements_sortiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.abonnements_sortiesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$abonnements_sortiesPayload>
          }
          findFirst: {
            args: Prisma.abonnements_sortiesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$abonnements_sortiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.abonnements_sortiesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$abonnements_sortiesPayload>
          }
          findMany: {
            args: Prisma.abonnements_sortiesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$abonnements_sortiesPayload>[]
          }
          create: {
            args: Prisma.abonnements_sortiesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$abonnements_sortiesPayload>
          }
          createMany: {
            args: Prisma.abonnements_sortiesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.abonnements_sortiesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$abonnements_sortiesPayload>
          }
          update: {
            args: Prisma.abonnements_sortiesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$abonnements_sortiesPayload>
          }
          deleteMany: {
            args: Prisma.abonnements_sortiesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.abonnements_sortiesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.abonnements_sortiesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$abonnements_sortiesPayload>
          }
          aggregate: {
            args: Prisma.Abonnements_sortiesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAbonnements_sorties>
          }
          groupBy: {
            args: Prisma.abonnements_sortiesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Abonnements_sortiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.abonnements_sortiesCountArgs<ExtArgs>,
            result: $Utils.Optional<Abonnements_sortiesCountAggregateOutputType> | number
          }
        }
      }
      purchase: {
        payload: Prisma.$purchasePayload<ExtArgs>
        fields: Prisma.purchaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.purchaseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$purchasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.purchaseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$purchasePayload>
          }
          findFirst: {
            args: Prisma.purchaseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$purchasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.purchaseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$purchasePayload>
          }
          findMany: {
            args: Prisma.purchaseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$purchasePayload>[]
          }
          create: {
            args: Prisma.purchaseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$purchasePayload>
          }
          createMany: {
            args: Prisma.purchaseCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.purchaseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$purchasePayload>
          }
          update: {
            args: Prisma.purchaseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$purchasePayload>
          }
          deleteMany: {
            args: Prisma.purchaseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.purchaseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.purchaseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$purchasePayload>
          }
          aggregate: {
            args: Prisma.PurchaseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePurchase>
          }
          groupBy: {
            args: Prisma.purchaseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PurchaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.purchaseCountArgs<ExtArgs>,
            result: $Utils.Optional<PurchaseCountAggregateOutputType> | number
          }
        }
      }
      authorUser: {
        payload: Prisma.$authorUserPayload<ExtArgs>
        fields: Prisma.authorUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.authorUserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$authorUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.authorUserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$authorUserPayload>
          }
          findFirst: {
            args: Prisma.authorUserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$authorUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.authorUserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$authorUserPayload>
          }
          findMany: {
            args: Prisma.authorUserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$authorUserPayload>[]
          }
          create: {
            args: Prisma.authorUserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$authorUserPayload>
          }
          createMany: {
            args: Prisma.authorUserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.authorUserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$authorUserPayload>
          }
          update: {
            args: Prisma.authorUserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$authorUserPayload>
          }
          deleteMany: {
            args: Prisma.authorUserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.authorUserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.authorUserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$authorUserPayload>
          }
          aggregate: {
            args: Prisma.AuthorUserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAuthorUser>
          }
          groupBy: {
            args: Prisma.authorUserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AuthorUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.authorUserCountArgs<ExtArgs>,
            result: $Utils.Optional<AuthorUserCountAggregateOutputType> | number
          }
        }
      }
      bibliotheque_contributeurs: {
        payload: Prisma.$bibliotheque_contributeursPayload<ExtArgs>
        fields: Prisma.bibliotheque_contributeursFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bibliotheque_contributeursFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bibliotheque_contributeursPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bibliotheque_contributeursFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bibliotheque_contributeursPayload>
          }
          findFirst: {
            args: Prisma.bibliotheque_contributeursFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bibliotheque_contributeursPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bibliotheque_contributeursFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bibliotheque_contributeursPayload>
          }
          findMany: {
            args: Prisma.bibliotheque_contributeursFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bibliotheque_contributeursPayload>[]
          }
          create: {
            args: Prisma.bibliotheque_contributeursCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bibliotheque_contributeursPayload>
          }
          createMany: {
            args: Prisma.bibliotheque_contributeursCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.bibliotheque_contributeursDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bibliotheque_contributeursPayload>
          }
          update: {
            args: Prisma.bibliotheque_contributeursUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bibliotheque_contributeursPayload>
          }
          deleteMany: {
            args: Prisma.bibliotheque_contributeursDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.bibliotheque_contributeursUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.bibliotheque_contributeursUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bibliotheque_contributeursPayload>
          }
          aggregate: {
            args: Prisma.Bibliotheque_contributeursAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBibliotheque_contributeurs>
          }
          groupBy: {
            args: Prisma.bibliotheque_contributeursGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Bibliotheque_contributeursGroupByOutputType>[]
          }
          count: {
            args: Prisma.bibliotheque_contributeursCountArgs<ExtArgs>,
            result: $Utils.Optional<Bibliotheque_contributeursCountAggregateOutputType> | number
          }
        }
      }
      bookcasePublicationOrder: {
        payload: Prisma.$bookcasePublicationOrderPayload<ExtArgs>
        fields: Prisma.bookcasePublicationOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bookcasePublicationOrderFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bookcasePublicationOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bookcasePublicationOrderFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bookcasePublicationOrderPayload>
          }
          findFirst: {
            args: Prisma.bookcasePublicationOrderFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bookcasePublicationOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bookcasePublicationOrderFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bookcasePublicationOrderPayload>
          }
          findMany: {
            args: Prisma.bookcasePublicationOrderFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bookcasePublicationOrderPayload>[]
          }
          create: {
            args: Prisma.bookcasePublicationOrderCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bookcasePublicationOrderPayload>
          }
          createMany: {
            args: Prisma.bookcasePublicationOrderCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.bookcasePublicationOrderDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bookcasePublicationOrderPayload>
          }
          update: {
            args: Prisma.bookcasePublicationOrderUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bookcasePublicationOrderPayload>
          }
          deleteMany: {
            args: Prisma.bookcasePublicationOrderDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.bookcasePublicationOrderUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.bookcasePublicationOrderUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bookcasePublicationOrderPayload>
          }
          aggregate: {
            args: Prisma.BookcasePublicationOrderAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBookcasePublicationOrder>
          }
          groupBy: {
            args: Prisma.bookcasePublicationOrderGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BookcasePublicationOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.bookcasePublicationOrderCountArgs<ExtArgs>,
            result: $Utils.Optional<BookcasePublicationOrderCountAggregateOutputType> | number
          }
        }
      }
      bookstore: {
        payload: Prisma.$bookstorePayload<ExtArgs>
        fields: Prisma.bookstoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bookstoreFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bookstorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bookstoreFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bookstorePayload>
          }
          findFirst: {
            args: Prisma.bookstoreFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bookstorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bookstoreFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bookstorePayload>
          }
          findMany: {
            args: Prisma.bookstoreFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bookstorePayload>[]
          }
          create: {
            args: Prisma.bookstoreCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bookstorePayload>
          }
          createMany: {
            args: Prisma.bookstoreCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.bookstoreDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bookstorePayload>
          }
          update: {
            args: Prisma.bookstoreUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bookstorePayload>
          }
          deleteMany: {
            args: Prisma.bookstoreDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.bookstoreUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.bookstoreUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bookstorePayload>
          }
          aggregate: {
            args: Prisma.BookstoreAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBookstore>
          }
          groupBy: {
            args: Prisma.bookstoreGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BookstoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.bookstoreCountArgs<ExtArgs>,
            result: $Utils.Optional<BookstoreCountAggregateOutputType> | number
          }
        }
      }
      bookstoreComment: {
        payload: Prisma.$bookstoreCommentPayload<ExtArgs>
        fields: Prisma.bookstoreCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bookstoreCommentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bookstoreCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bookstoreCommentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bookstoreCommentPayload>
          }
          findFirst: {
            args: Prisma.bookstoreCommentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bookstoreCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bookstoreCommentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bookstoreCommentPayload>
          }
          findMany: {
            args: Prisma.bookstoreCommentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bookstoreCommentPayload>[]
          }
          create: {
            args: Prisma.bookstoreCommentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bookstoreCommentPayload>
          }
          createMany: {
            args: Prisma.bookstoreCommentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.bookstoreCommentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bookstoreCommentPayload>
          }
          update: {
            args: Prisma.bookstoreCommentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bookstoreCommentPayload>
          }
          deleteMany: {
            args: Prisma.bookstoreCommentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.bookstoreCommentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.bookstoreCommentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bookstoreCommentPayload>
          }
          aggregate: {
            args: Prisma.BookstoreCommentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBookstoreComment>
          }
          groupBy: {
            args: Prisma.bookstoreCommentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BookstoreCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.bookstoreCommentCountArgs<ExtArgs>,
            result: $Utils.Optional<BookstoreCommentCountAggregateOutputType> | number
          }
        }
      }
      demo: {
        payload: Prisma.$demoPayload<ExtArgs>
        fields: Prisma.demoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.demoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$demoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.demoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$demoPayload>
          }
          findFirst: {
            args: Prisma.demoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$demoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.demoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$demoPayload>
          }
          findMany: {
            args: Prisma.demoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$demoPayload>[]
          }
          create: {
            args: Prisma.demoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$demoPayload>
          }
          createMany: {
            args: Prisma.demoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.demoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$demoPayload>
          }
          update: {
            args: Prisma.demoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$demoPayload>
          }
          deleteMany: {
            args: Prisma.demoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.demoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.demoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$demoPayload>
          }
          aggregate: {
            args: Prisma.DemoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDemo>
          }
          groupBy: {
            args: Prisma.demoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DemoGroupByOutputType>[]
          }
          count: {
            args: Prisma.demoCountArgs<ExtArgs>,
            result: $Utils.Optional<DemoCountAggregateOutputType> | number
          }
        }
      }
      magazines: {
        payload: Prisma.$magazinesPayload<ExtArgs>
        fields: Prisma.magazinesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.magazinesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$magazinesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.magazinesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$magazinesPayload>
          }
          findFirst: {
            args: Prisma.magazinesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$magazinesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.magazinesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$magazinesPayload>
          }
          findMany: {
            args: Prisma.magazinesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$magazinesPayload>[]
          }
          create: {
            args: Prisma.magazinesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$magazinesPayload>
          }
          createMany: {
            args: Prisma.magazinesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.magazinesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$magazinesPayload>
          }
          update: {
            args: Prisma.magazinesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$magazinesPayload>
          }
          deleteMany: {
            args: Prisma.magazinesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.magazinesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.magazinesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$magazinesPayload>
          }
          aggregate: {
            args: Prisma.MagazinesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMagazines>
          }
          groupBy: {
            args: Prisma.magazinesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MagazinesGroupByOutputType>[]
          }
          count: {
            args: Prisma.magazinesCountArgs<ExtArgs>,
            result: $Utils.Optional<MagazinesCountAggregateOutputType> | number
          }
        }
      }
      issue: {
        payload: Prisma.$issuePayload<ExtArgs>
        fields: Prisma.issueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.issueFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$issuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.issueFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$issuePayload>
          }
          findFirst: {
            args: Prisma.issueFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$issuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.issueFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$issuePayload>
          }
          findMany: {
            args: Prisma.issueFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$issuePayload>[]
          }
          create: {
            args: Prisma.issueCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$issuePayload>
          }
          createMany: {
            args: Prisma.issueCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.issueDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$issuePayload>
          }
          update: {
            args: Prisma.issueUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$issuePayload>
          }
          deleteMany: {
            args: Prisma.issueDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.issueUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.issueUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$issuePayload>
          }
          aggregate: {
            args: Prisma.IssueAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIssue>
          }
          groupBy: {
            args: Prisma.issueGroupByArgs<ExtArgs>,
            result: $Utils.Optional<IssueGroupByOutputType>[]
          }
          count: {
            args: Prisma.issueCountArgs<ExtArgs>,
            result: $Utils.Optional<IssueCountAggregateOutputType> | number
          }
        }
      }
      issuePopularity: {
        payload: Prisma.$issuePopularityPayload<ExtArgs>
        fields: Prisma.issuePopularityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.issuePopularityFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$issuePopularityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.issuePopularityFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$issuePopularityPayload>
          }
          findFirst: {
            args: Prisma.issuePopularityFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$issuePopularityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.issuePopularityFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$issuePopularityPayload>
          }
          findMany: {
            args: Prisma.issuePopularityFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$issuePopularityPayload>[]
          }
          create: {
            args: Prisma.issuePopularityCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$issuePopularityPayload>
          }
          createMany: {
            args: Prisma.issuePopularityCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.issuePopularityDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$issuePopularityPayload>
          }
          update: {
            args: Prisma.issuePopularityUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$issuePopularityPayload>
          }
          deleteMany: {
            args: Prisma.issuePopularityDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.issuePopularityUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.issuePopularityUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$issuePopularityPayload>
          }
          aggregate: {
            args: Prisma.IssuePopularityAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIssuePopularity>
          }
          groupBy: {
            args: Prisma.issuePopularityGroupByArgs<ExtArgs>,
            result: $Utils.Optional<IssuePopularityGroupByOutputType>[]
          }
          count: {
            args: Prisma.issuePopularityCountArgs<ExtArgs>,
            result: $Utils.Optional<IssuePopularityCountAggregateOutputType> | number
          }
        }
      }
      tranches_doublons: {
        payload: Prisma.$tranches_doublonsPayload<ExtArgs>
        fields: Prisma.tranches_doublonsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tranches_doublonsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tranches_doublonsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tranches_doublonsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tranches_doublonsPayload>
          }
          findFirst: {
            args: Prisma.tranches_doublonsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tranches_doublonsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tranches_doublonsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tranches_doublonsPayload>
          }
          findMany: {
            args: Prisma.tranches_doublonsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tranches_doublonsPayload>[]
          }
          create: {
            args: Prisma.tranches_doublonsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tranches_doublonsPayload>
          }
          createMany: {
            args: Prisma.tranches_doublonsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.tranches_doublonsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tranches_doublonsPayload>
          }
          update: {
            args: Prisma.tranches_doublonsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tranches_doublonsPayload>
          }
          deleteMany: {
            args: Prisma.tranches_doublonsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.tranches_doublonsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.tranches_doublonsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tranches_doublonsPayload>
          }
          aggregate: {
            args: Prisma.Tranches_doublonsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTranches_doublons>
          }
          groupBy: {
            args: Prisma.tranches_doublonsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Tranches_doublonsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tranches_doublonsCountArgs<ExtArgs>,
            result: $Utils.Optional<Tranches_doublonsCountAggregateOutputType> | number
          }
        }
      }
      edge: {
        payload: Prisma.$edgePayload<ExtArgs>
        fields: Prisma.edgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.edgeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$edgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.edgeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$edgePayload>
          }
          findFirst: {
            args: Prisma.edgeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$edgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.edgeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$edgePayload>
          }
          findMany: {
            args: Prisma.edgeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$edgePayload>[]
          }
          create: {
            args: Prisma.edgeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$edgePayload>
          }
          createMany: {
            args: Prisma.edgeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.edgeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$edgePayload>
          }
          update: {
            args: Prisma.edgeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$edgePayload>
          }
          deleteMany: {
            args: Prisma.edgeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.edgeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.edgeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$edgePayload>
          }
          aggregate: {
            args: Prisma.EdgeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEdge>
          }
          groupBy: {
            args: Prisma.edgeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EdgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.edgeCountArgs<ExtArgs>,
            result: $Utils.Optional<EdgeCountAggregateOutputType> | number
          }
        }
      }
      tranches_pretes_contributeurs: {
        payload: Prisma.$tranches_pretes_contributeursPayload<ExtArgs>
        fields: Prisma.tranches_pretes_contributeursFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tranches_pretes_contributeursFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tranches_pretes_contributeursPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tranches_pretes_contributeursFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tranches_pretes_contributeursPayload>
          }
          findFirst: {
            args: Prisma.tranches_pretes_contributeursFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tranches_pretes_contributeursPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tranches_pretes_contributeursFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tranches_pretes_contributeursPayload>
          }
          findMany: {
            args: Prisma.tranches_pretes_contributeursFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tranches_pretes_contributeursPayload>[]
          }
          create: {
            args: Prisma.tranches_pretes_contributeursCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tranches_pretes_contributeursPayload>
          }
          createMany: {
            args: Prisma.tranches_pretes_contributeursCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.tranches_pretes_contributeursDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tranches_pretes_contributeursPayload>
          }
          update: {
            args: Prisma.tranches_pretes_contributeursUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tranches_pretes_contributeursPayload>
          }
          deleteMany: {
            args: Prisma.tranches_pretes_contributeursDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.tranches_pretes_contributeursUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.tranches_pretes_contributeursUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tranches_pretes_contributeursPayload>
          }
          aggregate: {
            args: Prisma.Tranches_pretes_contributeursAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTranches_pretes_contributeurs>
          }
          groupBy: {
            args: Prisma.tranches_pretes_contributeursGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Tranches_pretes_contributeursGroupByOutputType>[]
          }
          count: {
            args: Prisma.tranches_pretes_contributeursCountArgs<ExtArgs>,
            result: $Utils.Optional<Tranches_pretes_contributeursCountAggregateOutputType> | number
          }
        }
      }
      tranches_pretes_contributions: {
        payload: Prisma.$tranches_pretes_contributionsPayload<ExtArgs>
        fields: Prisma.tranches_pretes_contributionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tranches_pretes_contributionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tranches_pretes_contributionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tranches_pretes_contributionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tranches_pretes_contributionsPayload>
          }
          findFirst: {
            args: Prisma.tranches_pretes_contributionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tranches_pretes_contributionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tranches_pretes_contributionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tranches_pretes_contributionsPayload>
          }
          findMany: {
            args: Prisma.tranches_pretes_contributionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tranches_pretes_contributionsPayload>[]
          }
          create: {
            args: Prisma.tranches_pretes_contributionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tranches_pretes_contributionsPayload>
          }
          createMany: {
            args: Prisma.tranches_pretes_contributionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.tranches_pretes_contributionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tranches_pretes_contributionsPayload>
          }
          update: {
            args: Prisma.tranches_pretes_contributionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tranches_pretes_contributionsPayload>
          }
          deleteMany: {
            args: Prisma.tranches_pretes_contributionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.tranches_pretes_contributionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.tranches_pretes_contributionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tranches_pretes_contributionsPayload>
          }
          aggregate: {
            args: Prisma.Tranches_pretes_contributionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTranches_pretes_contributions>
          }
          groupBy: {
            args: Prisma.tranches_pretes_contributionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Tranches_pretes_contributionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tranches_pretes_contributionsCountArgs<ExtArgs>,
            result: $Utils.Optional<Tranches_pretes_contributionsCountAggregateOutputType> | number
          }
        }
      }
      edgeSprite: {
        payload: Prisma.$edgeSpritePayload<ExtArgs>
        fields: Prisma.edgeSpriteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.edgeSpriteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$edgeSpritePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.edgeSpriteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$edgeSpritePayload>
          }
          findFirst: {
            args: Prisma.edgeSpriteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$edgeSpritePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.edgeSpriteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$edgeSpritePayload>
          }
          findMany: {
            args: Prisma.edgeSpriteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$edgeSpritePayload>[]
          }
          create: {
            args: Prisma.edgeSpriteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$edgeSpritePayload>
          }
          createMany: {
            args: Prisma.edgeSpriteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.edgeSpriteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$edgeSpritePayload>
          }
          update: {
            args: Prisma.edgeSpriteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$edgeSpritePayload>
          }
          deleteMany: {
            args: Prisma.edgeSpriteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.edgeSpriteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.edgeSpriteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$edgeSpritePayload>
          }
          aggregate: {
            args: Prisma.EdgeSpriteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEdgeSprite>
          }
          groupBy: {
            args: Prisma.edgeSpriteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EdgeSpriteGroupByOutputType>[]
          }
          count: {
            args: Prisma.edgeSpriteCountArgs<ExtArgs>,
            result: $Utils.Optional<EdgeSpriteCountAggregateOutputType> | number
          }
        }
      }
      edgeSpriteSize: {
        payload: Prisma.$edgeSpriteSizePayload<ExtArgs>
        fields: Prisma.edgeSpriteSizeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.edgeSpriteSizeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$edgeSpriteSizePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.edgeSpriteSizeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$edgeSpriteSizePayload>
          }
          findFirst: {
            args: Prisma.edgeSpriteSizeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$edgeSpriteSizePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.edgeSpriteSizeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$edgeSpriteSizePayload>
          }
          findMany: {
            args: Prisma.edgeSpriteSizeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$edgeSpriteSizePayload>[]
          }
          create: {
            args: Prisma.edgeSpriteSizeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$edgeSpriteSizePayload>
          }
          createMany: {
            args: Prisma.edgeSpriteSizeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.edgeSpriteSizeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$edgeSpriteSizePayload>
          }
          update: {
            args: Prisma.edgeSpriteSizeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$edgeSpriteSizePayload>
          }
          deleteMany: {
            args: Prisma.edgeSpriteSizeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.edgeSpriteSizeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.edgeSpriteSizeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$edgeSpriteSizePayload>
          }
          aggregate: {
            args: Prisma.EdgeSpriteSizeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEdgeSpriteSize>
          }
          groupBy: {
            args: Prisma.edgeSpriteSizeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EdgeSpriteSizeGroupByOutputType>[]
          }
          count: {
            args: Prisma.edgeSpriteSizeCountArgs<ExtArgs>,
            result: $Utils.Optional<EdgeSpriteSizeCountAggregateOutputType> | number
          }
        }
      }
      edgeSpriteUrl: {
        payload: Prisma.$edgeSpriteUrlPayload<ExtArgs>
        fields: Prisma.edgeSpriteUrlFieldRefs
        operations: {
          findUnique: {
            args: Prisma.edgeSpriteUrlFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$edgeSpriteUrlPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.edgeSpriteUrlFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$edgeSpriteUrlPayload>
          }
          findFirst: {
            args: Prisma.edgeSpriteUrlFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$edgeSpriteUrlPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.edgeSpriteUrlFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$edgeSpriteUrlPayload>
          }
          findMany: {
            args: Prisma.edgeSpriteUrlFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$edgeSpriteUrlPayload>[]
          }
          create: {
            args: Prisma.edgeSpriteUrlCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$edgeSpriteUrlPayload>
          }
          createMany: {
            args: Prisma.edgeSpriteUrlCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.edgeSpriteUrlDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$edgeSpriteUrlPayload>
          }
          update: {
            args: Prisma.edgeSpriteUrlUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$edgeSpriteUrlPayload>
          }
          deleteMany: {
            args: Prisma.edgeSpriteUrlDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.edgeSpriteUrlUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.edgeSpriteUrlUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$edgeSpriteUrlPayload>
          }
          aggregate: {
            args: Prisma.EdgeSpriteUrlAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEdgeSpriteUrl>
          }
          groupBy: {
            args: Prisma.edgeSpriteUrlGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EdgeSpriteUrlGroupByOutputType>[]
          }
          count: {
            args: Prisma.edgeSpriteUrlCountArgs<ExtArgs>,
            result: $Utils.Optional<EdgeSpriteUrlCountAggregateOutputType> | number
          }
        }
      }
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      userContribution: {
        payload: Prisma.$userContributionPayload<ExtArgs>
        fields: Prisma.userContributionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userContributionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userContributionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userContributionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userContributionPayload>
          }
          findFirst: {
            args: Prisma.userContributionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userContributionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userContributionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userContributionPayload>
          }
          findMany: {
            args: Prisma.userContributionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userContributionPayload>[]
          }
          create: {
            args: Prisma.userContributionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userContributionPayload>
          }
          createMany: {
            args: Prisma.userContributionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.userContributionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userContributionPayload>
          }
          update: {
            args: Prisma.userContributionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userContributionPayload>
          }
          deleteMany: {
            args: Prisma.userContributionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.userContributionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.userContributionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userContributionPayload>
          }
          aggregate: {
            args: Prisma.UserContributionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserContribution>
          }
          groupBy: {
            args: Prisma.userContributionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserContributionGroupByOutputType>[]
          }
          count: {
            args: Prisma.userContributionCountArgs<ExtArgs>,
            result: $Utils.Optional<UserContributionCountAggregateOutputType> | number
          }
        }
      }
      userOption: {
        payload: Prisma.$userOptionPayload<ExtArgs>
        fields: Prisma.userOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userOptionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userOptionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userOptionPayload>
          }
          findFirst: {
            args: Prisma.userOptionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userOptionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userOptionPayload>
          }
          findMany: {
            args: Prisma.userOptionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userOptionPayload>[]
          }
          create: {
            args: Prisma.userOptionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userOptionPayload>
          }
          createMany: {
            args: Prisma.userOptionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.userOptionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userOptionPayload>
          }
          update: {
            args: Prisma.userOptionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userOptionPayload>
          }
          deleteMany: {
            args: Prisma.userOptionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.userOptionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.userOptionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userOptionPayload>
          }
          aggregate: {
            args: Prisma.UserOptionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserOption>
          }
          groupBy: {
            args: Prisma.userOptionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.userOptionCountArgs<ExtArgs>,
            result: $Utils.Optional<UserOptionCountAggregateOutputType> | number
          }
        }
      }
      userPasswordToken: {
        payload: Prisma.$userPasswordTokenPayload<ExtArgs>
        fields: Prisma.userPasswordTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userPasswordTokenFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPasswordTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userPasswordTokenFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPasswordTokenPayload>
          }
          findFirst: {
            args: Prisma.userPasswordTokenFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPasswordTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userPasswordTokenFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPasswordTokenPayload>
          }
          findMany: {
            args: Prisma.userPasswordTokenFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPasswordTokenPayload>[]
          }
          create: {
            args: Prisma.userPasswordTokenCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPasswordTokenPayload>
          }
          createMany: {
            args: Prisma.userPasswordTokenCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.userPasswordTokenDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPasswordTokenPayload>
          }
          update: {
            args: Prisma.userPasswordTokenUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPasswordTokenPayload>
          }
          deleteMany: {
            args: Prisma.userPasswordTokenDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.userPasswordTokenUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.userPasswordTokenUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPasswordTokenPayload>
          }
          aggregate: {
            args: Prisma.UserPasswordTokenAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserPasswordToken>
          }
          groupBy: {
            args: Prisma.userPasswordTokenGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserPasswordTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.userPasswordTokenCountArgs<ExtArgs>,
            result: $Utils.Optional<UserPasswordTokenCountAggregateOutputType> | number
          }
        }
      }
      userPermission: {
        payload: Prisma.$userPermissionPayload<ExtArgs>
        fields: Prisma.userPermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userPermissionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userPermissionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPermissionPayload>
          }
          findFirst: {
            args: Prisma.userPermissionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userPermissionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPermissionPayload>
          }
          findMany: {
            args: Prisma.userPermissionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPermissionPayload>[]
          }
          create: {
            args: Prisma.userPermissionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPermissionPayload>
          }
          createMany: {
            args: Prisma.userPermissionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.userPermissionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPermissionPayload>
          }
          update: {
            args: Prisma.userPermissionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPermissionPayload>
          }
          deleteMany: {
            args: Prisma.userPermissionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.userPermissionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.userPermissionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userPermissionPayload>
          }
          aggregate: {
            args: Prisma.UserPermissionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserPermission>
          }
          groupBy: {
            args: Prisma.userPermissionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserPermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.userPermissionCountArgs<ExtArgs>,
            result: $Utils.Optional<UserPermissionCountAggregateOutputType> | number
          }
        }
      }
      users_points: {
        payload: Prisma.$users_pointsPayload<ExtArgs>
        fields: Prisma.users_pointsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.users_pointsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$users_pointsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.users_pointsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$users_pointsPayload>
          }
          findFirst: {
            args: Prisma.users_pointsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$users_pointsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.users_pointsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$users_pointsPayload>
          }
          findMany: {
            args: Prisma.users_pointsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$users_pointsPayload>[]
          }
          create: {
            args: Prisma.users_pointsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$users_pointsPayload>
          }
          createMany: {
            args: Prisma.users_pointsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.users_pointsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$users_pointsPayload>
          }
          update: {
            args: Prisma.users_pointsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$users_pointsPayload>
          }
          deleteMany: {
            args: Prisma.users_pointsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.users_pointsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.users_pointsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$users_pointsPayload>
          }
          aggregate: {
            args: Prisma.Users_pointsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUsers_points>
          }
          groupBy: {
            args: Prisma.users_pointsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Users_pointsGroupByOutputType>[]
          }
          count: {
            args: Prisma.users_pointsCountArgs<ExtArgs>,
            result: $Utils.Optional<Users_pointsCountAggregateOutputType> | number
          }
        }
      }
      userSuggestionNotification: {
        payload: Prisma.$userSuggestionNotificationPayload<ExtArgs>
        fields: Prisma.userSuggestionNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userSuggestionNotificationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userSuggestionNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userSuggestionNotificationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userSuggestionNotificationPayload>
          }
          findFirst: {
            args: Prisma.userSuggestionNotificationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userSuggestionNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userSuggestionNotificationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userSuggestionNotificationPayload>
          }
          findMany: {
            args: Prisma.userSuggestionNotificationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userSuggestionNotificationPayload>[]
          }
          create: {
            args: Prisma.userSuggestionNotificationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userSuggestionNotificationPayload>
          }
          createMany: {
            args: Prisma.userSuggestionNotificationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.userSuggestionNotificationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userSuggestionNotificationPayload>
          }
          update: {
            args: Prisma.userSuggestionNotificationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userSuggestionNotificationPayload>
          }
          deleteMany: {
            args: Prisma.userSuggestionNotificationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.userSuggestionNotificationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.userSuggestionNotificationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$userSuggestionNotificationPayload>
          }
          aggregate: {
            args: Prisma.UserSuggestionNotificationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserSuggestionNotification>
          }
          groupBy: {
            args: Prisma.userSuggestionNotificationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserSuggestionNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.userSuggestionNotificationCountArgs<ExtArgs>,
            result: $Utils.Optional<UserSuggestionNotificationCountAggregateOutputType> | number
          }
        }
      }
      requestedIssue: {
        payload: Prisma.$requestedIssuePayload<ExtArgs>
        fields: Prisma.requestedIssueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.requestedIssueFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$requestedIssuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.requestedIssueFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$requestedIssuePayload>
          }
          findFirst: {
            args: Prisma.requestedIssueFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$requestedIssuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.requestedIssueFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$requestedIssuePayload>
          }
          findMany: {
            args: Prisma.requestedIssueFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$requestedIssuePayload>[]
          }
          create: {
            args: Prisma.requestedIssueCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$requestedIssuePayload>
          }
          createMany: {
            args: Prisma.requestedIssueCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.requestedIssueDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$requestedIssuePayload>
          }
          update: {
            args: Prisma.requestedIssueUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$requestedIssuePayload>
          }
          deleteMany: {
            args: Prisma.requestedIssueDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.requestedIssueUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.requestedIssueUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$requestedIssuePayload>
          }
          aggregate: {
            args: Prisma.RequestedIssueAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRequestedIssue>
          }
          groupBy: {
            args: Prisma.requestedIssueGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RequestedIssueGroupByOutputType>[]
          }
          count: {
            args: Prisma.requestedIssueCountArgs<ExtArgs>,
            result: $Utils.Optional<RequestedIssueCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BookstoreCountOutputType
   */

  export type BookstoreCountOutputType = {
    comments: number
    users_contributions: number
  }

  export type BookstoreCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    comments?: boolean | BookstoreCountOutputTypeCountCommentsArgs
    users_contributions?: boolean | BookstoreCountOutputTypeCountUsers_contributionsArgs
  }

  // Custom InputTypes

  /**
   * BookstoreCountOutputType without action
   */
  export type BookstoreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookstoreCountOutputType
     */
    select?: BookstoreCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * BookstoreCountOutputType without action
   */
  export type BookstoreCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: bookstoreCommentWhereInput
  }


  /**
   * BookstoreCountOutputType without action
   */
  export type BookstoreCountOutputTypeCountUsers_contributionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: userContributionWhereInput
  }



  /**
   * Count Type BookstoreCommentCountOutputType
   */

  export type BookstoreCommentCountOutputType = {
    users_contributions: number
  }

  export type BookstoreCommentCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    users_contributions?: boolean | BookstoreCommentCountOutputTypeCountUsers_contributionsArgs
  }

  // Custom InputTypes

  /**
   * BookstoreCommentCountOutputType without action
   */
  export type BookstoreCommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookstoreCommentCountOutputType
     */
    select?: BookstoreCommentCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * BookstoreCommentCountOutputType without action
   */
  export type BookstoreCommentCountOutputTypeCountUsers_contributionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: userContributionWhereInput
  }



  /**
   * Count Type EdgeCountOutputType
   */

  export type EdgeCountOutputType = {
    users_contributions: number
  }

  export type EdgeCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    users_contributions?: boolean | EdgeCountOutputTypeCountUsers_contributionsArgs
  }

  // Custom InputTypes

  /**
   * EdgeCountOutputType without action
   */
  export type EdgeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EdgeCountOutputType
     */
    select?: EdgeCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EdgeCountOutputType without action
   */
  export type EdgeCountOutputTypeCountUsers_contributionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: userContributionWhereInput
  }



  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    abonnements: number
    bouquineries_commentaires: number
    users_contributions: number
    users_options: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    abonnements?: boolean | UserCountOutputTypeCountAbonnementsArgs
    bouquineries_commentaires?: boolean | UserCountOutputTypeCountBouquineries_commentairesArgs
    users_contributions?: boolean | UserCountOutputTypeCountUsers_contributionsArgs
    users_options?: boolean | UserCountOutputTypeCountUsers_optionsArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAbonnementsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: subscriptionWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBouquineries_commentairesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: bookstoreCommentWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUsers_contributionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: userContributionWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUsers_optionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: userOptionWhereInput
  }



  /**
   * Models
   */

  /**
   * Model subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SubscriptionSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: number | null
    userId: number | null
    country: string | null
    magazine: string | null
    startDate: Date | null
    endDate: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    country: string | null
    magazine: string | null
    startDate: Date | null
    endDate: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    country: number
    magazine: number
    startDate: number
    endDate: number
    _all: number
  }


  export type SubscriptionAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SubscriptionSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    country?: true
    magazine?: true
    startDate?: true
    endDate?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    country?: true
    magazine?: true
    startDate?: true
    endDate?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    country?: true
    magazine?: true
    startDate?: true
    endDate?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which subscription to aggregate.
     */
    where?: subscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionOrderByWithRelationInput | subscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: subscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type subscriptionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: subscriptionWhereInput
    orderBy?: subscriptionOrderByWithAggregationInput | subscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: subscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _avg?: SubscriptionAvgAggregateInputType
    _sum?: SubscriptionSumAggregateInputType
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: number
    userId: number
    country: string
    magazine: string
    startDate: Date
    endDate: Date
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends subscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type subscriptionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    country?: boolean
    magazine?: boolean
    startDate?: boolean
    endDate?: boolean
    users?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type subscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    country?: boolean
    magazine?: boolean
    startDate?: boolean
    endDate?: boolean
  }

  export type subscriptionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    users?: boolean | userDefaultArgs<ExtArgs>
  }


  export type $subscriptionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "subscription"
    objects: {
      users: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: number
      userId: number
      country: string
      magazine: string
      startDate: Date
      endDate: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }


  type subscriptionGetPayload<S extends boolean | null | undefined | subscriptionDefaultArgs> = $Result.GetResult<Prisma.$subscriptionPayload, S>

  type subscriptionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<subscriptionFindManyArgs, 'select' | 'include'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface subscriptionDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['subscription'], meta: { name: 'subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {subscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends subscriptionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, subscriptionFindUniqueArgs<ExtArgs>>
    ): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Subscription that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {subscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends subscriptionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, subscriptionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends subscriptionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, subscriptionFindFirstArgs<ExtArgs>>
    ): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends subscriptionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, subscriptionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends subscriptionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, subscriptionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Subscription.
     * @param {subscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
    **/
    create<T extends subscriptionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, subscriptionCreateArgs<ExtArgs>>
    ): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Subscriptions.
     *     @param {subscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     *     @example
     *     // Create many Subscriptions
     *     const subscription = await prisma.subscription.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends subscriptionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, subscriptionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subscription.
     * @param {subscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
    **/
    delete<T extends subscriptionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, subscriptionDeleteArgs<ExtArgs>>
    ): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Subscription.
     * @param {subscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends subscriptionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, subscriptionUpdateArgs<ExtArgs>>
    ): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Subscriptions.
     * @param {subscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends subscriptionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, subscriptionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends subscriptionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, subscriptionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscription.
     * @param {subscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
    **/
    upsert<T extends subscriptionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, subscriptionUpsertArgs<ExtArgs>>
    ): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends subscriptionCountArgs>(
      args?: Subset<T, subscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends subscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: subscriptionGroupByArgs['orderBy'] }
        : { orderBy?: subscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, subscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the subscription model
   */
  readonly fields: subscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__subscriptionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the subscription model
   */ 
  interface subscriptionFieldRefs {
    readonly id: FieldRef<"subscription", 'Int'>
    readonly userId: FieldRef<"subscription", 'Int'>
    readonly country: FieldRef<"subscription", 'String'>
    readonly magazine: FieldRef<"subscription", 'String'>
    readonly startDate: FieldRef<"subscription", 'DateTime'>
    readonly endDate: FieldRef<"subscription", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * subscription findUnique
   */
  export type subscriptionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: subscriptionInclude<ExtArgs> | null
    /**
     * Filter, which subscription to fetch.
     */
    where: subscriptionWhereUniqueInput
  }


  /**
   * subscription findUniqueOrThrow
   */
  export type subscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: subscriptionInclude<ExtArgs> | null
    /**
     * Filter, which subscription to fetch.
     */
    where: subscriptionWhereUniqueInput
  }


  /**
   * subscription findFirst
   */
  export type subscriptionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: subscriptionInclude<ExtArgs> | null
    /**
     * Filter, which subscription to fetch.
     */
    where?: subscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionOrderByWithRelationInput | subscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subscriptions.
     */
    cursor?: subscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }


  /**
   * subscription findFirstOrThrow
   */
  export type subscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: subscriptionInclude<ExtArgs> | null
    /**
     * Filter, which subscription to fetch.
     */
    where?: subscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionOrderByWithRelationInput | subscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subscriptions.
     */
    cursor?: subscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }


  /**
   * subscription findMany
   */
  export type subscriptionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: subscriptionInclude<ExtArgs> | null
    /**
     * Filter, which subscriptions to fetch.
     */
    where?: subscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionOrderByWithRelationInput | subscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing subscriptions.
     */
    cursor?: subscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }


  /**
   * subscription create
   */
  export type subscriptionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: subscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a subscription.
     */
    data: XOR<subscriptionCreateInput, subscriptionUncheckedCreateInput>
  }


  /**
   * subscription createMany
   */
  export type subscriptionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many subscriptions.
     */
    data: subscriptionCreateManyInput | subscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * subscription update
   */
  export type subscriptionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: subscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a subscription.
     */
    data: XOR<subscriptionUpdateInput, subscriptionUncheckedUpdateInput>
    /**
     * Choose, which subscription to update.
     */
    where: subscriptionWhereUniqueInput
  }


  /**
   * subscription updateMany
   */
  export type subscriptionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update subscriptions.
     */
    data: XOR<subscriptionUpdateManyMutationInput, subscriptionUncheckedUpdateManyInput>
    /**
     * Filter which subscriptions to update
     */
    where?: subscriptionWhereInput
  }


  /**
   * subscription upsert
   */
  export type subscriptionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: subscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the subscription to update in case it exists.
     */
    where: subscriptionWhereUniqueInput
    /**
     * In case the subscription found by the `where` argument doesn't exist, create a new subscription with this data.
     */
    create: XOR<subscriptionCreateInput, subscriptionUncheckedCreateInput>
    /**
     * In case the subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<subscriptionUpdateInput, subscriptionUncheckedUpdateInput>
  }


  /**
   * subscription delete
   */
  export type subscriptionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: subscriptionInclude<ExtArgs> | null
    /**
     * Filter which subscription to delete.
     */
    where: subscriptionWhereUniqueInput
  }


  /**
   * subscription deleteMany
   */
  export type subscriptionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which subscriptions to delete
     */
    where?: subscriptionWhereInput
  }


  /**
   * subscription without action
   */
  export type subscriptionDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: subscriptionInclude<ExtArgs> | null
  }



  /**
   * Model abonnements_sorties
   */

  export type AggregateAbonnements_sorties = {
    _count: Abonnements_sortiesCountAggregateOutputType | null
    _min: Abonnements_sortiesMinAggregateOutputType | null
    _max: Abonnements_sortiesMaxAggregateOutputType | null
  }

  export type Abonnements_sortiesMinAggregateOutputType = {
    Pays: string | null
    Magazine: string | null
    Numero: string | null
    Date_sortie: Date | null
    Numeros_ajoutes: boolean | null
  }

  export type Abonnements_sortiesMaxAggregateOutputType = {
    Pays: string | null
    Magazine: string | null
    Numero: string | null
    Date_sortie: Date | null
    Numeros_ajoutes: boolean | null
  }

  export type Abonnements_sortiesCountAggregateOutputType = {
    Pays: number
    Magazine: number
    Numero: number
    Date_sortie: number
    Numeros_ajoutes: number
    _all: number
  }


  export type Abonnements_sortiesMinAggregateInputType = {
    Pays?: true
    Magazine?: true
    Numero?: true
    Date_sortie?: true
    Numeros_ajoutes?: true
  }

  export type Abonnements_sortiesMaxAggregateInputType = {
    Pays?: true
    Magazine?: true
    Numero?: true
    Date_sortie?: true
    Numeros_ajoutes?: true
  }

  export type Abonnements_sortiesCountAggregateInputType = {
    Pays?: true
    Magazine?: true
    Numero?: true
    Date_sortie?: true
    Numeros_ajoutes?: true
    _all?: true
  }

  export type Abonnements_sortiesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which abonnements_sorties to aggregate.
     */
    where?: abonnements_sortiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of abonnements_sorties to fetch.
     */
    orderBy?: abonnements_sortiesOrderByWithRelationInput | abonnements_sortiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: abonnements_sortiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` abonnements_sorties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` abonnements_sorties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned abonnements_sorties
    **/
    _count?: true | Abonnements_sortiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Abonnements_sortiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Abonnements_sortiesMaxAggregateInputType
  }

  export type GetAbonnements_sortiesAggregateType<T extends Abonnements_sortiesAggregateArgs> = {
        [P in keyof T & keyof AggregateAbonnements_sorties]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAbonnements_sorties[P]>
      : GetScalarType<T[P], AggregateAbonnements_sorties[P]>
  }




  export type abonnements_sortiesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: abonnements_sortiesWhereInput
    orderBy?: abonnements_sortiesOrderByWithAggregationInput | abonnements_sortiesOrderByWithAggregationInput[]
    by: Abonnements_sortiesScalarFieldEnum[] | Abonnements_sortiesScalarFieldEnum
    having?: abonnements_sortiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Abonnements_sortiesCountAggregateInputType | true
    _min?: Abonnements_sortiesMinAggregateInputType
    _max?: Abonnements_sortiesMaxAggregateInputType
  }

  export type Abonnements_sortiesGroupByOutputType = {
    Pays: string
    Magazine: string
    Numero: string
    Date_sortie: Date
    Numeros_ajoutes: boolean
    _count: Abonnements_sortiesCountAggregateOutputType | null
    _min: Abonnements_sortiesMinAggregateOutputType | null
    _max: Abonnements_sortiesMaxAggregateOutputType | null
  }

  type GetAbonnements_sortiesGroupByPayload<T extends abonnements_sortiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Abonnements_sortiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Abonnements_sortiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Abonnements_sortiesGroupByOutputType[P]>
            : GetScalarType<T[P], Abonnements_sortiesGroupByOutputType[P]>
        }
      >
    >


  export type abonnements_sortiesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Pays?: boolean
    Magazine?: boolean
    Numero?: boolean
    Date_sortie?: boolean
    Numeros_ajoutes?: boolean
  }, ExtArgs["result"]["abonnements_sorties"]>

  export type abonnements_sortiesSelectScalar = {
    Pays?: boolean
    Magazine?: boolean
    Numero?: boolean
    Date_sortie?: boolean
    Numeros_ajoutes?: boolean
  }


  export type $abonnements_sortiesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "abonnements_sorties"
    objects: {}
    scalars: $Extensions.GetResult<{
      Pays: string
      Magazine: string
      Numero: string
      Date_sortie: Date
      Numeros_ajoutes: boolean
    }, ExtArgs["result"]["abonnements_sorties"]>
    composites: {}
  }


  type abonnements_sortiesGetPayload<S extends boolean | null | undefined | abonnements_sortiesDefaultArgs> = $Result.GetResult<Prisma.$abonnements_sortiesPayload, S>

  type abonnements_sortiesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<abonnements_sortiesFindManyArgs, 'select' | 'include'> & {
      select?: Abonnements_sortiesCountAggregateInputType | true
    }

  export interface abonnements_sortiesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['abonnements_sorties'], meta: { name: 'abonnements_sorties' } }
    /**
     * Find zero or one Abonnements_sorties that matches the filter.
     * @param {abonnements_sortiesFindUniqueArgs} args - Arguments to find a Abonnements_sorties
     * @example
     * // Get one Abonnements_sorties
     * const abonnements_sorties = await prisma.abonnements_sorties.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends abonnements_sortiesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, abonnements_sortiesFindUniqueArgs<ExtArgs>>
    ): Prisma__abonnements_sortiesClient<$Result.GetResult<Prisma.$abonnements_sortiesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Abonnements_sorties that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {abonnements_sortiesFindUniqueOrThrowArgs} args - Arguments to find a Abonnements_sorties
     * @example
     * // Get one Abonnements_sorties
     * const abonnements_sorties = await prisma.abonnements_sorties.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends abonnements_sortiesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, abonnements_sortiesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__abonnements_sortiesClient<$Result.GetResult<Prisma.$abonnements_sortiesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Abonnements_sorties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {abonnements_sortiesFindFirstArgs} args - Arguments to find a Abonnements_sorties
     * @example
     * // Get one Abonnements_sorties
     * const abonnements_sorties = await prisma.abonnements_sorties.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends abonnements_sortiesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, abonnements_sortiesFindFirstArgs<ExtArgs>>
    ): Prisma__abonnements_sortiesClient<$Result.GetResult<Prisma.$abonnements_sortiesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Abonnements_sorties that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {abonnements_sortiesFindFirstOrThrowArgs} args - Arguments to find a Abonnements_sorties
     * @example
     * // Get one Abonnements_sorties
     * const abonnements_sorties = await prisma.abonnements_sorties.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends abonnements_sortiesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, abonnements_sortiesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__abonnements_sortiesClient<$Result.GetResult<Prisma.$abonnements_sortiesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Abonnements_sorties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {abonnements_sortiesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Abonnements_sorties
     * const abonnements_sorties = await prisma.abonnements_sorties.findMany()
     * 
     * // Get first 10 Abonnements_sorties
     * const abonnements_sorties = await prisma.abonnements_sorties.findMany({ take: 10 })
     * 
     * // Only select the `Pays`
     * const abonnements_sortiesWithPaysOnly = await prisma.abonnements_sorties.findMany({ select: { Pays: true } })
     * 
    **/
    findMany<T extends abonnements_sortiesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, abonnements_sortiesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$abonnements_sortiesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Abonnements_sorties.
     * @param {abonnements_sortiesCreateArgs} args - Arguments to create a Abonnements_sorties.
     * @example
     * // Create one Abonnements_sorties
     * const Abonnements_sorties = await prisma.abonnements_sorties.create({
     *   data: {
     *     // ... data to create a Abonnements_sorties
     *   }
     * })
     * 
    **/
    create<T extends abonnements_sortiesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, abonnements_sortiesCreateArgs<ExtArgs>>
    ): Prisma__abonnements_sortiesClient<$Result.GetResult<Prisma.$abonnements_sortiesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Abonnements_sorties.
     *     @param {abonnements_sortiesCreateManyArgs} args - Arguments to create many Abonnements_sorties.
     *     @example
     *     // Create many Abonnements_sorties
     *     const abonnements_sorties = await prisma.abonnements_sorties.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends abonnements_sortiesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, abonnements_sortiesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Abonnements_sorties.
     * @param {abonnements_sortiesDeleteArgs} args - Arguments to delete one Abonnements_sorties.
     * @example
     * // Delete one Abonnements_sorties
     * const Abonnements_sorties = await prisma.abonnements_sorties.delete({
     *   where: {
     *     // ... filter to delete one Abonnements_sorties
     *   }
     * })
     * 
    **/
    delete<T extends abonnements_sortiesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, abonnements_sortiesDeleteArgs<ExtArgs>>
    ): Prisma__abonnements_sortiesClient<$Result.GetResult<Prisma.$abonnements_sortiesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Abonnements_sorties.
     * @param {abonnements_sortiesUpdateArgs} args - Arguments to update one Abonnements_sorties.
     * @example
     * // Update one Abonnements_sorties
     * const abonnements_sorties = await prisma.abonnements_sorties.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends abonnements_sortiesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, abonnements_sortiesUpdateArgs<ExtArgs>>
    ): Prisma__abonnements_sortiesClient<$Result.GetResult<Prisma.$abonnements_sortiesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Abonnements_sorties.
     * @param {abonnements_sortiesDeleteManyArgs} args - Arguments to filter Abonnements_sorties to delete.
     * @example
     * // Delete a few Abonnements_sorties
     * const { count } = await prisma.abonnements_sorties.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends abonnements_sortiesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, abonnements_sortiesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Abonnements_sorties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {abonnements_sortiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Abonnements_sorties
     * const abonnements_sorties = await prisma.abonnements_sorties.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends abonnements_sortiesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, abonnements_sortiesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Abonnements_sorties.
     * @param {abonnements_sortiesUpsertArgs} args - Arguments to update or create a Abonnements_sorties.
     * @example
     * // Update or create a Abonnements_sorties
     * const abonnements_sorties = await prisma.abonnements_sorties.upsert({
     *   create: {
     *     // ... data to create a Abonnements_sorties
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Abonnements_sorties we want to update
     *   }
     * })
    **/
    upsert<T extends abonnements_sortiesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, abonnements_sortiesUpsertArgs<ExtArgs>>
    ): Prisma__abonnements_sortiesClient<$Result.GetResult<Prisma.$abonnements_sortiesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Abonnements_sorties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {abonnements_sortiesCountArgs} args - Arguments to filter Abonnements_sorties to count.
     * @example
     * // Count the number of Abonnements_sorties
     * const count = await prisma.abonnements_sorties.count({
     *   where: {
     *     // ... the filter for the Abonnements_sorties we want to count
     *   }
     * })
    **/
    count<T extends abonnements_sortiesCountArgs>(
      args?: Subset<T, abonnements_sortiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Abonnements_sortiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Abonnements_sorties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Abonnements_sortiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Abonnements_sortiesAggregateArgs>(args: Subset<T, Abonnements_sortiesAggregateArgs>): Prisma.PrismaPromise<GetAbonnements_sortiesAggregateType<T>>

    /**
     * Group by Abonnements_sorties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {abonnements_sortiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends abonnements_sortiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: abonnements_sortiesGroupByArgs['orderBy'] }
        : { orderBy?: abonnements_sortiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, abonnements_sortiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAbonnements_sortiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the abonnements_sorties model
   */
  readonly fields: abonnements_sortiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for abonnements_sorties.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__abonnements_sortiesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the abonnements_sorties model
   */ 
  interface abonnements_sortiesFieldRefs {
    readonly Pays: FieldRef<"abonnements_sorties", 'String'>
    readonly Magazine: FieldRef<"abonnements_sorties", 'String'>
    readonly Numero: FieldRef<"abonnements_sorties", 'String'>
    readonly Date_sortie: FieldRef<"abonnements_sorties", 'DateTime'>
    readonly Numeros_ajoutes: FieldRef<"abonnements_sorties", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * abonnements_sorties findUnique
   */
  export type abonnements_sortiesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the abonnements_sorties
     */
    select?: abonnements_sortiesSelect<ExtArgs> | null
    /**
     * Filter, which abonnements_sorties to fetch.
     */
    where: abonnements_sortiesWhereUniqueInput
  }


  /**
   * abonnements_sorties findUniqueOrThrow
   */
  export type abonnements_sortiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the abonnements_sorties
     */
    select?: abonnements_sortiesSelect<ExtArgs> | null
    /**
     * Filter, which abonnements_sorties to fetch.
     */
    where: abonnements_sortiesWhereUniqueInput
  }


  /**
   * abonnements_sorties findFirst
   */
  export type abonnements_sortiesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the abonnements_sorties
     */
    select?: abonnements_sortiesSelect<ExtArgs> | null
    /**
     * Filter, which abonnements_sorties to fetch.
     */
    where?: abonnements_sortiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of abonnements_sorties to fetch.
     */
    orderBy?: abonnements_sortiesOrderByWithRelationInput | abonnements_sortiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for abonnements_sorties.
     */
    cursor?: abonnements_sortiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` abonnements_sorties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` abonnements_sorties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of abonnements_sorties.
     */
    distinct?: Abonnements_sortiesScalarFieldEnum | Abonnements_sortiesScalarFieldEnum[]
  }


  /**
   * abonnements_sorties findFirstOrThrow
   */
  export type abonnements_sortiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the abonnements_sorties
     */
    select?: abonnements_sortiesSelect<ExtArgs> | null
    /**
     * Filter, which abonnements_sorties to fetch.
     */
    where?: abonnements_sortiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of abonnements_sorties to fetch.
     */
    orderBy?: abonnements_sortiesOrderByWithRelationInput | abonnements_sortiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for abonnements_sorties.
     */
    cursor?: abonnements_sortiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` abonnements_sorties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` abonnements_sorties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of abonnements_sorties.
     */
    distinct?: Abonnements_sortiesScalarFieldEnum | Abonnements_sortiesScalarFieldEnum[]
  }


  /**
   * abonnements_sorties findMany
   */
  export type abonnements_sortiesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the abonnements_sorties
     */
    select?: abonnements_sortiesSelect<ExtArgs> | null
    /**
     * Filter, which abonnements_sorties to fetch.
     */
    where?: abonnements_sortiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of abonnements_sorties to fetch.
     */
    orderBy?: abonnements_sortiesOrderByWithRelationInput | abonnements_sortiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing abonnements_sorties.
     */
    cursor?: abonnements_sortiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` abonnements_sorties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` abonnements_sorties.
     */
    skip?: number
    distinct?: Abonnements_sortiesScalarFieldEnum | Abonnements_sortiesScalarFieldEnum[]
  }


  /**
   * abonnements_sorties create
   */
  export type abonnements_sortiesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the abonnements_sorties
     */
    select?: abonnements_sortiesSelect<ExtArgs> | null
    /**
     * The data needed to create a abonnements_sorties.
     */
    data: XOR<abonnements_sortiesCreateInput, abonnements_sortiesUncheckedCreateInput>
  }


  /**
   * abonnements_sorties createMany
   */
  export type abonnements_sortiesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many abonnements_sorties.
     */
    data: abonnements_sortiesCreateManyInput | abonnements_sortiesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * abonnements_sorties update
   */
  export type abonnements_sortiesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the abonnements_sorties
     */
    select?: abonnements_sortiesSelect<ExtArgs> | null
    /**
     * The data needed to update a abonnements_sorties.
     */
    data: XOR<abonnements_sortiesUpdateInput, abonnements_sortiesUncheckedUpdateInput>
    /**
     * Choose, which abonnements_sorties to update.
     */
    where: abonnements_sortiesWhereUniqueInput
  }


  /**
   * abonnements_sorties updateMany
   */
  export type abonnements_sortiesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update abonnements_sorties.
     */
    data: XOR<abonnements_sortiesUpdateManyMutationInput, abonnements_sortiesUncheckedUpdateManyInput>
    /**
     * Filter which abonnements_sorties to update
     */
    where?: abonnements_sortiesWhereInput
  }


  /**
   * abonnements_sorties upsert
   */
  export type abonnements_sortiesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the abonnements_sorties
     */
    select?: abonnements_sortiesSelect<ExtArgs> | null
    /**
     * The filter to search for the abonnements_sorties to update in case it exists.
     */
    where: abonnements_sortiesWhereUniqueInput
    /**
     * In case the abonnements_sorties found by the `where` argument doesn't exist, create a new abonnements_sorties with this data.
     */
    create: XOR<abonnements_sortiesCreateInput, abonnements_sortiesUncheckedCreateInput>
    /**
     * In case the abonnements_sorties was found with the provided `where` argument, update it with this data.
     */
    update: XOR<abonnements_sortiesUpdateInput, abonnements_sortiesUncheckedUpdateInput>
  }


  /**
   * abonnements_sorties delete
   */
  export type abonnements_sortiesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the abonnements_sorties
     */
    select?: abonnements_sortiesSelect<ExtArgs> | null
    /**
     * Filter which abonnements_sorties to delete.
     */
    where: abonnements_sortiesWhereUniqueInput
  }


  /**
   * abonnements_sorties deleteMany
   */
  export type abonnements_sortiesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which abonnements_sorties to delete
     */
    where?: abonnements_sortiesWhereInput
  }


  /**
   * abonnements_sorties without action
   */
  export type abonnements_sortiesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the abonnements_sorties
     */
    select?: abonnements_sortiesSelect<ExtArgs> | null
  }



  /**
   * Model purchase
   */

  export type AggregatePurchase = {
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  export type PurchaseAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PurchaseSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PurchaseMinAggregateOutputType = {
    id: number | null
    userId: number | null
    date: Date | null
    description: string | null
  }

  export type PurchaseMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    date: Date | null
    description: string | null
  }

  export type PurchaseCountAggregateOutputType = {
    id: number
    userId: number
    date: number
    description: number
    _all: number
  }


  export type PurchaseAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PurchaseSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PurchaseMinAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    description?: true
  }

  export type PurchaseMaxAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    description?: true
  }

  export type PurchaseCountAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    description?: true
    _all?: true
  }

  export type PurchaseAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which purchase to aggregate.
     */
    where?: purchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of purchases to fetch.
     */
    orderBy?: purchaseOrderByWithRelationInput | purchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: purchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned purchases
    **/
    _count?: true | PurchaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseMaxAggregateInputType
  }

  export type GetPurchaseAggregateType<T extends PurchaseAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchase[P]>
      : GetScalarType<T[P], AggregatePurchase[P]>
  }




  export type purchaseGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: purchaseWhereInput
    orderBy?: purchaseOrderByWithAggregationInput | purchaseOrderByWithAggregationInput[]
    by: PurchaseScalarFieldEnum[] | PurchaseScalarFieldEnum
    having?: purchaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseCountAggregateInputType | true
    _avg?: PurchaseAvgAggregateInputType
    _sum?: PurchaseSumAggregateInputType
    _min?: PurchaseMinAggregateInputType
    _max?: PurchaseMaxAggregateInputType
  }

  export type PurchaseGroupByOutputType = {
    id: number
    userId: number
    date: Date
    description: string
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  type GetPurchaseGroupByPayload<T extends purchaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
        }
      >
    >


  export type purchaseSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    description?: boolean
  }, ExtArgs["result"]["purchase"]>

  export type purchaseSelectScalar = {
    id?: boolean
    userId?: boolean
    date?: boolean
    description?: boolean
  }


  export type $purchasePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "purchase"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: number
      userId: number
      date: Date
      description: string
    }, ExtArgs["result"]["purchase"]>
    composites: {}
  }


  type purchaseGetPayload<S extends boolean | null | undefined | purchaseDefaultArgs> = $Result.GetResult<Prisma.$purchasePayload, S>

  type purchaseCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<purchaseFindManyArgs, 'select' | 'include'> & {
      select?: PurchaseCountAggregateInputType | true
    }

  export interface purchaseDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['purchase'], meta: { name: 'purchase' } }
    /**
     * Find zero or one Purchase that matches the filter.
     * @param {purchaseFindUniqueArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends purchaseFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, purchaseFindUniqueArgs<ExtArgs>>
    ): Prisma__purchaseClient<$Result.GetResult<Prisma.$purchasePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Purchase that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {purchaseFindUniqueOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends purchaseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, purchaseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__purchaseClient<$Result.GetResult<Prisma.$purchasePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Purchase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchaseFindFirstArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends purchaseFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, purchaseFindFirstArgs<ExtArgs>>
    ): Prisma__purchaseClient<$Result.GetResult<Prisma.$purchasePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Purchase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchaseFindFirstOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends purchaseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, purchaseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__purchaseClient<$Result.GetResult<Prisma.$purchasePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Purchases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchaseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Purchases
     * const purchases = await prisma.purchase.findMany()
     * 
     * // Get first 10 Purchases
     * const purchases = await prisma.purchase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseWithIdOnly = await prisma.purchase.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends purchaseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, purchaseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$purchasePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Purchase.
     * @param {purchaseCreateArgs} args - Arguments to create a Purchase.
     * @example
     * // Create one Purchase
     * const Purchase = await prisma.purchase.create({
     *   data: {
     *     // ... data to create a Purchase
     *   }
     * })
     * 
    **/
    create<T extends purchaseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, purchaseCreateArgs<ExtArgs>>
    ): Prisma__purchaseClient<$Result.GetResult<Prisma.$purchasePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Purchases.
     *     @param {purchaseCreateManyArgs} args - Arguments to create many Purchases.
     *     @example
     *     // Create many Purchases
     *     const purchase = await prisma.purchase.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends purchaseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, purchaseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Purchase.
     * @param {purchaseDeleteArgs} args - Arguments to delete one Purchase.
     * @example
     * // Delete one Purchase
     * const Purchase = await prisma.purchase.delete({
     *   where: {
     *     // ... filter to delete one Purchase
     *   }
     * })
     * 
    **/
    delete<T extends purchaseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, purchaseDeleteArgs<ExtArgs>>
    ): Prisma__purchaseClient<$Result.GetResult<Prisma.$purchasePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Purchase.
     * @param {purchaseUpdateArgs} args - Arguments to update one Purchase.
     * @example
     * // Update one Purchase
     * const purchase = await prisma.purchase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends purchaseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, purchaseUpdateArgs<ExtArgs>>
    ): Prisma__purchaseClient<$Result.GetResult<Prisma.$purchasePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Purchases.
     * @param {purchaseDeleteManyArgs} args - Arguments to filter Purchases to delete.
     * @example
     * // Delete a few Purchases
     * const { count } = await prisma.purchase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends purchaseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, purchaseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Purchases
     * const purchase = await prisma.purchase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends purchaseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, purchaseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Purchase.
     * @param {purchaseUpsertArgs} args - Arguments to update or create a Purchase.
     * @example
     * // Update or create a Purchase
     * const purchase = await prisma.purchase.upsert({
     *   create: {
     *     // ... data to create a Purchase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Purchase we want to update
     *   }
     * })
    **/
    upsert<T extends purchaseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, purchaseUpsertArgs<ExtArgs>>
    ): Prisma__purchaseClient<$Result.GetResult<Prisma.$purchasePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchaseCountArgs} args - Arguments to filter Purchases to count.
     * @example
     * // Count the number of Purchases
     * const count = await prisma.purchase.count({
     *   where: {
     *     // ... the filter for the Purchases we want to count
     *   }
     * })
    **/
    count<T extends purchaseCountArgs>(
      args?: Subset<T, purchaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseAggregateArgs>(args: Subset<T, PurchaseAggregateArgs>): Prisma.PrismaPromise<GetPurchaseAggregateType<T>>

    /**
     * Group by Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends purchaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: purchaseGroupByArgs['orderBy'] }
        : { orderBy?: purchaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, purchaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the purchase model
   */
  readonly fields: purchaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for purchase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__purchaseClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the purchase model
   */ 
  interface purchaseFieldRefs {
    readonly id: FieldRef<"purchase", 'Int'>
    readonly userId: FieldRef<"purchase", 'Int'>
    readonly date: FieldRef<"purchase", 'DateTime'>
    readonly description: FieldRef<"purchase", 'String'>
  }
    

  // Custom InputTypes

  /**
   * purchase findUnique
   */
  export type purchaseFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchase
     */
    select?: purchaseSelect<ExtArgs> | null
    /**
     * Filter, which purchase to fetch.
     */
    where: purchaseWhereUniqueInput
  }


  /**
   * purchase findUniqueOrThrow
   */
  export type purchaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchase
     */
    select?: purchaseSelect<ExtArgs> | null
    /**
     * Filter, which purchase to fetch.
     */
    where: purchaseWhereUniqueInput
  }


  /**
   * purchase findFirst
   */
  export type purchaseFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchase
     */
    select?: purchaseSelect<ExtArgs> | null
    /**
     * Filter, which purchase to fetch.
     */
    where?: purchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of purchases to fetch.
     */
    orderBy?: purchaseOrderByWithRelationInput | purchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for purchases.
     */
    cursor?: purchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }


  /**
   * purchase findFirstOrThrow
   */
  export type purchaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchase
     */
    select?: purchaseSelect<ExtArgs> | null
    /**
     * Filter, which purchase to fetch.
     */
    where?: purchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of purchases to fetch.
     */
    orderBy?: purchaseOrderByWithRelationInput | purchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for purchases.
     */
    cursor?: purchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }


  /**
   * purchase findMany
   */
  export type purchaseFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchase
     */
    select?: purchaseSelect<ExtArgs> | null
    /**
     * Filter, which purchases to fetch.
     */
    where?: purchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of purchases to fetch.
     */
    orderBy?: purchaseOrderByWithRelationInput | purchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing purchases.
     */
    cursor?: purchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` purchases.
     */
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }


  /**
   * purchase create
   */
  export type purchaseCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchase
     */
    select?: purchaseSelect<ExtArgs> | null
    /**
     * The data needed to create a purchase.
     */
    data: XOR<purchaseCreateInput, purchaseUncheckedCreateInput>
  }


  /**
   * purchase createMany
   */
  export type purchaseCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many purchases.
     */
    data: purchaseCreateManyInput | purchaseCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * purchase update
   */
  export type purchaseUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchase
     */
    select?: purchaseSelect<ExtArgs> | null
    /**
     * The data needed to update a purchase.
     */
    data: XOR<purchaseUpdateInput, purchaseUncheckedUpdateInput>
    /**
     * Choose, which purchase to update.
     */
    where: purchaseWhereUniqueInput
  }


  /**
   * purchase updateMany
   */
  export type purchaseUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update purchases.
     */
    data: XOR<purchaseUpdateManyMutationInput, purchaseUncheckedUpdateManyInput>
    /**
     * Filter which purchases to update
     */
    where?: purchaseWhereInput
  }


  /**
   * purchase upsert
   */
  export type purchaseUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchase
     */
    select?: purchaseSelect<ExtArgs> | null
    /**
     * The filter to search for the purchase to update in case it exists.
     */
    where: purchaseWhereUniqueInput
    /**
     * In case the purchase found by the `where` argument doesn't exist, create a new purchase with this data.
     */
    create: XOR<purchaseCreateInput, purchaseUncheckedCreateInput>
    /**
     * In case the purchase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<purchaseUpdateInput, purchaseUncheckedUpdateInput>
  }


  /**
   * purchase delete
   */
  export type purchaseDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchase
     */
    select?: purchaseSelect<ExtArgs> | null
    /**
     * Filter which purchase to delete.
     */
    where: purchaseWhereUniqueInput
  }


  /**
   * purchase deleteMany
   */
  export type purchaseDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which purchases to delete
     */
    where?: purchaseWhereInput
  }


  /**
   * purchase without action
   */
  export type purchaseDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the purchase
     */
    select?: purchaseSelect<ExtArgs> | null
  }



  /**
   * Model authorUser
   */

  export type AggregateAuthorUser = {
    _count: AuthorUserCountAggregateOutputType | null
    _avg: AuthorUserAvgAggregateOutputType | null
    _sum: AuthorUserSumAggregateOutputType | null
    _min: AuthorUserMinAggregateOutputType | null
    _max: AuthorUserMaxAggregateOutputType | null
  }

  export type AuthorUserAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    notation: number | null
  }

  export type AuthorUserSumAggregateOutputType = {
    id: number | null
    userId: number | null
    notation: number | null
  }

  export type AuthorUserMinAggregateOutputType = {
    id: number | null
    personcode: string | null
    userId: number | null
    notation: number | null
  }

  export type AuthorUserMaxAggregateOutputType = {
    id: number | null
    personcode: string | null
    userId: number | null
    notation: number | null
  }

  export type AuthorUserCountAggregateOutputType = {
    id: number
    personcode: number
    userId: number
    notation: number
    _all: number
  }


  export type AuthorUserAvgAggregateInputType = {
    id?: true
    userId?: true
    notation?: true
  }

  export type AuthorUserSumAggregateInputType = {
    id?: true
    userId?: true
    notation?: true
  }

  export type AuthorUserMinAggregateInputType = {
    id?: true
    personcode?: true
    userId?: true
    notation?: true
  }

  export type AuthorUserMaxAggregateInputType = {
    id?: true
    personcode?: true
    userId?: true
    notation?: true
  }

  export type AuthorUserCountAggregateInputType = {
    id?: true
    personcode?: true
    userId?: true
    notation?: true
    _all?: true
  }

  export type AuthorUserAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which authorUser to aggregate.
     */
    where?: authorUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of authorUsers to fetch.
     */
    orderBy?: authorUserOrderByWithRelationInput | authorUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: authorUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` authorUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` authorUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned authorUsers
    **/
    _count?: true | AuthorUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuthorUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuthorUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthorUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthorUserMaxAggregateInputType
  }

  export type GetAuthorUserAggregateType<T extends AuthorUserAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthorUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthorUser[P]>
      : GetScalarType<T[P], AggregateAuthorUser[P]>
  }




  export type authorUserGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: authorUserWhereInput
    orderBy?: authorUserOrderByWithAggregationInput | authorUserOrderByWithAggregationInput[]
    by: AuthorUserScalarFieldEnum[] | AuthorUserScalarFieldEnum
    having?: authorUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthorUserCountAggregateInputType | true
    _avg?: AuthorUserAvgAggregateInputType
    _sum?: AuthorUserSumAggregateInputType
    _min?: AuthorUserMinAggregateInputType
    _max?: AuthorUserMaxAggregateInputType
  }

  export type AuthorUserGroupByOutputType = {
    id: number
    personcode: string
    userId: number
    notation: number
    _count: AuthorUserCountAggregateOutputType | null
    _avg: AuthorUserAvgAggregateOutputType | null
    _sum: AuthorUserSumAggregateOutputType | null
    _min: AuthorUserMinAggregateOutputType | null
    _max: AuthorUserMaxAggregateOutputType | null
  }

  type GetAuthorUserGroupByPayload<T extends authorUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuthorUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthorUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthorUserGroupByOutputType[P]>
            : GetScalarType<T[P], AuthorUserGroupByOutputType[P]>
        }
      >
    >


  export type authorUserSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personcode?: boolean
    userId?: boolean
    notation?: boolean
  }, ExtArgs["result"]["authorUser"]>

  export type authorUserSelectScalar = {
    id?: boolean
    personcode?: boolean
    userId?: boolean
    notation?: boolean
  }


  export type $authorUserPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "authorUser"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: number
      personcode: string
      userId: number
      notation: number
    }, ExtArgs["result"]["authorUser"]>
    composites: {}
  }


  type authorUserGetPayload<S extends boolean | null | undefined | authorUserDefaultArgs> = $Result.GetResult<Prisma.$authorUserPayload, S>

  type authorUserCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<authorUserFindManyArgs, 'select' | 'include'> & {
      select?: AuthorUserCountAggregateInputType | true
    }

  export interface authorUserDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['authorUser'], meta: { name: 'authorUser' } }
    /**
     * Find zero or one AuthorUser that matches the filter.
     * @param {authorUserFindUniqueArgs} args - Arguments to find a AuthorUser
     * @example
     * // Get one AuthorUser
     * const authorUser = await prisma.authorUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends authorUserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, authorUserFindUniqueArgs<ExtArgs>>
    ): Prisma__authorUserClient<$Result.GetResult<Prisma.$authorUserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AuthorUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {authorUserFindUniqueOrThrowArgs} args - Arguments to find a AuthorUser
     * @example
     * // Get one AuthorUser
     * const authorUser = await prisma.authorUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends authorUserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, authorUserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__authorUserClient<$Result.GetResult<Prisma.$authorUserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AuthorUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authorUserFindFirstArgs} args - Arguments to find a AuthorUser
     * @example
     * // Get one AuthorUser
     * const authorUser = await prisma.authorUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends authorUserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, authorUserFindFirstArgs<ExtArgs>>
    ): Prisma__authorUserClient<$Result.GetResult<Prisma.$authorUserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AuthorUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authorUserFindFirstOrThrowArgs} args - Arguments to find a AuthorUser
     * @example
     * // Get one AuthorUser
     * const authorUser = await prisma.authorUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends authorUserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, authorUserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__authorUserClient<$Result.GetResult<Prisma.$authorUserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AuthorUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authorUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuthorUsers
     * const authorUsers = await prisma.authorUser.findMany()
     * 
     * // Get first 10 AuthorUsers
     * const authorUsers = await prisma.authorUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const authorUserWithIdOnly = await prisma.authorUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends authorUserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, authorUserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$authorUserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AuthorUser.
     * @param {authorUserCreateArgs} args - Arguments to create a AuthorUser.
     * @example
     * // Create one AuthorUser
     * const AuthorUser = await prisma.authorUser.create({
     *   data: {
     *     // ... data to create a AuthorUser
     *   }
     * })
     * 
    **/
    create<T extends authorUserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, authorUserCreateArgs<ExtArgs>>
    ): Prisma__authorUserClient<$Result.GetResult<Prisma.$authorUserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AuthorUsers.
     *     @param {authorUserCreateManyArgs} args - Arguments to create many AuthorUsers.
     *     @example
     *     // Create many AuthorUsers
     *     const authorUser = await prisma.authorUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends authorUserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, authorUserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AuthorUser.
     * @param {authorUserDeleteArgs} args - Arguments to delete one AuthorUser.
     * @example
     * // Delete one AuthorUser
     * const AuthorUser = await prisma.authorUser.delete({
     *   where: {
     *     // ... filter to delete one AuthorUser
     *   }
     * })
     * 
    **/
    delete<T extends authorUserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, authorUserDeleteArgs<ExtArgs>>
    ): Prisma__authorUserClient<$Result.GetResult<Prisma.$authorUserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AuthorUser.
     * @param {authorUserUpdateArgs} args - Arguments to update one AuthorUser.
     * @example
     * // Update one AuthorUser
     * const authorUser = await prisma.authorUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends authorUserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, authorUserUpdateArgs<ExtArgs>>
    ): Prisma__authorUserClient<$Result.GetResult<Prisma.$authorUserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AuthorUsers.
     * @param {authorUserDeleteManyArgs} args - Arguments to filter AuthorUsers to delete.
     * @example
     * // Delete a few AuthorUsers
     * const { count } = await prisma.authorUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends authorUserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, authorUserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuthorUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authorUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuthorUsers
     * const authorUser = await prisma.authorUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends authorUserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, authorUserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuthorUser.
     * @param {authorUserUpsertArgs} args - Arguments to update or create a AuthorUser.
     * @example
     * // Update or create a AuthorUser
     * const authorUser = await prisma.authorUser.upsert({
     *   create: {
     *     // ... data to create a AuthorUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuthorUser we want to update
     *   }
     * })
    **/
    upsert<T extends authorUserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, authorUserUpsertArgs<ExtArgs>>
    ): Prisma__authorUserClient<$Result.GetResult<Prisma.$authorUserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AuthorUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authorUserCountArgs} args - Arguments to filter AuthorUsers to count.
     * @example
     * // Count the number of AuthorUsers
     * const count = await prisma.authorUser.count({
     *   where: {
     *     // ... the filter for the AuthorUsers we want to count
     *   }
     * })
    **/
    count<T extends authorUserCountArgs>(
      args?: Subset<T, authorUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthorUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuthorUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthorUserAggregateArgs>(args: Subset<T, AuthorUserAggregateArgs>): Prisma.PrismaPromise<GetAuthorUserAggregateType<T>>

    /**
     * Group by AuthorUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authorUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends authorUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: authorUserGroupByArgs['orderBy'] }
        : { orderBy?: authorUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, authorUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthorUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the authorUser model
   */
  readonly fields: authorUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for authorUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__authorUserClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the authorUser model
   */ 
  interface authorUserFieldRefs {
    readonly id: FieldRef<"authorUser", 'Int'>
    readonly personcode: FieldRef<"authorUser", 'String'>
    readonly userId: FieldRef<"authorUser", 'Int'>
    readonly notation: FieldRef<"authorUser", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * authorUser findUnique
   */
  export type authorUserFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authorUser
     */
    select?: authorUserSelect<ExtArgs> | null
    /**
     * Filter, which authorUser to fetch.
     */
    where: authorUserWhereUniqueInput
  }


  /**
   * authorUser findUniqueOrThrow
   */
  export type authorUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authorUser
     */
    select?: authorUserSelect<ExtArgs> | null
    /**
     * Filter, which authorUser to fetch.
     */
    where: authorUserWhereUniqueInput
  }


  /**
   * authorUser findFirst
   */
  export type authorUserFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authorUser
     */
    select?: authorUserSelect<ExtArgs> | null
    /**
     * Filter, which authorUser to fetch.
     */
    where?: authorUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of authorUsers to fetch.
     */
    orderBy?: authorUserOrderByWithRelationInput | authorUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for authorUsers.
     */
    cursor?: authorUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` authorUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` authorUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of authorUsers.
     */
    distinct?: AuthorUserScalarFieldEnum | AuthorUserScalarFieldEnum[]
  }


  /**
   * authorUser findFirstOrThrow
   */
  export type authorUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authorUser
     */
    select?: authorUserSelect<ExtArgs> | null
    /**
     * Filter, which authorUser to fetch.
     */
    where?: authorUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of authorUsers to fetch.
     */
    orderBy?: authorUserOrderByWithRelationInput | authorUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for authorUsers.
     */
    cursor?: authorUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` authorUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` authorUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of authorUsers.
     */
    distinct?: AuthorUserScalarFieldEnum | AuthorUserScalarFieldEnum[]
  }


  /**
   * authorUser findMany
   */
  export type authorUserFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authorUser
     */
    select?: authorUserSelect<ExtArgs> | null
    /**
     * Filter, which authorUsers to fetch.
     */
    where?: authorUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of authorUsers to fetch.
     */
    orderBy?: authorUserOrderByWithRelationInput | authorUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing authorUsers.
     */
    cursor?: authorUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` authorUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` authorUsers.
     */
    skip?: number
    distinct?: AuthorUserScalarFieldEnum | AuthorUserScalarFieldEnum[]
  }


  /**
   * authorUser create
   */
  export type authorUserCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authorUser
     */
    select?: authorUserSelect<ExtArgs> | null
    /**
     * The data needed to create a authorUser.
     */
    data: XOR<authorUserCreateInput, authorUserUncheckedCreateInput>
  }


  /**
   * authorUser createMany
   */
  export type authorUserCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many authorUsers.
     */
    data: authorUserCreateManyInput | authorUserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * authorUser update
   */
  export type authorUserUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authorUser
     */
    select?: authorUserSelect<ExtArgs> | null
    /**
     * The data needed to update a authorUser.
     */
    data: XOR<authorUserUpdateInput, authorUserUncheckedUpdateInput>
    /**
     * Choose, which authorUser to update.
     */
    where: authorUserWhereUniqueInput
  }


  /**
   * authorUser updateMany
   */
  export type authorUserUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update authorUsers.
     */
    data: XOR<authorUserUpdateManyMutationInput, authorUserUncheckedUpdateManyInput>
    /**
     * Filter which authorUsers to update
     */
    where?: authorUserWhereInput
  }


  /**
   * authorUser upsert
   */
  export type authorUserUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authorUser
     */
    select?: authorUserSelect<ExtArgs> | null
    /**
     * The filter to search for the authorUser to update in case it exists.
     */
    where: authorUserWhereUniqueInput
    /**
     * In case the authorUser found by the `where` argument doesn't exist, create a new authorUser with this data.
     */
    create: XOR<authorUserCreateInput, authorUserUncheckedCreateInput>
    /**
     * In case the authorUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<authorUserUpdateInput, authorUserUncheckedUpdateInput>
  }


  /**
   * authorUser delete
   */
  export type authorUserDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authorUser
     */
    select?: authorUserSelect<ExtArgs> | null
    /**
     * Filter which authorUser to delete.
     */
    where: authorUserWhereUniqueInput
  }


  /**
   * authorUser deleteMany
   */
  export type authorUserDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which authorUsers to delete
     */
    where?: authorUserWhereInput
  }


  /**
   * authorUser without action
   */
  export type authorUserDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authorUser
     */
    select?: authorUserSelect<ExtArgs> | null
  }



  /**
   * Model bibliotheque_contributeurs
   */

  export type AggregateBibliotheque_contributeurs = {
    _count: Bibliotheque_contributeursCountAggregateOutputType | null
    _avg: Bibliotheque_contributeursAvgAggregateOutputType | null
    _sum: Bibliotheque_contributeursSumAggregateOutputType | null
    _min: Bibliotheque_contributeursMinAggregateOutputType | null
    _max: Bibliotheque_contributeursMaxAggregateOutputType | null
  }

  export type Bibliotheque_contributeursAvgAggregateOutputType = {
    ID: number | null
  }

  export type Bibliotheque_contributeursSumAggregateOutputType = {
    ID: number | null
  }

  export type Bibliotheque_contributeursMinAggregateOutputType = {
    ID: number | null
    Nom: string | null
    Texte: string | null
  }

  export type Bibliotheque_contributeursMaxAggregateOutputType = {
    ID: number | null
    Nom: string | null
    Texte: string | null
  }

  export type Bibliotheque_contributeursCountAggregateOutputType = {
    ID: number
    Nom: number
    Texte: number
    _all: number
  }


  export type Bibliotheque_contributeursAvgAggregateInputType = {
    ID?: true
  }

  export type Bibliotheque_contributeursSumAggregateInputType = {
    ID?: true
  }

  export type Bibliotheque_contributeursMinAggregateInputType = {
    ID?: true
    Nom?: true
    Texte?: true
  }

  export type Bibliotheque_contributeursMaxAggregateInputType = {
    ID?: true
    Nom?: true
    Texte?: true
  }

  export type Bibliotheque_contributeursCountAggregateInputType = {
    ID?: true
    Nom?: true
    Texte?: true
    _all?: true
  }

  export type Bibliotheque_contributeursAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which bibliotheque_contributeurs to aggregate.
     */
    where?: bibliotheque_contributeursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bibliotheque_contributeurs to fetch.
     */
    orderBy?: bibliotheque_contributeursOrderByWithRelationInput | bibliotheque_contributeursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bibliotheque_contributeursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bibliotheque_contributeurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bibliotheque_contributeurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bibliotheque_contributeurs
    **/
    _count?: true | Bibliotheque_contributeursCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bibliotheque_contributeursAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bibliotheque_contributeursSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bibliotheque_contributeursMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bibliotheque_contributeursMaxAggregateInputType
  }

  export type GetBibliotheque_contributeursAggregateType<T extends Bibliotheque_contributeursAggregateArgs> = {
        [P in keyof T & keyof AggregateBibliotheque_contributeurs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBibliotheque_contributeurs[P]>
      : GetScalarType<T[P], AggregateBibliotheque_contributeurs[P]>
  }




  export type bibliotheque_contributeursGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: bibliotheque_contributeursWhereInput
    orderBy?: bibliotheque_contributeursOrderByWithAggregationInput | bibliotheque_contributeursOrderByWithAggregationInput[]
    by: Bibliotheque_contributeursScalarFieldEnum[] | Bibliotheque_contributeursScalarFieldEnum
    having?: bibliotheque_contributeursScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bibliotheque_contributeursCountAggregateInputType | true
    _avg?: Bibliotheque_contributeursAvgAggregateInputType
    _sum?: Bibliotheque_contributeursSumAggregateInputType
    _min?: Bibliotheque_contributeursMinAggregateInputType
    _max?: Bibliotheque_contributeursMaxAggregateInputType
  }

  export type Bibliotheque_contributeursGroupByOutputType = {
    ID: number
    Nom: string | null
    Texte: string | null
    _count: Bibliotheque_contributeursCountAggregateOutputType | null
    _avg: Bibliotheque_contributeursAvgAggregateOutputType | null
    _sum: Bibliotheque_contributeursSumAggregateOutputType | null
    _min: Bibliotheque_contributeursMinAggregateOutputType | null
    _max: Bibliotheque_contributeursMaxAggregateOutputType | null
  }

  type GetBibliotheque_contributeursGroupByPayload<T extends bibliotheque_contributeursGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bibliotheque_contributeursGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bibliotheque_contributeursGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bibliotheque_contributeursGroupByOutputType[P]>
            : GetScalarType<T[P], Bibliotheque_contributeursGroupByOutputType[P]>
        }
      >
    >


  export type bibliotheque_contributeursSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Nom?: boolean
    Texte?: boolean
  }, ExtArgs["result"]["bibliotheque_contributeurs"]>

  export type bibliotheque_contributeursSelectScalar = {
    ID?: boolean
    Nom?: boolean
    Texte?: boolean
  }


  export type $bibliotheque_contributeursPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "bibliotheque_contributeurs"
    objects: {}
    scalars: $Extensions.GetResult<{
      ID: number
      Nom: string | null
      Texte: string | null
    }, ExtArgs["result"]["bibliotheque_contributeurs"]>
    composites: {}
  }


  type bibliotheque_contributeursGetPayload<S extends boolean | null | undefined | bibliotheque_contributeursDefaultArgs> = $Result.GetResult<Prisma.$bibliotheque_contributeursPayload, S>

  type bibliotheque_contributeursCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<bibliotheque_contributeursFindManyArgs, 'select' | 'include'> & {
      select?: Bibliotheque_contributeursCountAggregateInputType | true
    }

  export interface bibliotheque_contributeursDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bibliotheque_contributeurs'], meta: { name: 'bibliotheque_contributeurs' } }
    /**
     * Find zero or one Bibliotheque_contributeurs that matches the filter.
     * @param {bibliotheque_contributeursFindUniqueArgs} args - Arguments to find a Bibliotheque_contributeurs
     * @example
     * // Get one Bibliotheque_contributeurs
     * const bibliotheque_contributeurs = await prisma.bibliotheque_contributeurs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends bibliotheque_contributeursFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, bibliotheque_contributeursFindUniqueArgs<ExtArgs>>
    ): Prisma__bibliotheque_contributeursClient<$Result.GetResult<Prisma.$bibliotheque_contributeursPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Bibliotheque_contributeurs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {bibliotheque_contributeursFindUniqueOrThrowArgs} args - Arguments to find a Bibliotheque_contributeurs
     * @example
     * // Get one Bibliotheque_contributeurs
     * const bibliotheque_contributeurs = await prisma.bibliotheque_contributeurs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends bibliotheque_contributeursFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bibliotheque_contributeursFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__bibliotheque_contributeursClient<$Result.GetResult<Prisma.$bibliotheque_contributeursPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Bibliotheque_contributeurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bibliotheque_contributeursFindFirstArgs} args - Arguments to find a Bibliotheque_contributeurs
     * @example
     * // Get one Bibliotheque_contributeurs
     * const bibliotheque_contributeurs = await prisma.bibliotheque_contributeurs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends bibliotheque_contributeursFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, bibliotheque_contributeursFindFirstArgs<ExtArgs>>
    ): Prisma__bibliotheque_contributeursClient<$Result.GetResult<Prisma.$bibliotheque_contributeursPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Bibliotheque_contributeurs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bibliotheque_contributeursFindFirstOrThrowArgs} args - Arguments to find a Bibliotheque_contributeurs
     * @example
     * // Get one Bibliotheque_contributeurs
     * const bibliotheque_contributeurs = await prisma.bibliotheque_contributeurs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends bibliotheque_contributeursFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bibliotheque_contributeursFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__bibliotheque_contributeursClient<$Result.GetResult<Prisma.$bibliotheque_contributeursPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Bibliotheque_contributeurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bibliotheque_contributeursFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bibliotheque_contributeurs
     * const bibliotheque_contributeurs = await prisma.bibliotheque_contributeurs.findMany()
     * 
     * // Get first 10 Bibliotheque_contributeurs
     * const bibliotheque_contributeurs = await prisma.bibliotheque_contributeurs.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const bibliotheque_contributeursWithIDOnly = await prisma.bibliotheque_contributeurs.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends bibliotheque_contributeursFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bibliotheque_contributeursFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bibliotheque_contributeursPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Bibliotheque_contributeurs.
     * @param {bibliotheque_contributeursCreateArgs} args - Arguments to create a Bibliotheque_contributeurs.
     * @example
     * // Create one Bibliotheque_contributeurs
     * const Bibliotheque_contributeurs = await prisma.bibliotheque_contributeurs.create({
     *   data: {
     *     // ... data to create a Bibliotheque_contributeurs
     *   }
     * })
     * 
    **/
    create<T extends bibliotheque_contributeursCreateArgs<ExtArgs>>(
      args: SelectSubset<T, bibliotheque_contributeursCreateArgs<ExtArgs>>
    ): Prisma__bibliotheque_contributeursClient<$Result.GetResult<Prisma.$bibliotheque_contributeursPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Bibliotheque_contributeurs.
     *     @param {bibliotheque_contributeursCreateManyArgs} args - Arguments to create many Bibliotheque_contributeurs.
     *     @example
     *     // Create many Bibliotheque_contributeurs
     *     const bibliotheque_contributeurs = await prisma.bibliotheque_contributeurs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends bibliotheque_contributeursCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bibliotheque_contributeursCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bibliotheque_contributeurs.
     * @param {bibliotheque_contributeursDeleteArgs} args - Arguments to delete one Bibliotheque_contributeurs.
     * @example
     * // Delete one Bibliotheque_contributeurs
     * const Bibliotheque_contributeurs = await prisma.bibliotheque_contributeurs.delete({
     *   where: {
     *     // ... filter to delete one Bibliotheque_contributeurs
     *   }
     * })
     * 
    **/
    delete<T extends bibliotheque_contributeursDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, bibliotheque_contributeursDeleteArgs<ExtArgs>>
    ): Prisma__bibliotheque_contributeursClient<$Result.GetResult<Prisma.$bibliotheque_contributeursPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Bibliotheque_contributeurs.
     * @param {bibliotheque_contributeursUpdateArgs} args - Arguments to update one Bibliotheque_contributeurs.
     * @example
     * // Update one Bibliotheque_contributeurs
     * const bibliotheque_contributeurs = await prisma.bibliotheque_contributeurs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends bibliotheque_contributeursUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, bibliotheque_contributeursUpdateArgs<ExtArgs>>
    ): Prisma__bibliotheque_contributeursClient<$Result.GetResult<Prisma.$bibliotheque_contributeursPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Bibliotheque_contributeurs.
     * @param {bibliotheque_contributeursDeleteManyArgs} args - Arguments to filter Bibliotheque_contributeurs to delete.
     * @example
     * // Delete a few Bibliotheque_contributeurs
     * const { count } = await prisma.bibliotheque_contributeurs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends bibliotheque_contributeursDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bibliotheque_contributeursDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bibliotheque_contributeurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bibliotheque_contributeursUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bibliotheque_contributeurs
     * const bibliotheque_contributeurs = await prisma.bibliotheque_contributeurs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends bibliotheque_contributeursUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, bibliotheque_contributeursUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bibliotheque_contributeurs.
     * @param {bibliotheque_contributeursUpsertArgs} args - Arguments to update or create a Bibliotheque_contributeurs.
     * @example
     * // Update or create a Bibliotheque_contributeurs
     * const bibliotheque_contributeurs = await prisma.bibliotheque_contributeurs.upsert({
     *   create: {
     *     // ... data to create a Bibliotheque_contributeurs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bibliotheque_contributeurs we want to update
     *   }
     * })
    **/
    upsert<T extends bibliotheque_contributeursUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, bibliotheque_contributeursUpsertArgs<ExtArgs>>
    ): Prisma__bibliotheque_contributeursClient<$Result.GetResult<Prisma.$bibliotheque_contributeursPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Bibliotheque_contributeurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bibliotheque_contributeursCountArgs} args - Arguments to filter Bibliotheque_contributeurs to count.
     * @example
     * // Count the number of Bibliotheque_contributeurs
     * const count = await prisma.bibliotheque_contributeurs.count({
     *   where: {
     *     // ... the filter for the Bibliotheque_contributeurs we want to count
     *   }
     * })
    **/
    count<T extends bibliotheque_contributeursCountArgs>(
      args?: Subset<T, bibliotheque_contributeursCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bibliotheque_contributeursCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bibliotheque_contributeurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bibliotheque_contributeursAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bibliotheque_contributeursAggregateArgs>(args: Subset<T, Bibliotheque_contributeursAggregateArgs>): Prisma.PrismaPromise<GetBibliotheque_contributeursAggregateType<T>>

    /**
     * Group by Bibliotheque_contributeurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bibliotheque_contributeursGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bibliotheque_contributeursGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bibliotheque_contributeursGroupByArgs['orderBy'] }
        : { orderBy?: bibliotheque_contributeursGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bibliotheque_contributeursGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBibliotheque_contributeursGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bibliotheque_contributeurs model
   */
  readonly fields: bibliotheque_contributeursFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bibliotheque_contributeurs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bibliotheque_contributeursClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the bibliotheque_contributeurs model
   */ 
  interface bibliotheque_contributeursFieldRefs {
    readonly ID: FieldRef<"bibliotheque_contributeurs", 'Int'>
    readonly Nom: FieldRef<"bibliotheque_contributeurs", 'String'>
    readonly Texte: FieldRef<"bibliotheque_contributeurs", 'String'>
  }
    

  // Custom InputTypes

  /**
   * bibliotheque_contributeurs findUnique
   */
  export type bibliotheque_contributeursFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bibliotheque_contributeurs
     */
    select?: bibliotheque_contributeursSelect<ExtArgs> | null
    /**
     * Filter, which bibliotheque_contributeurs to fetch.
     */
    where: bibliotheque_contributeursWhereUniqueInput
  }


  /**
   * bibliotheque_contributeurs findUniqueOrThrow
   */
  export type bibliotheque_contributeursFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bibliotheque_contributeurs
     */
    select?: bibliotheque_contributeursSelect<ExtArgs> | null
    /**
     * Filter, which bibliotheque_contributeurs to fetch.
     */
    where: bibliotheque_contributeursWhereUniqueInput
  }


  /**
   * bibliotheque_contributeurs findFirst
   */
  export type bibliotheque_contributeursFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bibliotheque_contributeurs
     */
    select?: bibliotheque_contributeursSelect<ExtArgs> | null
    /**
     * Filter, which bibliotheque_contributeurs to fetch.
     */
    where?: bibliotheque_contributeursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bibliotheque_contributeurs to fetch.
     */
    orderBy?: bibliotheque_contributeursOrderByWithRelationInput | bibliotheque_contributeursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bibliotheque_contributeurs.
     */
    cursor?: bibliotheque_contributeursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bibliotheque_contributeurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bibliotheque_contributeurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bibliotheque_contributeurs.
     */
    distinct?: Bibliotheque_contributeursScalarFieldEnum | Bibliotheque_contributeursScalarFieldEnum[]
  }


  /**
   * bibliotheque_contributeurs findFirstOrThrow
   */
  export type bibliotheque_contributeursFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bibliotheque_contributeurs
     */
    select?: bibliotheque_contributeursSelect<ExtArgs> | null
    /**
     * Filter, which bibliotheque_contributeurs to fetch.
     */
    where?: bibliotheque_contributeursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bibliotheque_contributeurs to fetch.
     */
    orderBy?: bibliotheque_contributeursOrderByWithRelationInput | bibliotheque_contributeursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bibliotheque_contributeurs.
     */
    cursor?: bibliotheque_contributeursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bibliotheque_contributeurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bibliotheque_contributeurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bibliotheque_contributeurs.
     */
    distinct?: Bibliotheque_contributeursScalarFieldEnum | Bibliotheque_contributeursScalarFieldEnum[]
  }


  /**
   * bibliotheque_contributeurs findMany
   */
  export type bibliotheque_contributeursFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bibliotheque_contributeurs
     */
    select?: bibliotheque_contributeursSelect<ExtArgs> | null
    /**
     * Filter, which bibliotheque_contributeurs to fetch.
     */
    where?: bibliotheque_contributeursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bibliotheque_contributeurs to fetch.
     */
    orderBy?: bibliotheque_contributeursOrderByWithRelationInput | bibliotheque_contributeursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bibliotheque_contributeurs.
     */
    cursor?: bibliotheque_contributeursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bibliotheque_contributeurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bibliotheque_contributeurs.
     */
    skip?: number
    distinct?: Bibliotheque_contributeursScalarFieldEnum | Bibliotheque_contributeursScalarFieldEnum[]
  }


  /**
   * bibliotheque_contributeurs create
   */
  export type bibliotheque_contributeursCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bibliotheque_contributeurs
     */
    select?: bibliotheque_contributeursSelect<ExtArgs> | null
    /**
     * The data needed to create a bibliotheque_contributeurs.
     */
    data?: XOR<bibliotheque_contributeursCreateInput, bibliotheque_contributeursUncheckedCreateInput>
  }


  /**
   * bibliotheque_contributeurs createMany
   */
  export type bibliotheque_contributeursCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bibliotheque_contributeurs.
     */
    data: bibliotheque_contributeursCreateManyInput | bibliotheque_contributeursCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * bibliotheque_contributeurs update
   */
  export type bibliotheque_contributeursUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bibliotheque_contributeurs
     */
    select?: bibliotheque_contributeursSelect<ExtArgs> | null
    /**
     * The data needed to update a bibliotheque_contributeurs.
     */
    data: XOR<bibliotheque_contributeursUpdateInput, bibliotheque_contributeursUncheckedUpdateInput>
    /**
     * Choose, which bibliotheque_contributeurs to update.
     */
    where: bibliotheque_contributeursWhereUniqueInput
  }


  /**
   * bibliotheque_contributeurs updateMany
   */
  export type bibliotheque_contributeursUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bibliotheque_contributeurs.
     */
    data: XOR<bibliotheque_contributeursUpdateManyMutationInput, bibliotheque_contributeursUncheckedUpdateManyInput>
    /**
     * Filter which bibliotheque_contributeurs to update
     */
    where?: bibliotheque_contributeursWhereInput
  }


  /**
   * bibliotheque_contributeurs upsert
   */
  export type bibliotheque_contributeursUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bibliotheque_contributeurs
     */
    select?: bibliotheque_contributeursSelect<ExtArgs> | null
    /**
     * The filter to search for the bibliotheque_contributeurs to update in case it exists.
     */
    where: bibliotheque_contributeursWhereUniqueInput
    /**
     * In case the bibliotheque_contributeurs found by the `where` argument doesn't exist, create a new bibliotheque_contributeurs with this data.
     */
    create: XOR<bibliotheque_contributeursCreateInput, bibliotheque_contributeursUncheckedCreateInput>
    /**
     * In case the bibliotheque_contributeurs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bibliotheque_contributeursUpdateInput, bibliotheque_contributeursUncheckedUpdateInput>
  }


  /**
   * bibliotheque_contributeurs delete
   */
  export type bibliotheque_contributeursDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bibliotheque_contributeurs
     */
    select?: bibliotheque_contributeursSelect<ExtArgs> | null
    /**
     * Filter which bibliotheque_contributeurs to delete.
     */
    where: bibliotheque_contributeursWhereUniqueInput
  }


  /**
   * bibliotheque_contributeurs deleteMany
   */
  export type bibliotheque_contributeursDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which bibliotheque_contributeurs to delete
     */
    where?: bibliotheque_contributeursWhereInput
  }


  /**
   * bibliotheque_contributeurs without action
   */
  export type bibliotheque_contributeursDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bibliotheque_contributeurs
     */
    select?: bibliotheque_contributeursSelect<ExtArgs> | null
  }



  /**
   * Model bookcasePublicationOrder
   */

  export type AggregateBookcasePublicationOrder = {
    _count: BookcasePublicationOrderCountAggregateOutputType | null
    _avg: BookcasePublicationOrderAvgAggregateOutputType | null
    _sum: BookcasePublicationOrderSumAggregateOutputType | null
    _min: BookcasePublicationOrderMinAggregateOutputType | null
    _max: BookcasePublicationOrderMaxAggregateOutputType | null
  }

  export type BookcasePublicationOrderAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    order: number | null
  }

  export type BookcasePublicationOrderSumAggregateOutputType = {
    id: number | null
    userId: number | null
    order: number | null
  }

  export type BookcasePublicationOrderMinAggregateOutputType = {
    id: number | null
    userId: number | null
    publicationcode: string | null
    order: number | null
  }

  export type BookcasePublicationOrderMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    publicationcode: string | null
    order: number | null
  }

  export type BookcasePublicationOrderCountAggregateOutputType = {
    id: number
    userId: number
    publicationcode: number
    order: number
    _all: number
  }


  export type BookcasePublicationOrderAvgAggregateInputType = {
    id?: true
    userId?: true
    order?: true
  }

  export type BookcasePublicationOrderSumAggregateInputType = {
    id?: true
    userId?: true
    order?: true
  }

  export type BookcasePublicationOrderMinAggregateInputType = {
    id?: true
    userId?: true
    publicationcode?: true
    order?: true
  }

  export type BookcasePublicationOrderMaxAggregateInputType = {
    id?: true
    userId?: true
    publicationcode?: true
    order?: true
  }

  export type BookcasePublicationOrderCountAggregateInputType = {
    id?: true
    userId?: true
    publicationcode?: true
    order?: true
    _all?: true
  }

  export type BookcasePublicationOrderAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which bookcasePublicationOrder to aggregate.
     */
    where?: bookcasePublicationOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bookcasePublicationOrders to fetch.
     */
    orderBy?: bookcasePublicationOrderOrderByWithRelationInput | bookcasePublicationOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bookcasePublicationOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bookcasePublicationOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bookcasePublicationOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bookcasePublicationOrders
    **/
    _count?: true | BookcasePublicationOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookcasePublicationOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookcasePublicationOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookcasePublicationOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookcasePublicationOrderMaxAggregateInputType
  }

  export type GetBookcasePublicationOrderAggregateType<T extends BookcasePublicationOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateBookcasePublicationOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookcasePublicationOrder[P]>
      : GetScalarType<T[P], AggregateBookcasePublicationOrder[P]>
  }




  export type bookcasePublicationOrderGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: bookcasePublicationOrderWhereInput
    orderBy?: bookcasePublicationOrderOrderByWithAggregationInput | bookcasePublicationOrderOrderByWithAggregationInput[]
    by: BookcasePublicationOrderScalarFieldEnum[] | BookcasePublicationOrderScalarFieldEnum
    having?: bookcasePublicationOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookcasePublicationOrderCountAggregateInputType | true
    _avg?: BookcasePublicationOrderAvgAggregateInputType
    _sum?: BookcasePublicationOrderSumAggregateInputType
    _min?: BookcasePublicationOrderMinAggregateInputType
    _max?: BookcasePublicationOrderMaxAggregateInputType
  }

  export type BookcasePublicationOrderGroupByOutputType = {
    id: number
    userId: number
    publicationcode: string
    order: number
    _count: BookcasePublicationOrderCountAggregateOutputType | null
    _avg: BookcasePublicationOrderAvgAggregateOutputType | null
    _sum: BookcasePublicationOrderSumAggregateOutputType | null
    _min: BookcasePublicationOrderMinAggregateOutputType | null
    _max: BookcasePublicationOrderMaxAggregateOutputType | null
  }

  type GetBookcasePublicationOrderGroupByPayload<T extends bookcasePublicationOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookcasePublicationOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookcasePublicationOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookcasePublicationOrderGroupByOutputType[P]>
            : GetScalarType<T[P], BookcasePublicationOrderGroupByOutputType[P]>
        }
      >
    >


  export type bookcasePublicationOrderSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    publicationcode?: boolean
    order?: boolean
  }, ExtArgs["result"]["bookcasePublicationOrder"]>

  export type bookcasePublicationOrderSelectScalar = {
    id?: boolean
    userId?: boolean
    publicationcode?: boolean
    order?: boolean
  }


  export type $bookcasePublicationOrderPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "bookcasePublicationOrder"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: number
      userId: number
      publicationcode: string
      order: number
    }, ExtArgs["result"]["bookcasePublicationOrder"]>
    composites: {}
  }


  type bookcasePublicationOrderGetPayload<S extends boolean | null | undefined | bookcasePublicationOrderDefaultArgs> = $Result.GetResult<Prisma.$bookcasePublicationOrderPayload, S>

  type bookcasePublicationOrderCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<bookcasePublicationOrderFindManyArgs, 'select' | 'include'> & {
      select?: BookcasePublicationOrderCountAggregateInputType | true
    }

  export interface bookcasePublicationOrderDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bookcasePublicationOrder'], meta: { name: 'bookcasePublicationOrder' } }
    /**
     * Find zero or one BookcasePublicationOrder that matches the filter.
     * @param {bookcasePublicationOrderFindUniqueArgs} args - Arguments to find a BookcasePublicationOrder
     * @example
     * // Get one BookcasePublicationOrder
     * const bookcasePublicationOrder = await prisma.bookcasePublicationOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends bookcasePublicationOrderFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, bookcasePublicationOrderFindUniqueArgs<ExtArgs>>
    ): Prisma__bookcasePublicationOrderClient<$Result.GetResult<Prisma.$bookcasePublicationOrderPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BookcasePublicationOrder that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {bookcasePublicationOrderFindUniqueOrThrowArgs} args - Arguments to find a BookcasePublicationOrder
     * @example
     * // Get one BookcasePublicationOrder
     * const bookcasePublicationOrder = await prisma.bookcasePublicationOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends bookcasePublicationOrderFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bookcasePublicationOrderFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__bookcasePublicationOrderClient<$Result.GetResult<Prisma.$bookcasePublicationOrderPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BookcasePublicationOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookcasePublicationOrderFindFirstArgs} args - Arguments to find a BookcasePublicationOrder
     * @example
     * // Get one BookcasePublicationOrder
     * const bookcasePublicationOrder = await prisma.bookcasePublicationOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends bookcasePublicationOrderFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, bookcasePublicationOrderFindFirstArgs<ExtArgs>>
    ): Prisma__bookcasePublicationOrderClient<$Result.GetResult<Prisma.$bookcasePublicationOrderPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BookcasePublicationOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookcasePublicationOrderFindFirstOrThrowArgs} args - Arguments to find a BookcasePublicationOrder
     * @example
     * // Get one BookcasePublicationOrder
     * const bookcasePublicationOrder = await prisma.bookcasePublicationOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends bookcasePublicationOrderFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bookcasePublicationOrderFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__bookcasePublicationOrderClient<$Result.GetResult<Prisma.$bookcasePublicationOrderPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BookcasePublicationOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookcasePublicationOrderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookcasePublicationOrders
     * const bookcasePublicationOrders = await prisma.bookcasePublicationOrder.findMany()
     * 
     * // Get first 10 BookcasePublicationOrders
     * const bookcasePublicationOrders = await prisma.bookcasePublicationOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookcasePublicationOrderWithIdOnly = await prisma.bookcasePublicationOrder.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends bookcasePublicationOrderFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bookcasePublicationOrderFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bookcasePublicationOrderPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BookcasePublicationOrder.
     * @param {bookcasePublicationOrderCreateArgs} args - Arguments to create a BookcasePublicationOrder.
     * @example
     * // Create one BookcasePublicationOrder
     * const BookcasePublicationOrder = await prisma.bookcasePublicationOrder.create({
     *   data: {
     *     // ... data to create a BookcasePublicationOrder
     *   }
     * })
     * 
    **/
    create<T extends bookcasePublicationOrderCreateArgs<ExtArgs>>(
      args: SelectSubset<T, bookcasePublicationOrderCreateArgs<ExtArgs>>
    ): Prisma__bookcasePublicationOrderClient<$Result.GetResult<Prisma.$bookcasePublicationOrderPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BookcasePublicationOrders.
     *     @param {bookcasePublicationOrderCreateManyArgs} args - Arguments to create many BookcasePublicationOrders.
     *     @example
     *     // Create many BookcasePublicationOrders
     *     const bookcasePublicationOrder = await prisma.bookcasePublicationOrder.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends bookcasePublicationOrderCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bookcasePublicationOrderCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BookcasePublicationOrder.
     * @param {bookcasePublicationOrderDeleteArgs} args - Arguments to delete one BookcasePublicationOrder.
     * @example
     * // Delete one BookcasePublicationOrder
     * const BookcasePublicationOrder = await prisma.bookcasePublicationOrder.delete({
     *   where: {
     *     // ... filter to delete one BookcasePublicationOrder
     *   }
     * })
     * 
    **/
    delete<T extends bookcasePublicationOrderDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, bookcasePublicationOrderDeleteArgs<ExtArgs>>
    ): Prisma__bookcasePublicationOrderClient<$Result.GetResult<Prisma.$bookcasePublicationOrderPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BookcasePublicationOrder.
     * @param {bookcasePublicationOrderUpdateArgs} args - Arguments to update one BookcasePublicationOrder.
     * @example
     * // Update one BookcasePublicationOrder
     * const bookcasePublicationOrder = await prisma.bookcasePublicationOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends bookcasePublicationOrderUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, bookcasePublicationOrderUpdateArgs<ExtArgs>>
    ): Prisma__bookcasePublicationOrderClient<$Result.GetResult<Prisma.$bookcasePublicationOrderPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BookcasePublicationOrders.
     * @param {bookcasePublicationOrderDeleteManyArgs} args - Arguments to filter BookcasePublicationOrders to delete.
     * @example
     * // Delete a few BookcasePublicationOrders
     * const { count } = await prisma.bookcasePublicationOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends bookcasePublicationOrderDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bookcasePublicationOrderDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookcasePublicationOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookcasePublicationOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookcasePublicationOrders
     * const bookcasePublicationOrder = await prisma.bookcasePublicationOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends bookcasePublicationOrderUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, bookcasePublicationOrderUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BookcasePublicationOrder.
     * @param {bookcasePublicationOrderUpsertArgs} args - Arguments to update or create a BookcasePublicationOrder.
     * @example
     * // Update or create a BookcasePublicationOrder
     * const bookcasePublicationOrder = await prisma.bookcasePublicationOrder.upsert({
     *   create: {
     *     // ... data to create a BookcasePublicationOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookcasePublicationOrder we want to update
     *   }
     * })
    **/
    upsert<T extends bookcasePublicationOrderUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, bookcasePublicationOrderUpsertArgs<ExtArgs>>
    ): Prisma__bookcasePublicationOrderClient<$Result.GetResult<Prisma.$bookcasePublicationOrderPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BookcasePublicationOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookcasePublicationOrderCountArgs} args - Arguments to filter BookcasePublicationOrders to count.
     * @example
     * // Count the number of BookcasePublicationOrders
     * const count = await prisma.bookcasePublicationOrder.count({
     *   where: {
     *     // ... the filter for the BookcasePublicationOrders we want to count
     *   }
     * })
    **/
    count<T extends bookcasePublicationOrderCountArgs>(
      args?: Subset<T, bookcasePublicationOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookcasePublicationOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookcasePublicationOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookcasePublicationOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookcasePublicationOrderAggregateArgs>(args: Subset<T, BookcasePublicationOrderAggregateArgs>): Prisma.PrismaPromise<GetBookcasePublicationOrderAggregateType<T>>

    /**
     * Group by BookcasePublicationOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookcasePublicationOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bookcasePublicationOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bookcasePublicationOrderGroupByArgs['orderBy'] }
        : { orderBy?: bookcasePublicationOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bookcasePublicationOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookcasePublicationOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bookcasePublicationOrder model
   */
  readonly fields: bookcasePublicationOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bookcasePublicationOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bookcasePublicationOrderClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the bookcasePublicationOrder model
   */ 
  interface bookcasePublicationOrderFieldRefs {
    readonly id: FieldRef<"bookcasePublicationOrder", 'Int'>
    readonly userId: FieldRef<"bookcasePublicationOrder", 'Int'>
    readonly publicationcode: FieldRef<"bookcasePublicationOrder", 'String'>
    readonly order: FieldRef<"bookcasePublicationOrder", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * bookcasePublicationOrder findUnique
   */
  export type bookcasePublicationOrderFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookcasePublicationOrder
     */
    select?: bookcasePublicationOrderSelect<ExtArgs> | null
    /**
     * Filter, which bookcasePublicationOrder to fetch.
     */
    where: bookcasePublicationOrderWhereUniqueInput
  }


  /**
   * bookcasePublicationOrder findUniqueOrThrow
   */
  export type bookcasePublicationOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookcasePublicationOrder
     */
    select?: bookcasePublicationOrderSelect<ExtArgs> | null
    /**
     * Filter, which bookcasePublicationOrder to fetch.
     */
    where: bookcasePublicationOrderWhereUniqueInput
  }


  /**
   * bookcasePublicationOrder findFirst
   */
  export type bookcasePublicationOrderFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookcasePublicationOrder
     */
    select?: bookcasePublicationOrderSelect<ExtArgs> | null
    /**
     * Filter, which bookcasePublicationOrder to fetch.
     */
    where?: bookcasePublicationOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bookcasePublicationOrders to fetch.
     */
    orderBy?: bookcasePublicationOrderOrderByWithRelationInput | bookcasePublicationOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bookcasePublicationOrders.
     */
    cursor?: bookcasePublicationOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bookcasePublicationOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bookcasePublicationOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bookcasePublicationOrders.
     */
    distinct?: BookcasePublicationOrderScalarFieldEnum | BookcasePublicationOrderScalarFieldEnum[]
  }


  /**
   * bookcasePublicationOrder findFirstOrThrow
   */
  export type bookcasePublicationOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookcasePublicationOrder
     */
    select?: bookcasePublicationOrderSelect<ExtArgs> | null
    /**
     * Filter, which bookcasePublicationOrder to fetch.
     */
    where?: bookcasePublicationOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bookcasePublicationOrders to fetch.
     */
    orderBy?: bookcasePublicationOrderOrderByWithRelationInput | bookcasePublicationOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bookcasePublicationOrders.
     */
    cursor?: bookcasePublicationOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bookcasePublicationOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bookcasePublicationOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bookcasePublicationOrders.
     */
    distinct?: BookcasePublicationOrderScalarFieldEnum | BookcasePublicationOrderScalarFieldEnum[]
  }


  /**
   * bookcasePublicationOrder findMany
   */
  export type bookcasePublicationOrderFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookcasePublicationOrder
     */
    select?: bookcasePublicationOrderSelect<ExtArgs> | null
    /**
     * Filter, which bookcasePublicationOrders to fetch.
     */
    where?: bookcasePublicationOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bookcasePublicationOrders to fetch.
     */
    orderBy?: bookcasePublicationOrderOrderByWithRelationInput | bookcasePublicationOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bookcasePublicationOrders.
     */
    cursor?: bookcasePublicationOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bookcasePublicationOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bookcasePublicationOrders.
     */
    skip?: number
    distinct?: BookcasePublicationOrderScalarFieldEnum | BookcasePublicationOrderScalarFieldEnum[]
  }


  /**
   * bookcasePublicationOrder create
   */
  export type bookcasePublicationOrderCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookcasePublicationOrder
     */
    select?: bookcasePublicationOrderSelect<ExtArgs> | null
    /**
     * The data needed to create a bookcasePublicationOrder.
     */
    data: XOR<bookcasePublicationOrderCreateInput, bookcasePublicationOrderUncheckedCreateInput>
  }


  /**
   * bookcasePublicationOrder createMany
   */
  export type bookcasePublicationOrderCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bookcasePublicationOrders.
     */
    data: bookcasePublicationOrderCreateManyInput | bookcasePublicationOrderCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * bookcasePublicationOrder update
   */
  export type bookcasePublicationOrderUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookcasePublicationOrder
     */
    select?: bookcasePublicationOrderSelect<ExtArgs> | null
    /**
     * The data needed to update a bookcasePublicationOrder.
     */
    data: XOR<bookcasePublicationOrderUpdateInput, bookcasePublicationOrderUncheckedUpdateInput>
    /**
     * Choose, which bookcasePublicationOrder to update.
     */
    where: bookcasePublicationOrderWhereUniqueInput
  }


  /**
   * bookcasePublicationOrder updateMany
   */
  export type bookcasePublicationOrderUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bookcasePublicationOrders.
     */
    data: XOR<bookcasePublicationOrderUpdateManyMutationInput, bookcasePublicationOrderUncheckedUpdateManyInput>
    /**
     * Filter which bookcasePublicationOrders to update
     */
    where?: bookcasePublicationOrderWhereInput
  }


  /**
   * bookcasePublicationOrder upsert
   */
  export type bookcasePublicationOrderUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookcasePublicationOrder
     */
    select?: bookcasePublicationOrderSelect<ExtArgs> | null
    /**
     * The filter to search for the bookcasePublicationOrder to update in case it exists.
     */
    where: bookcasePublicationOrderWhereUniqueInput
    /**
     * In case the bookcasePublicationOrder found by the `where` argument doesn't exist, create a new bookcasePublicationOrder with this data.
     */
    create: XOR<bookcasePublicationOrderCreateInput, bookcasePublicationOrderUncheckedCreateInput>
    /**
     * In case the bookcasePublicationOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bookcasePublicationOrderUpdateInput, bookcasePublicationOrderUncheckedUpdateInput>
  }


  /**
   * bookcasePublicationOrder delete
   */
  export type bookcasePublicationOrderDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookcasePublicationOrder
     */
    select?: bookcasePublicationOrderSelect<ExtArgs> | null
    /**
     * Filter which bookcasePublicationOrder to delete.
     */
    where: bookcasePublicationOrderWhereUniqueInput
  }


  /**
   * bookcasePublicationOrder deleteMany
   */
  export type bookcasePublicationOrderDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which bookcasePublicationOrders to delete
     */
    where?: bookcasePublicationOrderWhereInput
  }


  /**
   * bookcasePublicationOrder without action
   */
  export type bookcasePublicationOrderDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookcasePublicationOrder
     */
    select?: bookcasePublicationOrderSelect<ExtArgs> | null
  }



  /**
   * Model bookstore
   */

  export type AggregateBookstore = {
    _count: BookstoreCountAggregateOutputType | null
    _avg: BookstoreAvgAggregateOutputType | null
    _sum: BookstoreSumAggregateOutputType | null
    _min: BookstoreMinAggregateOutputType | null
    _max: BookstoreMaxAggregateOutputType | null
  }

  export type BookstoreAvgAggregateOutputType = {
    id: number | null
    coordX: number | null
    coordY: number | null
  }

  export type BookstoreSumAggregateOutputType = {
    id: number | null
    coordX: number | null
    coordY: number | null
  }

  export type BookstoreMinAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    coordX: number | null
    coordY: number | null
  }

  export type BookstoreMaxAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    coordX: number | null
    coordY: number | null
  }

  export type BookstoreCountAggregateOutputType = {
    id: number
    name: number
    address: number
    coordX: number
    coordY: number
    _all: number
  }


  export type BookstoreAvgAggregateInputType = {
    id?: true
    coordX?: true
    coordY?: true
  }

  export type BookstoreSumAggregateInputType = {
    id?: true
    coordX?: true
    coordY?: true
  }

  export type BookstoreMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    coordX?: true
    coordY?: true
  }

  export type BookstoreMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    coordX?: true
    coordY?: true
  }

  export type BookstoreCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    coordX?: true
    coordY?: true
    _all?: true
  }

  export type BookstoreAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which bookstore to aggregate.
     */
    where?: bookstoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bookstores to fetch.
     */
    orderBy?: bookstoreOrderByWithRelationInput | bookstoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bookstoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bookstores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bookstores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bookstores
    **/
    _count?: true | BookstoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookstoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookstoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookstoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookstoreMaxAggregateInputType
  }

  export type GetBookstoreAggregateType<T extends BookstoreAggregateArgs> = {
        [P in keyof T & keyof AggregateBookstore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookstore[P]>
      : GetScalarType<T[P], AggregateBookstore[P]>
  }




  export type bookstoreGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: bookstoreWhereInput
    orderBy?: bookstoreOrderByWithAggregationInput | bookstoreOrderByWithAggregationInput[]
    by: BookstoreScalarFieldEnum[] | BookstoreScalarFieldEnum
    having?: bookstoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookstoreCountAggregateInputType | true
    _avg?: BookstoreAvgAggregateInputType
    _sum?: BookstoreSumAggregateInputType
    _min?: BookstoreMinAggregateInputType
    _max?: BookstoreMaxAggregateInputType
  }

  export type BookstoreGroupByOutputType = {
    id: number
    name: string
    address: string
    coordX: number
    coordY: number
    _count: BookstoreCountAggregateOutputType | null
    _avg: BookstoreAvgAggregateOutputType | null
    _sum: BookstoreSumAggregateOutputType | null
    _min: BookstoreMinAggregateOutputType | null
    _max: BookstoreMaxAggregateOutputType | null
  }

  type GetBookstoreGroupByPayload<T extends bookstoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookstoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookstoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookstoreGroupByOutputType[P]>
            : GetScalarType<T[P], BookstoreGroupByOutputType[P]>
        }
      >
    >


  export type bookstoreSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    coordX?: boolean
    coordY?: boolean
    comments?: boolean | bookstore$commentsArgs<ExtArgs>
    users_contributions?: boolean | bookstore$users_contributionsArgs<ExtArgs>
    _count?: boolean | BookstoreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookstore"]>

  export type bookstoreSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    coordX?: boolean
    coordY?: boolean
  }

  export type bookstoreInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    comments?: boolean | bookstore$commentsArgs<ExtArgs>
    users_contributions?: boolean | bookstore$users_contributionsArgs<ExtArgs>
    _count?: boolean | BookstoreCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $bookstorePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "bookstore"
    objects: {
      comments: Prisma.$bookstoreCommentPayload<ExtArgs>[]
      users_contributions: Prisma.$userContributionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      name: string
      address: string
      coordX: number
      coordY: number
    }, ExtArgs["result"]["bookstore"]>
    composites: {}
  }


  type bookstoreGetPayload<S extends boolean | null | undefined | bookstoreDefaultArgs> = $Result.GetResult<Prisma.$bookstorePayload, S>

  type bookstoreCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<bookstoreFindManyArgs, 'select' | 'include'> & {
      select?: BookstoreCountAggregateInputType | true
    }

  export interface bookstoreDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bookstore'], meta: { name: 'bookstore' } }
    /**
     * Find zero or one Bookstore that matches the filter.
     * @param {bookstoreFindUniqueArgs} args - Arguments to find a Bookstore
     * @example
     * // Get one Bookstore
     * const bookstore = await prisma.bookstore.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends bookstoreFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, bookstoreFindUniqueArgs<ExtArgs>>
    ): Prisma__bookstoreClient<$Result.GetResult<Prisma.$bookstorePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Bookstore that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {bookstoreFindUniqueOrThrowArgs} args - Arguments to find a Bookstore
     * @example
     * // Get one Bookstore
     * const bookstore = await prisma.bookstore.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends bookstoreFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bookstoreFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__bookstoreClient<$Result.GetResult<Prisma.$bookstorePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Bookstore that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookstoreFindFirstArgs} args - Arguments to find a Bookstore
     * @example
     * // Get one Bookstore
     * const bookstore = await prisma.bookstore.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends bookstoreFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, bookstoreFindFirstArgs<ExtArgs>>
    ): Prisma__bookstoreClient<$Result.GetResult<Prisma.$bookstorePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Bookstore that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookstoreFindFirstOrThrowArgs} args - Arguments to find a Bookstore
     * @example
     * // Get one Bookstore
     * const bookstore = await prisma.bookstore.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends bookstoreFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bookstoreFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__bookstoreClient<$Result.GetResult<Prisma.$bookstorePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Bookstores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookstoreFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookstores
     * const bookstores = await prisma.bookstore.findMany()
     * 
     * // Get first 10 Bookstores
     * const bookstores = await prisma.bookstore.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookstoreWithIdOnly = await prisma.bookstore.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends bookstoreFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bookstoreFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bookstorePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Bookstore.
     * @param {bookstoreCreateArgs} args - Arguments to create a Bookstore.
     * @example
     * // Create one Bookstore
     * const Bookstore = await prisma.bookstore.create({
     *   data: {
     *     // ... data to create a Bookstore
     *   }
     * })
     * 
    **/
    create<T extends bookstoreCreateArgs<ExtArgs>>(
      args: SelectSubset<T, bookstoreCreateArgs<ExtArgs>>
    ): Prisma__bookstoreClient<$Result.GetResult<Prisma.$bookstorePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Bookstores.
     *     @param {bookstoreCreateManyArgs} args - Arguments to create many Bookstores.
     *     @example
     *     // Create many Bookstores
     *     const bookstore = await prisma.bookstore.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends bookstoreCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bookstoreCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bookstore.
     * @param {bookstoreDeleteArgs} args - Arguments to delete one Bookstore.
     * @example
     * // Delete one Bookstore
     * const Bookstore = await prisma.bookstore.delete({
     *   where: {
     *     // ... filter to delete one Bookstore
     *   }
     * })
     * 
    **/
    delete<T extends bookstoreDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, bookstoreDeleteArgs<ExtArgs>>
    ): Prisma__bookstoreClient<$Result.GetResult<Prisma.$bookstorePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Bookstore.
     * @param {bookstoreUpdateArgs} args - Arguments to update one Bookstore.
     * @example
     * // Update one Bookstore
     * const bookstore = await prisma.bookstore.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends bookstoreUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, bookstoreUpdateArgs<ExtArgs>>
    ): Prisma__bookstoreClient<$Result.GetResult<Prisma.$bookstorePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Bookstores.
     * @param {bookstoreDeleteManyArgs} args - Arguments to filter Bookstores to delete.
     * @example
     * // Delete a few Bookstores
     * const { count } = await prisma.bookstore.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends bookstoreDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bookstoreDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookstores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookstoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookstores
     * const bookstore = await prisma.bookstore.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends bookstoreUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, bookstoreUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bookstore.
     * @param {bookstoreUpsertArgs} args - Arguments to update or create a Bookstore.
     * @example
     * // Update or create a Bookstore
     * const bookstore = await prisma.bookstore.upsert({
     *   create: {
     *     // ... data to create a Bookstore
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bookstore we want to update
     *   }
     * })
    **/
    upsert<T extends bookstoreUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, bookstoreUpsertArgs<ExtArgs>>
    ): Prisma__bookstoreClient<$Result.GetResult<Prisma.$bookstorePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Bookstores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookstoreCountArgs} args - Arguments to filter Bookstores to count.
     * @example
     * // Count the number of Bookstores
     * const count = await prisma.bookstore.count({
     *   where: {
     *     // ... the filter for the Bookstores we want to count
     *   }
     * })
    **/
    count<T extends bookstoreCountArgs>(
      args?: Subset<T, bookstoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookstoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bookstore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookstoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookstoreAggregateArgs>(args: Subset<T, BookstoreAggregateArgs>): Prisma.PrismaPromise<GetBookstoreAggregateType<T>>

    /**
     * Group by Bookstore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookstoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bookstoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bookstoreGroupByArgs['orderBy'] }
        : { orderBy?: bookstoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bookstoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookstoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bookstore model
   */
  readonly fields: bookstoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bookstore.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bookstoreClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    comments<T extends bookstore$commentsArgs<ExtArgs> = {}>(args?: Subset<T, bookstore$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bookstoreCommentPayload<ExtArgs>, T, 'findMany'> | Null>;

    users_contributions<T extends bookstore$users_contributionsArgs<ExtArgs> = {}>(args?: Subset<T, bookstore$users_contributionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userContributionPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the bookstore model
   */ 
  interface bookstoreFieldRefs {
    readonly id: FieldRef<"bookstore", 'Int'>
    readonly name: FieldRef<"bookstore", 'String'>
    readonly address: FieldRef<"bookstore", 'String'>
    readonly coordX: FieldRef<"bookstore", 'Float'>
    readonly coordY: FieldRef<"bookstore", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * bookstore findUnique
   */
  export type bookstoreFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookstore
     */
    select?: bookstoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bookstoreInclude<ExtArgs> | null
    /**
     * Filter, which bookstore to fetch.
     */
    where: bookstoreWhereUniqueInput
  }


  /**
   * bookstore findUniqueOrThrow
   */
  export type bookstoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookstore
     */
    select?: bookstoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bookstoreInclude<ExtArgs> | null
    /**
     * Filter, which bookstore to fetch.
     */
    where: bookstoreWhereUniqueInput
  }


  /**
   * bookstore findFirst
   */
  export type bookstoreFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookstore
     */
    select?: bookstoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bookstoreInclude<ExtArgs> | null
    /**
     * Filter, which bookstore to fetch.
     */
    where?: bookstoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bookstores to fetch.
     */
    orderBy?: bookstoreOrderByWithRelationInput | bookstoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bookstores.
     */
    cursor?: bookstoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bookstores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bookstores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bookstores.
     */
    distinct?: BookstoreScalarFieldEnum | BookstoreScalarFieldEnum[]
  }


  /**
   * bookstore findFirstOrThrow
   */
  export type bookstoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookstore
     */
    select?: bookstoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bookstoreInclude<ExtArgs> | null
    /**
     * Filter, which bookstore to fetch.
     */
    where?: bookstoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bookstores to fetch.
     */
    orderBy?: bookstoreOrderByWithRelationInput | bookstoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bookstores.
     */
    cursor?: bookstoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bookstores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bookstores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bookstores.
     */
    distinct?: BookstoreScalarFieldEnum | BookstoreScalarFieldEnum[]
  }


  /**
   * bookstore findMany
   */
  export type bookstoreFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookstore
     */
    select?: bookstoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bookstoreInclude<ExtArgs> | null
    /**
     * Filter, which bookstores to fetch.
     */
    where?: bookstoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bookstores to fetch.
     */
    orderBy?: bookstoreOrderByWithRelationInput | bookstoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bookstores.
     */
    cursor?: bookstoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bookstores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bookstores.
     */
    skip?: number
    distinct?: BookstoreScalarFieldEnum | BookstoreScalarFieldEnum[]
  }


  /**
   * bookstore create
   */
  export type bookstoreCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookstore
     */
    select?: bookstoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bookstoreInclude<ExtArgs> | null
    /**
     * The data needed to create a bookstore.
     */
    data: XOR<bookstoreCreateInput, bookstoreUncheckedCreateInput>
  }


  /**
   * bookstore createMany
   */
  export type bookstoreCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bookstores.
     */
    data: bookstoreCreateManyInput | bookstoreCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * bookstore update
   */
  export type bookstoreUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookstore
     */
    select?: bookstoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bookstoreInclude<ExtArgs> | null
    /**
     * The data needed to update a bookstore.
     */
    data: XOR<bookstoreUpdateInput, bookstoreUncheckedUpdateInput>
    /**
     * Choose, which bookstore to update.
     */
    where: bookstoreWhereUniqueInput
  }


  /**
   * bookstore updateMany
   */
  export type bookstoreUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bookstores.
     */
    data: XOR<bookstoreUpdateManyMutationInput, bookstoreUncheckedUpdateManyInput>
    /**
     * Filter which bookstores to update
     */
    where?: bookstoreWhereInput
  }


  /**
   * bookstore upsert
   */
  export type bookstoreUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookstore
     */
    select?: bookstoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bookstoreInclude<ExtArgs> | null
    /**
     * The filter to search for the bookstore to update in case it exists.
     */
    where: bookstoreWhereUniqueInput
    /**
     * In case the bookstore found by the `where` argument doesn't exist, create a new bookstore with this data.
     */
    create: XOR<bookstoreCreateInput, bookstoreUncheckedCreateInput>
    /**
     * In case the bookstore was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bookstoreUpdateInput, bookstoreUncheckedUpdateInput>
  }


  /**
   * bookstore delete
   */
  export type bookstoreDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookstore
     */
    select?: bookstoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bookstoreInclude<ExtArgs> | null
    /**
     * Filter which bookstore to delete.
     */
    where: bookstoreWhereUniqueInput
  }


  /**
   * bookstore deleteMany
   */
  export type bookstoreDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which bookstores to delete
     */
    where?: bookstoreWhereInput
  }


  /**
   * bookstore.comments
   */
  export type bookstore$commentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookstoreComment
     */
    select?: bookstoreCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bookstoreCommentInclude<ExtArgs> | null
    where?: bookstoreCommentWhereInput
    orderBy?: bookstoreCommentOrderByWithRelationInput | bookstoreCommentOrderByWithRelationInput[]
    cursor?: bookstoreCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookstoreCommentScalarFieldEnum | BookstoreCommentScalarFieldEnum[]
  }


  /**
   * bookstore.users_contributions
   */
  export type bookstore$users_contributionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userContribution
     */
    select?: userContributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userContributionInclude<ExtArgs> | null
    where?: userContributionWhereInput
    orderBy?: userContributionOrderByWithRelationInput | userContributionOrderByWithRelationInput[]
    cursor?: userContributionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserContributionScalarFieldEnum | UserContributionScalarFieldEnum[]
  }


  /**
   * bookstore without action
   */
  export type bookstoreDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookstore
     */
    select?: bookstoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bookstoreInclude<ExtArgs> | null
  }



  /**
   * Model bookstoreComment
   */

  export type AggregateBookstoreComment = {
    _count: BookstoreCommentCountAggregateOutputType | null
    _avg: BookstoreCommentAvgAggregateOutputType | null
    _sum: BookstoreCommentSumAggregateOutputType | null
    _min: BookstoreCommentMinAggregateOutputType | null
    _max: BookstoreCommentMaxAggregateOutputType | null
  }

  export type BookstoreCommentAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    bookstoreId: number | null
  }

  export type BookstoreCommentSumAggregateOutputType = {
    id: number | null
    userId: number | null
    bookstoreId: number | null
  }

  export type BookstoreCommentMinAggregateOutputType = {
    id: number | null
    userId: number | null
    comment: string | null
    creationDate: Date | null
    isActive: boolean | null
    bookstoreId: number | null
  }

  export type BookstoreCommentMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    comment: string | null
    creationDate: Date | null
    isActive: boolean | null
    bookstoreId: number | null
  }

  export type BookstoreCommentCountAggregateOutputType = {
    id: number
    userId: number
    comment: number
    creationDate: number
    isActive: number
    bookstoreId: number
    _all: number
  }


  export type BookstoreCommentAvgAggregateInputType = {
    id?: true
    userId?: true
    bookstoreId?: true
  }

  export type BookstoreCommentSumAggregateInputType = {
    id?: true
    userId?: true
    bookstoreId?: true
  }

  export type BookstoreCommentMinAggregateInputType = {
    id?: true
    userId?: true
    comment?: true
    creationDate?: true
    isActive?: true
    bookstoreId?: true
  }

  export type BookstoreCommentMaxAggregateInputType = {
    id?: true
    userId?: true
    comment?: true
    creationDate?: true
    isActive?: true
    bookstoreId?: true
  }

  export type BookstoreCommentCountAggregateInputType = {
    id?: true
    userId?: true
    comment?: true
    creationDate?: true
    isActive?: true
    bookstoreId?: true
    _all?: true
  }

  export type BookstoreCommentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which bookstoreComment to aggregate.
     */
    where?: bookstoreCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bookstoreComments to fetch.
     */
    orderBy?: bookstoreCommentOrderByWithRelationInput | bookstoreCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bookstoreCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bookstoreComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bookstoreComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bookstoreComments
    **/
    _count?: true | BookstoreCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookstoreCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookstoreCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookstoreCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookstoreCommentMaxAggregateInputType
  }

  export type GetBookstoreCommentAggregateType<T extends BookstoreCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateBookstoreComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookstoreComment[P]>
      : GetScalarType<T[P], AggregateBookstoreComment[P]>
  }




  export type bookstoreCommentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: bookstoreCommentWhereInput
    orderBy?: bookstoreCommentOrderByWithAggregationInput | bookstoreCommentOrderByWithAggregationInput[]
    by: BookstoreCommentScalarFieldEnum[] | BookstoreCommentScalarFieldEnum
    having?: bookstoreCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookstoreCommentCountAggregateInputType | true
    _avg?: BookstoreCommentAvgAggregateInputType
    _sum?: BookstoreCommentSumAggregateInputType
    _min?: BookstoreCommentMinAggregateInputType
    _max?: BookstoreCommentMaxAggregateInputType
  }

  export type BookstoreCommentGroupByOutputType = {
    id: number
    userId: number | null
    comment: string
    creationDate: Date
    isActive: boolean
    bookstoreId: number
    _count: BookstoreCommentCountAggregateOutputType | null
    _avg: BookstoreCommentAvgAggregateOutputType | null
    _sum: BookstoreCommentSumAggregateOutputType | null
    _min: BookstoreCommentMinAggregateOutputType | null
    _max: BookstoreCommentMaxAggregateOutputType | null
  }

  type GetBookstoreCommentGroupByPayload<T extends bookstoreCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookstoreCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookstoreCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookstoreCommentGroupByOutputType[P]>
            : GetScalarType<T[P], BookstoreCommentGroupByOutputType[P]>
        }
      >
    >


  export type bookstoreCommentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    comment?: boolean
    creationDate?: boolean
    isActive?: boolean
    bookstoreId?: boolean
    bouquineries?: boolean | bookstoreDefaultArgs<ExtArgs>
    user?: boolean | bookstoreComment$userArgs<ExtArgs>
    users_contributions?: boolean | bookstoreComment$users_contributionsArgs<ExtArgs>
    _count?: boolean | BookstoreCommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookstoreComment"]>

  export type bookstoreCommentSelectScalar = {
    id?: boolean
    userId?: boolean
    comment?: boolean
    creationDate?: boolean
    isActive?: boolean
    bookstoreId?: boolean
  }

  export type bookstoreCommentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    bouquineries?: boolean | bookstoreDefaultArgs<ExtArgs>
    user?: boolean | bookstoreComment$userArgs<ExtArgs>
    users_contributions?: boolean | bookstoreComment$users_contributionsArgs<ExtArgs>
    _count?: boolean | BookstoreCommentCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $bookstoreCommentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "bookstoreComment"
    objects: {
      bouquineries: Prisma.$bookstorePayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs> | null
      users_contributions: Prisma.$userContributionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      userId: number | null
      comment: string
      creationDate: Date
      isActive: boolean
      bookstoreId: number
    }, ExtArgs["result"]["bookstoreComment"]>
    composites: {}
  }


  type bookstoreCommentGetPayload<S extends boolean | null | undefined | bookstoreCommentDefaultArgs> = $Result.GetResult<Prisma.$bookstoreCommentPayload, S>

  type bookstoreCommentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<bookstoreCommentFindManyArgs, 'select' | 'include'> & {
      select?: BookstoreCommentCountAggregateInputType | true
    }

  export interface bookstoreCommentDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bookstoreComment'], meta: { name: 'bookstoreComment' } }
    /**
     * Find zero or one BookstoreComment that matches the filter.
     * @param {bookstoreCommentFindUniqueArgs} args - Arguments to find a BookstoreComment
     * @example
     * // Get one BookstoreComment
     * const bookstoreComment = await prisma.bookstoreComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends bookstoreCommentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, bookstoreCommentFindUniqueArgs<ExtArgs>>
    ): Prisma__bookstoreCommentClient<$Result.GetResult<Prisma.$bookstoreCommentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BookstoreComment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {bookstoreCommentFindUniqueOrThrowArgs} args - Arguments to find a BookstoreComment
     * @example
     * // Get one BookstoreComment
     * const bookstoreComment = await prisma.bookstoreComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends bookstoreCommentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bookstoreCommentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__bookstoreCommentClient<$Result.GetResult<Prisma.$bookstoreCommentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BookstoreComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookstoreCommentFindFirstArgs} args - Arguments to find a BookstoreComment
     * @example
     * // Get one BookstoreComment
     * const bookstoreComment = await prisma.bookstoreComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends bookstoreCommentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, bookstoreCommentFindFirstArgs<ExtArgs>>
    ): Prisma__bookstoreCommentClient<$Result.GetResult<Prisma.$bookstoreCommentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BookstoreComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookstoreCommentFindFirstOrThrowArgs} args - Arguments to find a BookstoreComment
     * @example
     * // Get one BookstoreComment
     * const bookstoreComment = await prisma.bookstoreComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends bookstoreCommentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bookstoreCommentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__bookstoreCommentClient<$Result.GetResult<Prisma.$bookstoreCommentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BookstoreComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookstoreCommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookstoreComments
     * const bookstoreComments = await prisma.bookstoreComment.findMany()
     * 
     * // Get first 10 BookstoreComments
     * const bookstoreComments = await prisma.bookstoreComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookstoreCommentWithIdOnly = await prisma.bookstoreComment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends bookstoreCommentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bookstoreCommentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bookstoreCommentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BookstoreComment.
     * @param {bookstoreCommentCreateArgs} args - Arguments to create a BookstoreComment.
     * @example
     * // Create one BookstoreComment
     * const BookstoreComment = await prisma.bookstoreComment.create({
     *   data: {
     *     // ... data to create a BookstoreComment
     *   }
     * })
     * 
    **/
    create<T extends bookstoreCommentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, bookstoreCommentCreateArgs<ExtArgs>>
    ): Prisma__bookstoreCommentClient<$Result.GetResult<Prisma.$bookstoreCommentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BookstoreComments.
     *     @param {bookstoreCommentCreateManyArgs} args - Arguments to create many BookstoreComments.
     *     @example
     *     // Create many BookstoreComments
     *     const bookstoreComment = await prisma.bookstoreComment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends bookstoreCommentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bookstoreCommentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BookstoreComment.
     * @param {bookstoreCommentDeleteArgs} args - Arguments to delete one BookstoreComment.
     * @example
     * // Delete one BookstoreComment
     * const BookstoreComment = await prisma.bookstoreComment.delete({
     *   where: {
     *     // ... filter to delete one BookstoreComment
     *   }
     * })
     * 
    **/
    delete<T extends bookstoreCommentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, bookstoreCommentDeleteArgs<ExtArgs>>
    ): Prisma__bookstoreCommentClient<$Result.GetResult<Prisma.$bookstoreCommentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BookstoreComment.
     * @param {bookstoreCommentUpdateArgs} args - Arguments to update one BookstoreComment.
     * @example
     * // Update one BookstoreComment
     * const bookstoreComment = await prisma.bookstoreComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends bookstoreCommentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, bookstoreCommentUpdateArgs<ExtArgs>>
    ): Prisma__bookstoreCommentClient<$Result.GetResult<Prisma.$bookstoreCommentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BookstoreComments.
     * @param {bookstoreCommentDeleteManyArgs} args - Arguments to filter BookstoreComments to delete.
     * @example
     * // Delete a few BookstoreComments
     * const { count } = await prisma.bookstoreComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends bookstoreCommentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bookstoreCommentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookstoreComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookstoreCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookstoreComments
     * const bookstoreComment = await prisma.bookstoreComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends bookstoreCommentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, bookstoreCommentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BookstoreComment.
     * @param {bookstoreCommentUpsertArgs} args - Arguments to update or create a BookstoreComment.
     * @example
     * // Update or create a BookstoreComment
     * const bookstoreComment = await prisma.bookstoreComment.upsert({
     *   create: {
     *     // ... data to create a BookstoreComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookstoreComment we want to update
     *   }
     * })
    **/
    upsert<T extends bookstoreCommentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, bookstoreCommentUpsertArgs<ExtArgs>>
    ): Prisma__bookstoreCommentClient<$Result.GetResult<Prisma.$bookstoreCommentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BookstoreComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookstoreCommentCountArgs} args - Arguments to filter BookstoreComments to count.
     * @example
     * // Count the number of BookstoreComments
     * const count = await prisma.bookstoreComment.count({
     *   where: {
     *     // ... the filter for the BookstoreComments we want to count
     *   }
     * })
    **/
    count<T extends bookstoreCommentCountArgs>(
      args?: Subset<T, bookstoreCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookstoreCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookstoreComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookstoreCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookstoreCommentAggregateArgs>(args: Subset<T, BookstoreCommentAggregateArgs>): Prisma.PrismaPromise<GetBookstoreCommentAggregateType<T>>

    /**
     * Group by BookstoreComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookstoreCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bookstoreCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bookstoreCommentGroupByArgs['orderBy'] }
        : { orderBy?: bookstoreCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bookstoreCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookstoreCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bookstoreComment model
   */
  readonly fields: bookstoreCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bookstoreComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bookstoreCommentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    bouquineries<T extends bookstoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, bookstoreDefaultArgs<ExtArgs>>): Prisma__bookstoreClient<$Result.GetResult<Prisma.$bookstorePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends bookstoreComment$userArgs<ExtArgs> = {}>(args?: Subset<T, bookstoreComment$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    users_contributions<T extends bookstoreComment$users_contributionsArgs<ExtArgs> = {}>(args?: Subset<T, bookstoreComment$users_contributionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userContributionPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the bookstoreComment model
   */ 
  interface bookstoreCommentFieldRefs {
    readonly id: FieldRef<"bookstoreComment", 'Int'>
    readonly userId: FieldRef<"bookstoreComment", 'Int'>
    readonly comment: FieldRef<"bookstoreComment", 'String'>
    readonly creationDate: FieldRef<"bookstoreComment", 'DateTime'>
    readonly isActive: FieldRef<"bookstoreComment", 'Boolean'>
    readonly bookstoreId: FieldRef<"bookstoreComment", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * bookstoreComment findUnique
   */
  export type bookstoreCommentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookstoreComment
     */
    select?: bookstoreCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bookstoreCommentInclude<ExtArgs> | null
    /**
     * Filter, which bookstoreComment to fetch.
     */
    where: bookstoreCommentWhereUniqueInput
  }


  /**
   * bookstoreComment findUniqueOrThrow
   */
  export type bookstoreCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookstoreComment
     */
    select?: bookstoreCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bookstoreCommentInclude<ExtArgs> | null
    /**
     * Filter, which bookstoreComment to fetch.
     */
    where: bookstoreCommentWhereUniqueInput
  }


  /**
   * bookstoreComment findFirst
   */
  export type bookstoreCommentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookstoreComment
     */
    select?: bookstoreCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bookstoreCommentInclude<ExtArgs> | null
    /**
     * Filter, which bookstoreComment to fetch.
     */
    where?: bookstoreCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bookstoreComments to fetch.
     */
    orderBy?: bookstoreCommentOrderByWithRelationInput | bookstoreCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bookstoreComments.
     */
    cursor?: bookstoreCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bookstoreComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bookstoreComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bookstoreComments.
     */
    distinct?: BookstoreCommentScalarFieldEnum | BookstoreCommentScalarFieldEnum[]
  }


  /**
   * bookstoreComment findFirstOrThrow
   */
  export type bookstoreCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookstoreComment
     */
    select?: bookstoreCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bookstoreCommentInclude<ExtArgs> | null
    /**
     * Filter, which bookstoreComment to fetch.
     */
    where?: bookstoreCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bookstoreComments to fetch.
     */
    orderBy?: bookstoreCommentOrderByWithRelationInput | bookstoreCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bookstoreComments.
     */
    cursor?: bookstoreCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bookstoreComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bookstoreComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bookstoreComments.
     */
    distinct?: BookstoreCommentScalarFieldEnum | BookstoreCommentScalarFieldEnum[]
  }


  /**
   * bookstoreComment findMany
   */
  export type bookstoreCommentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookstoreComment
     */
    select?: bookstoreCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bookstoreCommentInclude<ExtArgs> | null
    /**
     * Filter, which bookstoreComments to fetch.
     */
    where?: bookstoreCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bookstoreComments to fetch.
     */
    orderBy?: bookstoreCommentOrderByWithRelationInput | bookstoreCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bookstoreComments.
     */
    cursor?: bookstoreCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bookstoreComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bookstoreComments.
     */
    skip?: number
    distinct?: BookstoreCommentScalarFieldEnum | BookstoreCommentScalarFieldEnum[]
  }


  /**
   * bookstoreComment create
   */
  export type bookstoreCommentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookstoreComment
     */
    select?: bookstoreCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bookstoreCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a bookstoreComment.
     */
    data: XOR<bookstoreCommentCreateInput, bookstoreCommentUncheckedCreateInput>
  }


  /**
   * bookstoreComment createMany
   */
  export type bookstoreCommentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bookstoreComments.
     */
    data: bookstoreCommentCreateManyInput | bookstoreCommentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * bookstoreComment update
   */
  export type bookstoreCommentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookstoreComment
     */
    select?: bookstoreCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bookstoreCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a bookstoreComment.
     */
    data: XOR<bookstoreCommentUpdateInput, bookstoreCommentUncheckedUpdateInput>
    /**
     * Choose, which bookstoreComment to update.
     */
    where: bookstoreCommentWhereUniqueInput
  }


  /**
   * bookstoreComment updateMany
   */
  export type bookstoreCommentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bookstoreComments.
     */
    data: XOR<bookstoreCommentUpdateManyMutationInput, bookstoreCommentUncheckedUpdateManyInput>
    /**
     * Filter which bookstoreComments to update
     */
    where?: bookstoreCommentWhereInput
  }


  /**
   * bookstoreComment upsert
   */
  export type bookstoreCommentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookstoreComment
     */
    select?: bookstoreCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bookstoreCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the bookstoreComment to update in case it exists.
     */
    where: bookstoreCommentWhereUniqueInput
    /**
     * In case the bookstoreComment found by the `where` argument doesn't exist, create a new bookstoreComment with this data.
     */
    create: XOR<bookstoreCommentCreateInput, bookstoreCommentUncheckedCreateInput>
    /**
     * In case the bookstoreComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bookstoreCommentUpdateInput, bookstoreCommentUncheckedUpdateInput>
  }


  /**
   * bookstoreComment delete
   */
  export type bookstoreCommentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookstoreComment
     */
    select?: bookstoreCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bookstoreCommentInclude<ExtArgs> | null
    /**
     * Filter which bookstoreComment to delete.
     */
    where: bookstoreCommentWhereUniqueInput
  }


  /**
   * bookstoreComment deleteMany
   */
  export type bookstoreCommentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which bookstoreComments to delete
     */
    where?: bookstoreCommentWhereInput
  }


  /**
   * bookstoreComment.user
   */
  export type bookstoreComment$userArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }


  /**
   * bookstoreComment.users_contributions
   */
  export type bookstoreComment$users_contributionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userContribution
     */
    select?: userContributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userContributionInclude<ExtArgs> | null
    where?: userContributionWhereInput
    orderBy?: userContributionOrderByWithRelationInput | userContributionOrderByWithRelationInput[]
    cursor?: userContributionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserContributionScalarFieldEnum | UserContributionScalarFieldEnum[]
  }


  /**
   * bookstoreComment without action
   */
  export type bookstoreCommentDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookstoreComment
     */
    select?: bookstoreCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bookstoreCommentInclude<ExtArgs> | null
  }



  /**
   * Model demo
   */

  export type AggregateDemo = {
    _count: DemoCountAggregateOutputType | null
    _avg: DemoAvgAggregateOutputType | null
    _sum: DemoSumAggregateOutputType | null
    _min: DemoMinAggregateOutputType | null
    _max: DemoMaxAggregateOutputType | null
  }

  export type DemoAvgAggregateOutputType = {
    id: number | null
  }

  export type DemoSumAggregateOutputType = {
    id: number | null
  }

  export type DemoMinAggregateOutputType = {
    id: number | null
    lastReset: Date | null
  }

  export type DemoMaxAggregateOutputType = {
    id: number | null
    lastReset: Date | null
  }

  export type DemoCountAggregateOutputType = {
    id: number
    lastReset: number
    _all: number
  }


  export type DemoAvgAggregateInputType = {
    id?: true
  }

  export type DemoSumAggregateInputType = {
    id?: true
  }

  export type DemoMinAggregateInputType = {
    id?: true
    lastReset?: true
  }

  export type DemoMaxAggregateInputType = {
    id?: true
    lastReset?: true
  }

  export type DemoCountAggregateInputType = {
    id?: true
    lastReset?: true
    _all?: true
  }

  export type DemoAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which demo to aggregate.
     */
    where?: demoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of demos to fetch.
     */
    orderBy?: demoOrderByWithRelationInput | demoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: demoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` demos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` demos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned demos
    **/
    _count?: true | DemoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DemoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DemoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DemoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DemoMaxAggregateInputType
  }

  export type GetDemoAggregateType<T extends DemoAggregateArgs> = {
        [P in keyof T & keyof AggregateDemo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDemo[P]>
      : GetScalarType<T[P], AggregateDemo[P]>
  }




  export type demoGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: demoWhereInput
    orderBy?: demoOrderByWithAggregationInput | demoOrderByWithAggregationInput[]
    by: DemoScalarFieldEnum[] | DemoScalarFieldEnum
    having?: demoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DemoCountAggregateInputType | true
    _avg?: DemoAvgAggregateInputType
    _sum?: DemoSumAggregateInputType
    _min?: DemoMinAggregateInputType
    _max?: DemoMaxAggregateInputType
  }

  export type DemoGroupByOutputType = {
    id: number
    lastReset: Date
    _count: DemoCountAggregateOutputType | null
    _avg: DemoAvgAggregateOutputType | null
    _sum: DemoSumAggregateOutputType | null
    _min: DemoMinAggregateOutputType | null
    _max: DemoMaxAggregateOutputType | null
  }

  type GetDemoGroupByPayload<T extends demoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DemoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DemoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DemoGroupByOutputType[P]>
            : GetScalarType<T[P], DemoGroupByOutputType[P]>
        }
      >
    >


  export type demoSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lastReset?: boolean
  }, ExtArgs["result"]["demo"]>

  export type demoSelectScalar = {
    id?: boolean
    lastReset?: boolean
  }


  export type $demoPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "demo"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: number
      lastReset: Date
    }, ExtArgs["result"]["demo"]>
    composites: {}
  }


  type demoGetPayload<S extends boolean | null | undefined | demoDefaultArgs> = $Result.GetResult<Prisma.$demoPayload, S>

  type demoCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<demoFindManyArgs, 'select' | 'include'> & {
      select?: DemoCountAggregateInputType | true
    }

  export interface demoDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['demo'], meta: { name: 'demo' } }
    /**
     * Find zero or one Demo that matches the filter.
     * @param {demoFindUniqueArgs} args - Arguments to find a Demo
     * @example
     * // Get one Demo
     * const demo = await prisma.demo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends demoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, demoFindUniqueArgs<ExtArgs>>
    ): Prisma__demoClient<$Result.GetResult<Prisma.$demoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Demo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {demoFindUniqueOrThrowArgs} args - Arguments to find a Demo
     * @example
     * // Get one Demo
     * const demo = await prisma.demo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends demoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, demoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__demoClient<$Result.GetResult<Prisma.$demoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Demo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {demoFindFirstArgs} args - Arguments to find a Demo
     * @example
     * // Get one Demo
     * const demo = await prisma.demo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends demoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, demoFindFirstArgs<ExtArgs>>
    ): Prisma__demoClient<$Result.GetResult<Prisma.$demoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Demo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {demoFindFirstOrThrowArgs} args - Arguments to find a Demo
     * @example
     * // Get one Demo
     * const demo = await prisma.demo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends demoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, demoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__demoClient<$Result.GetResult<Prisma.$demoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Demos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {demoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Demos
     * const demos = await prisma.demo.findMany()
     * 
     * // Get first 10 Demos
     * const demos = await prisma.demo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const demoWithIdOnly = await prisma.demo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends demoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, demoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$demoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Demo.
     * @param {demoCreateArgs} args - Arguments to create a Demo.
     * @example
     * // Create one Demo
     * const Demo = await prisma.demo.create({
     *   data: {
     *     // ... data to create a Demo
     *   }
     * })
     * 
    **/
    create<T extends demoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, demoCreateArgs<ExtArgs>>
    ): Prisma__demoClient<$Result.GetResult<Prisma.$demoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Demos.
     *     @param {demoCreateManyArgs} args - Arguments to create many Demos.
     *     @example
     *     // Create many Demos
     *     const demo = await prisma.demo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends demoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, demoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Demo.
     * @param {demoDeleteArgs} args - Arguments to delete one Demo.
     * @example
     * // Delete one Demo
     * const Demo = await prisma.demo.delete({
     *   where: {
     *     // ... filter to delete one Demo
     *   }
     * })
     * 
    **/
    delete<T extends demoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, demoDeleteArgs<ExtArgs>>
    ): Prisma__demoClient<$Result.GetResult<Prisma.$demoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Demo.
     * @param {demoUpdateArgs} args - Arguments to update one Demo.
     * @example
     * // Update one Demo
     * const demo = await prisma.demo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends demoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, demoUpdateArgs<ExtArgs>>
    ): Prisma__demoClient<$Result.GetResult<Prisma.$demoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Demos.
     * @param {demoDeleteManyArgs} args - Arguments to filter Demos to delete.
     * @example
     * // Delete a few Demos
     * const { count } = await prisma.demo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends demoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, demoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Demos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {demoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Demos
     * const demo = await prisma.demo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends demoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, demoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Demo.
     * @param {demoUpsertArgs} args - Arguments to update or create a Demo.
     * @example
     * // Update or create a Demo
     * const demo = await prisma.demo.upsert({
     *   create: {
     *     // ... data to create a Demo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Demo we want to update
     *   }
     * })
    **/
    upsert<T extends demoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, demoUpsertArgs<ExtArgs>>
    ): Prisma__demoClient<$Result.GetResult<Prisma.$demoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Demos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {demoCountArgs} args - Arguments to filter Demos to count.
     * @example
     * // Count the number of Demos
     * const count = await prisma.demo.count({
     *   where: {
     *     // ... the filter for the Demos we want to count
     *   }
     * })
    **/
    count<T extends demoCountArgs>(
      args?: Subset<T, demoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DemoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Demo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DemoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DemoAggregateArgs>(args: Subset<T, DemoAggregateArgs>): Prisma.PrismaPromise<GetDemoAggregateType<T>>

    /**
     * Group by Demo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {demoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends demoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: demoGroupByArgs['orderBy'] }
        : { orderBy?: demoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, demoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDemoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the demo model
   */
  readonly fields: demoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for demo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__demoClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the demo model
   */ 
  interface demoFieldRefs {
    readonly id: FieldRef<"demo", 'Int'>
    readonly lastReset: FieldRef<"demo", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * demo findUnique
   */
  export type demoFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the demo
     */
    select?: demoSelect<ExtArgs> | null
    /**
     * Filter, which demo to fetch.
     */
    where: demoWhereUniqueInput
  }


  /**
   * demo findUniqueOrThrow
   */
  export type demoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the demo
     */
    select?: demoSelect<ExtArgs> | null
    /**
     * Filter, which demo to fetch.
     */
    where: demoWhereUniqueInput
  }


  /**
   * demo findFirst
   */
  export type demoFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the demo
     */
    select?: demoSelect<ExtArgs> | null
    /**
     * Filter, which demo to fetch.
     */
    where?: demoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of demos to fetch.
     */
    orderBy?: demoOrderByWithRelationInput | demoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for demos.
     */
    cursor?: demoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` demos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` demos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of demos.
     */
    distinct?: DemoScalarFieldEnum | DemoScalarFieldEnum[]
  }


  /**
   * demo findFirstOrThrow
   */
  export type demoFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the demo
     */
    select?: demoSelect<ExtArgs> | null
    /**
     * Filter, which demo to fetch.
     */
    where?: demoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of demos to fetch.
     */
    orderBy?: demoOrderByWithRelationInput | demoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for demos.
     */
    cursor?: demoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` demos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` demos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of demos.
     */
    distinct?: DemoScalarFieldEnum | DemoScalarFieldEnum[]
  }


  /**
   * demo findMany
   */
  export type demoFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the demo
     */
    select?: demoSelect<ExtArgs> | null
    /**
     * Filter, which demos to fetch.
     */
    where?: demoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of demos to fetch.
     */
    orderBy?: demoOrderByWithRelationInput | demoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing demos.
     */
    cursor?: demoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` demos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` demos.
     */
    skip?: number
    distinct?: DemoScalarFieldEnum | DemoScalarFieldEnum[]
  }


  /**
   * demo create
   */
  export type demoCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the demo
     */
    select?: demoSelect<ExtArgs> | null
    /**
     * The data needed to create a demo.
     */
    data: XOR<demoCreateInput, demoUncheckedCreateInput>
  }


  /**
   * demo createMany
   */
  export type demoCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many demos.
     */
    data: demoCreateManyInput | demoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * demo update
   */
  export type demoUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the demo
     */
    select?: demoSelect<ExtArgs> | null
    /**
     * The data needed to update a demo.
     */
    data: XOR<demoUpdateInput, demoUncheckedUpdateInput>
    /**
     * Choose, which demo to update.
     */
    where: demoWhereUniqueInput
  }


  /**
   * demo updateMany
   */
  export type demoUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update demos.
     */
    data: XOR<demoUpdateManyMutationInput, demoUncheckedUpdateManyInput>
    /**
     * Filter which demos to update
     */
    where?: demoWhereInput
  }


  /**
   * demo upsert
   */
  export type demoUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the demo
     */
    select?: demoSelect<ExtArgs> | null
    /**
     * The filter to search for the demo to update in case it exists.
     */
    where: demoWhereUniqueInput
    /**
     * In case the demo found by the `where` argument doesn't exist, create a new demo with this data.
     */
    create: XOR<demoCreateInput, demoUncheckedCreateInput>
    /**
     * In case the demo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<demoUpdateInput, demoUncheckedUpdateInput>
  }


  /**
   * demo delete
   */
  export type demoDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the demo
     */
    select?: demoSelect<ExtArgs> | null
    /**
     * Filter which demo to delete.
     */
    where: demoWhereUniqueInput
  }


  /**
   * demo deleteMany
   */
  export type demoDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which demos to delete
     */
    where?: demoWhereInput
  }


  /**
   * demo without action
   */
  export type demoDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the demo
     */
    select?: demoSelect<ExtArgs> | null
  }



  /**
   * Model magazines
   */

  export type AggregateMagazines = {
    _count: MagazinesCountAggregateOutputType | null
    _min: MagazinesMinAggregateOutputType | null
    _max: MagazinesMaxAggregateOutputType | null
  }

  export type MagazinesMinAggregateOutputType = {
    PaysAbrege: string | null
    NomAbrege: string | null
    NomComplet: string | null
    RedirigeDepuis: string | null
    NeParaitPlus: boolean | null
  }

  export type MagazinesMaxAggregateOutputType = {
    PaysAbrege: string | null
    NomAbrege: string | null
    NomComplet: string | null
    RedirigeDepuis: string | null
    NeParaitPlus: boolean | null
  }

  export type MagazinesCountAggregateOutputType = {
    PaysAbrege: number
    NomAbrege: number
    NomComplet: number
    RedirigeDepuis: number
    NeParaitPlus: number
    _all: number
  }


  export type MagazinesMinAggregateInputType = {
    PaysAbrege?: true
    NomAbrege?: true
    NomComplet?: true
    RedirigeDepuis?: true
    NeParaitPlus?: true
  }

  export type MagazinesMaxAggregateInputType = {
    PaysAbrege?: true
    NomAbrege?: true
    NomComplet?: true
    RedirigeDepuis?: true
    NeParaitPlus?: true
  }

  export type MagazinesCountAggregateInputType = {
    PaysAbrege?: true
    NomAbrege?: true
    NomComplet?: true
    RedirigeDepuis?: true
    NeParaitPlus?: true
    _all?: true
  }

  export type MagazinesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which magazines to aggregate.
     */
    where?: magazinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of magazines to fetch.
     */
    orderBy?: magazinesOrderByWithRelationInput | magazinesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: magazinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` magazines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` magazines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned magazines
    **/
    _count?: true | MagazinesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MagazinesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MagazinesMaxAggregateInputType
  }

  export type GetMagazinesAggregateType<T extends MagazinesAggregateArgs> = {
        [P in keyof T & keyof AggregateMagazines]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMagazines[P]>
      : GetScalarType<T[P], AggregateMagazines[P]>
  }




  export type magazinesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: magazinesWhereInput
    orderBy?: magazinesOrderByWithAggregationInput | magazinesOrderByWithAggregationInput[]
    by: MagazinesScalarFieldEnum[] | MagazinesScalarFieldEnum
    having?: magazinesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MagazinesCountAggregateInputType | true
    _min?: MagazinesMinAggregateInputType
    _max?: MagazinesMaxAggregateInputType
  }

  export type MagazinesGroupByOutputType = {
    PaysAbrege: string
    NomAbrege: string
    NomComplet: string
    RedirigeDepuis: string
    NeParaitPlus: boolean | null
    _count: MagazinesCountAggregateOutputType | null
    _min: MagazinesMinAggregateOutputType | null
    _max: MagazinesMaxAggregateOutputType | null
  }

  type GetMagazinesGroupByPayload<T extends magazinesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MagazinesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MagazinesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MagazinesGroupByOutputType[P]>
            : GetScalarType<T[P], MagazinesGroupByOutputType[P]>
        }
      >
    >


  export type magazinesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    PaysAbrege?: boolean
    NomAbrege?: boolean
    NomComplet?: boolean
    RedirigeDepuis?: boolean
    NeParaitPlus?: boolean
  }, ExtArgs["result"]["magazines"]>

  export type magazinesSelectScalar = {
    PaysAbrege?: boolean
    NomAbrege?: boolean
    NomComplet?: boolean
    RedirigeDepuis?: boolean
    NeParaitPlus?: boolean
  }


  export type $magazinesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "magazines"
    objects: {}
    scalars: $Extensions.GetResult<{
      PaysAbrege: string
      NomAbrege: string
      NomComplet: string
      RedirigeDepuis: string
      NeParaitPlus: boolean | null
    }, ExtArgs["result"]["magazines"]>
    composites: {}
  }


  type magazinesGetPayload<S extends boolean | null | undefined | magazinesDefaultArgs> = $Result.GetResult<Prisma.$magazinesPayload, S>

  type magazinesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<magazinesFindManyArgs, 'select' | 'include'> & {
      select?: MagazinesCountAggregateInputType | true
    }

  export interface magazinesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['magazines'], meta: { name: 'magazines' } }
    /**
     * Find zero or one Magazines that matches the filter.
     * @param {magazinesFindUniqueArgs} args - Arguments to find a Magazines
     * @example
     * // Get one Magazines
     * const magazines = await prisma.magazines.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends magazinesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, magazinesFindUniqueArgs<ExtArgs>>
    ): Prisma__magazinesClient<$Result.GetResult<Prisma.$magazinesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Magazines that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {magazinesFindUniqueOrThrowArgs} args - Arguments to find a Magazines
     * @example
     * // Get one Magazines
     * const magazines = await prisma.magazines.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends magazinesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, magazinesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__magazinesClient<$Result.GetResult<Prisma.$magazinesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Magazines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {magazinesFindFirstArgs} args - Arguments to find a Magazines
     * @example
     * // Get one Magazines
     * const magazines = await prisma.magazines.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends magazinesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, magazinesFindFirstArgs<ExtArgs>>
    ): Prisma__magazinesClient<$Result.GetResult<Prisma.$magazinesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Magazines that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {magazinesFindFirstOrThrowArgs} args - Arguments to find a Magazines
     * @example
     * // Get one Magazines
     * const magazines = await prisma.magazines.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends magazinesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, magazinesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__magazinesClient<$Result.GetResult<Prisma.$magazinesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Magazines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {magazinesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Magazines
     * const magazines = await prisma.magazines.findMany()
     * 
     * // Get first 10 Magazines
     * const magazines = await prisma.magazines.findMany({ take: 10 })
     * 
     * // Only select the `PaysAbrege`
     * const magazinesWithPaysAbregeOnly = await prisma.magazines.findMany({ select: { PaysAbrege: true } })
     * 
    **/
    findMany<T extends magazinesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, magazinesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$magazinesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Magazines.
     * @param {magazinesCreateArgs} args - Arguments to create a Magazines.
     * @example
     * // Create one Magazines
     * const Magazines = await prisma.magazines.create({
     *   data: {
     *     // ... data to create a Magazines
     *   }
     * })
     * 
    **/
    create<T extends magazinesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, magazinesCreateArgs<ExtArgs>>
    ): Prisma__magazinesClient<$Result.GetResult<Prisma.$magazinesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Magazines.
     *     @param {magazinesCreateManyArgs} args - Arguments to create many Magazines.
     *     @example
     *     // Create many Magazines
     *     const magazines = await prisma.magazines.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends magazinesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, magazinesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Magazines.
     * @param {magazinesDeleteArgs} args - Arguments to delete one Magazines.
     * @example
     * // Delete one Magazines
     * const Magazines = await prisma.magazines.delete({
     *   where: {
     *     // ... filter to delete one Magazines
     *   }
     * })
     * 
    **/
    delete<T extends magazinesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, magazinesDeleteArgs<ExtArgs>>
    ): Prisma__magazinesClient<$Result.GetResult<Prisma.$magazinesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Magazines.
     * @param {magazinesUpdateArgs} args - Arguments to update one Magazines.
     * @example
     * // Update one Magazines
     * const magazines = await prisma.magazines.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends magazinesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, magazinesUpdateArgs<ExtArgs>>
    ): Prisma__magazinesClient<$Result.GetResult<Prisma.$magazinesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Magazines.
     * @param {magazinesDeleteManyArgs} args - Arguments to filter Magazines to delete.
     * @example
     * // Delete a few Magazines
     * const { count } = await prisma.magazines.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends magazinesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, magazinesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Magazines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {magazinesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Magazines
     * const magazines = await prisma.magazines.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends magazinesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, magazinesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Magazines.
     * @param {magazinesUpsertArgs} args - Arguments to update or create a Magazines.
     * @example
     * // Update or create a Magazines
     * const magazines = await prisma.magazines.upsert({
     *   create: {
     *     // ... data to create a Magazines
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Magazines we want to update
     *   }
     * })
    **/
    upsert<T extends magazinesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, magazinesUpsertArgs<ExtArgs>>
    ): Prisma__magazinesClient<$Result.GetResult<Prisma.$magazinesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Magazines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {magazinesCountArgs} args - Arguments to filter Magazines to count.
     * @example
     * // Count the number of Magazines
     * const count = await prisma.magazines.count({
     *   where: {
     *     // ... the filter for the Magazines we want to count
     *   }
     * })
    **/
    count<T extends magazinesCountArgs>(
      args?: Subset<T, magazinesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MagazinesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Magazines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagazinesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MagazinesAggregateArgs>(args: Subset<T, MagazinesAggregateArgs>): Prisma.PrismaPromise<GetMagazinesAggregateType<T>>

    /**
     * Group by Magazines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {magazinesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends magazinesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: magazinesGroupByArgs['orderBy'] }
        : { orderBy?: magazinesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, magazinesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMagazinesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the magazines model
   */
  readonly fields: magazinesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for magazines.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__magazinesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the magazines model
   */ 
  interface magazinesFieldRefs {
    readonly PaysAbrege: FieldRef<"magazines", 'String'>
    readonly NomAbrege: FieldRef<"magazines", 'String'>
    readonly NomComplet: FieldRef<"magazines", 'String'>
    readonly RedirigeDepuis: FieldRef<"magazines", 'String'>
    readonly NeParaitPlus: FieldRef<"magazines", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * magazines findUnique
   */
  export type magazinesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the magazines
     */
    select?: magazinesSelect<ExtArgs> | null
    /**
     * Filter, which magazines to fetch.
     */
    where: magazinesWhereUniqueInput
  }


  /**
   * magazines findUniqueOrThrow
   */
  export type magazinesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the magazines
     */
    select?: magazinesSelect<ExtArgs> | null
    /**
     * Filter, which magazines to fetch.
     */
    where: magazinesWhereUniqueInput
  }


  /**
   * magazines findFirst
   */
  export type magazinesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the magazines
     */
    select?: magazinesSelect<ExtArgs> | null
    /**
     * Filter, which magazines to fetch.
     */
    where?: magazinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of magazines to fetch.
     */
    orderBy?: magazinesOrderByWithRelationInput | magazinesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for magazines.
     */
    cursor?: magazinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` magazines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` magazines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of magazines.
     */
    distinct?: MagazinesScalarFieldEnum | MagazinesScalarFieldEnum[]
  }


  /**
   * magazines findFirstOrThrow
   */
  export type magazinesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the magazines
     */
    select?: magazinesSelect<ExtArgs> | null
    /**
     * Filter, which magazines to fetch.
     */
    where?: magazinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of magazines to fetch.
     */
    orderBy?: magazinesOrderByWithRelationInput | magazinesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for magazines.
     */
    cursor?: magazinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` magazines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` magazines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of magazines.
     */
    distinct?: MagazinesScalarFieldEnum | MagazinesScalarFieldEnum[]
  }


  /**
   * magazines findMany
   */
  export type magazinesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the magazines
     */
    select?: magazinesSelect<ExtArgs> | null
    /**
     * Filter, which magazines to fetch.
     */
    where?: magazinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of magazines to fetch.
     */
    orderBy?: magazinesOrderByWithRelationInput | magazinesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing magazines.
     */
    cursor?: magazinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` magazines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` magazines.
     */
    skip?: number
    distinct?: MagazinesScalarFieldEnum | MagazinesScalarFieldEnum[]
  }


  /**
   * magazines create
   */
  export type magazinesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the magazines
     */
    select?: magazinesSelect<ExtArgs> | null
    /**
     * The data needed to create a magazines.
     */
    data: XOR<magazinesCreateInput, magazinesUncheckedCreateInput>
  }


  /**
   * magazines createMany
   */
  export type magazinesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many magazines.
     */
    data: magazinesCreateManyInput | magazinesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * magazines update
   */
  export type magazinesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the magazines
     */
    select?: magazinesSelect<ExtArgs> | null
    /**
     * The data needed to update a magazines.
     */
    data: XOR<magazinesUpdateInput, magazinesUncheckedUpdateInput>
    /**
     * Choose, which magazines to update.
     */
    where: magazinesWhereUniqueInput
  }


  /**
   * magazines updateMany
   */
  export type magazinesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update magazines.
     */
    data: XOR<magazinesUpdateManyMutationInput, magazinesUncheckedUpdateManyInput>
    /**
     * Filter which magazines to update
     */
    where?: magazinesWhereInput
  }


  /**
   * magazines upsert
   */
  export type magazinesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the magazines
     */
    select?: magazinesSelect<ExtArgs> | null
    /**
     * The filter to search for the magazines to update in case it exists.
     */
    where: magazinesWhereUniqueInput
    /**
     * In case the magazines found by the `where` argument doesn't exist, create a new magazines with this data.
     */
    create: XOR<magazinesCreateInput, magazinesUncheckedCreateInput>
    /**
     * In case the magazines was found with the provided `where` argument, update it with this data.
     */
    update: XOR<magazinesUpdateInput, magazinesUncheckedUpdateInput>
  }


  /**
   * magazines delete
   */
  export type magazinesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the magazines
     */
    select?: magazinesSelect<ExtArgs> | null
    /**
     * Filter which magazines to delete.
     */
    where: magazinesWhereUniqueInput
  }


  /**
   * magazines deleteMany
   */
  export type magazinesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which magazines to delete
     */
    where?: magazinesWhereInput
  }


  /**
   * magazines without action
   */
  export type magazinesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the magazines
     */
    select?: magazinesSelect<ExtArgs> | null
  }



  /**
   * Model issue
   */

  export type AggregateIssue = {
    _count: IssueCountAggregateOutputType | null
    _avg: IssueAvgAggregateOutputType | null
    _sum: IssueSumAggregateOutputType | null
    _min: IssueMinAggregateOutputType | null
    _max: IssueMaxAggregateOutputType | null
  }

  export type IssueAvgAggregateOutputType = {
    id: number | null
    purchaseId: number | null
    userId: number | null
  }

  export type IssueSumAggregateOutputType = {
    id: number | null
    purchaseId: number | null
    userId: number | null
  }

  export type IssueMinAggregateOutputType = {
    id: number | null
    country: string | null
    magazine: string | null
    issuenumber: string | null
    condition: $Enums.issue_condition | null
    purchaseId: number | null
    isOnSale: boolean | null
    isToRead: boolean | null
    isSubscription: boolean | null
    userId: number | null
    creationDate: Date | null
  }

  export type IssueMaxAggregateOutputType = {
    id: number | null
    country: string | null
    magazine: string | null
    issuenumber: string | null
    condition: $Enums.issue_condition | null
    purchaseId: number | null
    isOnSale: boolean | null
    isToRead: boolean | null
    isSubscription: boolean | null
    userId: number | null
    creationDate: Date | null
  }

  export type IssueCountAggregateOutputType = {
    id: number
    country: number
    magazine: number
    issuenumber: number
    condition: number
    purchaseId: number
    isOnSale: number
    isToRead: number
    isSubscription: number
    userId: number
    creationDate: number
    _all: number
  }


  export type IssueAvgAggregateInputType = {
    id?: true
    purchaseId?: true
    userId?: true
  }

  export type IssueSumAggregateInputType = {
    id?: true
    purchaseId?: true
    userId?: true
  }

  export type IssueMinAggregateInputType = {
    id?: true
    country?: true
    magazine?: true
    issuenumber?: true
    condition?: true
    purchaseId?: true
    isOnSale?: true
    isToRead?: true
    isSubscription?: true
    userId?: true
    creationDate?: true
  }

  export type IssueMaxAggregateInputType = {
    id?: true
    country?: true
    magazine?: true
    issuenumber?: true
    condition?: true
    purchaseId?: true
    isOnSale?: true
    isToRead?: true
    isSubscription?: true
    userId?: true
    creationDate?: true
  }

  export type IssueCountAggregateInputType = {
    id?: true
    country?: true
    magazine?: true
    issuenumber?: true
    condition?: true
    purchaseId?: true
    isOnSale?: true
    isToRead?: true
    isSubscription?: true
    userId?: true
    creationDate?: true
    _all?: true
  }

  export type IssueAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which issue to aggregate.
     */
    where?: issueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of issues to fetch.
     */
    orderBy?: issueOrderByWithRelationInput | issueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: issueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` issues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` issues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned issues
    **/
    _count?: true | IssueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IssueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IssueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IssueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IssueMaxAggregateInputType
  }

  export type GetIssueAggregateType<T extends IssueAggregateArgs> = {
        [P in keyof T & keyof AggregateIssue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIssue[P]>
      : GetScalarType<T[P], AggregateIssue[P]>
  }




  export type issueGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: issueWhereInput
    orderBy?: issueOrderByWithAggregationInput | issueOrderByWithAggregationInput[]
    by: IssueScalarFieldEnum[] | IssueScalarFieldEnum
    having?: issueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IssueCountAggregateInputType | true
    _avg?: IssueAvgAggregateInputType
    _sum?: IssueSumAggregateInputType
    _min?: IssueMinAggregateInputType
    _max?: IssueMaxAggregateInputType
  }

  export type IssueGroupByOutputType = {
    id: number
    country: string
    magazine: string
    issuenumber: string
    condition: $Enums.issue_condition
    purchaseId: number | null
    isOnSale: boolean
    isToRead: boolean
    isSubscription: boolean
    userId: number
    creationDate: Date | null
    _count: IssueCountAggregateOutputType | null
    _avg: IssueAvgAggregateOutputType | null
    _sum: IssueSumAggregateOutputType | null
    _min: IssueMinAggregateOutputType | null
    _max: IssueMaxAggregateOutputType | null
  }

  type GetIssueGroupByPayload<T extends issueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IssueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IssueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IssueGroupByOutputType[P]>
            : GetScalarType<T[P], IssueGroupByOutputType[P]>
        }
      >
    >


  export type issueSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    country?: boolean
    magazine?: boolean
    issuenumber?: boolean
    condition?: boolean
    purchaseId?: boolean
    isOnSale?: boolean
    isToRead?: boolean
    isSubscription?: boolean
    userId?: boolean
    creationDate?: boolean
  }, ExtArgs["result"]["issue"]>

  export type issueSelectScalar = {
    id?: boolean
    country?: boolean
    magazine?: boolean
    issuenumber?: boolean
    condition?: boolean
    purchaseId?: boolean
    isOnSale?: boolean
    isToRead?: boolean
    isSubscription?: boolean
    userId?: boolean
    creationDate?: boolean
  }


  export type $issuePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "issue"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: number
      country: string
      magazine: string
      issuenumber: string
      condition: $Enums.issue_condition
      purchaseId: number | null
      isOnSale: boolean
      isToRead: boolean
      isSubscription: boolean
      userId: number
      creationDate: Date | null
    }, ExtArgs["result"]["issue"]>
    composites: {}
  }


  type issueGetPayload<S extends boolean | null | undefined | issueDefaultArgs> = $Result.GetResult<Prisma.$issuePayload, S>

  type issueCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<issueFindManyArgs, 'select' | 'include'> & {
      select?: IssueCountAggregateInputType | true
    }

  export interface issueDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['issue'], meta: { name: 'issue' } }
    /**
     * Find zero or one Issue that matches the filter.
     * @param {issueFindUniqueArgs} args - Arguments to find a Issue
     * @example
     * // Get one Issue
     * const issue = await prisma.issue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends issueFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, issueFindUniqueArgs<ExtArgs>>
    ): Prisma__issueClient<$Result.GetResult<Prisma.$issuePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Issue that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {issueFindUniqueOrThrowArgs} args - Arguments to find a Issue
     * @example
     * // Get one Issue
     * const issue = await prisma.issue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends issueFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, issueFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__issueClient<$Result.GetResult<Prisma.$issuePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Issue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {issueFindFirstArgs} args - Arguments to find a Issue
     * @example
     * // Get one Issue
     * const issue = await prisma.issue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends issueFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, issueFindFirstArgs<ExtArgs>>
    ): Prisma__issueClient<$Result.GetResult<Prisma.$issuePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Issue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {issueFindFirstOrThrowArgs} args - Arguments to find a Issue
     * @example
     * // Get one Issue
     * const issue = await prisma.issue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends issueFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, issueFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__issueClient<$Result.GetResult<Prisma.$issuePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Issues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {issueFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Issues
     * const issues = await prisma.issue.findMany()
     * 
     * // Get first 10 Issues
     * const issues = await prisma.issue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const issueWithIdOnly = await prisma.issue.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends issueFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, issueFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$issuePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Issue.
     * @param {issueCreateArgs} args - Arguments to create a Issue.
     * @example
     * // Create one Issue
     * const Issue = await prisma.issue.create({
     *   data: {
     *     // ... data to create a Issue
     *   }
     * })
     * 
    **/
    create<T extends issueCreateArgs<ExtArgs>>(
      args: SelectSubset<T, issueCreateArgs<ExtArgs>>
    ): Prisma__issueClient<$Result.GetResult<Prisma.$issuePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Issues.
     *     @param {issueCreateManyArgs} args - Arguments to create many Issues.
     *     @example
     *     // Create many Issues
     *     const issue = await prisma.issue.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends issueCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, issueCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Issue.
     * @param {issueDeleteArgs} args - Arguments to delete one Issue.
     * @example
     * // Delete one Issue
     * const Issue = await prisma.issue.delete({
     *   where: {
     *     // ... filter to delete one Issue
     *   }
     * })
     * 
    **/
    delete<T extends issueDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, issueDeleteArgs<ExtArgs>>
    ): Prisma__issueClient<$Result.GetResult<Prisma.$issuePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Issue.
     * @param {issueUpdateArgs} args - Arguments to update one Issue.
     * @example
     * // Update one Issue
     * const issue = await prisma.issue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends issueUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, issueUpdateArgs<ExtArgs>>
    ): Prisma__issueClient<$Result.GetResult<Prisma.$issuePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Issues.
     * @param {issueDeleteManyArgs} args - Arguments to filter Issues to delete.
     * @example
     * // Delete a few Issues
     * const { count } = await prisma.issue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends issueDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, issueDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Issues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {issueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Issues
     * const issue = await prisma.issue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends issueUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, issueUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Issue.
     * @param {issueUpsertArgs} args - Arguments to update or create a Issue.
     * @example
     * // Update or create a Issue
     * const issue = await prisma.issue.upsert({
     *   create: {
     *     // ... data to create a Issue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Issue we want to update
     *   }
     * })
    **/
    upsert<T extends issueUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, issueUpsertArgs<ExtArgs>>
    ): Prisma__issueClient<$Result.GetResult<Prisma.$issuePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Issues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {issueCountArgs} args - Arguments to filter Issues to count.
     * @example
     * // Count the number of Issues
     * const count = await prisma.issue.count({
     *   where: {
     *     // ... the filter for the Issues we want to count
     *   }
     * })
    **/
    count<T extends issueCountArgs>(
      args?: Subset<T, issueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IssueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Issue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IssueAggregateArgs>(args: Subset<T, IssueAggregateArgs>): Prisma.PrismaPromise<GetIssueAggregateType<T>>

    /**
     * Group by Issue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {issueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends issueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: issueGroupByArgs['orderBy'] }
        : { orderBy?: issueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, issueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIssueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the issue model
   */
  readonly fields: issueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for issue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__issueClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the issue model
   */ 
  interface issueFieldRefs {
    readonly id: FieldRef<"issue", 'Int'>
    readonly country: FieldRef<"issue", 'String'>
    readonly magazine: FieldRef<"issue", 'String'>
    readonly issuenumber: FieldRef<"issue", 'String'>
    readonly condition: FieldRef<"issue", 'issue_condition'>
    readonly purchaseId: FieldRef<"issue", 'Int'>
    readonly isOnSale: FieldRef<"issue", 'Boolean'>
    readonly isToRead: FieldRef<"issue", 'Boolean'>
    readonly isSubscription: FieldRef<"issue", 'Boolean'>
    readonly userId: FieldRef<"issue", 'Int'>
    readonly creationDate: FieldRef<"issue", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * issue findUnique
   */
  export type issueFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issue
     */
    select?: issueSelect<ExtArgs> | null
    /**
     * Filter, which issue to fetch.
     */
    where: issueWhereUniqueInput
  }


  /**
   * issue findUniqueOrThrow
   */
  export type issueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issue
     */
    select?: issueSelect<ExtArgs> | null
    /**
     * Filter, which issue to fetch.
     */
    where: issueWhereUniqueInput
  }


  /**
   * issue findFirst
   */
  export type issueFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issue
     */
    select?: issueSelect<ExtArgs> | null
    /**
     * Filter, which issue to fetch.
     */
    where?: issueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of issues to fetch.
     */
    orderBy?: issueOrderByWithRelationInput | issueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for issues.
     */
    cursor?: issueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` issues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` issues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of issues.
     */
    distinct?: IssueScalarFieldEnum | IssueScalarFieldEnum[]
  }


  /**
   * issue findFirstOrThrow
   */
  export type issueFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issue
     */
    select?: issueSelect<ExtArgs> | null
    /**
     * Filter, which issue to fetch.
     */
    where?: issueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of issues to fetch.
     */
    orderBy?: issueOrderByWithRelationInput | issueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for issues.
     */
    cursor?: issueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` issues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` issues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of issues.
     */
    distinct?: IssueScalarFieldEnum | IssueScalarFieldEnum[]
  }


  /**
   * issue findMany
   */
  export type issueFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issue
     */
    select?: issueSelect<ExtArgs> | null
    /**
     * Filter, which issues to fetch.
     */
    where?: issueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of issues to fetch.
     */
    orderBy?: issueOrderByWithRelationInput | issueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing issues.
     */
    cursor?: issueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` issues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` issues.
     */
    skip?: number
    distinct?: IssueScalarFieldEnum | IssueScalarFieldEnum[]
  }


  /**
   * issue create
   */
  export type issueCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issue
     */
    select?: issueSelect<ExtArgs> | null
    /**
     * The data needed to create a issue.
     */
    data: XOR<issueCreateInput, issueUncheckedCreateInput>
  }


  /**
   * issue createMany
   */
  export type issueCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many issues.
     */
    data: issueCreateManyInput | issueCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * issue update
   */
  export type issueUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issue
     */
    select?: issueSelect<ExtArgs> | null
    /**
     * The data needed to update a issue.
     */
    data: XOR<issueUpdateInput, issueUncheckedUpdateInput>
    /**
     * Choose, which issue to update.
     */
    where: issueWhereUniqueInput
  }


  /**
   * issue updateMany
   */
  export type issueUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update issues.
     */
    data: XOR<issueUpdateManyMutationInput, issueUncheckedUpdateManyInput>
    /**
     * Filter which issues to update
     */
    where?: issueWhereInput
  }


  /**
   * issue upsert
   */
  export type issueUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issue
     */
    select?: issueSelect<ExtArgs> | null
    /**
     * The filter to search for the issue to update in case it exists.
     */
    where: issueWhereUniqueInput
    /**
     * In case the issue found by the `where` argument doesn't exist, create a new issue with this data.
     */
    create: XOR<issueCreateInput, issueUncheckedCreateInput>
    /**
     * In case the issue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<issueUpdateInput, issueUncheckedUpdateInput>
  }


  /**
   * issue delete
   */
  export type issueDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issue
     */
    select?: issueSelect<ExtArgs> | null
    /**
     * Filter which issue to delete.
     */
    where: issueWhereUniqueInput
  }


  /**
   * issue deleteMany
   */
  export type issueDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which issues to delete
     */
    where?: issueWhereInput
  }


  /**
   * issue without action
   */
  export type issueDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issue
     */
    select?: issueSelect<ExtArgs> | null
  }



  /**
   * Model issuePopularity
   */

  export type AggregateIssuePopularity = {
    _count: IssuePopularityCountAggregateOutputType | null
    _avg: IssuePopularityAvgAggregateOutputType | null
    _sum: IssuePopularitySumAggregateOutputType | null
    _min: IssuePopularityMinAggregateOutputType | null
    _max: IssuePopularityMaxAggregateOutputType | null
  }

  export type IssuePopularityAvgAggregateOutputType = {
    popularity: number | null
    id: number | null
  }

  export type IssuePopularitySumAggregateOutputType = {
    popularity: number | null
    id: number | null
  }

  export type IssuePopularityMinAggregateOutputType = {
    country: string | null
    magazine: string | null
    issuenumber: string | null
    popularity: number | null
    id: number | null
  }

  export type IssuePopularityMaxAggregateOutputType = {
    country: string | null
    magazine: string | null
    issuenumber: string | null
    popularity: number | null
    id: number | null
  }

  export type IssuePopularityCountAggregateOutputType = {
    country: number
    magazine: number
    issuenumber: number
    popularity: number
    id: number
    _all: number
  }


  export type IssuePopularityAvgAggregateInputType = {
    popularity?: true
    id?: true
  }

  export type IssuePopularitySumAggregateInputType = {
    popularity?: true
    id?: true
  }

  export type IssuePopularityMinAggregateInputType = {
    country?: true
    magazine?: true
    issuenumber?: true
    popularity?: true
    id?: true
  }

  export type IssuePopularityMaxAggregateInputType = {
    country?: true
    magazine?: true
    issuenumber?: true
    popularity?: true
    id?: true
  }

  export type IssuePopularityCountAggregateInputType = {
    country?: true
    magazine?: true
    issuenumber?: true
    popularity?: true
    id?: true
    _all?: true
  }

  export type IssuePopularityAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which issuePopularity to aggregate.
     */
    where?: issuePopularityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of issuePopularities to fetch.
     */
    orderBy?: issuePopularityOrderByWithRelationInput | issuePopularityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: issuePopularityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` issuePopularities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` issuePopularities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned issuePopularities
    **/
    _count?: true | IssuePopularityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IssuePopularityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IssuePopularitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IssuePopularityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IssuePopularityMaxAggregateInputType
  }

  export type GetIssuePopularityAggregateType<T extends IssuePopularityAggregateArgs> = {
        [P in keyof T & keyof AggregateIssuePopularity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIssuePopularity[P]>
      : GetScalarType<T[P], AggregateIssuePopularity[P]>
  }




  export type issuePopularityGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: issuePopularityWhereInput
    orderBy?: issuePopularityOrderByWithAggregationInput | issuePopularityOrderByWithAggregationInput[]
    by: IssuePopularityScalarFieldEnum[] | IssuePopularityScalarFieldEnum
    having?: issuePopularityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IssuePopularityCountAggregateInputType | true
    _avg?: IssuePopularityAvgAggregateInputType
    _sum?: IssuePopularitySumAggregateInputType
    _min?: IssuePopularityMinAggregateInputType
    _max?: IssuePopularityMaxAggregateInputType
  }

  export type IssuePopularityGroupByOutputType = {
    country: string
    magazine: string
    issuenumber: string
    popularity: number
    id: number
    _count: IssuePopularityCountAggregateOutputType | null
    _avg: IssuePopularityAvgAggregateOutputType | null
    _sum: IssuePopularitySumAggregateOutputType | null
    _min: IssuePopularityMinAggregateOutputType | null
    _max: IssuePopularityMaxAggregateOutputType | null
  }

  type GetIssuePopularityGroupByPayload<T extends issuePopularityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IssuePopularityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IssuePopularityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IssuePopularityGroupByOutputType[P]>
            : GetScalarType<T[P], IssuePopularityGroupByOutputType[P]>
        }
      >
    >


  export type issuePopularitySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    country?: boolean
    magazine?: boolean
    issuenumber?: boolean
    popularity?: boolean
    id?: boolean
  }, ExtArgs["result"]["issuePopularity"]>

  export type issuePopularitySelectScalar = {
    country?: boolean
    magazine?: boolean
    issuenumber?: boolean
    popularity?: boolean
    id?: boolean
  }


  export type $issuePopularityPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "issuePopularity"
    objects: {}
    scalars: $Extensions.GetResult<{
      country: string
      magazine: string
      issuenumber: string
      popularity: number
      id: number
    }, ExtArgs["result"]["issuePopularity"]>
    composites: {}
  }


  type issuePopularityGetPayload<S extends boolean | null | undefined | issuePopularityDefaultArgs> = $Result.GetResult<Prisma.$issuePopularityPayload, S>

  type issuePopularityCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<issuePopularityFindManyArgs, 'select' | 'include'> & {
      select?: IssuePopularityCountAggregateInputType | true
    }

  export interface issuePopularityDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['issuePopularity'], meta: { name: 'issuePopularity' } }
    /**
     * Find zero or one IssuePopularity that matches the filter.
     * @param {issuePopularityFindUniqueArgs} args - Arguments to find a IssuePopularity
     * @example
     * // Get one IssuePopularity
     * const issuePopularity = await prisma.issuePopularity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends issuePopularityFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, issuePopularityFindUniqueArgs<ExtArgs>>
    ): Prisma__issuePopularityClient<$Result.GetResult<Prisma.$issuePopularityPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one IssuePopularity that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {issuePopularityFindUniqueOrThrowArgs} args - Arguments to find a IssuePopularity
     * @example
     * // Get one IssuePopularity
     * const issuePopularity = await prisma.issuePopularity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends issuePopularityFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, issuePopularityFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__issuePopularityClient<$Result.GetResult<Prisma.$issuePopularityPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first IssuePopularity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {issuePopularityFindFirstArgs} args - Arguments to find a IssuePopularity
     * @example
     * // Get one IssuePopularity
     * const issuePopularity = await prisma.issuePopularity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends issuePopularityFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, issuePopularityFindFirstArgs<ExtArgs>>
    ): Prisma__issuePopularityClient<$Result.GetResult<Prisma.$issuePopularityPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first IssuePopularity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {issuePopularityFindFirstOrThrowArgs} args - Arguments to find a IssuePopularity
     * @example
     * // Get one IssuePopularity
     * const issuePopularity = await prisma.issuePopularity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends issuePopularityFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, issuePopularityFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__issuePopularityClient<$Result.GetResult<Prisma.$issuePopularityPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more IssuePopularities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {issuePopularityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IssuePopularities
     * const issuePopularities = await prisma.issuePopularity.findMany()
     * 
     * // Get first 10 IssuePopularities
     * const issuePopularities = await prisma.issuePopularity.findMany({ take: 10 })
     * 
     * // Only select the `country`
     * const issuePopularityWithCountryOnly = await prisma.issuePopularity.findMany({ select: { country: true } })
     * 
    **/
    findMany<T extends issuePopularityFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, issuePopularityFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$issuePopularityPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a IssuePopularity.
     * @param {issuePopularityCreateArgs} args - Arguments to create a IssuePopularity.
     * @example
     * // Create one IssuePopularity
     * const IssuePopularity = await prisma.issuePopularity.create({
     *   data: {
     *     // ... data to create a IssuePopularity
     *   }
     * })
     * 
    **/
    create<T extends issuePopularityCreateArgs<ExtArgs>>(
      args: SelectSubset<T, issuePopularityCreateArgs<ExtArgs>>
    ): Prisma__issuePopularityClient<$Result.GetResult<Prisma.$issuePopularityPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many IssuePopularities.
     *     @param {issuePopularityCreateManyArgs} args - Arguments to create many IssuePopularities.
     *     @example
     *     // Create many IssuePopularities
     *     const issuePopularity = await prisma.issuePopularity.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends issuePopularityCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, issuePopularityCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a IssuePopularity.
     * @param {issuePopularityDeleteArgs} args - Arguments to delete one IssuePopularity.
     * @example
     * // Delete one IssuePopularity
     * const IssuePopularity = await prisma.issuePopularity.delete({
     *   where: {
     *     // ... filter to delete one IssuePopularity
     *   }
     * })
     * 
    **/
    delete<T extends issuePopularityDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, issuePopularityDeleteArgs<ExtArgs>>
    ): Prisma__issuePopularityClient<$Result.GetResult<Prisma.$issuePopularityPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one IssuePopularity.
     * @param {issuePopularityUpdateArgs} args - Arguments to update one IssuePopularity.
     * @example
     * // Update one IssuePopularity
     * const issuePopularity = await prisma.issuePopularity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends issuePopularityUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, issuePopularityUpdateArgs<ExtArgs>>
    ): Prisma__issuePopularityClient<$Result.GetResult<Prisma.$issuePopularityPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more IssuePopularities.
     * @param {issuePopularityDeleteManyArgs} args - Arguments to filter IssuePopularities to delete.
     * @example
     * // Delete a few IssuePopularities
     * const { count } = await prisma.issuePopularity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends issuePopularityDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, issuePopularityDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IssuePopularities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {issuePopularityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IssuePopularities
     * const issuePopularity = await prisma.issuePopularity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends issuePopularityUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, issuePopularityUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IssuePopularity.
     * @param {issuePopularityUpsertArgs} args - Arguments to update or create a IssuePopularity.
     * @example
     * // Update or create a IssuePopularity
     * const issuePopularity = await prisma.issuePopularity.upsert({
     *   create: {
     *     // ... data to create a IssuePopularity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IssuePopularity we want to update
     *   }
     * })
    **/
    upsert<T extends issuePopularityUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, issuePopularityUpsertArgs<ExtArgs>>
    ): Prisma__issuePopularityClient<$Result.GetResult<Prisma.$issuePopularityPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of IssuePopularities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {issuePopularityCountArgs} args - Arguments to filter IssuePopularities to count.
     * @example
     * // Count the number of IssuePopularities
     * const count = await prisma.issuePopularity.count({
     *   where: {
     *     // ... the filter for the IssuePopularities we want to count
     *   }
     * })
    **/
    count<T extends issuePopularityCountArgs>(
      args?: Subset<T, issuePopularityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IssuePopularityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IssuePopularity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssuePopularityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IssuePopularityAggregateArgs>(args: Subset<T, IssuePopularityAggregateArgs>): Prisma.PrismaPromise<GetIssuePopularityAggregateType<T>>

    /**
     * Group by IssuePopularity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {issuePopularityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends issuePopularityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: issuePopularityGroupByArgs['orderBy'] }
        : { orderBy?: issuePopularityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, issuePopularityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIssuePopularityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the issuePopularity model
   */
  readonly fields: issuePopularityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for issuePopularity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__issuePopularityClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the issuePopularity model
   */ 
  interface issuePopularityFieldRefs {
    readonly country: FieldRef<"issuePopularity", 'String'>
    readonly magazine: FieldRef<"issuePopularity", 'String'>
    readonly issuenumber: FieldRef<"issuePopularity", 'String'>
    readonly popularity: FieldRef<"issuePopularity", 'Int'>
    readonly id: FieldRef<"issuePopularity", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * issuePopularity findUnique
   */
  export type issuePopularityFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issuePopularity
     */
    select?: issuePopularitySelect<ExtArgs> | null
    /**
     * Filter, which issuePopularity to fetch.
     */
    where: issuePopularityWhereUniqueInput
  }


  /**
   * issuePopularity findUniqueOrThrow
   */
  export type issuePopularityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issuePopularity
     */
    select?: issuePopularitySelect<ExtArgs> | null
    /**
     * Filter, which issuePopularity to fetch.
     */
    where: issuePopularityWhereUniqueInput
  }


  /**
   * issuePopularity findFirst
   */
  export type issuePopularityFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issuePopularity
     */
    select?: issuePopularitySelect<ExtArgs> | null
    /**
     * Filter, which issuePopularity to fetch.
     */
    where?: issuePopularityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of issuePopularities to fetch.
     */
    orderBy?: issuePopularityOrderByWithRelationInput | issuePopularityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for issuePopularities.
     */
    cursor?: issuePopularityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` issuePopularities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` issuePopularities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of issuePopularities.
     */
    distinct?: IssuePopularityScalarFieldEnum | IssuePopularityScalarFieldEnum[]
  }


  /**
   * issuePopularity findFirstOrThrow
   */
  export type issuePopularityFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issuePopularity
     */
    select?: issuePopularitySelect<ExtArgs> | null
    /**
     * Filter, which issuePopularity to fetch.
     */
    where?: issuePopularityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of issuePopularities to fetch.
     */
    orderBy?: issuePopularityOrderByWithRelationInput | issuePopularityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for issuePopularities.
     */
    cursor?: issuePopularityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` issuePopularities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` issuePopularities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of issuePopularities.
     */
    distinct?: IssuePopularityScalarFieldEnum | IssuePopularityScalarFieldEnum[]
  }


  /**
   * issuePopularity findMany
   */
  export type issuePopularityFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issuePopularity
     */
    select?: issuePopularitySelect<ExtArgs> | null
    /**
     * Filter, which issuePopularities to fetch.
     */
    where?: issuePopularityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of issuePopularities to fetch.
     */
    orderBy?: issuePopularityOrderByWithRelationInput | issuePopularityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing issuePopularities.
     */
    cursor?: issuePopularityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` issuePopularities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` issuePopularities.
     */
    skip?: number
    distinct?: IssuePopularityScalarFieldEnum | IssuePopularityScalarFieldEnum[]
  }


  /**
   * issuePopularity create
   */
  export type issuePopularityCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issuePopularity
     */
    select?: issuePopularitySelect<ExtArgs> | null
    /**
     * The data needed to create a issuePopularity.
     */
    data: XOR<issuePopularityCreateInput, issuePopularityUncheckedCreateInput>
  }


  /**
   * issuePopularity createMany
   */
  export type issuePopularityCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many issuePopularities.
     */
    data: issuePopularityCreateManyInput | issuePopularityCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * issuePopularity update
   */
  export type issuePopularityUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issuePopularity
     */
    select?: issuePopularitySelect<ExtArgs> | null
    /**
     * The data needed to update a issuePopularity.
     */
    data: XOR<issuePopularityUpdateInput, issuePopularityUncheckedUpdateInput>
    /**
     * Choose, which issuePopularity to update.
     */
    where: issuePopularityWhereUniqueInput
  }


  /**
   * issuePopularity updateMany
   */
  export type issuePopularityUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update issuePopularities.
     */
    data: XOR<issuePopularityUpdateManyMutationInput, issuePopularityUncheckedUpdateManyInput>
    /**
     * Filter which issuePopularities to update
     */
    where?: issuePopularityWhereInput
  }


  /**
   * issuePopularity upsert
   */
  export type issuePopularityUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issuePopularity
     */
    select?: issuePopularitySelect<ExtArgs> | null
    /**
     * The filter to search for the issuePopularity to update in case it exists.
     */
    where: issuePopularityWhereUniqueInput
    /**
     * In case the issuePopularity found by the `where` argument doesn't exist, create a new issuePopularity with this data.
     */
    create: XOR<issuePopularityCreateInput, issuePopularityUncheckedCreateInput>
    /**
     * In case the issuePopularity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<issuePopularityUpdateInput, issuePopularityUncheckedUpdateInput>
  }


  /**
   * issuePopularity delete
   */
  export type issuePopularityDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issuePopularity
     */
    select?: issuePopularitySelect<ExtArgs> | null
    /**
     * Filter which issuePopularity to delete.
     */
    where: issuePopularityWhereUniqueInput
  }


  /**
   * issuePopularity deleteMany
   */
  export type issuePopularityDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which issuePopularities to delete
     */
    where?: issuePopularityWhereInput
  }


  /**
   * issuePopularity without action
   */
  export type issuePopularityDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issuePopularity
     */
    select?: issuePopularitySelect<ExtArgs> | null
  }



  /**
   * Model tranches_doublons
   */

  export type AggregateTranches_doublons = {
    _count: Tranches_doublonsCountAggregateOutputType | null
    _avg: Tranches_doublonsAvgAggregateOutputType | null
    _sum: Tranches_doublonsSumAggregateOutputType | null
    _min: Tranches_doublonsMinAggregateOutputType | null
    _max: Tranches_doublonsMaxAggregateOutputType | null
  }

  export type Tranches_doublonsAvgAggregateOutputType = {
    ID: number | null
    TrancheReference: number | null
  }

  export type Tranches_doublonsSumAggregateOutputType = {
    ID: number | null
    TrancheReference: number | null
  }

  export type Tranches_doublonsMinAggregateOutputType = {
    ID: number | null
    Pays: string | null
    Magazine: string | null
    Numero: string | null
    NumeroReference: string | null
    TrancheReference: number | null
  }

  export type Tranches_doublonsMaxAggregateOutputType = {
    ID: number | null
    Pays: string | null
    Magazine: string | null
    Numero: string | null
    NumeroReference: string | null
    TrancheReference: number | null
  }

  export type Tranches_doublonsCountAggregateOutputType = {
    ID: number
    Pays: number
    Magazine: number
    Numero: number
    NumeroReference: number
    TrancheReference: number
    _all: number
  }


  export type Tranches_doublonsAvgAggregateInputType = {
    ID?: true
    TrancheReference?: true
  }

  export type Tranches_doublonsSumAggregateInputType = {
    ID?: true
    TrancheReference?: true
  }

  export type Tranches_doublonsMinAggregateInputType = {
    ID?: true
    Pays?: true
    Magazine?: true
    Numero?: true
    NumeroReference?: true
    TrancheReference?: true
  }

  export type Tranches_doublonsMaxAggregateInputType = {
    ID?: true
    Pays?: true
    Magazine?: true
    Numero?: true
    NumeroReference?: true
    TrancheReference?: true
  }

  export type Tranches_doublonsCountAggregateInputType = {
    ID?: true
    Pays?: true
    Magazine?: true
    Numero?: true
    NumeroReference?: true
    TrancheReference?: true
    _all?: true
  }

  export type Tranches_doublonsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which tranches_doublons to aggregate.
     */
    where?: tranches_doublonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tranches_doublons to fetch.
     */
    orderBy?: tranches_doublonsOrderByWithRelationInput | tranches_doublonsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tranches_doublonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tranches_doublons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tranches_doublons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tranches_doublons
    **/
    _count?: true | Tranches_doublonsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tranches_doublonsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tranches_doublonsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tranches_doublonsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tranches_doublonsMaxAggregateInputType
  }

  export type GetTranches_doublonsAggregateType<T extends Tranches_doublonsAggregateArgs> = {
        [P in keyof T & keyof AggregateTranches_doublons]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTranches_doublons[P]>
      : GetScalarType<T[P], AggregateTranches_doublons[P]>
  }




  export type tranches_doublonsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: tranches_doublonsWhereInput
    orderBy?: tranches_doublonsOrderByWithAggregationInput | tranches_doublonsOrderByWithAggregationInput[]
    by: Tranches_doublonsScalarFieldEnum[] | Tranches_doublonsScalarFieldEnum
    having?: tranches_doublonsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tranches_doublonsCountAggregateInputType | true
    _avg?: Tranches_doublonsAvgAggregateInputType
    _sum?: Tranches_doublonsSumAggregateInputType
    _min?: Tranches_doublonsMinAggregateInputType
    _max?: Tranches_doublonsMaxAggregateInputType
  }

  export type Tranches_doublonsGroupByOutputType = {
    ID: number
    Pays: string
    Magazine: string
    Numero: string
    NumeroReference: string
    TrancheReference: number | null
    _count: Tranches_doublonsCountAggregateOutputType | null
    _avg: Tranches_doublonsAvgAggregateOutputType | null
    _sum: Tranches_doublonsSumAggregateOutputType | null
    _min: Tranches_doublonsMinAggregateOutputType | null
    _max: Tranches_doublonsMaxAggregateOutputType | null
  }

  type GetTranches_doublonsGroupByPayload<T extends tranches_doublonsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tranches_doublonsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tranches_doublonsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tranches_doublonsGroupByOutputType[P]>
            : GetScalarType<T[P], Tranches_doublonsGroupByOutputType[P]>
        }
      >
    >


  export type tranches_doublonsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Pays?: boolean
    Magazine?: boolean
    Numero?: boolean
    NumeroReference?: boolean
    TrancheReference?: boolean
  }, ExtArgs["result"]["tranches_doublons"]>

  export type tranches_doublonsSelectScalar = {
    ID?: boolean
    Pays?: boolean
    Magazine?: boolean
    Numero?: boolean
    NumeroReference?: boolean
    TrancheReference?: boolean
  }


  export type $tranches_doublonsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "tranches_doublons"
    objects: {}
    scalars: $Extensions.GetResult<{
      ID: number
      Pays: string
      Magazine: string
      Numero: string
      NumeroReference: string
      TrancheReference: number | null
    }, ExtArgs["result"]["tranches_doublons"]>
    composites: {}
  }


  type tranches_doublonsGetPayload<S extends boolean | null | undefined | tranches_doublonsDefaultArgs> = $Result.GetResult<Prisma.$tranches_doublonsPayload, S>

  type tranches_doublonsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<tranches_doublonsFindManyArgs, 'select' | 'include'> & {
      select?: Tranches_doublonsCountAggregateInputType | true
    }

  export interface tranches_doublonsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tranches_doublons'], meta: { name: 'tranches_doublons' } }
    /**
     * Find zero or one Tranches_doublons that matches the filter.
     * @param {tranches_doublonsFindUniqueArgs} args - Arguments to find a Tranches_doublons
     * @example
     * // Get one Tranches_doublons
     * const tranches_doublons = await prisma.tranches_doublons.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tranches_doublonsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, tranches_doublonsFindUniqueArgs<ExtArgs>>
    ): Prisma__tranches_doublonsClient<$Result.GetResult<Prisma.$tranches_doublonsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tranches_doublons that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tranches_doublonsFindUniqueOrThrowArgs} args - Arguments to find a Tranches_doublons
     * @example
     * // Get one Tranches_doublons
     * const tranches_doublons = await prisma.tranches_doublons.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tranches_doublonsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tranches_doublonsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__tranches_doublonsClient<$Result.GetResult<Prisma.$tranches_doublonsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tranches_doublons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tranches_doublonsFindFirstArgs} args - Arguments to find a Tranches_doublons
     * @example
     * // Get one Tranches_doublons
     * const tranches_doublons = await prisma.tranches_doublons.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tranches_doublonsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, tranches_doublonsFindFirstArgs<ExtArgs>>
    ): Prisma__tranches_doublonsClient<$Result.GetResult<Prisma.$tranches_doublonsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tranches_doublons that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tranches_doublonsFindFirstOrThrowArgs} args - Arguments to find a Tranches_doublons
     * @example
     * // Get one Tranches_doublons
     * const tranches_doublons = await prisma.tranches_doublons.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tranches_doublonsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tranches_doublonsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__tranches_doublonsClient<$Result.GetResult<Prisma.$tranches_doublonsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tranches_doublons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tranches_doublonsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tranches_doublons
     * const tranches_doublons = await prisma.tranches_doublons.findMany()
     * 
     * // Get first 10 Tranches_doublons
     * const tranches_doublons = await prisma.tranches_doublons.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const tranches_doublonsWithIDOnly = await prisma.tranches_doublons.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends tranches_doublonsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tranches_doublonsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tranches_doublonsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tranches_doublons.
     * @param {tranches_doublonsCreateArgs} args - Arguments to create a Tranches_doublons.
     * @example
     * // Create one Tranches_doublons
     * const Tranches_doublons = await prisma.tranches_doublons.create({
     *   data: {
     *     // ... data to create a Tranches_doublons
     *   }
     * })
     * 
    **/
    create<T extends tranches_doublonsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, tranches_doublonsCreateArgs<ExtArgs>>
    ): Prisma__tranches_doublonsClient<$Result.GetResult<Prisma.$tranches_doublonsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tranches_doublons.
     *     @param {tranches_doublonsCreateManyArgs} args - Arguments to create many Tranches_doublons.
     *     @example
     *     // Create many Tranches_doublons
     *     const tranches_doublons = await prisma.tranches_doublons.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tranches_doublonsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tranches_doublonsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tranches_doublons.
     * @param {tranches_doublonsDeleteArgs} args - Arguments to delete one Tranches_doublons.
     * @example
     * // Delete one Tranches_doublons
     * const Tranches_doublons = await prisma.tranches_doublons.delete({
     *   where: {
     *     // ... filter to delete one Tranches_doublons
     *   }
     * })
     * 
    **/
    delete<T extends tranches_doublonsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, tranches_doublonsDeleteArgs<ExtArgs>>
    ): Prisma__tranches_doublonsClient<$Result.GetResult<Prisma.$tranches_doublonsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tranches_doublons.
     * @param {tranches_doublonsUpdateArgs} args - Arguments to update one Tranches_doublons.
     * @example
     * // Update one Tranches_doublons
     * const tranches_doublons = await prisma.tranches_doublons.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tranches_doublonsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, tranches_doublonsUpdateArgs<ExtArgs>>
    ): Prisma__tranches_doublonsClient<$Result.GetResult<Prisma.$tranches_doublonsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tranches_doublons.
     * @param {tranches_doublonsDeleteManyArgs} args - Arguments to filter Tranches_doublons to delete.
     * @example
     * // Delete a few Tranches_doublons
     * const { count } = await prisma.tranches_doublons.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tranches_doublonsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tranches_doublonsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tranches_doublons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tranches_doublonsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tranches_doublons
     * const tranches_doublons = await prisma.tranches_doublons.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tranches_doublonsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, tranches_doublonsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tranches_doublons.
     * @param {tranches_doublonsUpsertArgs} args - Arguments to update or create a Tranches_doublons.
     * @example
     * // Update or create a Tranches_doublons
     * const tranches_doublons = await prisma.tranches_doublons.upsert({
     *   create: {
     *     // ... data to create a Tranches_doublons
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tranches_doublons we want to update
     *   }
     * })
    **/
    upsert<T extends tranches_doublonsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, tranches_doublonsUpsertArgs<ExtArgs>>
    ): Prisma__tranches_doublonsClient<$Result.GetResult<Prisma.$tranches_doublonsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tranches_doublons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tranches_doublonsCountArgs} args - Arguments to filter Tranches_doublons to count.
     * @example
     * // Count the number of Tranches_doublons
     * const count = await prisma.tranches_doublons.count({
     *   where: {
     *     // ... the filter for the Tranches_doublons we want to count
     *   }
     * })
    **/
    count<T extends tranches_doublonsCountArgs>(
      args?: Subset<T, tranches_doublonsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tranches_doublonsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tranches_doublons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tranches_doublonsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tranches_doublonsAggregateArgs>(args: Subset<T, Tranches_doublonsAggregateArgs>): Prisma.PrismaPromise<GetTranches_doublonsAggregateType<T>>

    /**
     * Group by Tranches_doublons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tranches_doublonsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tranches_doublonsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tranches_doublonsGroupByArgs['orderBy'] }
        : { orderBy?: tranches_doublonsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tranches_doublonsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTranches_doublonsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tranches_doublons model
   */
  readonly fields: tranches_doublonsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tranches_doublons.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tranches_doublonsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the tranches_doublons model
   */ 
  interface tranches_doublonsFieldRefs {
    readonly ID: FieldRef<"tranches_doublons", 'Int'>
    readonly Pays: FieldRef<"tranches_doublons", 'String'>
    readonly Magazine: FieldRef<"tranches_doublons", 'String'>
    readonly Numero: FieldRef<"tranches_doublons", 'String'>
    readonly NumeroReference: FieldRef<"tranches_doublons", 'String'>
    readonly TrancheReference: FieldRef<"tranches_doublons", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * tranches_doublons findUnique
   */
  export type tranches_doublonsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tranches_doublons
     */
    select?: tranches_doublonsSelect<ExtArgs> | null
    /**
     * Filter, which tranches_doublons to fetch.
     */
    where: tranches_doublonsWhereUniqueInput
  }


  /**
   * tranches_doublons findUniqueOrThrow
   */
  export type tranches_doublonsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tranches_doublons
     */
    select?: tranches_doublonsSelect<ExtArgs> | null
    /**
     * Filter, which tranches_doublons to fetch.
     */
    where: tranches_doublonsWhereUniqueInput
  }


  /**
   * tranches_doublons findFirst
   */
  export type tranches_doublonsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tranches_doublons
     */
    select?: tranches_doublonsSelect<ExtArgs> | null
    /**
     * Filter, which tranches_doublons to fetch.
     */
    where?: tranches_doublonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tranches_doublons to fetch.
     */
    orderBy?: tranches_doublonsOrderByWithRelationInput | tranches_doublonsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tranches_doublons.
     */
    cursor?: tranches_doublonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tranches_doublons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tranches_doublons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tranches_doublons.
     */
    distinct?: Tranches_doublonsScalarFieldEnum | Tranches_doublonsScalarFieldEnum[]
  }


  /**
   * tranches_doublons findFirstOrThrow
   */
  export type tranches_doublonsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tranches_doublons
     */
    select?: tranches_doublonsSelect<ExtArgs> | null
    /**
     * Filter, which tranches_doublons to fetch.
     */
    where?: tranches_doublonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tranches_doublons to fetch.
     */
    orderBy?: tranches_doublonsOrderByWithRelationInput | tranches_doublonsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tranches_doublons.
     */
    cursor?: tranches_doublonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tranches_doublons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tranches_doublons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tranches_doublons.
     */
    distinct?: Tranches_doublonsScalarFieldEnum | Tranches_doublonsScalarFieldEnum[]
  }


  /**
   * tranches_doublons findMany
   */
  export type tranches_doublonsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tranches_doublons
     */
    select?: tranches_doublonsSelect<ExtArgs> | null
    /**
     * Filter, which tranches_doublons to fetch.
     */
    where?: tranches_doublonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tranches_doublons to fetch.
     */
    orderBy?: tranches_doublonsOrderByWithRelationInput | tranches_doublonsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tranches_doublons.
     */
    cursor?: tranches_doublonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tranches_doublons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tranches_doublons.
     */
    skip?: number
    distinct?: Tranches_doublonsScalarFieldEnum | Tranches_doublonsScalarFieldEnum[]
  }


  /**
   * tranches_doublons create
   */
  export type tranches_doublonsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tranches_doublons
     */
    select?: tranches_doublonsSelect<ExtArgs> | null
    /**
     * The data needed to create a tranches_doublons.
     */
    data: XOR<tranches_doublonsCreateInput, tranches_doublonsUncheckedCreateInput>
  }


  /**
   * tranches_doublons createMany
   */
  export type tranches_doublonsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tranches_doublons.
     */
    data: tranches_doublonsCreateManyInput | tranches_doublonsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * tranches_doublons update
   */
  export type tranches_doublonsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tranches_doublons
     */
    select?: tranches_doublonsSelect<ExtArgs> | null
    /**
     * The data needed to update a tranches_doublons.
     */
    data: XOR<tranches_doublonsUpdateInput, tranches_doublonsUncheckedUpdateInput>
    /**
     * Choose, which tranches_doublons to update.
     */
    where: tranches_doublonsWhereUniqueInput
  }


  /**
   * tranches_doublons updateMany
   */
  export type tranches_doublonsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tranches_doublons.
     */
    data: XOR<tranches_doublonsUpdateManyMutationInput, tranches_doublonsUncheckedUpdateManyInput>
    /**
     * Filter which tranches_doublons to update
     */
    where?: tranches_doublonsWhereInput
  }


  /**
   * tranches_doublons upsert
   */
  export type tranches_doublonsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tranches_doublons
     */
    select?: tranches_doublonsSelect<ExtArgs> | null
    /**
     * The filter to search for the tranches_doublons to update in case it exists.
     */
    where: tranches_doublonsWhereUniqueInput
    /**
     * In case the tranches_doublons found by the `where` argument doesn't exist, create a new tranches_doublons with this data.
     */
    create: XOR<tranches_doublonsCreateInput, tranches_doublonsUncheckedCreateInput>
    /**
     * In case the tranches_doublons was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tranches_doublonsUpdateInput, tranches_doublonsUncheckedUpdateInput>
  }


  /**
   * tranches_doublons delete
   */
  export type tranches_doublonsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tranches_doublons
     */
    select?: tranches_doublonsSelect<ExtArgs> | null
    /**
     * Filter which tranches_doublons to delete.
     */
    where: tranches_doublonsWhereUniqueInput
  }


  /**
   * tranches_doublons deleteMany
   */
  export type tranches_doublonsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which tranches_doublons to delete
     */
    where?: tranches_doublonsWhereInput
  }


  /**
   * tranches_doublons without action
   */
  export type tranches_doublonsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tranches_doublons
     */
    select?: tranches_doublonsSelect<ExtArgs> | null
  }



  /**
   * Model edge
   */

  export type AggregateEdge = {
    _count: EdgeCountAggregateOutputType | null
    _avg: EdgeAvgAggregateOutputType | null
    _sum: EdgeSumAggregateOutputType | null
    _min: EdgeMinAggregateOutputType | null
    _max: EdgeMaxAggregateOutputType | null
  }

  export type EdgeAvgAggregateOutputType = {
    id: number | null
    points: number | null
  }

  export type EdgeSumAggregateOutputType = {
    id: number | null
    points: number | null
  }

  export type EdgeMinAggregateOutputType = {
    id: number | null
    publicationcode: string | null
    issuenumber: string | null
    creationDate: Date | null
    points: number | null
    slug: string | null
    issuecode: string | null
  }

  export type EdgeMaxAggregateOutputType = {
    id: number | null
    publicationcode: string | null
    issuenumber: string | null
    creationDate: Date | null
    points: number | null
    slug: string | null
    issuecode: string | null
  }

  export type EdgeCountAggregateOutputType = {
    id: number
    publicationcode: number
    issuenumber: number
    creationDate: number
    points: number
    slug: number
    issuecode: number
    _all: number
  }


  export type EdgeAvgAggregateInputType = {
    id?: true
    points?: true
  }

  export type EdgeSumAggregateInputType = {
    id?: true
    points?: true
  }

  export type EdgeMinAggregateInputType = {
    id?: true
    publicationcode?: true
    issuenumber?: true
    creationDate?: true
    points?: true
    slug?: true
    issuecode?: true
  }

  export type EdgeMaxAggregateInputType = {
    id?: true
    publicationcode?: true
    issuenumber?: true
    creationDate?: true
    points?: true
    slug?: true
    issuecode?: true
  }

  export type EdgeCountAggregateInputType = {
    id?: true
    publicationcode?: true
    issuenumber?: true
    creationDate?: true
    points?: true
    slug?: true
    issuecode?: true
    _all?: true
  }

  export type EdgeAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which edge to aggregate.
     */
    where?: edgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of edges to fetch.
     */
    orderBy?: edgeOrderByWithRelationInput | edgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: edgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` edges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` edges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned edges
    **/
    _count?: true | EdgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EdgeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EdgeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EdgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EdgeMaxAggregateInputType
  }

  export type GetEdgeAggregateType<T extends EdgeAggregateArgs> = {
        [P in keyof T & keyof AggregateEdge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEdge[P]>
      : GetScalarType<T[P], AggregateEdge[P]>
  }




  export type edgeGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: edgeWhereInput
    orderBy?: edgeOrderByWithAggregationInput | edgeOrderByWithAggregationInput[]
    by: EdgeScalarFieldEnum[] | EdgeScalarFieldEnum
    having?: edgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EdgeCountAggregateInputType | true
    _avg?: EdgeAvgAggregateInputType
    _sum?: EdgeSumAggregateInputType
    _min?: EdgeMinAggregateInputType
    _max?: EdgeMaxAggregateInputType
  }

  export type EdgeGroupByOutputType = {
    id: number
    publicationcode: string
    issuenumber: string
    creationDate: Date
    points: number | null
    slug: string | null
    issuecode: string | null
    _count: EdgeCountAggregateOutputType | null
    _avg: EdgeAvgAggregateOutputType | null
    _sum: EdgeSumAggregateOutputType | null
    _min: EdgeMinAggregateOutputType | null
    _max: EdgeMaxAggregateOutputType | null
  }

  type GetEdgeGroupByPayload<T extends edgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EdgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EdgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EdgeGroupByOutputType[P]>
            : GetScalarType<T[P], EdgeGroupByOutputType[P]>
        }
      >
    >


  export type edgeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publicationcode?: boolean
    issuenumber?: boolean
    creationDate?: boolean
    points?: boolean
    slug?: boolean
    issuecode?: boolean
    users_contributions?: boolean | edge$users_contributionsArgs<ExtArgs>
    _count?: boolean | EdgeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["edge"]>

  export type edgeSelectScalar = {
    id?: boolean
    publicationcode?: boolean
    issuenumber?: boolean
    creationDate?: boolean
    points?: boolean
    slug?: boolean
    issuecode?: boolean
  }

  export type edgeInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    users_contributions?: boolean | edge$users_contributionsArgs<ExtArgs>
    _count?: boolean | EdgeCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $edgePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "edge"
    objects: {
      users_contributions: Prisma.$userContributionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      publicationcode: string
      issuenumber: string
      creationDate: Date
      points: number | null
      slug: string | null
      issuecode: string | null
    }, ExtArgs["result"]["edge"]>
    composites: {}
  }


  type edgeGetPayload<S extends boolean | null | undefined | edgeDefaultArgs> = $Result.GetResult<Prisma.$edgePayload, S>

  type edgeCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<edgeFindManyArgs, 'select' | 'include'> & {
      select?: EdgeCountAggregateInputType | true
    }

  export interface edgeDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['edge'], meta: { name: 'edge' } }
    /**
     * Find zero or one Edge that matches the filter.
     * @param {edgeFindUniqueArgs} args - Arguments to find a Edge
     * @example
     * // Get one Edge
     * const edge = await prisma.edge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends edgeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, edgeFindUniqueArgs<ExtArgs>>
    ): Prisma__edgeClient<$Result.GetResult<Prisma.$edgePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Edge that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {edgeFindUniqueOrThrowArgs} args - Arguments to find a Edge
     * @example
     * // Get one Edge
     * const edge = await prisma.edge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends edgeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, edgeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__edgeClient<$Result.GetResult<Prisma.$edgePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Edge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edgeFindFirstArgs} args - Arguments to find a Edge
     * @example
     * // Get one Edge
     * const edge = await prisma.edge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends edgeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, edgeFindFirstArgs<ExtArgs>>
    ): Prisma__edgeClient<$Result.GetResult<Prisma.$edgePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Edge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edgeFindFirstOrThrowArgs} args - Arguments to find a Edge
     * @example
     * // Get one Edge
     * const edge = await prisma.edge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends edgeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, edgeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__edgeClient<$Result.GetResult<Prisma.$edgePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Edges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edgeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Edges
     * const edges = await prisma.edge.findMany()
     * 
     * // Get first 10 Edges
     * const edges = await prisma.edge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const edgeWithIdOnly = await prisma.edge.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends edgeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, edgeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$edgePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Edge.
     * @param {edgeCreateArgs} args - Arguments to create a Edge.
     * @example
     * // Create one Edge
     * const Edge = await prisma.edge.create({
     *   data: {
     *     // ... data to create a Edge
     *   }
     * })
     * 
    **/
    create<T extends edgeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, edgeCreateArgs<ExtArgs>>
    ): Prisma__edgeClient<$Result.GetResult<Prisma.$edgePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Edges.
     *     @param {edgeCreateManyArgs} args - Arguments to create many Edges.
     *     @example
     *     // Create many Edges
     *     const edge = await prisma.edge.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends edgeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, edgeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Edge.
     * @param {edgeDeleteArgs} args - Arguments to delete one Edge.
     * @example
     * // Delete one Edge
     * const Edge = await prisma.edge.delete({
     *   where: {
     *     // ... filter to delete one Edge
     *   }
     * })
     * 
    **/
    delete<T extends edgeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, edgeDeleteArgs<ExtArgs>>
    ): Prisma__edgeClient<$Result.GetResult<Prisma.$edgePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Edge.
     * @param {edgeUpdateArgs} args - Arguments to update one Edge.
     * @example
     * // Update one Edge
     * const edge = await prisma.edge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends edgeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, edgeUpdateArgs<ExtArgs>>
    ): Prisma__edgeClient<$Result.GetResult<Prisma.$edgePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Edges.
     * @param {edgeDeleteManyArgs} args - Arguments to filter Edges to delete.
     * @example
     * // Delete a few Edges
     * const { count } = await prisma.edge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends edgeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, edgeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Edges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Edges
     * const edge = await prisma.edge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends edgeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, edgeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Edge.
     * @param {edgeUpsertArgs} args - Arguments to update or create a Edge.
     * @example
     * // Update or create a Edge
     * const edge = await prisma.edge.upsert({
     *   create: {
     *     // ... data to create a Edge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Edge we want to update
     *   }
     * })
    **/
    upsert<T extends edgeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, edgeUpsertArgs<ExtArgs>>
    ): Prisma__edgeClient<$Result.GetResult<Prisma.$edgePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Edges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edgeCountArgs} args - Arguments to filter Edges to count.
     * @example
     * // Count the number of Edges
     * const count = await prisma.edge.count({
     *   where: {
     *     // ... the filter for the Edges we want to count
     *   }
     * })
    **/
    count<T extends edgeCountArgs>(
      args?: Subset<T, edgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EdgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Edge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EdgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EdgeAggregateArgs>(args: Subset<T, EdgeAggregateArgs>): Prisma.PrismaPromise<GetEdgeAggregateType<T>>

    /**
     * Group by Edge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends edgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: edgeGroupByArgs['orderBy'] }
        : { orderBy?: edgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, edgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEdgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the edge model
   */
  readonly fields: edgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for edge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__edgeClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users_contributions<T extends edge$users_contributionsArgs<ExtArgs> = {}>(args?: Subset<T, edge$users_contributionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userContributionPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the edge model
   */ 
  interface edgeFieldRefs {
    readonly id: FieldRef<"edge", 'Int'>
    readonly publicationcode: FieldRef<"edge", 'String'>
    readonly issuenumber: FieldRef<"edge", 'String'>
    readonly creationDate: FieldRef<"edge", 'DateTime'>
    readonly points: FieldRef<"edge", 'Int'>
    readonly slug: FieldRef<"edge", 'String'>
    readonly issuecode: FieldRef<"edge", 'String'>
  }
    

  // Custom InputTypes

  /**
   * edge findUnique
   */
  export type edgeFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edge
     */
    select?: edgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: edgeInclude<ExtArgs> | null
    /**
     * Filter, which edge to fetch.
     */
    where: edgeWhereUniqueInput
  }


  /**
   * edge findUniqueOrThrow
   */
  export type edgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edge
     */
    select?: edgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: edgeInclude<ExtArgs> | null
    /**
     * Filter, which edge to fetch.
     */
    where: edgeWhereUniqueInput
  }


  /**
   * edge findFirst
   */
  export type edgeFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edge
     */
    select?: edgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: edgeInclude<ExtArgs> | null
    /**
     * Filter, which edge to fetch.
     */
    where?: edgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of edges to fetch.
     */
    orderBy?: edgeOrderByWithRelationInput | edgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for edges.
     */
    cursor?: edgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` edges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` edges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of edges.
     */
    distinct?: EdgeScalarFieldEnum | EdgeScalarFieldEnum[]
  }


  /**
   * edge findFirstOrThrow
   */
  export type edgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edge
     */
    select?: edgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: edgeInclude<ExtArgs> | null
    /**
     * Filter, which edge to fetch.
     */
    where?: edgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of edges to fetch.
     */
    orderBy?: edgeOrderByWithRelationInput | edgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for edges.
     */
    cursor?: edgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` edges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` edges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of edges.
     */
    distinct?: EdgeScalarFieldEnum | EdgeScalarFieldEnum[]
  }


  /**
   * edge findMany
   */
  export type edgeFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edge
     */
    select?: edgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: edgeInclude<ExtArgs> | null
    /**
     * Filter, which edges to fetch.
     */
    where?: edgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of edges to fetch.
     */
    orderBy?: edgeOrderByWithRelationInput | edgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing edges.
     */
    cursor?: edgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` edges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` edges.
     */
    skip?: number
    distinct?: EdgeScalarFieldEnum | EdgeScalarFieldEnum[]
  }


  /**
   * edge create
   */
  export type edgeCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edge
     */
    select?: edgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: edgeInclude<ExtArgs> | null
    /**
     * The data needed to create a edge.
     */
    data: XOR<edgeCreateInput, edgeUncheckedCreateInput>
  }


  /**
   * edge createMany
   */
  export type edgeCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many edges.
     */
    data: edgeCreateManyInput | edgeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * edge update
   */
  export type edgeUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edge
     */
    select?: edgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: edgeInclude<ExtArgs> | null
    /**
     * The data needed to update a edge.
     */
    data: XOR<edgeUpdateInput, edgeUncheckedUpdateInput>
    /**
     * Choose, which edge to update.
     */
    where: edgeWhereUniqueInput
  }


  /**
   * edge updateMany
   */
  export type edgeUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update edges.
     */
    data: XOR<edgeUpdateManyMutationInput, edgeUncheckedUpdateManyInput>
    /**
     * Filter which edges to update
     */
    where?: edgeWhereInput
  }


  /**
   * edge upsert
   */
  export type edgeUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edge
     */
    select?: edgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: edgeInclude<ExtArgs> | null
    /**
     * The filter to search for the edge to update in case it exists.
     */
    where: edgeWhereUniqueInput
    /**
     * In case the edge found by the `where` argument doesn't exist, create a new edge with this data.
     */
    create: XOR<edgeCreateInput, edgeUncheckedCreateInput>
    /**
     * In case the edge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<edgeUpdateInput, edgeUncheckedUpdateInput>
  }


  /**
   * edge delete
   */
  export type edgeDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edge
     */
    select?: edgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: edgeInclude<ExtArgs> | null
    /**
     * Filter which edge to delete.
     */
    where: edgeWhereUniqueInput
  }


  /**
   * edge deleteMany
   */
  export type edgeDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which edges to delete
     */
    where?: edgeWhereInput
  }


  /**
   * edge.users_contributions
   */
  export type edge$users_contributionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userContribution
     */
    select?: userContributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userContributionInclude<ExtArgs> | null
    where?: userContributionWhereInput
    orderBy?: userContributionOrderByWithRelationInput | userContributionOrderByWithRelationInput[]
    cursor?: userContributionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserContributionScalarFieldEnum | UserContributionScalarFieldEnum[]
  }


  /**
   * edge without action
   */
  export type edgeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edge
     */
    select?: edgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: edgeInclude<ExtArgs> | null
  }



  /**
   * Model tranches_pretes_contributeurs
   */

  export type AggregateTranches_pretes_contributeurs = {
    _count: Tranches_pretes_contributeursCountAggregateOutputType | null
    _avg: Tranches_pretes_contributeursAvgAggregateOutputType | null
    _sum: Tranches_pretes_contributeursSumAggregateOutputType | null
    _min: Tranches_pretes_contributeursMinAggregateOutputType | null
    _max: Tranches_pretes_contributeursMaxAggregateOutputType | null
  }

  export type Tranches_pretes_contributeursAvgAggregateOutputType = {
    contributeur: number | null
  }

  export type Tranches_pretes_contributeursSumAggregateOutputType = {
    contributeur: number | null
  }

  export type Tranches_pretes_contributeursMinAggregateOutputType = {
    publicationcode: string | null
    issuenumber: string | null
    contributeur: number | null
    contribution: $Enums.tranches_pretes_contributeurs_contribution | null
  }

  export type Tranches_pretes_contributeursMaxAggregateOutputType = {
    publicationcode: string | null
    issuenumber: string | null
    contributeur: number | null
    contribution: $Enums.tranches_pretes_contributeurs_contribution | null
  }

  export type Tranches_pretes_contributeursCountAggregateOutputType = {
    publicationcode: number
    issuenumber: number
    contributeur: number
    contribution: number
    _all: number
  }


  export type Tranches_pretes_contributeursAvgAggregateInputType = {
    contributeur?: true
  }

  export type Tranches_pretes_contributeursSumAggregateInputType = {
    contributeur?: true
  }

  export type Tranches_pretes_contributeursMinAggregateInputType = {
    publicationcode?: true
    issuenumber?: true
    contributeur?: true
    contribution?: true
  }

  export type Tranches_pretes_contributeursMaxAggregateInputType = {
    publicationcode?: true
    issuenumber?: true
    contributeur?: true
    contribution?: true
  }

  export type Tranches_pretes_contributeursCountAggregateInputType = {
    publicationcode?: true
    issuenumber?: true
    contributeur?: true
    contribution?: true
    _all?: true
  }

  export type Tranches_pretes_contributeursAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which tranches_pretes_contributeurs to aggregate.
     */
    where?: tranches_pretes_contributeursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tranches_pretes_contributeurs to fetch.
     */
    orderBy?: tranches_pretes_contributeursOrderByWithRelationInput | tranches_pretes_contributeursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tranches_pretes_contributeursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tranches_pretes_contributeurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tranches_pretes_contributeurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tranches_pretes_contributeurs
    **/
    _count?: true | Tranches_pretes_contributeursCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tranches_pretes_contributeursAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tranches_pretes_contributeursSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tranches_pretes_contributeursMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tranches_pretes_contributeursMaxAggregateInputType
  }

  export type GetTranches_pretes_contributeursAggregateType<T extends Tranches_pretes_contributeursAggregateArgs> = {
        [P in keyof T & keyof AggregateTranches_pretes_contributeurs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTranches_pretes_contributeurs[P]>
      : GetScalarType<T[P], AggregateTranches_pretes_contributeurs[P]>
  }




  export type tranches_pretes_contributeursGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: tranches_pretes_contributeursWhereInput
    orderBy?: tranches_pretes_contributeursOrderByWithAggregationInput | tranches_pretes_contributeursOrderByWithAggregationInput[]
    by: Tranches_pretes_contributeursScalarFieldEnum[] | Tranches_pretes_contributeursScalarFieldEnum
    having?: tranches_pretes_contributeursScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tranches_pretes_contributeursCountAggregateInputType | true
    _avg?: Tranches_pretes_contributeursAvgAggregateInputType
    _sum?: Tranches_pretes_contributeursSumAggregateInputType
    _min?: Tranches_pretes_contributeursMinAggregateInputType
    _max?: Tranches_pretes_contributeursMaxAggregateInputType
  }

  export type Tranches_pretes_contributeursGroupByOutputType = {
    publicationcode: string
    issuenumber: string
    contributeur: number
    contribution: $Enums.tranches_pretes_contributeurs_contribution
    _count: Tranches_pretes_contributeursCountAggregateOutputType | null
    _avg: Tranches_pretes_contributeursAvgAggregateOutputType | null
    _sum: Tranches_pretes_contributeursSumAggregateOutputType | null
    _min: Tranches_pretes_contributeursMinAggregateOutputType | null
    _max: Tranches_pretes_contributeursMaxAggregateOutputType | null
  }

  type GetTranches_pretes_contributeursGroupByPayload<T extends tranches_pretes_contributeursGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tranches_pretes_contributeursGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tranches_pretes_contributeursGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tranches_pretes_contributeursGroupByOutputType[P]>
            : GetScalarType<T[P], Tranches_pretes_contributeursGroupByOutputType[P]>
        }
      >
    >


  export type tranches_pretes_contributeursSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    publicationcode?: boolean
    issuenumber?: boolean
    contributeur?: boolean
    contribution?: boolean
  }, ExtArgs["result"]["tranches_pretes_contributeurs"]>

  export type tranches_pretes_contributeursSelectScalar = {
    publicationcode?: boolean
    issuenumber?: boolean
    contributeur?: boolean
    contribution?: boolean
  }


  export type $tranches_pretes_contributeursPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "tranches_pretes_contributeurs"
    objects: {}
    scalars: $Extensions.GetResult<{
      publicationcode: string
      issuenumber: string
      contributeur: number
      contribution: $Enums.tranches_pretes_contributeurs_contribution
    }, ExtArgs["result"]["tranches_pretes_contributeurs"]>
    composites: {}
  }


  type tranches_pretes_contributeursGetPayload<S extends boolean | null | undefined | tranches_pretes_contributeursDefaultArgs> = $Result.GetResult<Prisma.$tranches_pretes_contributeursPayload, S>

  type tranches_pretes_contributeursCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<tranches_pretes_contributeursFindManyArgs, 'select' | 'include'> & {
      select?: Tranches_pretes_contributeursCountAggregateInputType | true
    }

  export interface tranches_pretes_contributeursDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tranches_pretes_contributeurs'], meta: { name: 'tranches_pretes_contributeurs' } }
    /**
     * Find zero or one Tranches_pretes_contributeurs that matches the filter.
     * @param {tranches_pretes_contributeursFindUniqueArgs} args - Arguments to find a Tranches_pretes_contributeurs
     * @example
     * // Get one Tranches_pretes_contributeurs
     * const tranches_pretes_contributeurs = await prisma.tranches_pretes_contributeurs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tranches_pretes_contributeursFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, tranches_pretes_contributeursFindUniqueArgs<ExtArgs>>
    ): Prisma__tranches_pretes_contributeursClient<$Result.GetResult<Prisma.$tranches_pretes_contributeursPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tranches_pretes_contributeurs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tranches_pretes_contributeursFindUniqueOrThrowArgs} args - Arguments to find a Tranches_pretes_contributeurs
     * @example
     * // Get one Tranches_pretes_contributeurs
     * const tranches_pretes_contributeurs = await prisma.tranches_pretes_contributeurs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tranches_pretes_contributeursFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tranches_pretes_contributeursFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__tranches_pretes_contributeursClient<$Result.GetResult<Prisma.$tranches_pretes_contributeursPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tranches_pretes_contributeurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tranches_pretes_contributeursFindFirstArgs} args - Arguments to find a Tranches_pretes_contributeurs
     * @example
     * // Get one Tranches_pretes_contributeurs
     * const tranches_pretes_contributeurs = await prisma.tranches_pretes_contributeurs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tranches_pretes_contributeursFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, tranches_pretes_contributeursFindFirstArgs<ExtArgs>>
    ): Prisma__tranches_pretes_contributeursClient<$Result.GetResult<Prisma.$tranches_pretes_contributeursPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tranches_pretes_contributeurs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tranches_pretes_contributeursFindFirstOrThrowArgs} args - Arguments to find a Tranches_pretes_contributeurs
     * @example
     * // Get one Tranches_pretes_contributeurs
     * const tranches_pretes_contributeurs = await prisma.tranches_pretes_contributeurs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tranches_pretes_contributeursFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tranches_pretes_contributeursFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__tranches_pretes_contributeursClient<$Result.GetResult<Prisma.$tranches_pretes_contributeursPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tranches_pretes_contributeurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tranches_pretes_contributeursFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tranches_pretes_contributeurs
     * const tranches_pretes_contributeurs = await prisma.tranches_pretes_contributeurs.findMany()
     * 
     * // Get first 10 Tranches_pretes_contributeurs
     * const tranches_pretes_contributeurs = await prisma.tranches_pretes_contributeurs.findMany({ take: 10 })
     * 
     * // Only select the `publicationcode`
     * const tranches_pretes_contributeursWithPublicationcodeOnly = await prisma.tranches_pretes_contributeurs.findMany({ select: { publicationcode: true } })
     * 
    **/
    findMany<T extends tranches_pretes_contributeursFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tranches_pretes_contributeursFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tranches_pretes_contributeursPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tranches_pretes_contributeurs.
     * @param {tranches_pretes_contributeursCreateArgs} args - Arguments to create a Tranches_pretes_contributeurs.
     * @example
     * // Create one Tranches_pretes_contributeurs
     * const Tranches_pretes_contributeurs = await prisma.tranches_pretes_contributeurs.create({
     *   data: {
     *     // ... data to create a Tranches_pretes_contributeurs
     *   }
     * })
     * 
    **/
    create<T extends tranches_pretes_contributeursCreateArgs<ExtArgs>>(
      args: SelectSubset<T, tranches_pretes_contributeursCreateArgs<ExtArgs>>
    ): Prisma__tranches_pretes_contributeursClient<$Result.GetResult<Prisma.$tranches_pretes_contributeursPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tranches_pretes_contributeurs.
     *     @param {tranches_pretes_contributeursCreateManyArgs} args - Arguments to create many Tranches_pretes_contributeurs.
     *     @example
     *     // Create many Tranches_pretes_contributeurs
     *     const tranches_pretes_contributeurs = await prisma.tranches_pretes_contributeurs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tranches_pretes_contributeursCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tranches_pretes_contributeursCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tranches_pretes_contributeurs.
     * @param {tranches_pretes_contributeursDeleteArgs} args - Arguments to delete one Tranches_pretes_contributeurs.
     * @example
     * // Delete one Tranches_pretes_contributeurs
     * const Tranches_pretes_contributeurs = await prisma.tranches_pretes_contributeurs.delete({
     *   where: {
     *     // ... filter to delete one Tranches_pretes_contributeurs
     *   }
     * })
     * 
    **/
    delete<T extends tranches_pretes_contributeursDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, tranches_pretes_contributeursDeleteArgs<ExtArgs>>
    ): Prisma__tranches_pretes_contributeursClient<$Result.GetResult<Prisma.$tranches_pretes_contributeursPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tranches_pretes_contributeurs.
     * @param {tranches_pretes_contributeursUpdateArgs} args - Arguments to update one Tranches_pretes_contributeurs.
     * @example
     * // Update one Tranches_pretes_contributeurs
     * const tranches_pretes_contributeurs = await prisma.tranches_pretes_contributeurs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tranches_pretes_contributeursUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, tranches_pretes_contributeursUpdateArgs<ExtArgs>>
    ): Prisma__tranches_pretes_contributeursClient<$Result.GetResult<Prisma.$tranches_pretes_contributeursPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tranches_pretes_contributeurs.
     * @param {tranches_pretes_contributeursDeleteManyArgs} args - Arguments to filter Tranches_pretes_contributeurs to delete.
     * @example
     * // Delete a few Tranches_pretes_contributeurs
     * const { count } = await prisma.tranches_pretes_contributeurs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tranches_pretes_contributeursDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tranches_pretes_contributeursDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tranches_pretes_contributeurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tranches_pretes_contributeursUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tranches_pretes_contributeurs
     * const tranches_pretes_contributeurs = await prisma.tranches_pretes_contributeurs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tranches_pretes_contributeursUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, tranches_pretes_contributeursUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tranches_pretes_contributeurs.
     * @param {tranches_pretes_contributeursUpsertArgs} args - Arguments to update or create a Tranches_pretes_contributeurs.
     * @example
     * // Update or create a Tranches_pretes_contributeurs
     * const tranches_pretes_contributeurs = await prisma.tranches_pretes_contributeurs.upsert({
     *   create: {
     *     // ... data to create a Tranches_pretes_contributeurs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tranches_pretes_contributeurs we want to update
     *   }
     * })
    **/
    upsert<T extends tranches_pretes_contributeursUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, tranches_pretes_contributeursUpsertArgs<ExtArgs>>
    ): Prisma__tranches_pretes_contributeursClient<$Result.GetResult<Prisma.$tranches_pretes_contributeursPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tranches_pretes_contributeurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tranches_pretes_contributeursCountArgs} args - Arguments to filter Tranches_pretes_contributeurs to count.
     * @example
     * // Count the number of Tranches_pretes_contributeurs
     * const count = await prisma.tranches_pretes_contributeurs.count({
     *   where: {
     *     // ... the filter for the Tranches_pretes_contributeurs we want to count
     *   }
     * })
    **/
    count<T extends tranches_pretes_contributeursCountArgs>(
      args?: Subset<T, tranches_pretes_contributeursCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tranches_pretes_contributeursCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tranches_pretes_contributeurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tranches_pretes_contributeursAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tranches_pretes_contributeursAggregateArgs>(args: Subset<T, Tranches_pretes_contributeursAggregateArgs>): Prisma.PrismaPromise<GetTranches_pretes_contributeursAggregateType<T>>

    /**
     * Group by Tranches_pretes_contributeurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tranches_pretes_contributeursGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tranches_pretes_contributeursGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tranches_pretes_contributeursGroupByArgs['orderBy'] }
        : { orderBy?: tranches_pretes_contributeursGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tranches_pretes_contributeursGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTranches_pretes_contributeursGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tranches_pretes_contributeurs model
   */
  readonly fields: tranches_pretes_contributeursFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tranches_pretes_contributeurs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tranches_pretes_contributeursClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the tranches_pretes_contributeurs model
   */ 
  interface tranches_pretes_contributeursFieldRefs {
    readonly publicationcode: FieldRef<"tranches_pretes_contributeurs", 'String'>
    readonly issuenumber: FieldRef<"tranches_pretes_contributeurs", 'String'>
    readonly contributeur: FieldRef<"tranches_pretes_contributeurs", 'Int'>
    readonly contribution: FieldRef<"tranches_pretes_contributeurs", 'tranches_pretes_contributeurs_contribution'>
  }
    

  // Custom InputTypes

  /**
   * tranches_pretes_contributeurs findUnique
   */
  export type tranches_pretes_contributeursFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tranches_pretes_contributeurs
     */
    select?: tranches_pretes_contributeursSelect<ExtArgs> | null
    /**
     * Filter, which tranches_pretes_contributeurs to fetch.
     */
    where: tranches_pretes_contributeursWhereUniqueInput
  }


  /**
   * tranches_pretes_contributeurs findUniqueOrThrow
   */
  export type tranches_pretes_contributeursFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tranches_pretes_contributeurs
     */
    select?: tranches_pretes_contributeursSelect<ExtArgs> | null
    /**
     * Filter, which tranches_pretes_contributeurs to fetch.
     */
    where: tranches_pretes_contributeursWhereUniqueInput
  }


  /**
   * tranches_pretes_contributeurs findFirst
   */
  export type tranches_pretes_contributeursFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tranches_pretes_contributeurs
     */
    select?: tranches_pretes_contributeursSelect<ExtArgs> | null
    /**
     * Filter, which tranches_pretes_contributeurs to fetch.
     */
    where?: tranches_pretes_contributeursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tranches_pretes_contributeurs to fetch.
     */
    orderBy?: tranches_pretes_contributeursOrderByWithRelationInput | tranches_pretes_contributeursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tranches_pretes_contributeurs.
     */
    cursor?: tranches_pretes_contributeursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tranches_pretes_contributeurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tranches_pretes_contributeurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tranches_pretes_contributeurs.
     */
    distinct?: Tranches_pretes_contributeursScalarFieldEnum | Tranches_pretes_contributeursScalarFieldEnum[]
  }


  /**
   * tranches_pretes_contributeurs findFirstOrThrow
   */
  export type tranches_pretes_contributeursFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tranches_pretes_contributeurs
     */
    select?: tranches_pretes_contributeursSelect<ExtArgs> | null
    /**
     * Filter, which tranches_pretes_contributeurs to fetch.
     */
    where?: tranches_pretes_contributeursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tranches_pretes_contributeurs to fetch.
     */
    orderBy?: tranches_pretes_contributeursOrderByWithRelationInput | tranches_pretes_contributeursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tranches_pretes_contributeurs.
     */
    cursor?: tranches_pretes_contributeursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tranches_pretes_contributeurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tranches_pretes_contributeurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tranches_pretes_contributeurs.
     */
    distinct?: Tranches_pretes_contributeursScalarFieldEnum | Tranches_pretes_contributeursScalarFieldEnum[]
  }


  /**
   * tranches_pretes_contributeurs findMany
   */
  export type tranches_pretes_contributeursFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tranches_pretes_contributeurs
     */
    select?: tranches_pretes_contributeursSelect<ExtArgs> | null
    /**
     * Filter, which tranches_pretes_contributeurs to fetch.
     */
    where?: tranches_pretes_contributeursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tranches_pretes_contributeurs to fetch.
     */
    orderBy?: tranches_pretes_contributeursOrderByWithRelationInput | tranches_pretes_contributeursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tranches_pretes_contributeurs.
     */
    cursor?: tranches_pretes_contributeursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tranches_pretes_contributeurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tranches_pretes_contributeurs.
     */
    skip?: number
    distinct?: Tranches_pretes_contributeursScalarFieldEnum | Tranches_pretes_contributeursScalarFieldEnum[]
  }


  /**
   * tranches_pretes_contributeurs create
   */
  export type tranches_pretes_contributeursCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tranches_pretes_contributeurs
     */
    select?: tranches_pretes_contributeursSelect<ExtArgs> | null
    /**
     * The data needed to create a tranches_pretes_contributeurs.
     */
    data: XOR<tranches_pretes_contributeursCreateInput, tranches_pretes_contributeursUncheckedCreateInput>
  }


  /**
   * tranches_pretes_contributeurs createMany
   */
  export type tranches_pretes_contributeursCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tranches_pretes_contributeurs.
     */
    data: tranches_pretes_contributeursCreateManyInput | tranches_pretes_contributeursCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * tranches_pretes_contributeurs update
   */
  export type tranches_pretes_contributeursUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tranches_pretes_contributeurs
     */
    select?: tranches_pretes_contributeursSelect<ExtArgs> | null
    /**
     * The data needed to update a tranches_pretes_contributeurs.
     */
    data: XOR<tranches_pretes_contributeursUpdateInput, tranches_pretes_contributeursUncheckedUpdateInput>
    /**
     * Choose, which tranches_pretes_contributeurs to update.
     */
    where: tranches_pretes_contributeursWhereUniqueInput
  }


  /**
   * tranches_pretes_contributeurs updateMany
   */
  export type tranches_pretes_contributeursUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tranches_pretes_contributeurs.
     */
    data: XOR<tranches_pretes_contributeursUpdateManyMutationInput, tranches_pretes_contributeursUncheckedUpdateManyInput>
    /**
     * Filter which tranches_pretes_contributeurs to update
     */
    where?: tranches_pretes_contributeursWhereInput
  }


  /**
   * tranches_pretes_contributeurs upsert
   */
  export type tranches_pretes_contributeursUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tranches_pretes_contributeurs
     */
    select?: tranches_pretes_contributeursSelect<ExtArgs> | null
    /**
     * The filter to search for the tranches_pretes_contributeurs to update in case it exists.
     */
    where: tranches_pretes_contributeursWhereUniqueInput
    /**
     * In case the tranches_pretes_contributeurs found by the `where` argument doesn't exist, create a new tranches_pretes_contributeurs with this data.
     */
    create: XOR<tranches_pretes_contributeursCreateInput, tranches_pretes_contributeursUncheckedCreateInput>
    /**
     * In case the tranches_pretes_contributeurs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tranches_pretes_contributeursUpdateInput, tranches_pretes_contributeursUncheckedUpdateInput>
  }


  /**
   * tranches_pretes_contributeurs delete
   */
  export type tranches_pretes_contributeursDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tranches_pretes_contributeurs
     */
    select?: tranches_pretes_contributeursSelect<ExtArgs> | null
    /**
     * Filter which tranches_pretes_contributeurs to delete.
     */
    where: tranches_pretes_contributeursWhereUniqueInput
  }


  /**
   * tranches_pretes_contributeurs deleteMany
   */
  export type tranches_pretes_contributeursDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which tranches_pretes_contributeurs to delete
     */
    where?: tranches_pretes_contributeursWhereInput
  }


  /**
   * tranches_pretes_contributeurs without action
   */
  export type tranches_pretes_contributeursDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tranches_pretes_contributeurs
     */
    select?: tranches_pretes_contributeursSelect<ExtArgs> | null
  }



  /**
   * Model tranches_pretes_contributions
   */

  export type AggregateTranches_pretes_contributions = {
    _count: Tranches_pretes_contributionsCountAggregateOutputType | null
    _avg: Tranches_pretes_contributionsAvgAggregateOutputType | null
    _sum: Tranches_pretes_contributionsSumAggregateOutputType | null
    _min: Tranches_pretes_contributionsMinAggregateOutputType | null
    _max: Tranches_pretes_contributionsMaxAggregateOutputType | null
  }

  export type Tranches_pretes_contributionsAvgAggregateOutputType = {
    ID: number | null
    ID_tranche: number | null
    ID_user: number | null
    points_new: number | null
    points_total: number | null
  }

  export type Tranches_pretes_contributionsSumAggregateOutputType = {
    ID: number | null
    ID_tranche: number | null
    ID_user: number | null
    points_new: number | null
    points_total: number | null
  }

  export type Tranches_pretes_contributionsMinAggregateOutputType = {
    ID: number | null
    ID_tranche: number | null
    ID_user: number | null
    dateajout: Date | null
    contribution: $Enums.tranches_pretes_contributions_contribution | null
    points_new: number | null
    points_total: number | null
  }

  export type Tranches_pretes_contributionsMaxAggregateOutputType = {
    ID: number | null
    ID_tranche: number | null
    ID_user: number | null
    dateajout: Date | null
    contribution: $Enums.tranches_pretes_contributions_contribution | null
    points_new: number | null
    points_total: number | null
  }

  export type Tranches_pretes_contributionsCountAggregateOutputType = {
    ID: number
    ID_tranche: number
    ID_user: number
    dateajout: number
    contribution: number
    points_new: number
    points_total: number
    _all: number
  }


  export type Tranches_pretes_contributionsAvgAggregateInputType = {
    ID?: true
    ID_tranche?: true
    ID_user?: true
    points_new?: true
    points_total?: true
  }

  export type Tranches_pretes_contributionsSumAggregateInputType = {
    ID?: true
    ID_tranche?: true
    ID_user?: true
    points_new?: true
    points_total?: true
  }

  export type Tranches_pretes_contributionsMinAggregateInputType = {
    ID?: true
    ID_tranche?: true
    ID_user?: true
    dateajout?: true
    contribution?: true
    points_new?: true
    points_total?: true
  }

  export type Tranches_pretes_contributionsMaxAggregateInputType = {
    ID?: true
    ID_tranche?: true
    ID_user?: true
    dateajout?: true
    contribution?: true
    points_new?: true
    points_total?: true
  }

  export type Tranches_pretes_contributionsCountAggregateInputType = {
    ID?: true
    ID_tranche?: true
    ID_user?: true
    dateajout?: true
    contribution?: true
    points_new?: true
    points_total?: true
    _all?: true
  }

  export type Tranches_pretes_contributionsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which tranches_pretes_contributions to aggregate.
     */
    where?: tranches_pretes_contributionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tranches_pretes_contributions to fetch.
     */
    orderBy?: tranches_pretes_contributionsOrderByWithRelationInput | tranches_pretes_contributionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tranches_pretes_contributionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tranches_pretes_contributions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tranches_pretes_contributions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tranches_pretes_contributions
    **/
    _count?: true | Tranches_pretes_contributionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tranches_pretes_contributionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tranches_pretes_contributionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tranches_pretes_contributionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tranches_pretes_contributionsMaxAggregateInputType
  }

  export type GetTranches_pretes_contributionsAggregateType<T extends Tranches_pretes_contributionsAggregateArgs> = {
        [P in keyof T & keyof AggregateTranches_pretes_contributions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTranches_pretes_contributions[P]>
      : GetScalarType<T[P], AggregateTranches_pretes_contributions[P]>
  }




  export type tranches_pretes_contributionsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: tranches_pretes_contributionsWhereInput
    orderBy?: tranches_pretes_contributionsOrderByWithAggregationInput | tranches_pretes_contributionsOrderByWithAggregationInput[]
    by: Tranches_pretes_contributionsScalarFieldEnum[] | Tranches_pretes_contributionsScalarFieldEnum
    having?: tranches_pretes_contributionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tranches_pretes_contributionsCountAggregateInputType | true
    _avg?: Tranches_pretes_contributionsAvgAggregateInputType
    _sum?: Tranches_pretes_contributionsSumAggregateInputType
    _min?: Tranches_pretes_contributionsMinAggregateInputType
    _max?: Tranches_pretes_contributionsMaxAggregateInputType
  }

  export type Tranches_pretes_contributionsGroupByOutputType = {
    ID: number
    ID_tranche: number
    ID_user: number
    dateajout: Date
    contribution: $Enums.tranches_pretes_contributions_contribution
    points_new: number
    points_total: number
    _count: Tranches_pretes_contributionsCountAggregateOutputType | null
    _avg: Tranches_pretes_contributionsAvgAggregateOutputType | null
    _sum: Tranches_pretes_contributionsSumAggregateOutputType | null
    _min: Tranches_pretes_contributionsMinAggregateOutputType | null
    _max: Tranches_pretes_contributionsMaxAggregateOutputType | null
  }

  type GetTranches_pretes_contributionsGroupByPayload<T extends tranches_pretes_contributionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tranches_pretes_contributionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tranches_pretes_contributionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tranches_pretes_contributionsGroupByOutputType[P]>
            : GetScalarType<T[P], Tranches_pretes_contributionsGroupByOutputType[P]>
        }
      >
    >


  export type tranches_pretes_contributionsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    ID_tranche?: boolean
    ID_user?: boolean
    dateajout?: boolean
    contribution?: boolean
    points_new?: boolean
    points_total?: boolean
  }, ExtArgs["result"]["tranches_pretes_contributions"]>

  export type tranches_pretes_contributionsSelectScalar = {
    ID?: boolean
    ID_tranche?: boolean
    ID_user?: boolean
    dateajout?: boolean
    contribution?: boolean
    points_new?: boolean
    points_total?: boolean
  }


  export type $tranches_pretes_contributionsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "tranches_pretes_contributions"
    objects: {}
    scalars: $Extensions.GetResult<{
      ID: number
      ID_tranche: number
      ID_user: number
      dateajout: Date
      contribution: $Enums.tranches_pretes_contributions_contribution
      points_new: number
      points_total: number
    }, ExtArgs["result"]["tranches_pretes_contributions"]>
    composites: {}
  }


  type tranches_pretes_contributionsGetPayload<S extends boolean | null | undefined | tranches_pretes_contributionsDefaultArgs> = $Result.GetResult<Prisma.$tranches_pretes_contributionsPayload, S>

  type tranches_pretes_contributionsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<tranches_pretes_contributionsFindManyArgs, 'select' | 'include'> & {
      select?: Tranches_pretes_contributionsCountAggregateInputType | true
    }

  export interface tranches_pretes_contributionsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tranches_pretes_contributions'], meta: { name: 'tranches_pretes_contributions' } }
    /**
     * Find zero or one Tranches_pretes_contributions that matches the filter.
     * @param {tranches_pretes_contributionsFindUniqueArgs} args - Arguments to find a Tranches_pretes_contributions
     * @example
     * // Get one Tranches_pretes_contributions
     * const tranches_pretes_contributions = await prisma.tranches_pretes_contributions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tranches_pretes_contributionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, tranches_pretes_contributionsFindUniqueArgs<ExtArgs>>
    ): Prisma__tranches_pretes_contributionsClient<$Result.GetResult<Prisma.$tranches_pretes_contributionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tranches_pretes_contributions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tranches_pretes_contributionsFindUniqueOrThrowArgs} args - Arguments to find a Tranches_pretes_contributions
     * @example
     * // Get one Tranches_pretes_contributions
     * const tranches_pretes_contributions = await prisma.tranches_pretes_contributions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tranches_pretes_contributionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tranches_pretes_contributionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__tranches_pretes_contributionsClient<$Result.GetResult<Prisma.$tranches_pretes_contributionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tranches_pretes_contributions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tranches_pretes_contributionsFindFirstArgs} args - Arguments to find a Tranches_pretes_contributions
     * @example
     * // Get one Tranches_pretes_contributions
     * const tranches_pretes_contributions = await prisma.tranches_pretes_contributions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tranches_pretes_contributionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, tranches_pretes_contributionsFindFirstArgs<ExtArgs>>
    ): Prisma__tranches_pretes_contributionsClient<$Result.GetResult<Prisma.$tranches_pretes_contributionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tranches_pretes_contributions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tranches_pretes_contributionsFindFirstOrThrowArgs} args - Arguments to find a Tranches_pretes_contributions
     * @example
     * // Get one Tranches_pretes_contributions
     * const tranches_pretes_contributions = await prisma.tranches_pretes_contributions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tranches_pretes_contributionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tranches_pretes_contributionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__tranches_pretes_contributionsClient<$Result.GetResult<Prisma.$tranches_pretes_contributionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tranches_pretes_contributions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tranches_pretes_contributionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tranches_pretes_contributions
     * const tranches_pretes_contributions = await prisma.tranches_pretes_contributions.findMany()
     * 
     * // Get first 10 Tranches_pretes_contributions
     * const tranches_pretes_contributions = await prisma.tranches_pretes_contributions.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const tranches_pretes_contributionsWithIDOnly = await prisma.tranches_pretes_contributions.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends tranches_pretes_contributionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tranches_pretes_contributionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tranches_pretes_contributionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tranches_pretes_contributions.
     * @param {tranches_pretes_contributionsCreateArgs} args - Arguments to create a Tranches_pretes_contributions.
     * @example
     * // Create one Tranches_pretes_contributions
     * const Tranches_pretes_contributions = await prisma.tranches_pretes_contributions.create({
     *   data: {
     *     // ... data to create a Tranches_pretes_contributions
     *   }
     * })
     * 
    **/
    create<T extends tranches_pretes_contributionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, tranches_pretes_contributionsCreateArgs<ExtArgs>>
    ): Prisma__tranches_pretes_contributionsClient<$Result.GetResult<Prisma.$tranches_pretes_contributionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tranches_pretes_contributions.
     *     @param {tranches_pretes_contributionsCreateManyArgs} args - Arguments to create many Tranches_pretes_contributions.
     *     @example
     *     // Create many Tranches_pretes_contributions
     *     const tranches_pretes_contributions = await prisma.tranches_pretes_contributions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tranches_pretes_contributionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tranches_pretes_contributionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tranches_pretes_contributions.
     * @param {tranches_pretes_contributionsDeleteArgs} args - Arguments to delete one Tranches_pretes_contributions.
     * @example
     * // Delete one Tranches_pretes_contributions
     * const Tranches_pretes_contributions = await prisma.tranches_pretes_contributions.delete({
     *   where: {
     *     // ... filter to delete one Tranches_pretes_contributions
     *   }
     * })
     * 
    **/
    delete<T extends tranches_pretes_contributionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, tranches_pretes_contributionsDeleteArgs<ExtArgs>>
    ): Prisma__tranches_pretes_contributionsClient<$Result.GetResult<Prisma.$tranches_pretes_contributionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tranches_pretes_contributions.
     * @param {tranches_pretes_contributionsUpdateArgs} args - Arguments to update one Tranches_pretes_contributions.
     * @example
     * // Update one Tranches_pretes_contributions
     * const tranches_pretes_contributions = await prisma.tranches_pretes_contributions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tranches_pretes_contributionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, tranches_pretes_contributionsUpdateArgs<ExtArgs>>
    ): Prisma__tranches_pretes_contributionsClient<$Result.GetResult<Prisma.$tranches_pretes_contributionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tranches_pretes_contributions.
     * @param {tranches_pretes_contributionsDeleteManyArgs} args - Arguments to filter Tranches_pretes_contributions to delete.
     * @example
     * // Delete a few Tranches_pretes_contributions
     * const { count } = await prisma.tranches_pretes_contributions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tranches_pretes_contributionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tranches_pretes_contributionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tranches_pretes_contributions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tranches_pretes_contributionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tranches_pretes_contributions
     * const tranches_pretes_contributions = await prisma.tranches_pretes_contributions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tranches_pretes_contributionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, tranches_pretes_contributionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tranches_pretes_contributions.
     * @param {tranches_pretes_contributionsUpsertArgs} args - Arguments to update or create a Tranches_pretes_contributions.
     * @example
     * // Update or create a Tranches_pretes_contributions
     * const tranches_pretes_contributions = await prisma.tranches_pretes_contributions.upsert({
     *   create: {
     *     // ... data to create a Tranches_pretes_contributions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tranches_pretes_contributions we want to update
     *   }
     * })
    **/
    upsert<T extends tranches_pretes_contributionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, tranches_pretes_contributionsUpsertArgs<ExtArgs>>
    ): Prisma__tranches_pretes_contributionsClient<$Result.GetResult<Prisma.$tranches_pretes_contributionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tranches_pretes_contributions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tranches_pretes_contributionsCountArgs} args - Arguments to filter Tranches_pretes_contributions to count.
     * @example
     * // Count the number of Tranches_pretes_contributions
     * const count = await prisma.tranches_pretes_contributions.count({
     *   where: {
     *     // ... the filter for the Tranches_pretes_contributions we want to count
     *   }
     * })
    **/
    count<T extends tranches_pretes_contributionsCountArgs>(
      args?: Subset<T, tranches_pretes_contributionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tranches_pretes_contributionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tranches_pretes_contributions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tranches_pretes_contributionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tranches_pretes_contributionsAggregateArgs>(args: Subset<T, Tranches_pretes_contributionsAggregateArgs>): Prisma.PrismaPromise<GetTranches_pretes_contributionsAggregateType<T>>

    /**
     * Group by Tranches_pretes_contributions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tranches_pretes_contributionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tranches_pretes_contributionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tranches_pretes_contributionsGroupByArgs['orderBy'] }
        : { orderBy?: tranches_pretes_contributionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tranches_pretes_contributionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTranches_pretes_contributionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tranches_pretes_contributions model
   */
  readonly fields: tranches_pretes_contributionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tranches_pretes_contributions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tranches_pretes_contributionsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the tranches_pretes_contributions model
   */ 
  interface tranches_pretes_contributionsFieldRefs {
    readonly ID: FieldRef<"tranches_pretes_contributions", 'Int'>
    readonly ID_tranche: FieldRef<"tranches_pretes_contributions", 'Int'>
    readonly ID_user: FieldRef<"tranches_pretes_contributions", 'Int'>
    readonly dateajout: FieldRef<"tranches_pretes_contributions", 'DateTime'>
    readonly contribution: FieldRef<"tranches_pretes_contributions", 'tranches_pretes_contributions_contribution'>
    readonly points_new: FieldRef<"tranches_pretes_contributions", 'Int'>
    readonly points_total: FieldRef<"tranches_pretes_contributions", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * tranches_pretes_contributions findUnique
   */
  export type tranches_pretes_contributionsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tranches_pretes_contributions
     */
    select?: tranches_pretes_contributionsSelect<ExtArgs> | null
    /**
     * Filter, which tranches_pretes_contributions to fetch.
     */
    where: tranches_pretes_contributionsWhereUniqueInput
  }


  /**
   * tranches_pretes_contributions findUniqueOrThrow
   */
  export type tranches_pretes_contributionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tranches_pretes_contributions
     */
    select?: tranches_pretes_contributionsSelect<ExtArgs> | null
    /**
     * Filter, which tranches_pretes_contributions to fetch.
     */
    where: tranches_pretes_contributionsWhereUniqueInput
  }


  /**
   * tranches_pretes_contributions findFirst
   */
  export type tranches_pretes_contributionsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tranches_pretes_contributions
     */
    select?: tranches_pretes_contributionsSelect<ExtArgs> | null
    /**
     * Filter, which tranches_pretes_contributions to fetch.
     */
    where?: tranches_pretes_contributionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tranches_pretes_contributions to fetch.
     */
    orderBy?: tranches_pretes_contributionsOrderByWithRelationInput | tranches_pretes_contributionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tranches_pretes_contributions.
     */
    cursor?: tranches_pretes_contributionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tranches_pretes_contributions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tranches_pretes_contributions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tranches_pretes_contributions.
     */
    distinct?: Tranches_pretes_contributionsScalarFieldEnum | Tranches_pretes_contributionsScalarFieldEnum[]
  }


  /**
   * tranches_pretes_contributions findFirstOrThrow
   */
  export type tranches_pretes_contributionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tranches_pretes_contributions
     */
    select?: tranches_pretes_contributionsSelect<ExtArgs> | null
    /**
     * Filter, which tranches_pretes_contributions to fetch.
     */
    where?: tranches_pretes_contributionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tranches_pretes_contributions to fetch.
     */
    orderBy?: tranches_pretes_contributionsOrderByWithRelationInput | tranches_pretes_contributionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tranches_pretes_contributions.
     */
    cursor?: tranches_pretes_contributionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tranches_pretes_contributions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tranches_pretes_contributions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tranches_pretes_contributions.
     */
    distinct?: Tranches_pretes_contributionsScalarFieldEnum | Tranches_pretes_contributionsScalarFieldEnum[]
  }


  /**
   * tranches_pretes_contributions findMany
   */
  export type tranches_pretes_contributionsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tranches_pretes_contributions
     */
    select?: tranches_pretes_contributionsSelect<ExtArgs> | null
    /**
     * Filter, which tranches_pretes_contributions to fetch.
     */
    where?: tranches_pretes_contributionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tranches_pretes_contributions to fetch.
     */
    orderBy?: tranches_pretes_contributionsOrderByWithRelationInput | tranches_pretes_contributionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tranches_pretes_contributions.
     */
    cursor?: tranches_pretes_contributionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tranches_pretes_contributions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tranches_pretes_contributions.
     */
    skip?: number
    distinct?: Tranches_pretes_contributionsScalarFieldEnum | Tranches_pretes_contributionsScalarFieldEnum[]
  }


  /**
   * tranches_pretes_contributions create
   */
  export type tranches_pretes_contributionsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tranches_pretes_contributions
     */
    select?: tranches_pretes_contributionsSelect<ExtArgs> | null
    /**
     * The data needed to create a tranches_pretes_contributions.
     */
    data: XOR<tranches_pretes_contributionsCreateInput, tranches_pretes_contributionsUncheckedCreateInput>
  }


  /**
   * tranches_pretes_contributions createMany
   */
  export type tranches_pretes_contributionsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tranches_pretes_contributions.
     */
    data: tranches_pretes_contributionsCreateManyInput | tranches_pretes_contributionsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * tranches_pretes_contributions update
   */
  export type tranches_pretes_contributionsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tranches_pretes_contributions
     */
    select?: tranches_pretes_contributionsSelect<ExtArgs> | null
    /**
     * The data needed to update a tranches_pretes_contributions.
     */
    data: XOR<tranches_pretes_contributionsUpdateInput, tranches_pretes_contributionsUncheckedUpdateInput>
    /**
     * Choose, which tranches_pretes_contributions to update.
     */
    where: tranches_pretes_contributionsWhereUniqueInput
  }


  /**
   * tranches_pretes_contributions updateMany
   */
  export type tranches_pretes_contributionsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tranches_pretes_contributions.
     */
    data: XOR<tranches_pretes_contributionsUpdateManyMutationInput, tranches_pretes_contributionsUncheckedUpdateManyInput>
    /**
     * Filter which tranches_pretes_contributions to update
     */
    where?: tranches_pretes_contributionsWhereInput
  }


  /**
   * tranches_pretes_contributions upsert
   */
  export type tranches_pretes_contributionsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tranches_pretes_contributions
     */
    select?: tranches_pretes_contributionsSelect<ExtArgs> | null
    /**
     * The filter to search for the tranches_pretes_contributions to update in case it exists.
     */
    where: tranches_pretes_contributionsWhereUniqueInput
    /**
     * In case the tranches_pretes_contributions found by the `where` argument doesn't exist, create a new tranches_pretes_contributions with this data.
     */
    create: XOR<tranches_pretes_contributionsCreateInput, tranches_pretes_contributionsUncheckedCreateInput>
    /**
     * In case the tranches_pretes_contributions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tranches_pretes_contributionsUpdateInput, tranches_pretes_contributionsUncheckedUpdateInput>
  }


  /**
   * tranches_pretes_contributions delete
   */
  export type tranches_pretes_contributionsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tranches_pretes_contributions
     */
    select?: tranches_pretes_contributionsSelect<ExtArgs> | null
    /**
     * Filter which tranches_pretes_contributions to delete.
     */
    where: tranches_pretes_contributionsWhereUniqueInput
  }


  /**
   * tranches_pretes_contributions deleteMany
   */
  export type tranches_pretes_contributionsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which tranches_pretes_contributions to delete
     */
    where?: tranches_pretes_contributionsWhereInput
  }


  /**
   * tranches_pretes_contributions without action
   */
  export type tranches_pretes_contributionsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tranches_pretes_contributions
     */
    select?: tranches_pretes_contributionsSelect<ExtArgs> | null
  }



  /**
   * Model edgeSprite
   */

  export type AggregateEdgeSprite = {
    _count: EdgeSpriteCountAggregateOutputType | null
    _avg: EdgeSpriteAvgAggregateOutputType | null
    _sum: EdgeSpriteSumAggregateOutputType | null
    _min: EdgeSpriteMinAggregateOutputType | null
    _max: EdgeSpriteMaxAggregateOutputType | null
  }

  export type EdgeSpriteAvgAggregateOutputType = {
    id: number | null
    edgeId: number | null
    spriteSize: number | null
  }

  export type EdgeSpriteSumAggregateOutputType = {
    id: number | null
    edgeId: number | null
    spriteSize: number | null
  }

  export type EdgeSpriteMinAggregateOutputType = {
    id: number | null
    edgeId: number | null
    spriteName: string | null
    spriteSize: number | null
  }

  export type EdgeSpriteMaxAggregateOutputType = {
    id: number | null
    edgeId: number | null
    spriteName: string | null
    spriteSize: number | null
  }

  export type EdgeSpriteCountAggregateOutputType = {
    id: number
    edgeId: number
    spriteName: number
    spriteSize: number
    _all: number
  }


  export type EdgeSpriteAvgAggregateInputType = {
    id?: true
    edgeId?: true
    spriteSize?: true
  }

  export type EdgeSpriteSumAggregateInputType = {
    id?: true
    edgeId?: true
    spriteSize?: true
  }

  export type EdgeSpriteMinAggregateInputType = {
    id?: true
    edgeId?: true
    spriteName?: true
    spriteSize?: true
  }

  export type EdgeSpriteMaxAggregateInputType = {
    id?: true
    edgeId?: true
    spriteName?: true
    spriteSize?: true
  }

  export type EdgeSpriteCountAggregateInputType = {
    id?: true
    edgeId?: true
    spriteName?: true
    spriteSize?: true
    _all?: true
  }

  export type EdgeSpriteAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which edgeSprite to aggregate.
     */
    where?: edgeSpriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of edgeSprites to fetch.
     */
    orderBy?: edgeSpriteOrderByWithRelationInput | edgeSpriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: edgeSpriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` edgeSprites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` edgeSprites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned edgeSprites
    **/
    _count?: true | EdgeSpriteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EdgeSpriteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EdgeSpriteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EdgeSpriteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EdgeSpriteMaxAggregateInputType
  }

  export type GetEdgeSpriteAggregateType<T extends EdgeSpriteAggregateArgs> = {
        [P in keyof T & keyof AggregateEdgeSprite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEdgeSprite[P]>
      : GetScalarType<T[P], AggregateEdgeSprite[P]>
  }




  export type edgeSpriteGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: edgeSpriteWhereInput
    orderBy?: edgeSpriteOrderByWithAggregationInput | edgeSpriteOrderByWithAggregationInput[]
    by: EdgeSpriteScalarFieldEnum[] | EdgeSpriteScalarFieldEnum
    having?: edgeSpriteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EdgeSpriteCountAggregateInputType | true
    _avg?: EdgeSpriteAvgAggregateInputType
    _sum?: EdgeSpriteSumAggregateInputType
    _min?: EdgeSpriteMinAggregateInputType
    _max?: EdgeSpriteMaxAggregateInputType
  }

  export type EdgeSpriteGroupByOutputType = {
    id: number
    edgeId: number
    spriteName: string
    spriteSize: number | null
    _count: EdgeSpriteCountAggregateOutputType | null
    _avg: EdgeSpriteAvgAggregateOutputType | null
    _sum: EdgeSpriteSumAggregateOutputType | null
    _min: EdgeSpriteMinAggregateOutputType | null
    _max: EdgeSpriteMaxAggregateOutputType | null
  }

  type GetEdgeSpriteGroupByPayload<T extends edgeSpriteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EdgeSpriteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EdgeSpriteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EdgeSpriteGroupByOutputType[P]>
            : GetScalarType<T[P], EdgeSpriteGroupByOutputType[P]>
        }
      >
    >


  export type edgeSpriteSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    edgeId?: boolean
    spriteName?: boolean
    spriteSize?: boolean
  }, ExtArgs["result"]["edgeSprite"]>

  export type edgeSpriteSelectScalar = {
    id?: boolean
    edgeId?: boolean
    spriteName?: boolean
    spriteSize?: boolean
  }


  export type $edgeSpritePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "edgeSprite"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: number
      edgeId: number
      spriteName: string
      spriteSize: number | null
    }, ExtArgs["result"]["edgeSprite"]>
    composites: {}
  }


  type edgeSpriteGetPayload<S extends boolean | null | undefined | edgeSpriteDefaultArgs> = $Result.GetResult<Prisma.$edgeSpritePayload, S>

  type edgeSpriteCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<edgeSpriteFindManyArgs, 'select' | 'include'> & {
      select?: EdgeSpriteCountAggregateInputType | true
    }

  export interface edgeSpriteDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['edgeSprite'], meta: { name: 'edgeSprite' } }
    /**
     * Find zero or one EdgeSprite that matches the filter.
     * @param {edgeSpriteFindUniqueArgs} args - Arguments to find a EdgeSprite
     * @example
     * // Get one EdgeSprite
     * const edgeSprite = await prisma.edgeSprite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends edgeSpriteFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, edgeSpriteFindUniqueArgs<ExtArgs>>
    ): Prisma__edgeSpriteClient<$Result.GetResult<Prisma.$edgeSpritePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EdgeSprite that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {edgeSpriteFindUniqueOrThrowArgs} args - Arguments to find a EdgeSprite
     * @example
     * // Get one EdgeSprite
     * const edgeSprite = await prisma.edgeSprite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends edgeSpriteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, edgeSpriteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__edgeSpriteClient<$Result.GetResult<Prisma.$edgeSpritePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EdgeSprite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edgeSpriteFindFirstArgs} args - Arguments to find a EdgeSprite
     * @example
     * // Get one EdgeSprite
     * const edgeSprite = await prisma.edgeSprite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends edgeSpriteFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, edgeSpriteFindFirstArgs<ExtArgs>>
    ): Prisma__edgeSpriteClient<$Result.GetResult<Prisma.$edgeSpritePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EdgeSprite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edgeSpriteFindFirstOrThrowArgs} args - Arguments to find a EdgeSprite
     * @example
     * // Get one EdgeSprite
     * const edgeSprite = await prisma.edgeSprite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends edgeSpriteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, edgeSpriteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__edgeSpriteClient<$Result.GetResult<Prisma.$edgeSpritePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EdgeSprites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edgeSpriteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EdgeSprites
     * const edgeSprites = await prisma.edgeSprite.findMany()
     * 
     * // Get first 10 EdgeSprites
     * const edgeSprites = await prisma.edgeSprite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const edgeSpriteWithIdOnly = await prisma.edgeSprite.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends edgeSpriteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, edgeSpriteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$edgeSpritePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EdgeSprite.
     * @param {edgeSpriteCreateArgs} args - Arguments to create a EdgeSprite.
     * @example
     * // Create one EdgeSprite
     * const EdgeSprite = await prisma.edgeSprite.create({
     *   data: {
     *     // ... data to create a EdgeSprite
     *   }
     * })
     * 
    **/
    create<T extends edgeSpriteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, edgeSpriteCreateArgs<ExtArgs>>
    ): Prisma__edgeSpriteClient<$Result.GetResult<Prisma.$edgeSpritePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EdgeSprites.
     *     @param {edgeSpriteCreateManyArgs} args - Arguments to create many EdgeSprites.
     *     @example
     *     // Create many EdgeSprites
     *     const edgeSprite = await prisma.edgeSprite.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends edgeSpriteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, edgeSpriteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EdgeSprite.
     * @param {edgeSpriteDeleteArgs} args - Arguments to delete one EdgeSprite.
     * @example
     * // Delete one EdgeSprite
     * const EdgeSprite = await prisma.edgeSprite.delete({
     *   where: {
     *     // ... filter to delete one EdgeSprite
     *   }
     * })
     * 
    **/
    delete<T extends edgeSpriteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, edgeSpriteDeleteArgs<ExtArgs>>
    ): Prisma__edgeSpriteClient<$Result.GetResult<Prisma.$edgeSpritePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EdgeSprite.
     * @param {edgeSpriteUpdateArgs} args - Arguments to update one EdgeSprite.
     * @example
     * // Update one EdgeSprite
     * const edgeSprite = await prisma.edgeSprite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends edgeSpriteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, edgeSpriteUpdateArgs<ExtArgs>>
    ): Prisma__edgeSpriteClient<$Result.GetResult<Prisma.$edgeSpritePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EdgeSprites.
     * @param {edgeSpriteDeleteManyArgs} args - Arguments to filter EdgeSprites to delete.
     * @example
     * // Delete a few EdgeSprites
     * const { count } = await prisma.edgeSprite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends edgeSpriteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, edgeSpriteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EdgeSprites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edgeSpriteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EdgeSprites
     * const edgeSprite = await prisma.edgeSprite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends edgeSpriteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, edgeSpriteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EdgeSprite.
     * @param {edgeSpriteUpsertArgs} args - Arguments to update or create a EdgeSprite.
     * @example
     * // Update or create a EdgeSprite
     * const edgeSprite = await prisma.edgeSprite.upsert({
     *   create: {
     *     // ... data to create a EdgeSprite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EdgeSprite we want to update
     *   }
     * })
    **/
    upsert<T extends edgeSpriteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, edgeSpriteUpsertArgs<ExtArgs>>
    ): Prisma__edgeSpriteClient<$Result.GetResult<Prisma.$edgeSpritePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EdgeSprites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edgeSpriteCountArgs} args - Arguments to filter EdgeSprites to count.
     * @example
     * // Count the number of EdgeSprites
     * const count = await prisma.edgeSprite.count({
     *   where: {
     *     // ... the filter for the EdgeSprites we want to count
     *   }
     * })
    **/
    count<T extends edgeSpriteCountArgs>(
      args?: Subset<T, edgeSpriteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EdgeSpriteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EdgeSprite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EdgeSpriteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EdgeSpriteAggregateArgs>(args: Subset<T, EdgeSpriteAggregateArgs>): Prisma.PrismaPromise<GetEdgeSpriteAggregateType<T>>

    /**
     * Group by EdgeSprite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edgeSpriteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends edgeSpriteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: edgeSpriteGroupByArgs['orderBy'] }
        : { orderBy?: edgeSpriteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, edgeSpriteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEdgeSpriteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the edgeSprite model
   */
  readonly fields: edgeSpriteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for edgeSprite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__edgeSpriteClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the edgeSprite model
   */ 
  interface edgeSpriteFieldRefs {
    readonly id: FieldRef<"edgeSprite", 'Int'>
    readonly edgeId: FieldRef<"edgeSprite", 'Int'>
    readonly spriteName: FieldRef<"edgeSprite", 'String'>
    readonly spriteSize: FieldRef<"edgeSprite", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * edgeSprite findUnique
   */
  export type edgeSpriteFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edgeSprite
     */
    select?: edgeSpriteSelect<ExtArgs> | null
    /**
     * Filter, which edgeSprite to fetch.
     */
    where: edgeSpriteWhereUniqueInput
  }


  /**
   * edgeSprite findUniqueOrThrow
   */
  export type edgeSpriteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edgeSprite
     */
    select?: edgeSpriteSelect<ExtArgs> | null
    /**
     * Filter, which edgeSprite to fetch.
     */
    where: edgeSpriteWhereUniqueInput
  }


  /**
   * edgeSprite findFirst
   */
  export type edgeSpriteFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edgeSprite
     */
    select?: edgeSpriteSelect<ExtArgs> | null
    /**
     * Filter, which edgeSprite to fetch.
     */
    where?: edgeSpriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of edgeSprites to fetch.
     */
    orderBy?: edgeSpriteOrderByWithRelationInput | edgeSpriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for edgeSprites.
     */
    cursor?: edgeSpriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` edgeSprites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` edgeSprites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of edgeSprites.
     */
    distinct?: EdgeSpriteScalarFieldEnum | EdgeSpriteScalarFieldEnum[]
  }


  /**
   * edgeSprite findFirstOrThrow
   */
  export type edgeSpriteFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edgeSprite
     */
    select?: edgeSpriteSelect<ExtArgs> | null
    /**
     * Filter, which edgeSprite to fetch.
     */
    where?: edgeSpriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of edgeSprites to fetch.
     */
    orderBy?: edgeSpriteOrderByWithRelationInput | edgeSpriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for edgeSprites.
     */
    cursor?: edgeSpriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` edgeSprites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` edgeSprites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of edgeSprites.
     */
    distinct?: EdgeSpriteScalarFieldEnum | EdgeSpriteScalarFieldEnum[]
  }


  /**
   * edgeSprite findMany
   */
  export type edgeSpriteFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edgeSprite
     */
    select?: edgeSpriteSelect<ExtArgs> | null
    /**
     * Filter, which edgeSprites to fetch.
     */
    where?: edgeSpriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of edgeSprites to fetch.
     */
    orderBy?: edgeSpriteOrderByWithRelationInput | edgeSpriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing edgeSprites.
     */
    cursor?: edgeSpriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` edgeSprites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` edgeSprites.
     */
    skip?: number
    distinct?: EdgeSpriteScalarFieldEnum | EdgeSpriteScalarFieldEnum[]
  }


  /**
   * edgeSprite create
   */
  export type edgeSpriteCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edgeSprite
     */
    select?: edgeSpriteSelect<ExtArgs> | null
    /**
     * The data needed to create a edgeSprite.
     */
    data: XOR<edgeSpriteCreateInput, edgeSpriteUncheckedCreateInput>
  }


  /**
   * edgeSprite createMany
   */
  export type edgeSpriteCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many edgeSprites.
     */
    data: edgeSpriteCreateManyInput | edgeSpriteCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * edgeSprite update
   */
  export type edgeSpriteUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edgeSprite
     */
    select?: edgeSpriteSelect<ExtArgs> | null
    /**
     * The data needed to update a edgeSprite.
     */
    data: XOR<edgeSpriteUpdateInput, edgeSpriteUncheckedUpdateInput>
    /**
     * Choose, which edgeSprite to update.
     */
    where: edgeSpriteWhereUniqueInput
  }


  /**
   * edgeSprite updateMany
   */
  export type edgeSpriteUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update edgeSprites.
     */
    data: XOR<edgeSpriteUpdateManyMutationInput, edgeSpriteUncheckedUpdateManyInput>
    /**
     * Filter which edgeSprites to update
     */
    where?: edgeSpriteWhereInput
  }


  /**
   * edgeSprite upsert
   */
  export type edgeSpriteUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edgeSprite
     */
    select?: edgeSpriteSelect<ExtArgs> | null
    /**
     * The filter to search for the edgeSprite to update in case it exists.
     */
    where: edgeSpriteWhereUniqueInput
    /**
     * In case the edgeSprite found by the `where` argument doesn't exist, create a new edgeSprite with this data.
     */
    create: XOR<edgeSpriteCreateInput, edgeSpriteUncheckedCreateInput>
    /**
     * In case the edgeSprite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<edgeSpriteUpdateInput, edgeSpriteUncheckedUpdateInput>
  }


  /**
   * edgeSprite delete
   */
  export type edgeSpriteDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edgeSprite
     */
    select?: edgeSpriteSelect<ExtArgs> | null
    /**
     * Filter which edgeSprite to delete.
     */
    where: edgeSpriteWhereUniqueInput
  }


  /**
   * edgeSprite deleteMany
   */
  export type edgeSpriteDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which edgeSprites to delete
     */
    where?: edgeSpriteWhereInput
  }


  /**
   * edgeSprite without action
   */
  export type edgeSpriteDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edgeSprite
     */
    select?: edgeSpriteSelect<ExtArgs> | null
  }



  /**
   * Model edgeSpriteSize
   */

  export type AggregateEdgeSpriteSize = {
    _count: EdgeSpriteSizeCountAggregateOutputType | null
    _avg: EdgeSpriteSizeAvgAggregateOutputType | null
    _sum: EdgeSpriteSizeSumAggregateOutputType | null
    _min: EdgeSpriteSizeMinAggregateOutputType | null
    _max: EdgeSpriteSizeMaxAggregateOutputType | null
  }

  export type EdgeSpriteSizeAvgAggregateOutputType = {
    id: number | null
    size: number | null
  }

  export type EdgeSpriteSizeSumAggregateOutputType = {
    id: number | null
    size: number | null
  }

  export type EdgeSpriteSizeMinAggregateOutputType = {
    id: number | null
    spriteName: string | null
    size: number | null
  }

  export type EdgeSpriteSizeMaxAggregateOutputType = {
    id: number | null
    spriteName: string | null
    size: number | null
  }

  export type EdgeSpriteSizeCountAggregateOutputType = {
    id: number
    spriteName: number
    size: number
    _all: number
  }


  export type EdgeSpriteSizeAvgAggregateInputType = {
    id?: true
    size?: true
  }

  export type EdgeSpriteSizeSumAggregateInputType = {
    id?: true
    size?: true
  }

  export type EdgeSpriteSizeMinAggregateInputType = {
    id?: true
    spriteName?: true
    size?: true
  }

  export type EdgeSpriteSizeMaxAggregateInputType = {
    id?: true
    spriteName?: true
    size?: true
  }

  export type EdgeSpriteSizeCountAggregateInputType = {
    id?: true
    spriteName?: true
    size?: true
    _all?: true
  }

  export type EdgeSpriteSizeAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which edgeSpriteSize to aggregate.
     */
    where?: edgeSpriteSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of edgeSpriteSizes to fetch.
     */
    orderBy?: edgeSpriteSizeOrderByWithRelationInput | edgeSpriteSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: edgeSpriteSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` edgeSpriteSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` edgeSpriteSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned edgeSpriteSizes
    **/
    _count?: true | EdgeSpriteSizeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EdgeSpriteSizeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EdgeSpriteSizeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EdgeSpriteSizeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EdgeSpriteSizeMaxAggregateInputType
  }

  export type GetEdgeSpriteSizeAggregateType<T extends EdgeSpriteSizeAggregateArgs> = {
        [P in keyof T & keyof AggregateEdgeSpriteSize]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEdgeSpriteSize[P]>
      : GetScalarType<T[P], AggregateEdgeSpriteSize[P]>
  }




  export type edgeSpriteSizeGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: edgeSpriteSizeWhereInput
    orderBy?: edgeSpriteSizeOrderByWithAggregationInput | edgeSpriteSizeOrderByWithAggregationInput[]
    by: EdgeSpriteSizeScalarFieldEnum[] | EdgeSpriteSizeScalarFieldEnum
    having?: edgeSpriteSizeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EdgeSpriteSizeCountAggregateInputType | true
    _avg?: EdgeSpriteSizeAvgAggregateInputType
    _sum?: EdgeSpriteSizeSumAggregateInputType
    _min?: EdgeSpriteSizeMinAggregateInputType
    _max?: EdgeSpriteSizeMaxAggregateInputType
  }

  export type EdgeSpriteSizeGroupByOutputType = {
    id: number
    spriteName: string | null
    size: number | null
    _count: EdgeSpriteSizeCountAggregateOutputType | null
    _avg: EdgeSpriteSizeAvgAggregateOutputType | null
    _sum: EdgeSpriteSizeSumAggregateOutputType | null
    _min: EdgeSpriteSizeMinAggregateOutputType | null
    _max: EdgeSpriteSizeMaxAggregateOutputType | null
  }

  type GetEdgeSpriteSizeGroupByPayload<T extends edgeSpriteSizeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EdgeSpriteSizeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EdgeSpriteSizeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EdgeSpriteSizeGroupByOutputType[P]>
            : GetScalarType<T[P], EdgeSpriteSizeGroupByOutputType[P]>
        }
      >
    >


  export type edgeSpriteSizeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    spriteName?: boolean
    size?: boolean
  }, ExtArgs["result"]["edgeSpriteSize"]>

  export type edgeSpriteSizeSelectScalar = {
    id?: boolean
    spriteName?: boolean
    size?: boolean
  }


  export type $edgeSpriteSizePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "edgeSpriteSize"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: number
      spriteName: string | null
      size: number | null
    }, ExtArgs["result"]["edgeSpriteSize"]>
    composites: {}
  }


  type edgeSpriteSizeGetPayload<S extends boolean | null | undefined | edgeSpriteSizeDefaultArgs> = $Result.GetResult<Prisma.$edgeSpriteSizePayload, S>

  type edgeSpriteSizeCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<edgeSpriteSizeFindManyArgs, 'select' | 'include'> & {
      select?: EdgeSpriteSizeCountAggregateInputType | true
    }

  export interface edgeSpriteSizeDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['edgeSpriteSize'], meta: { name: 'edgeSpriteSize' } }
    /**
     * Find zero or one EdgeSpriteSize that matches the filter.
     * @param {edgeSpriteSizeFindUniqueArgs} args - Arguments to find a EdgeSpriteSize
     * @example
     * // Get one EdgeSpriteSize
     * const edgeSpriteSize = await prisma.edgeSpriteSize.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends edgeSpriteSizeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, edgeSpriteSizeFindUniqueArgs<ExtArgs>>
    ): Prisma__edgeSpriteSizeClient<$Result.GetResult<Prisma.$edgeSpriteSizePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EdgeSpriteSize that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {edgeSpriteSizeFindUniqueOrThrowArgs} args - Arguments to find a EdgeSpriteSize
     * @example
     * // Get one EdgeSpriteSize
     * const edgeSpriteSize = await prisma.edgeSpriteSize.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends edgeSpriteSizeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, edgeSpriteSizeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__edgeSpriteSizeClient<$Result.GetResult<Prisma.$edgeSpriteSizePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EdgeSpriteSize that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edgeSpriteSizeFindFirstArgs} args - Arguments to find a EdgeSpriteSize
     * @example
     * // Get one EdgeSpriteSize
     * const edgeSpriteSize = await prisma.edgeSpriteSize.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends edgeSpriteSizeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, edgeSpriteSizeFindFirstArgs<ExtArgs>>
    ): Prisma__edgeSpriteSizeClient<$Result.GetResult<Prisma.$edgeSpriteSizePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EdgeSpriteSize that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edgeSpriteSizeFindFirstOrThrowArgs} args - Arguments to find a EdgeSpriteSize
     * @example
     * // Get one EdgeSpriteSize
     * const edgeSpriteSize = await prisma.edgeSpriteSize.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends edgeSpriteSizeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, edgeSpriteSizeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__edgeSpriteSizeClient<$Result.GetResult<Prisma.$edgeSpriteSizePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EdgeSpriteSizes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edgeSpriteSizeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EdgeSpriteSizes
     * const edgeSpriteSizes = await prisma.edgeSpriteSize.findMany()
     * 
     * // Get first 10 EdgeSpriteSizes
     * const edgeSpriteSizes = await prisma.edgeSpriteSize.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const edgeSpriteSizeWithIdOnly = await prisma.edgeSpriteSize.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends edgeSpriteSizeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, edgeSpriteSizeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$edgeSpriteSizePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EdgeSpriteSize.
     * @param {edgeSpriteSizeCreateArgs} args - Arguments to create a EdgeSpriteSize.
     * @example
     * // Create one EdgeSpriteSize
     * const EdgeSpriteSize = await prisma.edgeSpriteSize.create({
     *   data: {
     *     // ... data to create a EdgeSpriteSize
     *   }
     * })
     * 
    **/
    create<T extends edgeSpriteSizeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, edgeSpriteSizeCreateArgs<ExtArgs>>
    ): Prisma__edgeSpriteSizeClient<$Result.GetResult<Prisma.$edgeSpriteSizePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EdgeSpriteSizes.
     *     @param {edgeSpriteSizeCreateManyArgs} args - Arguments to create many EdgeSpriteSizes.
     *     @example
     *     // Create many EdgeSpriteSizes
     *     const edgeSpriteSize = await prisma.edgeSpriteSize.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends edgeSpriteSizeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, edgeSpriteSizeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EdgeSpriteSize.
     * @param {edgeSpriteSizeDeleteArgs} args - Arguments to delete one EdgeSpriteSize.
     * @example
     * // Delete one EdgeSpriteSize
     * const EdgeSpriteSize = await prisma.edgeSpriteSize.delete({
     *   where: {
     *     // ... filter to delete one EdgeSpriteSize
     *   }
     * })
     * 
    **/
    delete<T extends edgeSpriteSizeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, edgeSpriteSizeDeleteArgs<ExtArgs>>
    ): Prisma__edgeSpriteSizeClient<$Result.GetResult<Prisma.$edgeSpriteSizePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EdgeSpriteSize.
     * @param {edgeSpriteSizeUpdateArgs} args - Arguments to update one EdgeSpriteSize.
     * @example
     * // Update one EdgeSpriteSize
     * const edgeSpriteSize = await prisma.edgeSpriteSize.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends edgeSpriteSizeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, edgeSpriteSizeUpdateArgs<ExtArgs>>
    ): Prisma__edgeSpriteSizeClient<$Result.GetResult<Prisma.$edgeSpriteSizePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EdgeSpriteSizes.
     * @param {edgeSpriteSizeDeleteManyArgs} args - Arguments to filter EdgeSpriteSizes to delete.
     * @example
     * // Delete a few EdgeSpriteSizes
     * const { count } = await prisma.edgeSpriteSize.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends edgeSpriteSizeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, edgeSpriteSizeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EdgeSpriteSizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edgeSpriteSizeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EdgeSpriteSizes
     * const edgeSpriteSize = await prisma.edgeSpriteSize.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends edgeSpriteSizeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, edgeSpriteSizeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EdgeSpriteSize.
     * @param {edgeSpriteSizeUpsertArgs} args - Arguments to update or create a EdgeSpriteSize.
     * @example
     * // Update or create a EdgeSpriteSize
     * const edgeSpriteSize = await prisma.edgeSpriteSize.upsert({
     *   create: {
     *     // ... data to create a EdgeSpriteSize
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EdgeSpriteSize we want to update
     *   }
     * })
    **/
    upsert<T extends edgeSpriteSizeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, edgeSpriteSizeUpsertArgs<ExtArgs>>
    ): Prisma__edgeSpriteSizeClient<$Result.GetResult<Prisma.$edgeSpriteSizePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EdgeSpriteSizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edgeSpriteSizeCountArgs} args - Arguments to filter EdgeSpriteSizes to count.
     * @example
     * // Count the number of EdgeSpriteSizes
     * const count = await prisma.edgeSpriteSize.count({
     *   where: {
     *     // ... the filter for the EdgeSpriteSizes we want to count
     *   }
     * })
    **/
    count<T extends edgeSpriteSizeCountArgs>(
      args?: Subset<T, edgeSpriteSizeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EdgeSpriteSizeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EdgeSpriteSize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EdgeSpriteSizeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EdgeSpriteSizeAggregateArgs>(args: Subset<T, EdgeSpriteSizeAggregateArgs>): Prisma.PrismaPromise<GetEdgeSpriteSizeAggregateType<T>>

    /**
     * Group by EdgeSpriteSize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edgeSpriteSizeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends edgeSpriteSizeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: edgeSpriteSizeGroupByArgs['orderBy'] }
        : { orderBy?: edgeSpriteSizeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, edgeSpriteSizeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEdgeSpriteSizeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the edgeSpriteSize model
   */
  readonly fields: edgeSpriteSizeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for edgeSpriteSize.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__edgeSpriteSizeClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the edgeSpriteSize model
   */ 
  interface edgeSpriteSizeFieldRefs {
    readonly id: FieldRef<"edgeSpriteSize", 'Int'>
    readonly spriteName: FieldRef<"edgeSpriteSize", 'String'>
    readonly size: FieldRef<"edgeSpriteSize", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * edgeSpriteSize findUnique
   */
  export type edgeSpriteSizeFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edgeSpriteSize
     */
    select?: edgeSpriteSizeSelect<ExtArgs> | null
    /**
     * Filter, which edgeSpriteSize to fetch.
     */
    where: edgeSpriteSizeWhereUniqueInput
  }


  /**
   * edgeSpriteSize findUniqueOrThrow
   */
  export type edgeSpriteSizeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edgeSpriteSize
     */
    select?: edgeSpriteSizeSelect<ExtArgs> | null
    /**
     * Filter, which edgeSpriteSize to fetch.
     */
    where: edgeSpriteSizeWhereUniqueInput
  }


  /**
   * edgeSpriteSize findFirst
   */
  export type edgeSpriteSizeFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edgeSpriteSize
     */
    select?: edgeSpriteSizeSelect<ExtArgs> | null
    /**
     * Filter, which edgeSpriteSize to fetch.
     */
    where?: edgeSpriteSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of edgeSpriteSizes to fetch.
     */
    orderBy?: edgeSpriteSizeOrderByWithRelationInput | edgeSpriteSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for edgeSpriteSizes.
     */
    cursor?: edgeSpriteSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` edgeSpriteSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` edgeSpriteSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of edgeSpriteSizes.
     */
    distinct?: EdgeSpriteSizeScalarFieldEnum | EdgeSpriteSizeScalarFieldEnum[]
  }


  /**
   * edgeSpriteSize findFirstOrThrow
   */
  export type edgeSpriteSizeFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edgeSpriteSize
     */
    select?: edgeSpriteSizeSelect<ExtArgs> | null
    /**
     * Filter, which edgeSpriteSize to fetch.
     */
    where?: edgeSpriteSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of edgeSpriteSizes to fetch.
     */
    orderBy?: edgeSpriteSizeOrderByWithRelationInput | edgeSpriteSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for edgeSpriteSizes.
     */
    cursor?: edgeSpriteSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` edgeSpriteSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` edgeSpriteSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of edgeSpriteSizes.
     */
    distinct?: EdgeSpriteSizeScalarFieldEnum | EdgeSpriteSizeScalarFieldEnum[]
  }


  /**
   * edgeSpriteSize findMany
   */
  export type edgeSpriteSizeFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edgeSpriteSize
     */
    select?: edgeSpriteSizeSelect<ExtArgs> | null
    /**
     * Filter, which edgeSpriteSizes to fetch.
     */
    where?: edgeSpriteSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of edgeSpriteSizes to fetch.
     */
    orderBy?: edgeSpriteSizeOrderByWithRelationInput | edgeSpriteSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing edgeSpriteSizes.
     */
    cursor?: edgeSpriteSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` edgeSpriteSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` edgeSpriteSizes.
     */
    skip?: number
    distinct?: EdgeSpriteSizeScalarFieldEnum | EdgeSpriteSizeScalarFieldEnum[]
  }


  /**
   * edgeSpriteSize create
   */
  export type edgeSpriteSizeCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edgeSpriteSize
     */
    select?: edgeSpriteSizeSelect<ExtArgs> | null
    /**
     * The data needed to create a edgeSpriteSize.
     */
    data?: XOR<edgeSpriteSizeCreateInput, edgeSpriteSizeUncheckedCreateInput>
  }


  /**
   * edgeSpriteSize createMany
   */
  export type edgeSpriteSizeCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many edgeSpriteSizes.
     */
    data: edgeSpriteSizeCreateManyInput | edgeSpriteSizeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * edgeSpriteSize update
   */
  export type edgeSpriteSizeUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edgeSpriteSize
     */
    select?: edgeSpriteSizeSelect<ExtArgs> | null
    /**
     * The data needed to update a edgeSpriteSize.
     */
    data: XOR<edgeSpriteSizeUpdateInput, edgeSpriteSizeUncheckedUpdateInput>
    /**
     * Choose, which edgeSpriteSize to update.
     */
    where: edgeSpriteSizeWhereUniqueInput
  }


  /**
   * edgeSpriteSize updateMany
   */
  export type edgeSpriteSizeUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update edgeSpriteSizes.
     */
    data: XOR<edgeSpriteSizeUpdateManyMutationInput, edgeSpriteSizeUncheckedUpdateManyInput>
    /**
     * Filter which edgeSpriteSizes to update
     */
    where?: edgeSpriteSizeWhereInput
  }


  /**
   * edgeSpriteSize upsert
   */
  export type edgeSpriteSizeUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edgeSpriteSize
     */
    select?: edgeSpriteSizeSelect<ExtArgs> | null
    /**
     * The filter to search for the edgeSpriteSize to update in case it exists.
     */
    where: edgeSpriteSizeWhereUniqueInput
    /**
     * In case the edgeSpriteSize found by the `where` argument doesn't exist, create a new edgeSpriteSize with this data.
     */
    create: XOR<edgeSpriteSizeCreateInput, edgeSpriteSizeUncheckedCreateInput>
    /**
     * In case the edgeSpriteSize was found with the provided `where` argument, update it with this data.
     */
    update: XOR<edgeSpriteSizeUpdateInput, edgeSpriteSizeUncheckedUpdateInput>
  }


  /**
   * edgeSpriteSize delete
   */
  export type edgeSpriteSizeDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edgeSpriteSize
     */
    select?: edgeSpriteSizeSelect<ExtArgs> | null
    /**
     * Filter which edgeSpriteSize to delete.
     */
    where: edgeSpriteSizeWhereUniqueInput
  }


  /**
   * edgeSpriteSize deleteMany
   */
  export type edgeSpriteSizeDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which edgeSpriteSizes to delete
     */
    where?: edgeSpriteSizeWhereInput
  }


  /**
   * edgeSpriteSize without action
   */
  export type edgeSpriteSizeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edgeSpriteSize
     */
    select?: edgeSpriteSizeSelect<ExtArgs> | null
  }



  /**
   * Model edgeSpriteUrl
   */

  export type AggregateEdgeSpriteUrl = {
    _count: EdgeSpriteUrlCountAggregateOutputType | null
    _avg: EdgeSpriteUrlAvgAggregateOutputType | null
    _sum: EdgeSpriteUrlSumAggregateOutputType | null
    _min: EdgeSpriteUrlMinAggregateOutputType | null
    _max: EdgeSpriteUrlMaxAggregateOutputType | null
  }

  export type EdgeSpriteUrlAvgAggregateOutputType = {
    id: number | null
  }

  export type EdgeSpriteUrlSumAggregateOutputType = {
    id: number | null
  }

  export type EdgeSpriteUrlMinAggregateOutputType = {
    id: number | null
    spriteName: string | null
    version: string | null
  }

  export type EdgeSpriteUrlMaxAggregateOutputType = {
    id: number | null
    spriteName: string | null
    version: string | null
  }

  export type EdgeSpriteUrlCountAggregateOutputType = {
    id: number
    spriteName: number
    version: number
    _all: number
  }


  export type EdgeSpriteUrlAvgAggregateInputType = {
    id?: true
  }

  export type EdgeSpriteUrlSumAggregateInputType = {
    id?: true
  }

  export type EdgeSpriteUrlMinAggregateInputType = {
    id?: true
    spriteName?: true
    version?: true
  }

  export type EdgeSpriteUrlMaxAggregateInputType = {
    id?: true
    spriteName?: true
    version?: true
  }

  export type EdgeSpriteUrlCountAggregateInputType = {
    id?: true
    spriteName?: true
    version?: true
    _all?: true
  }

  export type EdgeSpriteUrlAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which edgeSpriteUrl to aggregate.
     */
    where?: edgeSpriteUrlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of edgeSpriteUrls to fetch.
     */
    orderBy?: edgeSpriteUrlOrderByWithRelationInput | edgeSpriteUrlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: edgeSpriteUrlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` edgeSpriteUrls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` edgeSpriteUrls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned edgeSpriteUrls
    **/
    _count?: true | EdgeSpriteUrlCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EdgeSpriteUrlAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EdgeSpriteUrlSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EdgeSpriteUrlMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EdgeSpriteUrlMaxAggregateInputType
  }

  export type GetEdgeSpriteUrlAggregateType<T extends EdgeSpriteUrlAggregateArgs> = {
        [P in keyof T & keyof AggregateEdgeSpriteUrl]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEdgeSpriteUrl[P]>
      : GetScalarType<T[P], AggregateEdgeSpriteUrl[P]>
  }




  export type edgeSpriteUrlGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: edgeSpriteUrlWhereInput
    orderBy?: edgeSpriteUrlOrderByWithAggregationInput | edgeSpriteUrlOrderByWithAggregationInput[]
    by: EdgeSpriteUrlScalarFieldEnum[] | EdgeSpriteUrlScalarFieldEnum
    having?: edgeSpriteUrlScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EdgeSpriteUrlCountAggregateInputType | true
    _avg?: EdgeSpriteUrlAvgAggregateInputType
    _sum?: EdgeSpriteUrlSumAggregateInputType
    _min?: EdgeSpriteUrlMinAggregateInputType
    _max?: EdgeSpriteUrlMaxAggregateInputType
  }

  export type EdgeSpriteUrlGroupByOutputType = {
    id: number
    spriteName: string
    version: string
    _count: EdgeSpriteUrlCountAggregateOutputType | null
    _avg: EdgeSpriteUrlAvgAggregateOutputType | null
    _sum: EdgeSpriteUrlSumAggregateOutputType | null
    _min: EdgeSpriteUrlMinAggregateOutputType | null
    _max: EdgeSpriteUrlMaxAggregateOutputType | null
  }

  type GetEdgeSpriteUrlGroupByPayload<T extends edgeSpriteUrlGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EdgeSpriteUrlGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EdgeSpriteUrlGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EdgeSpriteUrlGroupByOutputType[P]>
            : GetScalarType<T[P], EdgeSpriteUrlGroupByOutputType[P]>
        }
      >
    >


  export type edgeSpriteUrlSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    spriteName?: boolean
    version?: boolean
  }, ExtArgs["result"]["edgeSpriteUrl"]>

  export type edgeSpriteUrlSelectScalar = {
    id?: boolean
    spriteName?: boolean
    version?: boolean
  }


  export type $edgeSpriteUrlPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "edgeSpriteUrl"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: number
      spriteName: string
      version: string
    }, ExtArgs["result"]["edgeSpriteUrl"]>
    composites: {}
  }


  type edgeSpriteUrlGetPayload<S extends boolean | null | undefined | edgeSpriteUrlDefaultArgs> = $Result.GetResult<Prisma.$edgeSpriteUrlPayload, S>

  type edgeSpriteUrlCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<edgeSpriteUrlFindManyArgs, 'select' | 'include'> & {
      select?: EdgeSpriteUrlCountAggregateInputType | true
    }

  export interface edgeSpriteUrlDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['edgeSpriteUrl'], meta: { name: 'edgeSpriteUrl' } }
    /**
     * Find zero or one EdgeSpriteUrl that matches the filter.
     * @param {edgeSpriteUrlFindUniqueArgs} args - Arguments to find a EdgeSpriteUrl
     * @example
     * // Get one EdgeSpriteUrl
     * const edgeSpriteUrl = await prisma.edgeSpriteUrl.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends edgeSpriteUrlFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, edgeSpriteUrlFindUniqueArgs<ExtArgs>>
    ): Prisma__edgeSpriteUrlClient<$Result.GetResult<Prisma.$edgeSpriteUrlPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EdgeSpriteUrl that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {edgeSpriteUrlFindUniqueOrThrowArgs} args - Arguments to find a EdgeSpriteUrl
     * @example
     * // Get one EdgeSpriteUrl
     * const edgeSpriteUrl = await prisma.edgeSpriteUrl.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends edgeSpriteUrlFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, edgeSpriteUrlFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__edgeSpriteUrlClient<$Result.GetResult<Prisma.$edgeSpriteUrlPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EdgeSpriteUrl that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edgeSpriteUrlFindFirstArgs} args - Arguments to find a EdgeSpriteUrl
     * @example
     * // Get one EdgeSpriteUrl
     * const edgeSpriteUrl = await prisma.edgeSpriteUrl.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends edgeSpriteUrlFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, edgeSpriteUrlFindFirstArgs<ExtArgs>>
    ): Prisma__edgeSpriteUrlClient<$Result.GetResult<Prisma.$edgeSpriteUrlPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EdgeSpriteUrl that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edgeSpriteUrlFindFirstOrThrowArgs} args - Arguments to find a EdgeSpriteUrl
     * @example
     * // Get one EdgeSpriteUrl
     * const edgeSpriteUrl = await prisma.edgeSpriteUrl.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends edgeSpriteUrlFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, edgeSpriteUrlFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__edgeSpriteUrlClient<$Result.GetResult<Prisma.$edgeSpriteUrlPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EdgeSpriteUrls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edgeSpriteUrlFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EdgeSpriteUrls
     * const edgeSpriteUrls = await prisma.edgeSpriteUrl.findMany()
     * 
     * // Get first 10 EdgeSpriteUrls
     * const edgeSpriteUrls = await prisma.edgeSpriteUrl.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const edgeSpriteUrlWithIdOnly = await prisma.edgeSpriteUrl.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends edgeSpriteUrlFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, edgeSpriteUrlFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$edgeSpriteUrlPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EdgeSpriteUrl.
     * @param {edgeSpriteUrlCreateArgs} args - Arguments to create a EdgeSpriteUrl.
     * @example
     * // Create one EdgeSpriteUrl
     * const EdgeSpriteUrl = await prisma.edgeSpriteUrl.create({
     *   data: {
     *     // ... data to create a EdgeSpriteUrl
     *   }
     * })
     * 
    **/
    create<T extends edgeSpriteUrlCreateArgs<ExtArgs>>(
      args: SelectSubset<T, edgeSpriteUrlCreateArgs<ExtArgs>>
    ): Prisma__edgeSpriteUrlClient<$Result.GetResult<Prisma.$edgeSpriteUrlPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EdgeSpriteUrls.
     *     @param {edgeSpriteUrlCreateManyArgs} args - Arguments to create many EdgeSpriteUrls.
     *     @example
     *     // Create many EdgeSpriteUrls
     *     const edgeSpriteUrl = await prisma.edgeSpriteUrl.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends edgeSpriteUrlCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, edgeSpriteUrlCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EdgeSpriteUrl.
     * @param {edgeSpriteUrlDeleteArgs} args - Arguments to delete one EdgeSpriteUrl.
     * @example
     * // Delete one EdgeSpriteUrl
     * const EdgeSpriteUrl = await prisma.edgeSpriteUrl.delete({
     *   where: {
     *     // ... filter to delete one EdgeSpriteUrl
     *   }
     * })
     * 
    **/
    delete<T extends edgeSpriteUrlDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, edgeSpriteUrlDeleteArgs<ExtArgs>>
    ): Prisma__edgeSpriteUrlClient<$Result.GetResult<Prisma.$edgeSpriteUrlPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EdgeSpriteUrl.
     * @param {edgeSpriteUrlUpdateArgs} args - Arguments to update one EdgeSpriteUrl.
     * @example
     * // Update one EdgeSpriteUrl
     * const edgeSpriteUrl = await prisma.edgeSpriteUrl.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends edgeSpriteUrlUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, edgeSpriteUrlUpdateArgs<ExtArgs>>
    ): Prisma__edgeSpriteUrlClient<$Result.GetResult<Prisma.$edgeSpriteUrlPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EdgeSpriteUrls.
     * @param {edgeSpriteUrlDeleteManyArgs} args - Arguments to filter EdgeSpriteUrls to delete.
     * @example
     * // Delete a few EdgeSpriteUrls
     * const { count } = await prisma.edgeSpriteUrl.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends edgeSpriteUrlDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, edgeSpriteUrlDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EdgeSpriteUrls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edgeSpriteUrlUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EdgeSpriteUrls
     * const edgeSpriteUrl = await prisma.edgeSpriteUrl.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends edgeSpriteUrlUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, edgeSpriteUrlUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EdgeSpriteUrl.
     * @param {edgeSpriteUrlUpsertArgs} args - Arguments to update or create a EdgeSpriteUrl.
     * @example
     * // Update or create a EdgeSpriteUrl
     * const edgeSpriteUrl = await prisma.edgeSpriteUrl.upsert({
     *   create: {
     *     // ... data to create a EdgeSpriteUrl
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EdgeSpriteUrl we want to update
     *   }
     * })
    **/
    upsert<T extends edgeSpriteUrlUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, edgeSpriteUrlUpsertArgs<ExtArgs>>
    ): Prisma__edgeSpriteUrlClient<$Result.GetResult<Prisma.$edgeSpriteUrlPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EdgeSpriteUrls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edgeSpriteUrlCountArgs} args - Arguments to filter EdgeSpriteUrls to count.
     * @example
     * // Count the number of EdgeSpriteUrls
     * const count = await prisma.edgeSpriteUrl.count({
     *   where: {
     *     // ... the filter for the EdgeSpriteUrls we want to count
     *   }
     * })
    **/
    count<T extends edgeSpriteUrlCountArgs>(
      args?: Subset<T, edgeSpriteUrlCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EdgeSpriteUrlCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EdgeSpriteUrl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EdgeSpriteUrlAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EdgeSpriteUrlAggregateArgs>(args: Subset<T, EdgeSpriteUrlAggregateArgs>): Prisma.PrismaPromise<GetEdgeSpriteUrlAggregateType<T>>

    /**
     * Group by EdgeSpriteUrl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edgeSpriteUrlGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends edgeSpriteUrlGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: edgeSpriteUrlGroupByArgs['orderBy'] }
        : { orderBy?: edgeSpriteUrlGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, edgeSpriteUrlGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEdgeSpriteUrlGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the edgeSpriteUrl model
   */
  readonly fields: edgeSpriteUrlFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for edgeSpriteUrl.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__edgeSpriteUrlClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the edgeSpriteUrl model
   */ 
  interface edgeSpriteUrlFieldRefs {
    readonly id: FieldRef<"edgeSpriteUrl", 'Int'>
    readonly spriteName: FieldRef<"edgeSpriteUrl", 'String'>
    readonly version: FieldRef<"edgeSpriteUrl", 'String'>
  }
    

  // Custom InputTypes

  /**
   * edgeSpriteUrl findUnique
   */
  export type edgeSpriteUrlFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edgeSpriteUrl
     */
    select?: edgeSpriteUrlSelect<ExtArgs> | null
    /**
     * Filter, which edgeSpriteUrl to fetch.
     */
    where: edgeSpriteUrlWhereUniqueInput
  }


  /**
   * edgeSpriteUrl findUniqueOrThrow
   */
  export type edgeSpriteUrlFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edgeSpriteUrl
     */
    select?: edgeSpriteUrlSelect<ExtArgs> | null
    /**
     * Filter, which edgeSpriteUrl to fetch.
     */
    where: edgeSpriteUrlWhereUniqueInput
  }


  /**
   * edgeSpriteUrl findFirst
   */
  export type edgeSpriteUrlFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edgeSpriteUrl
     */
    select?: edgeSpriteUrlSelect<ExtArgs> | null
    /**
     * Filter, which edgeSpriteUrl to fetch.
     */
    where?: edgeSpriteUrlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of edgeSpriteUrls to fetch.
     */
    orderBy?: edgeSpriteUrlOrderByWithRelationInput | edgeSpriteUrlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for edgeSpriteUrls.
     */
    cursor?: edgeSpriteUrlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` edgeSpriteUrls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` edgeSpriteUrls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of edgeSpriteUrls.
     */
    distinct?: EdgeSpriteUrlScalarFieldEnum | EdgeSpriteUrlScalarFieldEnum[]
  }


  /**
   * edgeSpriteUrl findFirstOrThrow
   */
  export type edgeSpriteUrlFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edgeSpriteUrl
     */
    select?: edgeSpriteUrlSelect<ExtArgs> | null
    /**
     * Filter, which edgeSpriteUrl to fetch.
     */
    where?: edgeSpriteUrlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of edgeSpriteUrls to fetch.
     */
    orderBy?: edgeSpriteUrlOrderByWithRelationInput | edgeSpriteUrlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for edgeSpriteUrls.
     */
    cursor?: edgeSpriteUrlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` edgeSpriteUrls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` edgeSpriteUrls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of edgeSpriteUrls.
     */
    distinct?: EdgeSpriteUrlScalarFieldEnum | EdgeSpriteUrlScalarFieldEnum[]
  }


  /**
   * edgeSpriteUrl findMany
   */
  export type edgeSpriteUrlFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edgeSpriteUrl
     */
    select?: edgeSpriteUrlSelect<ExtArgs> | null
    /**
     * Filter, which edgeSpriteUrls to fetch.
     */
    where?: edgeSpriteUrlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of edgeSpriteUrls to fetch.
     */
    orderBy?: edgeSpriteUrlOrderByWithRelationInput | edgeSpriteUrlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing edgeSpriteUrls.
     */
    cursor?: edgeSpriteUrlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` edgeSpriteUrls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` edgeSpriteUrls.
     */
    skip?: number
    distinct?: EdgeSpriteUrlScalarFieldEnum | EdgeSpriteUrlScalarFieldEnum[]
  }


  /**
   * edgeSpriteUrl create
   */
  export type edgeSpriteUrlCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edgeSpriteUrl
     */
    select?: edgeSpriteUrlSelect<ExtArgs> | null
    /**
     * The data needed to create a edgeSpriteUrl.
     */
    data: XOR<edgeSpriteUrlCreateInput, edgeSpriteUrlUncheckedCreateInput>
  }


  /**
   * edgeSpriteUrl createMany
   */
  export type edgeSpriteUrlCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many edgeSpriteUrls.
     */
    data: edgeSpriteUrlCreateManyInput | edgeSpriteUrlCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * edgeSpriteUrl update
   */
  export type edgeSpriteUrlUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edgeSpriteUrl
     */
    select?: edgeSpriteUrlSelect<ExtArgs> | null
    /**
     * The data needed to update a edgeSpriteUrl.
     */
    data: XOR<edgeSpriteUrlUpdateInput, edgeSpriteUrlUncheckedUpdateInput>
    /**
     * Choose, which edgeSpriteUrl to update.
     */
    where: edgeSpriteUrlWhereUniqueInput
  }


  /**
   * edgeSpriteUrl updateMany
   */
  export type edgeSpriteUrlUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update edgeSpriteUrls.
     */
    data: XOR<edgeSpriteUrlUpdateManyMutationInput, edgeSpriteUrlUncheckedUpdateManyInput>
    /**
     * Filter which edgeSpriteUrls to update
     */
    where?: edgeSpriteUrlWhereInput
  }


  /**
   * edgeSpriteUrl upsert
   */
  export type edgeSpriteUrlUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edgeSpriteUrl
     */
    select?: edgeSpriteUrlSelect<ExtArgs> | null
    /**
     * The filter to search for the edgeSpriteUrl to update in case it exists.
     */
    where: edgeSpriteUrlWhereUniqueInput
    /**
     * In case the edgeSpriteUrl found by the `where` argument doesn't exist, create a new edgeSpriteUrl with this data.
     */
    create: XOR<edgeSpriteUrlCreateInput, edgeSpriteUrlUncheckedCreateInput>
    /**
     * In case the edgeSpriteUrl was found with the provided `where` argument, update it with this data.
     */
    update: XOR<edgeSpriteUrlUpdateInput, edgeSpriteUrlUncheckedUpdateInput>
  }


  /**
   * edgeSpriteUrl delete
   */
  export type edgeSpriteUrlDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edgeSpriteUrl
     */
    select?: edgeSpriteUrlSelect<ExtArgs> | null
    /**
     * Filter which edgeSpriteUrl to delete.
     */
    where: edgeSpriteUrlWhereUniqueInput
  }


  /**
   * edgeSpriteUrl deleteMany
   */
  export type edgeSpriteUrlDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which edgeSpriteUrls to delete
     */
    where?: edgeSpriteUrlWhereInput
  }


  /**
   * edgeSpriteUrl without action
   */
  export type edgeSpriteUrlDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edgeSpriteUrl
     */
    select?: edgeSpriteUrlSelect<ExtArgs> | null
  }



  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    discordId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    discordId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    allowSharing: boolean | null
    signupDate: Date | null
    email: string | null
    discordId: number | null
    showRecommendations: boolean | null
    isBetaUser: boolean | null
    showPresentationVideo: boolean | null
    showDuplicatesInBookcase: boolean | null
    bookcaseTexture1: string | null
    bookcaseSubTexture1: string | null
    bookcaseTexture2: string | null
    bookcaseSubTexture2: string | null
    presentationText: string | null
    lastAccess: Date | null
    previousAccess: Date | null
    marketplaceAcceptsExchanges: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    allowSharing: boolean | null
    signupDate: Date | null
    email: string | null
    discordId: number | null
    showRecommendations: boolean | null
    isBetaUser: boolean | null
    showPresentationVideo: boolean | null
    showDuplicatesInBookcase: boolean | null
    bookcaseTexture1: string | null
    bookcaseSubTexture1: string | null
    bookcaseTexture2: string | null
    bookcaseSubTexture2: string | null
    presentationText: string | null
    lastAccess: Date | null
    previousAccess: Date | null
    marketplaceAcceptsExchanges: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    password: number
    allowSharing: number
    signupDate: number
    email: number
    discordId: number
    showRecommendations: number
    isBetaUser: number
    showPresentationVideo: number
    showDuplicatesInBookcase: number
    bookcaseTexture1: number
    bookcaseSubTexture1: number
    bookcaseTexture2: number
    bookcaseSubTexture2: number
    presentationText: number
    lastAccess: number
    previousAccess: number
    marketplaceAcceptsExchanges: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    discordId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    discordId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    allowSharing?: true
    signupDate?: true
    email?: true
    discordId?: true
    showRecommendations?: true
    isBetaUser?: true
    showPresentationVideo?: true
    showDuplicatesInBookcase?: true
    bookcaseTexture1?: true
    bookcaseSubTexture1?: true
    bookcaseTexture2?: true
    bookcaseSubTexture2?: true
    presentationText?: true
    lastAccess?: true
    previousAccess?: true
    marketplaceAcceptsExchanges?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    allowSharing?: true
    signupDate?: true
    email?: true
    discordId?: true
    showRecommendations?: true
    isBetaUser?: true
    showPresentationVideo?: true
    showDuplicatesInBookcase?: true
    bookcaseTexture1?: true
    bookcaseSubTexture1?: true
    bookcaseTexture2?: true
    bookcaseSubTexture2?: true
    presentationText?: true
    lastAccess?: true
    previousAccess?: true
    marketplaceAcceptsExchanges?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    allowSharing?: true
    signupDate?: true
    email?: true
    discordId?: true
    showRecommendations?: true
    isBetaUser?: true
    showPresentationVideo?: true
    showDuplicatesInBookcase?: true
    bookcaseTexture1?: true
    bookcaseSubTexture1?: true
    bookcaseTexture2?: true
    bookcaseSubTexture2?: true
    presentationText?: true
    lastAccess?: true
    previousAccess?: true
    marketplaceAcceptsExchanges?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string
    password: string
    allowSharing: boolean
    signupDate: Date
    email: string
    discordId: number | null
    showRecommendations: boolean
    isBetaUser: boolean
    showPresentationVideo: boolean
    showDuplicatesInBookcase: boolean
    bookcaseTexture1: string
    bookcaseSubTexture1: string
    bookcaseTexture2: string
    bookcaseSubTexture2: string
    presentationText: string | null
    lastAccess: Date | null
    previousAccess: Date | null
    marketplaceAcceptsExchanges: boolean
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    allowSharing?: boolean
    signupDate?: boolean
    email?: boolean
    discordId?: boolean
    showRecommendations?: boolean
    isBetaUser?: boolean
    showPresentationVideo?: boolean
    showDuplicatesInBookcase?: boolean
    bookcaseTexture1?: boolean
    bookcaseSubTexture1?: boolean
    bookcaseTexture2?: boolean
    bookcaseSubTexture2?: boolean
    presentationText?: boolean
    lastAccess?: boolean
    previousAccess?: boolean
    marketplaceAcceptsExchanges?: boolean
    abonnements?: boolean | user$abonnementsArgs<ExtArgs>
    bouquineries_commentaires?: boolean | user$bouquineries_commentairesArgs<ExtArgs>
    users_contributions?: boolean | user$users_contributionsArgs<ExtArgs>
    users_options?: boolean | user$users_optionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type userSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
    allowSharing?: boolean
    signupDate?: boolean
    email?: boolean
    discordId?: boolean
    showRecommendations?: boolean
    isBetaUser?: boolean
    showPresentationVideo?: boolean
    showDuplicatesInBookcase?: boolean
    bookcaseTexture1?: boolean
    bookcaseSubTexture1?: boolean
    bookcaseTexture2?: boolean
    bookcaseSubTexture2?: boolean
    presentationText?: boolean
    lastAccess?: boolean
    previousAccess?: boolean
    marketplaceAcceptsExchanges?: boolean
  }

  export type userInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    abonnements?: boolean | user$abonnementsArgs<ExtArgs>
    bouquineries_commentaires?: boolean | user$bouquineries_commentairesArgs<ExtArgs>
    users_contributions?: boolean | user$users_contributionsArgs<ExtArgs>
    users_options?: boolean | user$users_optionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $userPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {
      abonnements: Prisma.$subscriptionPayload<ExtArgs>[]
      bouquineries_commentaires: Prisma.$bookstoreCommentPayload<ExtArgs>[]
      users_contributions: Prisma.$userContributionPayload<ExtArgs>[]
      users_options: Prisma.$userOptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      username: string
      password: string
      allowSharing: boolean
      signupDate: Date
      email: string
      discordId: number | null
      showRecommendations: boolean
      isBetaUser: boolean
      showPresentationVideo: boolean
      showDuplicatesInBookcase: boolean
      bookcaseTexture1: string
      bookcaseSubTexture1: string
      bookcaseTexture2: string
      bookcaseSubTexture2: string
      presentationText: string | null
      lastAccess: Date | null
      previousAccess: Date | null
      marketplaceAcceptsExchanges: boolean
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<userFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends userFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends userFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends userFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends userFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends userCreateArgs<ExtArgs>>(
      args: SelectSubset<T, userCreateArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {userCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends userCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends userDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, userDeleteArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends userUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, userUpdateArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends userDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends userUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends userUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, userUpsertArgs<ExtArgs>>
    ): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    abonnements<T extends user$abonnementsArgs<ExtArgs> = {}>(args?: Subset<T, user$abonnementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, 'findMany'> | Null>;

    bouquineries_commentaires<T extends user$bouquineries_commentairesArgs<ExtArgs> = {}>(args?: Subset<T, user$bouquineries_commentairesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bookstoreCommentPayload<ExtArgs>, T, 'findMany'> | Null>;

    users_contributions<T extends user$users_contributionsArgs<ExtArgs> = {}>(args?: Subset<T, user$users_contributionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userContributionPayload<ExtArgs>, T, 'findMany'> | Null>;

    users_options<T extends user$users_optionsArgs<ExtArgs> = {}>(args?: Subset<T, user$users_optionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userOptionPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the user model
   */ 
  interface userFieldRefs {
    readonly id: FieldRef<"user", 'Int'>
    readonly username: FieldRef<"user", 'String'>
    readonly password: FieldRef<"user", 'String'>
    readonly allowSharing: FieldRef<"user", 'Boolean'>
    readonly signupDate: FieldRef<"user", 'DateTime'>
    readonly email: FieldRef<"user", 'String'>
    readonly discordId: FieldRef<"user", 'Int'>
    readonly showRecommendations: FieldRef<"user", 'Boolean'>
    readonly isBetaUser: FieldRef<"user", 'Boolean'>
    readonly showPresentationVideo: FieldRef<"user", 'Boolean'>
    readonly showDuplicatesInBookcase: FieldRef<"user", 'Boolean'>
    readonly bookcaseTexture1: FieldRef<"user", 'String'>
    readonly bookcaseSubTexture1: FieldRef<"user", 'String'>
    readonly bookcaseTexture2: FieldRef<"user", 'String'>
    readonly bookcaseSubTexture2: FieldRef<"user", 'String'>
    readonly presentationText: FieldRef<"user", 'String'>
    readonly lastAccess: FieldRef<"user", 'DateTime'>
    readonly previousAccess: FieldRef<"user", 'DateTime'>
    readonly marketplaceAcceptsExchanges: FieldRef<"user", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }


  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }


  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }


  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }


  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
  }


  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }


  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }


  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
  }


  /**
   * user.abonnements
   */
  export type user$abonnementsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: subscriptionInclude<ExtArgs> | null
    where?: subscriptionWhereInput
    orderBy?: subscriptionOrderByWithRelationInput | subscriptionOrderByWithRelationInput[]
    cursor?: subscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }


  /**
   * user.bouquineries_commentaires
   */
  export type user$bouquineries_commentairesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookstoreComment
     */
    select?: bookstoreCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bookstoreCommentInclude<ExtArgs> | null
    where?: bookstoreCommentWhereInput
    orderBy?: bookstoreCommentOrderByWithRelationInput | bookstoreCommentOrderByWithRelationInput[]
    cursor?: bookstoreCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookstoreCommentScalarFieldEnum | BookstoreCommentScalarFieldEnum[]
  }


  /**
   * user.users_contributions
   */
  export type user$users_contributionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userContribution
     */
    select?: userContributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userContributionInclude<ExtArgs> | null
    where?: userContributionWhereInput
    orderBy?: userContributionOrderByWithRelationInput | userContributionOrderByWithRelationInput[]
    cursor?: userContributionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserContributionScalarFieldEnum | UserContributionScalarFieldEnum[]
  }


  /**
   * user.users_options
   */
  export type user$users_optionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userOption
     */
    select?: userOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userOptionInclude<ExtArgs> | null
    where?: userOptionWhereInput
    orderBy?: userOptionOrderByWithRelationInput | userOptionOrderByWithRelationInput[]
    cursor?: userOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserOptionScalarFieldEnum | UserOptionScalarFieldEnum[]
  }


  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
  }



  /**
   * Model userContribution
   */

  export type AggregateUserContribution = {
    _count: UserContributionCountAggregateOutputType | null
    _avg: UserContributionAvgAggregateOutputType | null
    _sum: UserContributionSumAggregateOutputType | null
    _min: UserContributionMinAggregateOutputType | null
    _max: UserContributionMaxAggregateOutputType | null
  }

  export type UserContributionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    newPoints: number | null
    totalPoints: number | null
    edgeId: number | null
    bookstoreId: number | null
    bookstoreCommentId: number | null
  }

  export type UserContributionSumAggregateOutputType = {
    id: number | null
    userId: number | null
    newPoints: number | null
    totalPoints: number | null
    edgeId: number | null
    bookstoreId: number | null
    bookstoreCommentId: number | null
  }

  export type UserContributionMinAggregateOutputType = {
    id: number | null
    userId: number | null
    date: Date | null
    contribution: string | null
    newPoints: number | null
    totalPoints: number | null
    isEmailSent: boolean | null
    edgeId: number | null
    bookstoreId: number | null
    bookstoreCommentId: number | null
  }

  export type UserContributionMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    date: Date | null
    contribution: string | null
    newPoints: number | null
    totalPoints: number | null
    isEmailSent: boolean | null
    edgeId: number | null
    bookstoreId: number | null
    bookstoreCommentId: number | null
  }

  export type UserContributionCountAggregateOutputType = {
    id: number
    userId: number
    date: number
    contribution: number
    newPoints: number
    totalPoints: number
    isEmailSent: number
    edgeId: number
    bookstoreId: number
    bookstoreCommentId: number
    _all: number
  }


  export type UserContributionAvgAggregateInputType = {
    id?: true
    userId?: true
    newPoints?: true
    totalPoints?: true
    edgeId?: true
    bookstoreId?: true
    bookstoreCommentId?: true
  }

  export type UserContributionSumAggregateInputType = {
    id?: true
    userId?: true
    newPoints?: true
    totalPoints?: true
    edgeId?: true
    bookstoreId?: true
    bookstoreCommentId?: true
  }

  export type UserContributionMinAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    contribution?: true
    newPoints?: true
    totalPoints?: true
    isEmailSent?: true
    edgeId?: true
    bookstoreId?: true
    bookstoreCommentId?: true
  }

  export type UserContributionMaxAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    contribution?: true
    newPoints?: true
    totalPoints?: true
    isEmailSent?: true
    edgeId?: true
    bookstoreId?: true
    bookstoreCommentId?: true
  }

  export type UserContributionCountAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    contribution?: true
    newPoints?: true
    totalPoints?: true
    isEmailSent?: true
    edgeId?: true
    bookstoreId?: true
    bookstoreCommentId?: true
    _all?: true
  }

  export type UserContributionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which userContribution to aggregate.
     */
    where?: userContributionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userContributions to fetch.
     */
    orderBy?: userContributionOrderByWithRelationInput | userContributionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userContributionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userContributions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userContributions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userContributions
    **/
    _count?: true | UserContributionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserContributionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserContributionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserContributionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserContributionMaxAggregateInputType
  }

  export type GetUserContributionAggregateType<T extends UserContributionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserContribution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserContribution[P]>
      : GetScalarType<T[P], AggregateUserContribution[P]>
  }




  export type userContributionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: userContributionWhereInput
    orderBy?: userContributionOrderByWithAggregationInput | userContributionOrderByWithAggregationInput[]
    by: UserContributionScalarFieldEnum[] | UserContributionScalarFieldEnum
    having?: userContributionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserContributionCountAggregateInputType | true
    _avg?: UserContributionAvgAggregateInputType
    _sum?: UserContributionSumAggregateInputType
    _min?: UserContributionMinAggregateInputType
    _max?: UserContributionMaxAggregateInputType
  }

  export type UserContributionGroupByOutputType = {
    id: number
    userId: number
    date: Date
    contribution: string
    newPoints: number
    totalPoints: number
    isEmailSent: boolean
    edgeId: number | null
    bookstoreId: number | null
    bookstoreCommentId: number | null
    _count: UserContributionCountAggregateOutputType | null
    _avg: UserContributionAvgAggregateOutputType | null
    _sum: UserContributionSumAggregateOutputType | null
    _min: UserContributionMinAggregateOutputType | null
    _max: UserContributionMaxAggregateOutputType | null
  }

  type GetUserContributionGroupByPayload<T extends userContributionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserContributionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserContributionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserContributionGroupByOutputType[P]>
            : GetScalarType<T[P], UserContributionGroupByOutputType[P]>
        }
      >
    >


  export type userContributionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    contribution?: boolean
    newPoints?: boolean
    totalPoints?: boolean
    isEmailSent?: boolean
    edgeId?: boolean
    bookstoreId?: boolean
    bookstoreCommentId?: boolean
    tranches_pretes?: boolean | userContribution$tranches_pretesArgs<ExtArgs>
    bouquineries?: boolean | userContribution$bouquineriesArgs<ExtArgs>
    users?: boolean | userDefaultArgs<ExtArgs>
    bouquineries_commentaires?: boolean | userContribution$bouquineries_commentairesArgs<ExtArgs>
  }, ExtArgs["result"]["userContribution"]>

  export type userContributionSelectScalar = {
    id?: boolean
    userId?: boolean
    date?: boolean
    contribution?: boolean
    newPoints?: boolean
    totalPoints?: boolean
    isEmailSent?: boolean
    edgeId?: boolean
    bookstoreId?: boolean
    bookstoreCommentId?: boolean
  }

  export type userContributionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    tranches_pretes?: boolean | userContribution$tranches_pretesArgs<ExtArgs>
    bouquineries?: boolean | userContribution$bouquineriesArgs<ExtArgs>
    users?: boolean | userDefaultArgs<ExtArgs>
    bouquineries_commentaires?: boolean | userContribution$bouquineries_commentairesArgs<ExtArgs>
  }


  export type $userContributionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "userContribution"
    objects: {
      tranches_pretes: Prisma.$edgePayload<ExtArgs> | null
      bouquineries: Prisma.$bookstorePayload<ExtArgs> | null
      users: Prisma.$userPayload<ExtArgs>
      bouquineries_commentaires: Prisma.$bookstoreCommentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: number
      userId: number
      date: Date
      contribution: string
      newPoints: number
      totalPoints: number
      isEmailSent: boolean
      edgeId: number | null
      bookstoreId: number | null
      bookstoreCommentId: number | null
    }, ExtArgs["result"]["userContribution"]>
    composites: {}
  }


  type userContributionGetPayload<S extends boolean | null | undefined | userContributionDefaultArgs> = $Result.GetResult<Prisma.$userContributionPayload, S>

  type userContributionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<userContributionFindManyArgs, 'select' | 'include'> & {
      select?: UserContributionCountAggregateInputType | true
    }

  export interface userContributionDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['userContribution'], meta: { name: 'userContribution' } }
    /**
     * Find zero or one UserContribution that matches the filter.
     * @param {userContributionFindUniqueArgs} args - Arguments to find a UserContribution
     * @example
     * // Get one UserContribution
     * const userContribution = await prisma.userContribution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends userContributionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, userContributionFindUniqueArgs<ExtArgs>>
    ): Prisma__userContributionClient<$Result.GetResult<Prisma.$userContributionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserContribution that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {userContributionFindUniqueOrThrowArgs} args - Arguments to find a UserContribution
     * @example
     * // Get one UserContribution
     * const userContribution = await prisma.userContribution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends userContributionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userContributionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__userContributionClient<$Result.GetResult<Prisma.$userContributionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserContribution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userContributionFindFirstArgs} args - Arguments to find a UserContribution
     * @example
     * // Get one UserContribution
     * const userContribution = await prisma.userContribution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends userContributionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, userContributionFindFirstArgs<ExtArgs>>
    ): Prisma__userContributionClient<$Result.GetResult<Prisma.$userContributionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserContribution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userContributionFindFirstOrThrowArgs} args - Arguments to find a UserContribution
     * @example
     * // Get one UserContribution
     * const userContribution = await prisma.userContribution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends userContributionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userContributionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__userContributionClient<$Result.GetResult<Prisma.$userContributionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserContributions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userContributionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserContributions
     * const userContributions = await prisma.userContribution.findMany()
     * 
     * // Get first 10 UserContributions
     * const userContributions = await prisma.userContribution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userContributionWithIdOnly = await prisma.userContribution.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends userContributionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userContributionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userContributionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserContribution.
     * @param {userContributionCreateArgs} args - Arguments to create a UserContribution.
     * @example
     * // Create one UserContribution
     * const UserContribution = await prisma.userContribution.create({
     *   data: {
     *     // ... data to create a UserContribution
     *   }
     * })
     * 
    **/
    create<T extends userContributionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, userContributionCreateArgs<ExtArgs>>
    ): Prisma__userContributionClient<$Result.GetResult<Prisma.$userContributionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserContributions.
     *     @param {userContributionCreateManyArgs} args - Arguments to create many UserContributions.
     *     @example
     *     // Create many UserContributions
     *     const userContribution = await prisma.userContribution.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends userContributionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userContributionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserContribution.
     * @param {userContributionDeleteArgs} args - Arguments to delete one UserContribution.
     * @example
     * // Delete one UserContribution
     * const UserContribution = await prisma.userContribution.delete({
     *   where: {
     *     // ... filter to delete one UserContribution
     *   }
     * })
     * 
    **/
    delete<T extends userContributionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, userContributionDeleteArgs<ExtArgs>>
    ): Prisma__userContributionClient<$Result.GetResult<Prisma.$userContributionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserContribution.
     * @param {userContributionUpdateArgs} args - Arguments to update one UserContribution.
     * @example
     * // Update one UserContribution
     * const userContribution = await prisma.userContribution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends userContributionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, userContributionUpdateArgs<ExtArgs>>
    ): Prisma__userContributionClient<$Result.GetResult<Prisma.$userContributionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserContributions.
     * @param {userContributionDeleteManyArgs} args - Arguments to filter UserContributions to delete.
     * @example
     * // Delete a few UserContributions
     * const { count } = await prisma.userContribution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends userContributionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userContributionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserContributions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userContributionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserContributions
     * const userContribution = await prisma.userContribution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends userContributionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, userContributionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserContribution.
     * @param {userContributionUpsertArgs} args - Arguments to update or create a UserContribution.
     * @example
     * // Update or create a UserContribution
     * const userContribution = await prisma.userContribution.upsert({
     *   create: {
     *     // ... data to create a UserContribution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserContribution we want to update
     *   }
     * })
    **/
    upsert<T extends userContributionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, userContributionUpsertArgs<ExtArgs>>
    ): Prisma__userContributionClient<$Result.GetResult<Prisma.$userContributionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserContributions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userContributionCountArgs} args - Arguments to filter UserContributions to count.
     * @example
     * // Count the number of UserContributions
     * const count = await prisma.userContribution.count({
     *   where: {
     *     // ... the filter for the UserContributions we want to count
     *   }
     * })
    **/
    count<T extends userContributionCountArgs>(
      args?: Subset<T, userContributionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserContributionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserContribution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserContributionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserContributionAggregateArgs>(args: Subset<T, UserContributionAggregateArgs>): Prisma.PrismaPromise<GetUserContributionAggregateType<T>>

    /**
     * Group by UserContribution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userContributionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userContributionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userContributionGroupByArgs['orderBy'] }
        : { orderBy?: userContributionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userContributionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserContributionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the userContribution model
   */
  readonly fields: userContributionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for userContribution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userContributionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    tranches_pretes<T extends userContribution$tranches_pretesArgs<ExtArgs> = {}>(args?: Subset<T, userContribution$tranches_pretesArgs<ExtArgs>>): Prisma__edgeClient<$Result.GetResult<Prisma.$edgePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    bouquineries<T extends userContribution$bouquineriesArgs<ExtArgs> = {}>(args?: Subset<T, userContribution$bouquineriesArgs<ExtArgs>>): Prisma__bookstoreClient<$Result.GetResult<Prisma.$bookstorePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    users<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    bouquineries_commentaires<T extends userContribution$bouquineries_commentairesArgs<ExtArgs> = {}>(args?: Subset<T, userContribution$bouquineries_commentairesArgs<ExtArgs>>): Prisma__bookstoreCommentClient<$Result.GetResult<Prisma.$bookstoreCommentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the userContribution model
   */ 
  interface userContributionFieldRefs {
    readonly id: FieldRef<"userContribution", 'Int'>
    readonly userId: FieldRef<"userContribution", 'Int'>
    readonly date: FieldRef<"userContribution", 'DateTime'>
    readonly contribution: FieldRef<"userContribution", 'String'>
    readonly newPoints: FieldRef<"userContribution", 'Int'>
    readonly totalPoints: FieldRef<"userContribution", 'Int'>
    readonly isEmailSent: FieldRef<"userContribution", 'Boolean'>
    readonly edgeId: FieldRef<"userContribution", 'Int'>
    readonly bookstoreId: FieldRef<"userContribution", 'Int'>
    readonly bookstoreCommentId: FieldRef<"userContribution", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * userContribution findUnique
   */
  export type userContributionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userContribution
     */
    select?: userContributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userContributionInclude<ExtArgs> | null
    /**
     * Filter, which userContribution to fetch.
     */
    where: userContributionWhereUniqueInput
  }


  /**
   * userContribution findUniqueOrThrow
   */
  export type userContributionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userContribution
     */
    select?: userContributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userContributionInclude<ExtArgs> | null
    /**
     * Filter, which userContribution to fetch.
     */
    where: userContributionWhereUniqueInput
  }


  /**
   * userContribution findFirst
   */
  export type userContributionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userContribution
     */
    select?: userContributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userContributionInclude<ExtArgs> | null
    /**
     * Filter, which userContribution to fetch.
     */
    where?: userContributionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userContributions to fetch.
     */
    orderBy?: userContributionOrderByWithRelationInput | userContributionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userContributions.
     */
    cursor?: userContributionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userContributions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userContributions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userContributions.
     */
    distinct?: UserContributionScalarFieldEnum | UserContributionScalarFieldEnum[]
  }


  /**
   * userContribution findFirstOrThrow
   */
  export type userContributionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userContribution
     */
    select?: userContributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userContributionInclude<ExtArgs> | null
    /**
     * Filter, which userContribution to fetch.
     */
    where?: userContributionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userContributions to fetch.
     */
    orderBy?: userContributionOrderByWithRelationInput | userContributionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userContributions.
     */
    cursor?: userContributionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userContributions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userContributions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userContributions.
     */
    distinct?: UserContributionScalarFieldEnum | UserContributionScalarFieldEnum[]
  }


  /**
   * userContribution findMany
   */
  export type userContributionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userContribution
     */
    select?: userContributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userContributionInclude<ExtArgs> | null
    /**
     * Filter, which userContributions to fetch.
     */
    where?: userContributionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userContributions to fetch.
     */
    orderBy?: userContributionOrderByWithRelationInput | userContributionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userContributions.
     */
    cursor?: userContributionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userContributions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userContributions.
     */
    skip?: number
    distinct?: UserContributionScalarFieldEnum | UserContributionScalarFieldEnum[]
  }


  /**
   * userContribution create
   */
  export type userContributionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userContribution
     */
    select?: userContributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userContributionInclude<ExtArgs> | null
    /**
     * The data needed to create a userContribution.
     */
    data: XOR<userContributionCreateInput, userContributionUncheckedCreateInput>
  }


  /**
   * userContribution createMany
   */
  export type userContributionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many userContributions.
     */
    data: userContributionCreateManyInput | userContributionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * userContribution update
   */
  export type userContributionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userContribution
     */
    select?: userContributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userContributionInclude<ExtArgs> | null
    /**
     * The data needed to update a userContribution.
     */
    data: XOR<userContributionUpdateInput, userContributionUncheckedUpdateInput>
    /**
     * Choose, which userContribution to update.
     */
    where: userContributionWhereUniqueInput
  }


  /**
   * userContribution updateMany
   */
  export type userContributionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update userContributions.
     */
    data: XOR<userContributionUpdateManyMutationInput, userContributionUncheckedUpdateManyInput>
    /**
     * Filter which userContributions to update
     */
    where?: userContributionWhereInput
  }


  /**
   * userContribution upsert
   */
  export type userContributionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userContribution
     */
    select?: userContributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userContributionInclude<ExtArgs> | null
    /**
     * The filter to search for the userContribution to update in case it exists.
     */
    where: userContributionWhereUniqueInput
    /**
     * In case the userContribution found by the `where` argument doesn't exist, create a new userContribution with this data.
     */
    create: XOR<userContributionCreateInput, userContributionUncheckedCreateInput>
    /**
     * In case the userContribution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userContributionUpdateInput, userContributionUncheckedUpdateInput>
  }


  /**
   * userContribution delete
   */
  export type userContributionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userContribution
     */
    select?: userContributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userContributionInclude<ExtArgs> | null
    /**
     * Filter which userContribution to delete.
     */
    where: userContributionWhereUniqueInput
  }


  /**
   * userContribution deleteMany
   */
  export type userContributionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which userContributions to delete
     */
    where?: userContributionWhereInput
  }


  /**
   * userContribution.tranches_pretes
   */
  export type userContribution$tranches_pretesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edge
     */
    select?: edgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: edgeInclude<ExtArgs> | null
    where?: edgeWhereInput
  }


  /**
   * userContribution.bouquineries
   */
  export type userContribution$bouquineriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookstore
     */
    select?: bookstoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bookstoreInclude<ExtArgs> | null
    where?: bookstoreWhereInput
  }


  /**
   * userContribution.bouquineries_commentaires
   */
  export type userContribution$bouquineries_commentairesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookstoreComment
     */
    select?: bookstoreCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bookstoreCommentInclude<ExtArgs> | null
    where?: bookstoreCommentWhereInput
  }


  /**
   * userContribution without action
   */
  export type userContributionDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userContribution
     */
    select?: userContributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userContributionInclude<ExtArgs> | null
  }



  /**
   * Model userOption
   */

  export type AggregateUserOption = {
    _count: UserOptionCountAggregateOutputType | null
    _avg: UserOptionAvgAggregateOutputType | null
    _sum: UserOptionSumAggregateOutputType | null
    _min: UserOptionMinAggregateOutputType | null
    _max: UserOptionMaxAggregateOutputType | null
  }

  export type UserOptionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserOptionSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserOptionMinAggregateOutputType = {
    id: number | null
    userId: number | null
    optionName: $Enums.userOptionType | null
    optionValue: string | null
  }

  export type UserOptionMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    optionName: $Enums.userOptionType | null
    optionValue: string | null
  }

  export type UserOptionCountAggregateOutputType = {
    id: number
    userId: number
    optionName: number
    optionValue: number
    _all: number
  }


  export type UserOptionAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserOptionSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserOptionMinAggregateInputType = {
    id?: true
    userId?: true
    optionName?: true
    optionValue?: true
  }

  export type UserOptionMaxAggregateInputType = {
    id?: true
    userId?: true
    optionName?: true
    optionValue?: true
  }

  export type UserOptionCountAggregateInputType = {
    id?: true
    userId?: true
    optionName?: true
    optionValue?: true
    _all?: true
  }

  export type UserOptionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which userOption to aggregate.
     */
    where?: userOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userOptions to fetch.
     */
    orderBy?: userOptionOrderByWithRelationInput | userOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userOptions
    **/
    _count?: true | UserOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserOptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserOptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserOptionMaxAggregateInputType
  }

  export type GetUserOptionAggregateType<T extends UserOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserOption[P]>
      : GetScalarType<T[P], AggregateUserOption[P]>
  }




  export type userOptionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: userOptionWhereInput
    orderBy?: userOptionOrderByWithAggregationInput | userOptionOrderByWithAggregationInput[]
    by: UserOptionScalarFieldEnum[] | UserOptionScalarFieldEnum
    having?: userOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserOptionCountAggregateInputType | true
    _avg?: UserOptionAvgAggregateInputType
    _sum?: UserOptionSumAggregateInputType
    _min?: UserOptionMinAggregateInputType
    _max?: UserOptionMaxAggregateInputType
  }

  export type UserOptionGroupByOutputType = {
    id: number
    userId: number
    optionName: $Enums.userOptionType
    optionValue: string
    _count: UserOptionCountAggregateOutputType | null
    _avg: UserOptionAvgAggregateOutputType | null
    _sum: UserOptionSumAggregateOutputType | null
    _min: UserOptionMinAggregateOutputType | null
    _max: UserOptionMaxAggregateOutputType | null
  }

  type GetUserOptionGroupByPayload<T extends userOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserOptionGroupByOutputType[P]>
            : GetScalarType<T[P], UserOptionGroupByOutputType[P]>
        }
      >
    >


  export type userOptionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    optionName?: boolean
    optionValue?: boolean
    users?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userOption"]>

  export type userOptionSelectScalar = {
    id?: boolean
    userId?: boolean
    optionName?: boolean
    optionValue?: boolean
  }

  export type userOptionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    users?: boolean | userDefaultArgs<ExtArgs>
  }


  export type $userOptionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "userOption"
    objects: {
      users: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: number
      userId: number
      optionName: $Enums.userOptionType
      optionValue: string
    }, ExtArgs["result"]["userOption"]>
    composites: {}
  }


  type userOptionGetPayload<S extends boolean | null | undefined | userOptionDefaultArgs> = $Result.GetResult<Prisma.$userOptionPayload, S>

  type userOptionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<userOptionFindManyArgs, 'select' | 'include'> & {
      select?: UserOptionCountAggregateInputType | true
    }

  export interface userOptionDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['userOption'], meta: { name: 'userOption' } }
    /**
     * Find zero or one UserOption that matches the filter.
     * @param {userOptionFindUniqueArgs} args - Arguments to find a UserOption
     * @example
     * // Get one UserOption
     * const userOption = await prisma.userOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends userOptionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, userOptionFindUniqueArgs<ExtArgs>>
    ): Prisma__userOptionClient<$Result.GetResult<Prisma.$userOptionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserOption that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {userOptionFindUniqueOrThrowArgs} args - Arguments to find a UserOption
     * @example
     * // Get one UserOption
     * const userOption = await prisma.userOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends userOptionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userOptionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__userOptionClient<$Result.GetResult<Prisma.$userOptionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userOptionFindFirstArgs} args - Arguments to find a UserOption
     * @example
     * // Get one UserOption
     * const userOption = await prisma.userOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends userOptionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, userOptionFindFirstArgs<ExtArgs>>
    ): Prisma__userOptionClient<$Result.GetResult<Prisma.$userOptionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userOptionFindFirstOrThrowArgs} args - Arguments to find a UserOption
     * @example
     * // Get one UserOption
     * const userOption = await prisma.userOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends userOptionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userOptionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__userOptionClient<$Result.GetResult<Prisma.$userOptionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userOptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserOptions
     * const userOptions = await prisma.userOption.findMany()
     * 
     * // Get first 10 UserOptions
     * const userOptions = await prisma.userOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userOptionWithIdOnly = await prisma.userOption.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends userOptionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userOptionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userOptionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserOption.
     * @param {userOptionCreateArgs} args - Arguments to create a UserOption.
     * @example
     * // Create one UserOption
     * const UserOption = await prisma.userOption.create({
     *   data: {
     *     // ... data to create a UserOption
     *   }
     * })
     * 
    **/
    create<T extends userOptionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, userOptionCreateArgs<ExtArgs>>
    ): Prisma__userOptionClient<$Result.GetResult<Prisma.$userOptionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserOptions.
     *     @param {userOptionCreateManyArgs} args - Arguments to create many UserOptions.
     *     @example
     *     // Create many UserOptions
     *     const userOption = await prisma.userOption.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends userOptionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userOptionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserOption.
     * @param {userOptionDeleteArgs} args - Arguments to delete one UserOption.
     * @example
     * // Delete one UserOption
     * const UserOption = await prisma.userOption.delete({
     *   where: {
     *     // ... filter to delete one UserOption
     *   }
     * })
     * 
    **/
    delete<T extends userOptionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, userOptionDeleteArgs<ExtArgs>>
    ): Prisma__userOptionClient<$Result.GetResult<Prisma.$userOptionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserOption.
     * @param {userOptionUpdateArgs} args - Arguments to update one UserOption.
     * @example
     * // Update one UserOption
     * const userOption = await prisma.userOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends userOptionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, userOptionUpdateArgs<ExtArgs>>
    ): Prisma__userOptionClient<$Result.GetResult<Prisma.$userOptionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserOptions.
     * @param {userOptionDeleteManyArgs} args - Arguments to filter UserOptions to delete.
     * @example
     * // Delete a few UserOptions
     * const { count } = await prisma.userOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends userOptionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userOptionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserOptions
     * const userOption = await prisma.userOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends userOptionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, userOptionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserOption.
     * @param {userOptionUpsertArgs} args - Arguments to update or create a UserOption.
     * @example
     * // Update or create a UserOption
     * const userOption = await prisma.userOption.upsert({
     *   create: {
     *     // ... data to create a UserOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserOption we want to update
     *   }
     * })
    **/
    upsert<T extends userOptionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, userOptionUpsertArgs<ExtArgs>>
    ): Prisma__userOptionClient<$Result.GetResult<Prisma.$userOptionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userOptionCountArgs} args - Arguments to filter UserOptions to count.
     * @example
     * // Count the number of UserOptions
     * const count = await prisma.userOption.count({
     *   where: {
     *     // ... the filter for the UserOptions we want to count
     *   }
     * })
    **/
    count<T extends userOptionCountArgs>(
      args?: Subset<T, userOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserOptionAggregateArgs>(args: Subset<T, UserOptionAggregateArgs>): Prisma.PrismaPromise<GetUserOptionAggregateType<T>>

    /**
     * Group by UserOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userOptionGroupByArgs['orderBy'] }
        : { orderBy?: userOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the userOption model
   */
  readonly fields: userOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for userOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userOptionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the userOption model
   */ 
  interface userOptionFieldRefs {
    readonly id: FieldRef<"userOption", 'Int'>
    readonly userId: FieldRef<"userOption", 'Int'>
    readonly optionName: FieldRef<"userOption", 'userOptionType'>
    readonly optionValue: FieldRef<"userOption", 'String'>
  }
    

  // Custom InputTypes

  /**
   * userOption findUnique
   */
  export type userOptionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userOption
     */
    select?: userOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userOptionInclude<ExtArgs> | null
    /**
     * Filter, which userOption to fetch.
     */
    where: userOptionWhereUniqueInput
  }


  /**
   * userOption findUniqueOrThrow
   */
  export type userOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userOption
     */
    select?: userOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userOptionInclude<ExtArgs> | null
    /**
     * Filter, which userOption to fetch.
     */
    where: userOptionWhereUniqueInput
  }


  /**
   * userOption findFirst
   */
  export type userOptionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userOption
     */
    select?: userOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userOptionInclude<ExtArgs> | null
    /**
     * Filter, which userOption to fetch.
     */
    where?: userOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userOptions to fetch.
     */
    orderBy?: userOptionOrderByWithRelationInput | userOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userOptions.
     */
    cursor?: userOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userOptions.
     */
    distinct?: UserOptionScalarFieldEnum | UserOptionScalarFieldEnum[]
  }


  /**
   * userOption findFirstOrThrow
   */
  export type userOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userOption
     */
    select?: userOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userOptionInclude<ExtArgs> | null
    /**
     * Filter, which userOption to fetch.
     */
    where?: userOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userOptions to fetch.
     */
    orderBy?: userOptionOrderByWithRelationInput | userOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userOptions.
     */
    cursor?: userOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userOptions.
     */
    distinct?: UserOptionScalarFieldEnum | UserOptionScalarFieldEnum[]
  }


  /**
   * userOption findMany
   */
  export type userOptionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userOption
     */
    select?: userOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userOptionInclude<ExtArgs> | null
    /**
     * Filter, which userOptions to fetch.
     */
    where?: userOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userOptions to fetch.
     */
    orderBy?: userOptionOrderByWithRelationInput | userOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userOptions.
     */
    cursor?: userOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userOptions.
     */
    skip?: number
    distinct?: UserOptionScalarFieldEnum | UserOptionScalarFieldEnum[]
  }


  /**
   * userOption create
   */
  export type userOptionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userOption
     */
    select?: userOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a userOption.
     */
    data: XOR<userOptionCreateInput, userOptionUncheckedCreateInput>
  }


  /**
   * userOption createMany
   */
  export type userOptionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many userOptions.
     */
    data: userOptionCreateManyInput | userOptionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * userOption update
   */
  export type userOptionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userOption
     */
    select?: userOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a userOption.
     */
    data: XOR<userOptionUpdateInput, userOptionUncheckedUpdateInput>
    /**
     * Choose, which userOption to update.
     */
    where: userOptionWhereUniqueInput
  }


  /**
   * userOption updateMany
   */
  export type userOptionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update userOptions.
     */
    data: XOR<userOptionUpdateManyMutationInput, userOptionUncheckedUpdateManyInput>
    /**
     * Filter which userOptions to update
     */
    where?: userOptionWhereInput
  }


  /**
   * userOption upsert
   */
  export type userOptionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userOption
     */
    select?: userOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the userOption to update in case it exists.
     */
    where: userOptionWhereUniqueInput
    /**
     * In case the userOption found by the `where` argument doesn't exist, create a new userOption with this data.
     */
    create: XOR<userOptionCreateInput, userOptionUncheckedCreateInput>
    /**
     * In case the userOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userOptionUpdateInput, userOptionUncheckedUpdateInput>
  }


  /**
   * userOption delete
   */
  export type userOptionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userOption
     */
    select?: userOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userOptionInclude<ExtArgs> | null
    /**
     * Filter which userOption to delete.
     */
    where: userOptionWhereUniqueInput
  }


  /**
   * userOption deleteMany
   */
  export type userOptionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which userOptions to delete
     */
    where?: userOptionWhereInput
  }


  /**
   * userOption without action
   */
  export type userOptionDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userOption
     */
    select?: userOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userOptionInclude<ExtArgs> | null
  }



  /**
   * Model userPasswordToken
   */

  export type AggregateUserPasswordToken = {
    _count: UserPasswordTokenCountAggregateOutputType | null
    _avg: UserPasswordTokenAvgAggregateOutputType | null
    _sum: UserPasswordTokenSumAggregateOutputType | null
    _min: UserPasswordTokenMinAggregateOutputType | null
    _max: UserPasswordTokenMaxAggregateOutputType | null
  }

  export type UserPasswordTokenAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserPasswordTokenSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserPasswordTokenMinAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
  }

  export type UserPasswordTokenMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
  }

  export type UserPasswordTokenCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    _all: number
  }


  export type UserPasswordTokenAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserPasswordTokenSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserPasswordTokenMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
  }

  export type UserPasswordTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
  }

  export type UserPasswordTokenCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    _all?: true
  }

  export type UserPasswordTokenAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which userPasswordToken to aggregate.
     */
    where?: userPasswordTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userPasswordTokens to fetch.
     */
    orderBy?: userPasswordTokenOrderByWithRelationInput | userPasswordTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userPasswordTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userPasswordTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userPasswordTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userPasswordTokens
    **/
    _count?: true | UserPasswordTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPasswordTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPasswordTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPasswordTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPasswordTokenMaxAggregateInputType
  }

  export type GetUserPasswordTokenAggregateType<T extends UserPasswordTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPasswordToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPasswordToken[P]>
      : GetScalarType<T[P], AggregateUserPasswordToken[P]>
  }




  export type userPasswordTokenGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: userPasswordTokenWhereInput
    orderBy?: userPasswordTokenOrderByWithAggregationInput | userPasswordTokenOrderByWithAggregationInput[]
    by: UserPasswordTokenScalarFieldEnum[] | UserPasswordTokenScalarFieldEnum
    having?: userPasswordTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPasswordTokenCountAggregateInputType | true
    _avg?: UserPasswordTokenAvgAggregateInputType
    _sum?: UserPasswordTokenSumAggregateInputType
    _min?: UserPasswordTokenMinAggregateInputType
    _max?: UserPasswordTokenMaxAggregateInputType
  }

  export type UserPasswordTokenGroupByOutputType = {
    id: number
    userId: number
    token: string
    _count: UserPasswordTokenCountAggregateOutputType | null
    _avg: UserPasswordTokenAvgAggregateOutputType | null
    _sum: UserPasswordTokenSumAggregateOutputType | null
    _min: UserPasswordTokenMinAggregateOutputType | null
    _max: UserPasswordTokenMaxAggregateOutputType | null
  }

  type GetUserPasswordTokenGroupByPayload<T extends userPasswordTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPasswordTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPasswordTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPasswordTokenGroupByOutputType[P]>
            : GetScalarType<T[P], UserPasswordTokenGroupByOutputType[P]>
        }
      >
    >


  export type userPasswordTokenSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
  }, ExtArgs["result"]["userPasswordToken"]>

  export type userPasswordTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
  }


  export type $userPasswordTokenPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "userPasswordToken"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: number
      userId: number
      token: string
    }, ExtArgs["result"]["userPasswordToken"]>
    composites: {}
  }


  type userPasswordTokenGetPayload<S extends boolean | null | undefined | userPasswordTokenDefaultArgs> = $Result.GetResult<Prisma.$userPasswordTokenPayload, S>

  type userPasswordTokenCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<userPasswordTokenFindManyArgs, 'select' | 'include'> & {
      select?: UserPasswordTokenCountAggregateInputType | true
    }

  export interface userPasswordTokenDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['userPasswordToken'], meta: { name: 'userPasswordToken' } }
    /**
     * Find zero or one UserPasswordToken that matches the filter.
     * @param {userPasswordTokenFindUniqueArgs} args - Arguments to find a UserPasswordToken
     * @example
     * // Get one UserPasswordToken
     * const userPasswordToken = await prisma.userPasswordToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends userPasswordTokenFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, userPasswordTokenFindUniqueArgs<ExtArgs>>
    ): Prisma__userPasswordTokenClient<$Result.GetResult<Prisma.$userPasswordTokenPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserPasswordToken that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {userPasswordTokenFindUniqueOrThrowArgs} args - Arguments to find a UserPasswordToken
     * @example
     * // Get one UserPasswordToken
     * const userPasswordToken = await prisma.userPasswordToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends userPasswordTokenFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userPasswordTokenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__userPasswordTokenClient<$Result.GetResult<Prisma.$userPasswordTokenPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserPasswordToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userPasswordTokenFindFirstArgs} args - Arguments to find a UserPasswordToken
     * @example
     * // Get one UserPasswordToken
     * const userPasswordToken = await prisma.userPasswordToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends userPasswordTokenFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, userPasswordTokenFindFirstArgs<ExtArgs>>
    ): Prisma__userPasswordTokenClient<$Result.GetResult<Prisma.$userPasswordTokenPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserPasswordToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userPasswordTokenFindFirstOrThrowArgs} args - Arguments to find a UserPasswordToken
     * @example
     * // Get one UserPasswordToken
     * const userPasswordToken = await prisma.userPasswordToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends userPasswordTokenFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userPasswordTokenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__userPasswordTokenClient<$Result.GetResult<Prisma.$userPasswordTokenPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserPasswordTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userPasswordTokenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPasswordTokens
     * const userPasswordTokens = await prisma.userPasswordToken.findMany()
     * 
     * // Get first 10 UserPasswordTokens
     * const userPasswordTokens = await prisma.userPasswordToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPasswordTokenWithIdOnly = await prisma.userPasswordToken.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends userPasswordTokenFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userPasswordTokenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPasswordTokenPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserPasswordToken.
     * @param {userPasswordTokenCreateArgs} args - Arguments to create a UserPasswordToken.
     * @example
     * // Create one UserPasswordToken
     * const UserPasswordToken = await prisma.userPasswordToken.create({
     *   data: {
     *     // ... data to create a UserPasswordToken
     *   }
     * })
     * 
    **/
    create<T extends userPasswordTokenCreateArgs<ExtArgs>>(
      args: SelectSubset<T, userPasswordTokenCreateArgs<ExtArgs>>
    ): Prisma__userPasswordTokenClient<$Result.GetResult<Prisma.$userPasswordTokenPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserPasswordTokens.
     *     @param {userPasswordTokenCreateManyArgs} args - Arguments to create many UserPasswordTokens.
     *     @example
     *     // Create many UserPasswordTokens
     *     const userPasswordToken = await prisma.userPasswordToken.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends userPasswordTokenCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userPasswordTokenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserPasswordToken.
     * @param {userPasswordTokenDeleteArgs} args - Arguments to delete one UserPasswordToken.
     * @example
     * // Delete one UserPasswordToken
     * const UserPasswordToken = await prisma.userPasswordToken.delete({
     *   where: {
     *     // ... filter to delete one UserPasswordToken
     *   }
     * })
     * 
    **/
    delete<T extends userPasswordTokenDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, userPasswordTokenDeleteArgs<ExtArgs>>
    ): Prisma__userPasswordTokenClient<$Result.GetResult<Prisma.$userPasswordTokenPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserPasswordToken.
     * @param {userPasswordTokenUpdateArgs} args - Arguments to update one UserPasswordToken.
     * @example
     * // Update one UserPasswordToken
     * const userPasswordToken = await prisma.userPasswordToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends userPasswordTokenUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, userPasswordTokenUpdateArgs<ExtArgs>>
    ): Prisma__userPasswordTokenClient<$Result.GetResult<Prisma.$userPasswordTokenPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserPasswordTokens.
     * @param {userPasswordTokenDeleteManyArgs} args - Arguments to filter UserPasswordTokens to delete.
     * @example
     * // Delete a few UserPasswordTokens
     * const { count } = await prisma.userPasswordToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends userPasswordTokenDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userPasswordTokenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPasswordTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userPasswordTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPasswordTokens
     * const userPasswordToken = await prisma.userPasswordToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends userPasswordTokenUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, userPasswordTokenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserPasswordToken.
     * @param {userPasswordTokenUpsertArgs} args - Arguments to update or create a UserPasswordToken.
     * @example
     * // Update or create a UserPasswordToken
     * const userPasswordToken = await prisma.userPasswordToken.upsert({
     *   create: {
     *     // ... data to create a UserPasswordToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPasswordToken we want to update
     *   }
     * })
    **/
    upsert<T extends userPasswordTokenUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, userPasswordTokenUpsertArgs<ExtArgs>>
    ): Prisma__userPasswordTokenClient<$Result.GetResult<Prisma.$userPasswordTokenPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserPasswordTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userPasswordTokenCountArgs} args - Arguments to filter UserPasswordTokens to count.
     * @example
     * // Count the number of UserPasswordTokens
     * const count = await prisma.userPasswordToken.count({
     *   where: {
     *     // ... the filter for the UserPasswordTokens we want to count
     *   }
     * })
    **/
    count<T extends userPasswordTokenCountArgs>(
      args?: Subset<T, userPasswordTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPasswordTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPasswordToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPasswordTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPasswordTokenAggregateArgs>(args: Subset<T, UserPasswordTokenAggregateArgs>): Prisma.PrismaPromise<GetUserPasswordTokenAggregateType<T>>

    /**
     * Group by UserPasswordToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userPasswordTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userPasswordTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userPasswordTokenGroupByArgs['orderBy'] }
        : { orderBy?: userPasswordTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userPasswordTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPasswordTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the userPasswordToken model
   */
  readonly fields: userPasswordTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for userPasswordToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userPasswordTokenClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the userPasswordToken model
   */ 
  interface userPasswordTokenFieldRefs {
    readonly id: FieldRef<"userPasswordToken", 'Int'>
    readonly userId: FieldRef<"userPasswordToken", 'Int'>
    readonly token: FieldRef<"userPasswordToken", 'String'>
  }
    

  // Custom InputTypes

  /**
   * userPasswordToken findUnique
   */
  export type userPasswordTokenFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userPasswordToken
     */
    select?: userPasswordTokenSelect<ExtArgs> | null
    /**
     * Filter, which userPasswordToken to fetch.
     */
    where: userPasswordTokenWhereUniqueInput
  }


  /**
   * userPasswordToken findUniqueOrThrow
   */
  export type userPasswordTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userPasswordToken
     */
    select?: userPasswordTokenSelect<ExtArgs> | null
    /**
     * Filter, which userPasswordToken to fetch.
     */
    where: userPasswordTokenWhereUniqueInput
  }


  /**
   * userPasswordToken findFirst
   */
  export type userPasswordTokenFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userPasswordToken
     */
    select?: userPasswordTokenSelect<ExtArgs> | null
    /**
     * Filter, which userPasswordToken to fetch.
     */
    where?: userPasswordTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userPasswordTokens to fetch.
     */
    orderBy?: userPasswordTokenOrderByWithRelationInput | userPasswordTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userPasswordTokens.
     */
    cursor?: userPasswordTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userPasswordTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userPasswordTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userPasswordTokens.
     */
    distinct?: UserPasswordTokenScalarFieldEnum | UserPasswordTokenScalarFieldEnum[]
  }


  /**
   * userPasswordToken findFirstOrThrow
   */
  export type userPasswordTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userPasswordToken
     */
    select?: userPasswordTokenSelect<ExtArgs> | null
    /**
     * Filter, which userPasswordToken to fetch.
     */
    where?: userPasswordTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userPasswordTokens to fetch.
     */
    orderBy?: userPasswordTokenOrderByWithRelationInput | userPasswordTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userPasswordTokens.
     */
    cursor?: userPasswordTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userPasswordTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userPasswordTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userPasswordTokens.
     */
    distinct?: UserPasswordTokenScalarFieldEnum | UserPasswordTokenScalarFieldEnum[]
  }


  /**
   * userPasswordToken findMany
   */
  export type userPasswordTokenFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userPasswordToken
     */
    select?: userPasswordTokenSelect<ExtArgs> | null
    /**
     * Filter, which userPasswordTokens to fetch.
     */
    where?: userPasswordTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userPasswordTokens to fetch.
     */
    orderBy?: userPasswordTokenOrderByWithRelationInput | userPasswordTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userPasswordTokens.
     */
    cursor?: userPasswordTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userPasswordTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userPasswordTokens.
     */
    skip?: number
    distinct?: UserPasswordTokenScalarFieldEnum | UserPasswordTokenScalarFieldEnum[]
  }


  /**
   * userPasswordToken create
   */
  export type userPasswordTokenCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userPasswordToken
     */
    select?: userPasswordTokenSelect<ExtArgs> | null
    /**
     * The data needed to create a userPasswordToken.
     */
    data: XOR<userPasswordTokenCreateInput, userPasswordTokenUncheckedCreateInput>
  }


  /**
   * userPasswordToken createMany
   */
  export type userPasswordTokenCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many userPasswordTokens.
     */
    data: userPasswordTokenCreateManyInput | userPasswordTokenCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * userPasswordToken update
   */
  export type userPasswordTokenUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userPasswordToken
     */
    select?: userPasswordTokenSelect<ExtArgs> | null
    /**
     * The data needed to update a userPasswordToken.
     */
    data: XOR<userPasswordTokenUpdateInput, userPasswordTokenUncheckedUpdateInput>
    /**
     * Choose, which userPasswordToken to update.
     */
    where: userPasswordTokenWhereUniqueInput
  }


  /**
   * userPasswordToken updateMany
   */
  export type userPasswordTokenUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update userPasswordTokens.
     */
    data: XOR<userPasswordTokenUpdateManyMutationInput, userPasswordTokenUncheckedUpdateManyInput>
    /**
     * Filter which userPasswordTokens to update
     */
    where?: userPasswordTokenWhereInput
  }


  /**
   * userPasswordToken upsert
   */
  export type userPasswordTokenUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userPasswordToken
     */
    select?: userPasswordTokenSelect<ExtArgs> | null
    /**
     * The filter to search for the userPasswordToken to update in case it exists.
     */
    where: userPasswordTokenWhereUniqueInput
    /**
     * In case the userPasswordToken found by the `where` argument doesn't exist, create a new userPasswordToken with this data.
     */
    create: XOR<userPasswordTokenCreateInput, userPasswordTokenUncheckedCreateInput>
    /**
     * In case the userPasswordToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userPasswordTokenUpdateInput, userPasswordTokenUncheckedUpdateInput>
  }


  /**
   * userPasswordToken delete
   */
  export type userPasswordTokenDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userPasswordToken
     */
    select?: userPasswordTokenSelect<ExtArgs> | null
    /**
     * Filter which userPasswordToken to delete.
     */
    where: userPasswordTokenWhereUniqueInput
  }


  /**
   * userPasswordToken deleteMany
   */
  export type userPasswordTokenDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which userPasswordTokens to delete
     */
    where?: userPasswordTokenWhereInput
  }


  /**
   * userPasswordToken without action
   */
  export type userPasswordTokenDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userPasswordToken
     */
    select?: userPasswordTokenSelect<ExtArgs> | null
  }



  /**
   * Model userPermission
   */

  export type AggregateUserPermission = {
    _count: UserPermissionCountAggregateOutputType | null
    _avg: UserPermissionAvgAggregateOutputType | null
    _sum: UserPermissionSumAggregateOutputType | null
    _min: UserPermissionMinAggregateOutputType | null
    _max: UserPermissionMaxAggregateOutputType | null
  }

  export type UserPermissionAvgAggregateOutputType = {
    id: number | null
  }

  export type UserPermissionSumAggregateOutputType = {
    id: number | null
  }

  export type UserPermissionMinAggregateOutputType = {
    id: number | null
    username: string | null
    role: string | null
    privilege: $Enums.users_permissions_privilege | null
  }

  export type UserPermissionMaxAggregateOutputType = {
    id: number | null
    username: string | null
    role: string | null
    privilege: $Enums.users_permissions_privilege | null
  }

  export type UserPermissionCountAggregateOutputType = {
    id: number
    username: number
    role: number
    privilege: number
    _all: number
  }


  export type UserPermissionAvgAggregateInputType = {
    id?: true
  }

  export type UserPermissionSumAggregateInputType = {
    id?: true
  }

  export type UserPermissionMinAggregateInputType = {
    id?: true
    username?: true
    role?: true
    privilege?: true
  }

  export type UserPermissionMaxAggregateInputType = {
    id?: true
    username?: true
    role?: true
    privilege?: true
  }

  export type UserPermissionCountAggregateInputType = {
    id?: true
    username?: true
    role?: true
    privilege?: true
    _all?: true
  }

  export type UserPermissionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which userPermission to aggregate.
     */
    where?: userPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userPermissions to fetch.
     */
    orderBy?: userPermissionOrderByWithRelationInput | userPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userPermissions
    **/
    _count?: true | UserPermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPermissionMaxAggregateInputType
  }

  export type GetUserPermissionAggregateType<T extends UserPermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPermission[P]>
      : GetScalarType<T[P], AggregateUserPermission[P]>
  }




  export type userPermissionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: userPermissionWhereInput
    orderBy?: userPermissionOrderByWithAggregationInput | userPermissionOrderByWithAggregationInput[]
    by: UserPermissionScalarFieldEnum[] | UserPermissionScalarFieldEnum
    having?: userPermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPermissionCountAggregateInputType | true
    _avg?: UserPermissionAvgAggregateInputType
    _sum?: UserPermissionSumAggregateInputType
    _min?: UserPermissionMinAggregateInputType
    _max?: UserPermissionMaxAggregateInputType
  }

  export type UserPermissionGroupByOutputType = {
    id: number
    username: string
    role: string
    privilege: $Enums.users_permissions_privilege
    _count: UserPermissionCountAggregateOutputType | null
    _avg: UserPermissionAvgAggregateOutputType | null
    _sum: UserPermissionSumAggregateOutputType | null
    _min: UserPermissionMinAggregateOutputType | null
    _max: UserPermissionMaxAggregateOutputType | null
  }

  type GetUserPermissionGroupByPayload<T extends userPermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPermissionGroupByOutputType[P]>
            : GetScalarType<T[P], UserPermissionGroupByOutputType[P]>
        }
      >
    >


  export type userPermissionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    role?: boolean
    privilege?: boolean
  }, ExtArgs["result"]["userPermission"]>

  export type userPermissionSelectScalar = {
    id?: boolean
    username?: boolean
    role?: boolean
    privilege?: boolean
  }


  export type $userPermissionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "userPermission"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: number
      username: string
      role: string
      privilege: $Enums.users_permissions_privilege
    }, ExtArgs["result"]["userPermission"]>
    composites: {}
  }


  type userPermissionGetPayload<S extends boolean | null | undefined | userPermissionDefaultArgs> = $Result.GetResult<Prisma.$userPermissionPayload, S>

  type userPermissionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<userPermissionFindManyArgs, 'select' | 'include'> & {
      select?: UserPermissionCountAggregateInputType | true
    }

  export interface userPermissionDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['userPermission'], meta: { name: 'userPermission' } }
    /**
     * Find zero or one UserPermission that matches the filter.
     * @param {userPermissionFindUniqueArgs} args - Arguments to find a UserPermission
     * @example
     * // Get one UserPermission
     * const userPermission = await prisma.userPermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends userPermissionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, userPermissionFindUniqueArgs<ExtArgs>>
    ): Prisma__userPermissionClient<$Result.GetResult<Prisma.$userPermissionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserPermission that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {userPermissionFindUniqueOrThrowArgs} args - Arguments to find a UserPermission
     * @example
     * // Get one UserPermission
     * const userPermission = await prisma.userPermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends userPermissionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userPermissionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__userPermissionClient<$Result.GetResult<Prisma.$userPermissionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserPermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userPermissionFindFirstArgs} args - Arguments to find a UserPermission
     * @example
     * // Get one UserPermission
     * const userPermission = await prisma.userPermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends userPermissionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, userPermissionFindFirstArgs<ExtArgs>>
    ): Prisma__userPermissionClient<$Result.GetResult<Prisma.$userPermissionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserPermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userPermissionFindFirstOrThrowArgs} args - Arguments to find a UserPermission
     * @example
     * // Get one UserPermission
     * const userPermission = await prisma.userPermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends userPermissionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userPermissionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__userPermissionClient<$Result.GetResult<Prisma.$userPermissionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserPermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userPermissionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPermissions
     * const userPermissions = await prisma.userPermission.findMany()
     * 
     * // Get first 10 UserPermissions
     * const userPermissions = await prisma.userPermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPermissionWithIdOnly = await prisma.userPermission.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends userPermissionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userPermissionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPermissionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserPermission.
     * @param {userPermissionCreateArgs} args - Arguments to create a UserPermission.
     * @example
     * // Create one UserPermission
     * const UserPermission = await prisma.userPermission.create({
     *   data: {
     *     // ... data to create a UserPermission
     *   }
     * })
     * 
    **/
    create<T extends userPermissionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, userPermissionCreateArgs<ExtArgs>>
    ): Prisma__userPermissionClient<$Result.GetResult<Prisma.$userPermissionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserPermissions.
     *     @param {userPermissionCreateManyArgs} args - Arguments to create many UserPermissions.
     *     @example
     *     // Create many UserPermissions
     *     const userPermission = await prisma.userPermission.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends userPermissionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userPermissionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserPermission.
     * @param {userPermissionDeleteArgs} args - Arguments to delete one UserPermission.
     * @example
     * // Delete one UserPermission
     * const UserPermission = await prisma.userPermission.delete({
     *   where: {
     *     // ... filter to delete one UserPermission
     *   }
     * })
     * 
    **/
    delete<T extends userPermissionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, userPermissionDeleteArgs<ExtArgs>>
    ): Prisma__userPermissionClient<$Result.GetResult<Prisma.$userPermissionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserPermission.
     * @param {userPermissionUpdateArgs} args - Arguments to update one UserPermission.
     * @example
     * // Update one UserPermission
     * const userPermission = await prisma.userPermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends userPermissionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, userPermissionUpdateArgs<ExtArgs>>
    ): Prisma__userPermissionClient<$Result.GetResult<Prisma.$userPermissionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserPermissions.
     * @param {userPermissionDeleteManyArgs} args - Arguments to filter UserPermissions to delete.
     * @example
     * // Delete a few UserPermissions
     * const { count } = await prisma.userPermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends userPermissionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userPermissionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userPermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPermissions
     * const userPermission = await prisma.userPermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends userPermissionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, userPermissionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserPermission.
     * @param {userPermissionUpsertArgs} args - Arguments to update or create a UserPermission.
     * @example
     * // Update or create a UserPermission
     * const userPermission = await prisma.userPermission.upsert({
     *   create: {
     *     // ... data to create a UserPermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPermission we want to update
     *   }
     * })
    **/
    upsert<T extends userPermissionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, userPermissionUpsertArgs<ExtArgs>>
    ): Prisma__userPermissionClient<$Result.GetResult<Prisma.$userPermissionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userPermissionCountArgs} args - Arguments to filter UserPermissions to count.
     * @example
     * // Count the number of UserPermissions
     * const count = await prisma.userPermission.count({
     *   where: {
     *     // ... the filter for the UserPermissions we want to count
     *   }
     * })
    **/
    count<T extends userPermissionCountArgs>(
      args?: Subset<T, userPermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPermissionAggregateArgs>(args: Subset<T, UserPermissionAggregateArgs>): Prisma.PrismaPromise<GetUserPermissionAggregateType<T>>

    /**
     * Group by UserPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userPermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userPermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userPermissionGroupByArgs['orderBy'] }
        : { orderBy?: userPermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userPermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the userPermission model
   */
  readonly fields: userPermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for userPermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userPermissionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the userPermission model
   */ 
  interface userPermissionFieldRefs {
    readonly id: FieldRef<"userPermission", 'Int'>
    readonly username: FieldRef<"userPermission", 'String'>
    readonly role: FieldRef<"userPermission", 'String'>
    readonly privilege: FieldRef<"userPermission", 'users_permissions_privilege'>
  }
    

  // Custom InputTypes

  /**
   * userPermission findUnique
   */
  export type userPermissionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userPermission
     */
    select?: userPermissionSelect<ExtArgs> | null
    /**
     * Filter, which userPermission to fetch.
     */
    where: userPermissionWhereUniqueInput
  }


  /**
   * userPermission findUniqueOrThrow
   */
  export type userPermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userPermission
     */
    select?: userPermissionSelect<ExtArgs> | null
    /**
     * Filter, which userPermission to fetch.
     */
    where: userPermissionWhereUniqueInput
  }


  /**
   * userPermission findFirst
   */
  export type userPermissionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userPermission
     */
    select?: userPermissionSelect<ExtArgs> | null
    /**
     * Filter, which userPermission to fetch.
     */
    where?: userPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userPermissions to fetch.
     */
    orderBy?: userPermissionOrderByWithRelationInput | userPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userPermissions.
     */
    cursor?: userPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userPermissions.
     */
    distinct?: UserPermissionScalarFieldEnum | UserPermissionScalarFieldEnum[]
  }


  /**
   * userPermission findFirstOrThrow
   */
  export type userPermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userPermission
     */
    select?: userPermissionSelect<ExtArgs> | null
    /**
     * Filter, which userPermission to fetch.
     */
    where?: userPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userPermissions to fetch.
     */
    orderBy?: userPermissionOrderByWithRelationInput | userPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userPermissions.
     */
    cursor?: userPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userPermissions.
     */
    distinct?: UserPermissionScalarFieldEnum | UserPermissionScalarFieldEnum[]
  }


  /**
   * userPermission findMany
   */
  export type userPermissionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userPermission
     */
    select?: userPermissionSelect<ExtArgs> | null
    /**
     * Filter, which userPermissions to fetch.
     */
    where?: userPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userPermissions to fetch.
     */
    orderBy?: userPermissionOrderByWithRelationInput | userPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userPermissions.
     */
    cursor?: userPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userPermissions.
     */
    skip?: number
    distinct?: UserPermissionScalarFieldEnum | UserPermissionScalarFieldEnum[]
  }


  /**
   * userPermission create
   */
  export type userPermissionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userPermission
     */
    select?: userPermissionSelect<ExtArgs> | null
    /**
     * The data needed to create a userPermission.
     */
    data: XOR<userPermissionCreateInput, userPermissionUncheckedCreateInput>
  }


  /**
   * userPermission createMany
   */
  export type userPermissionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many userPermissions.
     */
    data: userPermissionCreateManyInput | userPermissionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * userPermission update
   */
  export type userPermissionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userPermission
     */
    select?: userPermissionSelect<ExtArgs> | null
    /**
     * The data needed to update a userPermission.
     */
    data: XOR<userPermissionUpdateInput, userPermissionUncheckedUpdateInput>
    /**
     * Choose, which userPermission to update.
     */
    where: userPermissionWhereUniqueInput
  }


  /**
   * userPermission updateMany
   */
  export type userPermissionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update userPermissions.
     */
    data: XOR<userPermissionUpdateManyMutationInput, userPermissionUncheckedUpdateManyInput>
    /**
     * Filter which userPermissions to update
     */
    where?: userPermissionWhereInput
  }


  /**
   * userPermission upsert
   */
  export type userPermissionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userPermission
     */
    select?: userPermissionSelect<ExtArgs> | null
    /**
     * The filter to search for the userPermission to update in case it exists.
     */
    where: userPermissionWhereUniqueInput
    /**
     * In case the userPermission found by the `where` argument doesn't exist, create a new userPermission with this data.
     */
    create: XOR<userPermissionCreateInput, userPermissionUncheckedCreateInput>
    /**
     * In case the userPermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userPermissionUpdateInput, userPermissionUncheckedUpdateInput>
  }


  /**
   * userPermission delete
   */
  export type userPermissionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userPermission
     */
    select?: userPermissionSelect<ExtArgs> | null
    /**
     * Filter which userPermission to delete.
     */
    where: userPermissionWhereUniqueInput
  }


  /**
   * userPermission deleteMany
   */
  export type userPermissionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which userPermissions to delete
     */
    where?: userPermissionWhereInput
  }


  /**
   * userPermission without action
   */
  export type userPermissionDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userPermission
     */
    select?: userPermissionSelect<ExtArgs> | null
  }



  /**
   * Model users_points
   */

  export type AggregateUsers_points = {
    _count: Users_pointsCountAggregateOutputType | null
    _avg: Users_pointsAvgAggregateOutputType | null
    _sum: Users_pointsSumAggregateOutputType | null
    _min: Users_pointsMinAggregateOutputType | null
    _max: Users_pointsMaxAggregateOutputType | null
  }

  export type Users_pointsAvgAggregateOutputType = {
    ID: number | null
    ID_Utilisateur: number | null
    NbPoints: number | null
  }

  export type Users_pointsSumAggregateOutputType = {
    ID: number | null
    ID_Utilisateur: number | null
    NbPoints: number | null
  }

  export type Users_pointsMinAggregateOutputType = {
    ID: number | null
    ID_Utilisateur: number | null
    TypeContribution: $Enums.userContributionType | null
    NbPoints: number | null
  }

  export type Users_pointsMaxAggregateOutputType = {
    ID: number | null
    ID_Utilisateur: number | null
    TypeContribution: $Enums.userContributionType | null
    NbPoints: number | null
  }

  export type Users_pointsCountAggregateOutputType = {
    ID: number
    ID_Utilisateur: number
    TypeContribution: number
    NbPoints: number
    _all: number
  }


  export type Users_pointsAvgAggregateInputType = {
    ID?: true
    ID_Utilisateur?: true
    NbPoints?: true
  }

  export type Users_pointsSumAggregateInputType = {
    ID?: true
    ID_Utilisateur?: true
    NbPoints?: true
  }

  export type Users_pointsMinAggregateInputType = {
    ID?: true
    ID_Utilisateur?: true
    TypeContribution?: true
    NbPoints?: true
  }

  export type Users_pointsMaxAggregateInputType = {
    ID?: true
    ID_Utilisateur?: true
    TypeContribution?: true
    NbPoints?: true
  }

  export type Users_pointsCountAggregateInputType = {
    ID?: true
    ID_Utilisateur?: true
    TypeContribution?: true
    NbPoints?: true
    _all?: true
  }

  export type Users_pointsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which users_points to aggregate.
     */
    where?: users_pointsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_points to fetch.
     */
    orderBy?: users_pointsOrderByWithRelationInput | users_pointsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: users_pointsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_points from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_points.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users_points
    **/
    _count?: true | Users_pointsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Users_pointsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Users_pointsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Users_pointsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Users_pointsMaxAggregateInputType
  }

  export type GetUsers_pointsAggregateType<T extends Users_pointsAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers_points]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers_points[P]>
      : GetScalarType<T[P], AggregateUsers_points[P]>
  }




  export type users_pointsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: users_pointsWhereInput
    orderBy?: users_pointsOrderByWithAggregationInput | users_pointsOrderByWithAggregationInput[]
    by: Users_pointsScalarFieldEnum[] | Users_pointsScalarFieldEnum
    having?: users_pointsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Users_pointsCountAggregateInputType | true
    _avg?: Users_pointsAvgAggregateInputType
    _sum?: Users_pointsSumAggregateInputType
    _min?: Users_pointsMinAggregateInputType
    _max?: Users_pointsMaxAggregateInputType
  }

  export type Users_pointsGroupByOutputType = {
    ID: number
    ID_Utilisateur: number
    TypeContribution: $Enums.userContributionType
    NbPoints: number | null
    _count: Users_pointsCountAggregateOutputType | null
    _avg: Users_pointsAvgAggregateOutputType | null
    _sum: Users_pointsSumAggregateOutputType | null
    _min: Users_pointsMinAggregateOutputType | null
    _max: Users_pointsMaxAggregateOutputType | null
  }

  type GetUsers_pointsGroupByPayload<T extends users_pointsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Users_pointsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Users_pointsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Users_pointsGroupByOutputType[P]>
            : GetScalarType<T[P], Users_pointsGroupByOutputType[P]>
        }
      >
    >


  export type users_pointsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    ID_Utilisateur?: boolean
    TypeContribution?: boolean
    NbPoints?: boolean
  }, ExtArgs["result"]["users_points"]>

  export type users_pointsSelectScalar = {
    ID?: boolean
    ID_Utilisateur?: boolean
    TypeContribution?: boolean
    NbPoints?: boolean
  }


  export type $users_pointsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "users_points"
    objects: {}
    scalars: $Extensions.GetResult<{
      ID: number
      ID_Utilisateur: number
      TypeContribution: $Enums.userContributionType
      NbPoints: number | null
    }, ExtArgs["result"]["users_points"]>
    composites: {}
  }


  type users_pointsGetPayload<S extends boolean | null | undefined | users_pointsDefaultArgs> = $Result.GetResult<Prisma.$users_pointsPayload, S>

  type users_pointsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<users_pointsFindManyArgs, 'select' | 'include'> & {
      select?: Users_pointsCountAggregateInputType | true
    }

  export interface users_pointsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users_points'], meta: { name: 'users_points' } }
    /**
     * Find zero or one Users_points that matches the filter.
     * @param {users_pointsFindUniqueArgs} args - Arguments to find a Users_points
     * @example
     * // Get one Users_points
     * const users_points = await prisma.users_points.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends users_pointsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, users_pointsFindUniqueArgs<ExtArgs>>
    ): Prisma__users_pointsClient<$Result.GetResult<Prisma.$users_pointsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Users_points that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {users_pointsFindUniqueOrThrowArgs} args - Arguments to find a Users_points
     * @example
     * // Get one Users_points
     * const users_points = await prisma.users_points.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends users_pointsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, users_pointsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__users_pointsClient<$Result.GetResult<Prisma.$users_pointsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Users_points that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_pointsFindFirstArgs} args - Arguments to find a Users_points
     * @example
     * // Get one Users_points
     * const users_points = await prisma.users_points.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends users_pointsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, users_pointsFindFirstArgs<ExtArgs>>
    ): Prisma__users_pointsClient<$Result.GetResult<Prisma.$users_pointsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Users_points that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_pointsFindFirstOrThrowArgs} args - Arguments to find a Users_points
     * @example
     * // Get one Users_points
     * const users_points = await prisma.users_points.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends users_pointsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, users_pointsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__users_pointsClient<$Result.GetResult<Prisma.$users_pointsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users_points that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_pointsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users_points
     * const users_points = await prisma.users_points.findMany()
     * 
     * // Get first 10 Users_points
     * const users_points = await prisma.users_points.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const users_pointsWithIDOnly = await prisma.users_points.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends users_pointsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, users_pointsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$users_pointsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Users_points.
     * @param {users_pointsCreateArgs} args - Arguments to create a Users_points.
     * @example
     * // Create one Users_points
     * const Users_points = await prisma.users_points.create({
     *   data: {
     *     // ... data to create a Users_points
     *   }
     * })
     * 
    **/
    create<T extends users_pointsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, users_pointsCreateArgs<ExtArgs>>
    ): Prisma__users_pointsClient<$Result.GetResult<Prisma.$users_pointsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users_points.
     *     @param {users_pointsCreateManyArgs} args - Arguments to create many Users_points.
     *     @example
     *     // Create many Users_points
     *     const users_points = await prisma.users_points.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends users_pointsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, users_pointsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users_points.
     * @param {users_pointsDeleteArgs} args - Arguments to delete one Users_points.
     * @example
     * // Delete one Users_points
     * const Users_points = await prisma.users_points.delete({
     *   where: {
     *     // ... filter to delete one Users_points
     *   }
     * })
     * 
    **/
    delete<T extends users_pointsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, users_pointsDeleteArgs<ExtArgs>>
    ): Prisma__users_pointsClient<$Result.GetResult<Prisma.$users_pointsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Users_points.
     * @param {users_pointsUpdateArgs} args - Arguments to update one Users_points.
     * @example
     * // Update one Users_points
     * const users_points = await prisma.users_points.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends users_pointsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, users_pointsUpdateArgs<ExtArgs>>
    ): Prisma__users_pointsClient<$Result.GetResult<Prisma.$users_pointsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users_points.
     * @param {users_pointsDeleteManyArgs} args - Arguments to filter Users_points to delete.
     * @example
     * // Delete a few Users_points
     * const { count } = await prisma.users_points.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends users_pointsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, users_pointsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users_points.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_pointsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users_points
     * const users_points = await prisma.users_points.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends users_pointsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, users_pointsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users_points.
     * @param {users_pointsUpsertArgs} args - Arguments to update or create a Users_points.
     * @example
     * // Update or create a Users_points
     * const users_points = await prisma.users_points.upsert({
     *   create: {
     *     // ... data to create a Users_points
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users_points we want to update
     *   }
     * })
    **/
    upsert<T extends users_pointsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, users_pointsUpsertArgs<ExtArgs>>
    ): Prisma__users_pointsClient<$Result.GetResult<Prisma.$users_pointsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users_points.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_pointsCountArgs} args - Arguments to filter Users_points to count.
     * @example
     * // Count the number of Users_points
     * const count = await prisma.users_points.count({
     *   where: {
     *     // ... the filter for the Users_points we want to count
     *   }
     * })
    **/
    count<T extends users_pointsCountArgs>(
      args?: Subset<T, users_pointsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Users_pointsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users_points.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Users_pointsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Users_pointsAggregateArgs>(args: Subset<T, Users_pointsAggregateArgs>): Prisma.PrismaPromise<GetUsers_pointsAggregateType<T>>

    /**
     * Group by Users_points.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_pointsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends users_pointsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: users_pointsGroupByArgs['orderBy'] }
        : { orderBy?: users_pointsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, users_pointsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsers_pointsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users_points model
   */
  readonly fields: users_pointsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users_points.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__users_pointsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the users_points model
   */ 
  interface users_pointsFieldRefs {
    readonly ID: FieldRef<"users_points", 'Int'>
    readonly ID_Utilisateur: FieldRef<"users_points", 'Int'>
    readonly TypeContribution: FieldRef<"users_points", 'userContributionType'>
    readonly NbPoints: FieldRef<"users_points", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * users_points findUnique
   */
  export type users_pointsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_points
     */
    select?: users_pointsSelect<ExtArgs> | null
    /**
     * Filter, which users_points to fetch.
     */
    where: users_pointsWhereUniqueInput
  }


  /**
   * users_points findUniqueOrThrow
   */
  export type users_pointsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_points
     */
    select?: users_pointsSelect<ExtArgs> | null
    /**
     * Filter, which users_points to fetch.
     */
    where: users_pointsWhereUniqueInput
  }


  /**
   * users_points findFirst
   */
  export type users_pointsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_points
     */
    select?: users_pointsSelect<ExtArgs> | null
    /**
     * Filter, which users_points to fetch.
     */
    where?: users_pointsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_points to fetch.
     */
    orderBy?: users_pointsOrderByWithRelationInput | users_pointsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users_points.
     */
    cursor?: users_pointsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_points from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_points.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users_points.
     */
    distinct?: Users_pointsScalarFieldEnum | Users_pointsScalarFieldEnum[]
  }


  /**
   * users_points findFirstOrThrow
   */
  export type users_pointsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_points
     */
    select?: users_pointsSelect<ExtArgs> | null
    /**
     * Filter, which users_points to fetch.
     */
    where?: users_pointsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_points to fetch.
     */
    orderBy?: users_pointsOrderByWithRelationInput | users_pointsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users_points.
     */
    cursor?: users_pointsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_points from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_points.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users_points.
     */
    distinct?: Users_pointsScalarFieldEnum | Users_pointsScalarFieldEnum[]
  }


  /**
   * users_points findMany
   */
  export type users_pointsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_points
     */
    select?: users_pointsSelect<ExtArgs> | null
    /**
     * Filter, which users_points to fetch.
     */
    where?: users_pointsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_points to fetch.
     */
    orderBy?: users_pointsOrderByWithRelationInput | users_pointsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users_points.
     */
    cursor?: users_pointsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_points from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_points.
     */
    skip?: number
    distinct?: Users_pointsScalarFieldEnum | Users_pointsScalarFieldEnum[]
  }


  /**
   * users_points create
   */
  export type users_pointsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_points
     */
    select?: users_pointsSelect<ExtArgs> | null
    /**
     * The data needed to create a users_points.
     */
    data: XOR<users_pointsCreateInput, users_pointsUncheckedCreateInput>
  }


  /**
   * users_points createMany
   */
  export type users_pointsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users_points.
     */
    data: users_pointsCreateManyInput | users_pointsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * users_points update
   */
  export type users_pointsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_points
     */
    select?: users_pointsSelect<ExtArgs> | null
    /**
     * The data needed to update a users_points.
     */
    data: XOR<users_pointsUpdateInput, users_pointsUncheckedUpdateInput>
    /**
     * Choose, which users_points to update.
     */
    where: users_pointsWhereUniqueInput
  }


  /**
   * users_points updateMany
   */
  export type users_pointsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users_points.
     */
    data: XOR<users_pointsUpdateManyMutationInput, users_pointsUncheckedUpdateManyInput>
    /**
     * Filter which users_points to update
     */
    where?: users_pointsWhereInput
  }


  /**
   * users_points upsert
   */
  export type users_pointsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_points
     */
    select?: users_pointsSelect<ExtArgs> | null
    /**
     * The filter to search for the users_points to update in case it exists.
     */
    where: users_pointsWhereUniqueInput
    /**
     * In case the users_points found by the `where` argument doesn't exist, create a new users_points with this data.
     */
    create: XOR<users_pointsCreateInput, users_pointsUncheckedCreateInput>
    /**
     * In case the users_points was found with the provided `where` argument, update it with this data.
     */
    update: XOR<users_pointsUpdateInput, users_pointsUncheckedUpdateInput>
  }


  /**
   * users_points delete
   */
  export type users_pointsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_points
     */
    select?: users_pointsSelect<ExtArgs> | null
    /**
     * Filter which users_points to delete.
     */
    where: users_pointsWhereUniqueInput
  }


  /**
   * users_points deleteMany
   */
  export type users_pointsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which users_points to delete
     */
    where?: users_pointsWhereInput
  }


  /**
   * users_points without action
   */
  export type users_pointsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_points
     */
    select?: users_pointsSelect<ExtArgs> | null
  }



  /**
   * Model userSuggestionNotification
   */

  export type AggregateUserSuggestionNotification = {
    _count: UserSuggestionNotificationCountAggregateOutputType | null
    _avg: UserSuggestionNotificationAvgAggregateOutputType | null
    _sum: UserSuggestionNotificationSumAggregateOutputType | null
    _min: UserSuggestionNotificationMinAggregateOutputType | null
    _max: UserSuggestionNotificationMaxAggregateOutputType | null
  }

  export type UserSuggestionNotificationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserSuggestionNotificationSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserSuggestionNotificationMinAggregateOutputType = {
    id: number | null
    userId: number | null
    issuecode: string | null
    text: string | null
    date: Date | null
  }

  export type UserSuggestionNotificationMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    issuecode: string | null
    text: string | null
    date: Date | null
  }

  export type UserSuggestionNotificationCountAggregateOutputType = {
    id: number
    userId: number
    issuecode: number
    text: number
    date: number
    _all: number
  }


  export type UserSuggestionNotificationAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserSuggestionNotificationSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserSuggestionNotificationMinAggregateInputType = {
    id?: true
    userId?: true
    issuecode?: true
    text?: true
    date?: true
  }

  export type UserSuggestionNotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    issuecode?: true
    text?: true
    date?: true
  }

  export type UserSuggestionNotificationCountAggregateInputType = {
    id?: true
    userId?: true
    issuecode?: true
    text?: true
    date?: true
    _all?: true
  }

  export type UserSuggestionNotificationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which userSuggestionNotification to aggregate.
     */
    where?: userSuggestionNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userSuggestionNotifications to fetch.
     */
    orderBy?: userSuggestionNotificationOrderByWithRelationInput | userSuggestionNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userSuggestionNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userSuggestionNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userSuggestionNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userSuggestionNotifications
    **/
    _count?: true | UserSuggestionNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserSuggestionNotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSuggestionNotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSuggestionNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSuggestionNotificationMaxAggregateInputType
  }

  export type GetUserSuggestionNotificationAggregateType<T extends UserSuggestionNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSuggestionNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSuggestionNotification[P]>
      : GetScalarType<T[P], AggregateUserSuggestionNotification[P]>
  }




  export type userSuggestionNotificationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: userSuggestionNotificationWhereInput
    orderBy?: userSuggestionNotificationOrderByWithAggregationInput | userSuggestionNotificationOrderByWithAggregationInput[]
    by: UserSuggestionNotificationScalarFieldEnum[] | UserSuggestionNotificationScalarFieldEnum
    having?: userSuggestionNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSuggestionNotificationCountAggregateInputType | true
    _avg?: UserSuggestionNotificationAvgAggregateInputType
    _sum?: UserSuggestionNotificationSumAggregateInputType
    _min?: UserSuggestionNotificationMinAggregateInputType
    _max?: UserSuggestionNotificationMaxAggregateInputType
  }

  export type UserSuggestionNotificationGroupByOutputType = {
    id: number
    userId: number
    issuecode: string
    text: string | null
    date: Date | null
    _count: UserSuggestionNotificationCountAggregateOutputType | null
    _avg: UserSuggestionNotificationAvgAggregateOutputType | null
    _sum: UserSuggestionNotificationSumAggregateOutputType | null
    _min: UserSuggestionNotificationMinAggregateOutputType | null
    _max: UserSuggestionNotificationMaxAggregateOutputType | null
  }

  type GetUserSuggestionNotificationGroupByPayload<T extends userSuggestionNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSuggestionNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSuggestionNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSuggestionNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], UserSuggestionNotificationGroupByOutputType[P]>
        }
      >
    >


  export type userSuggestionNotificationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    issuecode?: boolean
    text?: boolean
    date?: boolean
  }, ExtArgs["result"]["userSuggestionNotification"]>

  export type userSuggestionNotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    issuecode?: boolean
    text?: boolean
    date?: boolean
  }


  export type $userSuggestionNotificationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "userSuggestionNotification"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: number
      userId: number
      issuecode: string
      text: string | null
      date: Date | null
    }, ExtArgs["result"]["userSuggestionNotification"]>
    composites: {}
  }


  type userSuggestionNotificationGetPayload<S extends boolean | null | undefined | userSuggestionNotificationDefaultArgs> = $Result.GetResult<Prisma.$userSuggestionNotificationPayload, S>

  type userSuggestionNotificationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<userSuggestionNotificationFindManyArgs, 'select' | 'include'> & {
      select?: UserSuggestionNotificationCountAggregateInputType | true
    }

  export interface userSuggestionNotificationDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['userSuggestionNotification'], meta: { name: 'userSuggestionNotification' } }
    /**
     * Find zero or one UserSuggestionNotification that matches the filter.
     * @param {userSuggestionNotificationFindUniqueArgs} args - Arguments to find a UserSuggestionNotification
     * @example
     * // Get one UserSuggestionNotification
     * const userSuggestionNotification = await prisma.userSuggestionNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends userSuggestionNotificationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, userSuggestionNotificationFindUniqueArgs<ExtArgs>>
    ): Prisma__userSuggestionNotificationClient<$Result.GetResult<Prisma.$userSuggestionNotificationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserSuggestionNotification that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {userSuggestionNotificationFindUniqueOrThrowArgs} args - Arguments to find a UserSuggestionNotification
     * @example
     * // Get one UserSuggestionNotification
     * const userSuggestionNotification = await prisma.userSuggestionNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends userSuggestionNotificationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userSuggestionNotificationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__userSuggestionNotificationClient<$Result.GetResult<Prisma.$userSuggestionNotificationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserSuggestionNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userSuggestionNotificationFindFirstArgs} args - Arguments to find a UserSuggestionNotification
     * @example
     * // Get one UserSuggestionNotification
     * const userSuggestionNotification = await prisma.userSuggestionNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends userSuggestionNotificationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, userSuggestionNotificationFindFirstArgs<ExtArgs>>
    ): Prisma__userSuggestionNotificationClient<$Result.GetResult<Prisma.$userSuggestionNotificationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserSuggestionNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userSuggestionNotificationFindFirstOrThrowArgs} args - Arguments to find a UserSuggestionNotification
     * @example
     * // Get one UserSuggestionNotification
     * const userSuggestionNotification = await prisma.userSuggestionNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends userSuggestionNotificationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userSuggestionNotificationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__userSuggestionNotificationClient<$Result.GetResult<Prisma.$userSuggestionNotificationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserSuggestionNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userSuggestionNotificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSuggestionNotifications
     * const userSuggestionNotifications = await prisma.userSuggestionNotification.findMany()
     * 
     * // Get first 10 UserSuggestionNotifications
     * const userSuggestionNotifications = await prisma.userSuggestionNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSuggestionNotificationWithIdOnly = await prisma.userSuggestionNotification.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends userSuggestionNotificationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userSuggestionNotificationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userSuggestionNotificationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserSuggestionNotification.
     * @param {userSuggestionNotificationCreateArgs} args - Arguments to create a UserSuggestionNotification.
     * @example
     * // Create one UserSuggestionNotification
     * const UserSuggestionNotification = await prisma.userSuggestionNotification.create({
     *   data: {
     *     // ... data to create a UserSuggestionNotification
     *   }
     * })
     * 
    **/
    create<T extends userSuggestionNotificationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, userSuggestionNotificationCreateArgs<ExtArgs>>
    ): Prisma__userSuggestionNotificationClient<$Result.GetResult<Prisma.$userSuggestionNotificationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserSuggestionNotifications.
     *     @param {userSuggestionNotificationCreateManyArgs} args - Arguments to create many UserSuggestionNotifications.
     *     @example
     *     // Create many UserSuggestionNotifications
     *     const userSuggestionNotification = await prisma.userSuggestionNotification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends userSuggestionNotificationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userSuggestionNotificationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserSuggestionNotification.
     * @param {userSuggestionNotificationDeleteArgs} args - Arguments to delete one UserSuggestionNotification.
     * @example
     * // Delete one UserSuggestionNotification
     * const UserSuggestionNotification = await prisma.userSuggestionNotification.delete({
     *   where: {
     *     // ... filter to delete one UserSuggestionNotification
     *   }
     * })
     * 
    **/
    delete<T extends userSuggestionNotificationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, userSuggestionNotificationDeleteArgs<ExtArgs>>
    ): Prisma__userSuggestionNotificationClient<$Result.GetResult<Prisma.$userSuggestionNotificationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserSuggestionNotification.
     * @param {userSuggestionNotificationUpdateArgs} args - Arguments to update one UserSuggestionNotification.
     * @example
     * // Update one UserSuggestionNotification
     * const userSuggestionNotification = await prisma.userSuggestionNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends userSuggestionNotificationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, userSuggestionNotificationUpdateArgs<ExtArgs>>
    ): Prisma__userSuggestionNotificationClient<$Result.GetResult<Prisma.$userSuggestionNotificationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserSuggestionNotifications.
     * @param {userSuggestionNotificationDeleteManyArgs} args - Arguments to filter UserSuggestionNotifications to delete.
     * @example
     * // Delete a few UserSuggestionNotifications
     * const { count } = await prisma.userSuggestionNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends userSuggestionNotificationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userSuggestionNotificationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSuggestionNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userSuggestionNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSuggestionNotifications
     * const userSuggestionNotification = await prisma.userSuggestionNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends userSuggestionNotificationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, userSuggestionNotificationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserSuggestionNotification.
     * @param {userSuggestionNotificationUpsertArgs} args - Arguments to update or create a UserSuggestionNotification.
     * @example
     * // Update or create a UserSuggestionNotification
     * const userSuggestionNotification = await prisma.userSuggestionNotification.upsert({
     *   create: {
     *     // ... data to create a UserSuggestionNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSuggestionNotification we want to update
     *   }
     * })
    **/
    upsert<T extends userSuggestionNotificationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, userSuggestionNotificationUpsertArgs<ExtArgs>>
    ): Prisma__userSuggestionNotificationClient<$Result.GetResult<Prisma.$userSuggestionNotificationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserSuggestionNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userSuggestionNotificationCountArgs} args - Arguments to filter UserSuggestionNotifications to count.
     * @example
     * // Count the number of UserSuggestionNotifications
     * const count = await prisma.userSuggestionNotification.count({
     *   where: {
     *     // ... the filter for the UserSuggestionNotifications we want to count
     *   }
     * })
    **/
    count<T extends userSuggestionNotificationCountArgs>(
      args?: Subset<T, userSuggestionNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSuggestionNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSuggestionNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSuggestionNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSuggestionNotificationAggregateArgs>(args: Subset<T, UserSuggestionNotificationAggregateArgs>): Prisma.PrismaPromise<GetUserSuggestionNotificationAggregateType<T>>

    /**
     * Group by UserSuggestionNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userSuggestionNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userSuggestionNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userSuggestionNotificationGroupByArgs['orderBy'] }
        : { orderBy?: userSuggestionNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userSuggestionNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSuggestionNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the userSuggestionNotification model
   */
  readonly fields: userSuggestionNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for userSuggestionNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userSuggestionNotificationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the userSuggestionNotification model
   */ 
  interface userSuggestionNotificationFieldRefs {
    readonly id: FieldRef<"userSuggestionNotification", 'Int'>
    readonly userId: FieldRef<"userSuggestionNotification", 'Int'>
    readonly issuecode: FieldRef<"userSuggestionNotification", 'String'>
    readonly text: FieldRef<"userSuggestionNotification", 'String'>
    readonly date: FieldRef<"userSuggestionNotification", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * userSuggestionNotification findUnique
   */
  export type userSuggestionNotificationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userSuggestionNotification
     */
    select?: userSuggestionNotificationSelect<ExtArgs> | null
    /**
     * Filter, which userSuggestionNotification to fetch.
     */
    where: userSuggestionNotificationWhereUniqueInput
  }


  /**
   * userSuggestionNotification findUniqueOrThrow
   */
  export type userSuggestionNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userSuggestionNotification
     */
    select?: userSuggestionNotificationSelect<ExtArgs> | null
    /**
     * Filter, which userSuggestionNotification to fetch.
     */
    where: userSuggestionNotificationWhereUniqueInput
  }


  /**
   * userSuggestionNotification findFirst
   */
  export type userSuggestionNotificationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userSuggestionNotification
     */
    select?: userSuggestionNotificationSelect<ExtArgs> | null
    /**
     * Filter, which userSuggestionNotification to fetch.
     */
    where?: userSuggestionNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userSuggestionNotifications to fetch.
     */
    orderBy?: userSuggestionNotificationOrderByWithRelationInput | userSuggestionNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userSuggestionNotifications.
     */
    cursor?: userSuggestionNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userSuggestionNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userSuggestionNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userSuggestionNotifications.
     */
    distinct?: UserSuggestionNotificationScalarFieldEnum | UserSuggestionNotificationScalarFieldEnum[]
  }


  /**
   * userSuggestionNotification findFirstOrThrow
   */
  export type userSuggestionNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userSuggestionNotification
     */
    select?: userSuggestionNotificationSelect<ExtArgs> | null
    /**
     * Filter, which userSuggestionNotification to fetch.
     */
    where?: userSuggestionNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userSuggestionNotifications to fetch.
     */
    orderBy?: userSuggestionNotificationOrderByWithRelationInput | userSuggestionNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userSuggestionNotifications.
     */
    cursor?: userSuggestionNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userSuggestionNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userSuggestionNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userSuggestionNotifications.
     */
    distinct?: UserSuggestionNotificationScalarFieldEnum | UserSuggestionNotificationScalarFieldEnum[]
  }


  /**
   * userSuggestionNotification findMany
   */
  export type userSuggestionNotificationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userSuggestionNotification
     */
    select?: userSuggestionNotificationSelect<ExtArgs> | null
    /**
     * Filter, which userSuggestionNotifications to fetch.
     */
    where?: userSuggestionNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userSuggestionNotifications to fetch.
     */
    orderBy?: userSuggestionNotificationOrderByWithRelationInput | userSuggestionNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userSuggestionNotifications.
     */
    cursor?: userSuggestionNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userSuggestionNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userSuggestionNotifications.
     */
    skip?: number
    distinct?: UserSuggestionNotificationScalarFieldEnum | UserSuggestionNotificationScalarFieldEnum[]
  }


  /**
   * userSuggestionNotification create
   */
  export type userSuggestionNotificationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userSuggestionNotification
     */
    select?: userSuggestionNotificationSelect<ExtArgs> | null
    /**
     * The data needed to create a userSuggestionNotification.
     */
    data: XOR<userSuggestionNotificationCreateInput, userSuggestionNotificationUncheckedCreateInput>
  }


  /**
   * userSuggestionNotification createMany
   */
  export type userSuggestionNotificationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many userSuggestionNotifications.
     */
    data: userSuggestionNotificationCreateManyInput | userSuggestionNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * userSuggestionNotification update
   */
  export type userSuggestionNotificationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userSuggestionNotification
     */
    select?: userSuggestionNotificationSelect<ExtArgs> | null
    /**
     * The data needed to update a userSuggestionNotification.
     */
    data: XOR<userSuggestionNotificationUpdateInput, userSuggestionNotificationUncheckedUpdateInput>
    /**
     * Choose, which userSuggestionNotification to update.
     */
    where: userSuggestionNotificationWhereUniqueInput
  }


  /**
   * userSuggestionNotification updateMany
   */
  export type userSuggestionNotificationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update userSuggestionNotifications.
     */
    data: XOR<userSuggestionNotificationUpdateManyMutationInput, userSuggestionNotificationUncheckedUpdateManyInput>
    /**
     * Filter which userSuggestionNotifications to update
     */
    where?: userSuggestionNotificationWhereInput
  }


  /**
   * userSuggestionNotification upsert
   */
  export type userSuggestionNotificationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userSuggestionNotification
     */
    select?: userSuggestionNotificationSelect<ExtArgs> | null
    /**
     * The filter to search for the userSuggestionNotification to update in case it exists.
     */
    where: userSuggestionNotificationWhereUniqueInput
    /**
     * In case the userSuggestionNotification found by the `where` argument doesn't exist, create a new userSuggestionNotification with this data.
     */
    create: XOR<userSuggestionNotificationCreateInput, userSuggestionNotificationUncheckedCreateInput>
    /**
     * In case the userSuggestionNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userSuggestionNotificationUpdateInput, userSuggestionNotificationUncheckedUpdateInput>
  }


  /**
   * userSuggestionNotification delete
   */
  export type userSuggestionNotificationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userSuggestionNotification
     */
    select?: userSuggestionNotificationSelect<ExtArgs> | null
    /**
     * Filter which userSuggestionNotification to delete.
     */
    where: userSuggestionNotificationWhereUniqueInput
  }


  /**
   * userSuggestionNotification deleteMany
   */
  export type userSuggestionNotificationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which userSuggestionNotifications to delete
     */
    where?: userSuggestionNotificationWhereInput
  }


  /**
   * userSuggestionNotification without action
   */
  export type userSuggestionNotificationDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userSuggestionNotification
     */
    select?: userSuggestionNotificationSelect<ExtArgs> | null
  }



  /**
   * Model requestedIssue
   */

  export type AggregateRequestedIssue = {
    _count: RequestedIssueCountAggregateOutputType | null
    _avg: RequestedIssueAvgAggregateOutputType | null
    _sum: RequestedIssueSumAggregateOutputType | null
    _min: RequestedIssueMinAggregateOutputType | null
    _max: RequestedIssueMaxAggregateOutputType | null
  }

  export type RequestedIssueAvgAggregateOutputType = {
    id: number | null
    issueId: number | null
    buyerId: number | null
  }

  export type RequestedIssueSumAggregateOutputType = {
    id: number | null
    issueId: number | null
    buyerId: number | null
  }

  export type RequestedIssueMinAggregateOutputType = {
    id: number | null
    issueId: number | null
    buyerId: number | null
    isBooked: boolean | null
  }

  export type RequestedIssueMaxAggregateOutputType = {
    id: number | null
    issueId: number | null
    buyerId: number | null
    isBooked: boolean | null
  }

  export type RequestedIssueCountAggregateOutputType = {
    id: number
    issueId: number
    buyerId: number
    isBooked: number
    _all: number
  }


  export type RequestedIssueAvgAggregateInputType = {
    id?: true
    issueId?: true
    buyerId?: true
  }

  export type RequestedIssueSumAggregateInputType = {
    id?: true
    issueId?: true
    buyerId?: true
  }

  export type RequestedIssueMinAggregateInputType = {
    id?: true
    issueId?: true
    buyerId?: true
    isBooked?: true
  }

  export type RequestedIssueMaxAggregateInputType = {
    id?: true
    issueId?: true
    buyerId?: true
    isBooked?: true
  }

  export type RequestedIssueCountAggregateInputType = {
    id?: true
    issueId?: true
    buyerId?: true
    isBooked?: true
    _all?: true
  }

  export type RequestedIssueAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which requestedIssue to aggregate.
     */
    where?: requestedIssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requestedIssues to fetch.
     */
    orderBy?: requestedIssueOrderByWithRelationInput | requestedIssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: requestedIssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requestedIssues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requestedIssues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned requestedIssues
    **/
    _count?: true | RequestedIssueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestedIssueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestedIssueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestedIssueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestedIssueMaxAggregateInputType
  }

  export type GetRequestedIssueAggregateType<T extends RequestedIssueAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestedIssue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestedIssue[P]>
      : GetScalarType<T[P], AggregateRequestedIssue[P]>
  }




  export type requestedIssueGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: requestedIssueWhereInput
    orderBy?: requestedIssueOrderByWithAggregationInput | requestedIssueOrderByWithAggregationInput[]
    by: RequestedIssueScalarFieldEnum[] | RequestedIssueScalarFieldEnum
    having?: requestedIssueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestedIssueCountAggregateInputType | true
    _avg?: RequestedIssueAvgAggregateInputType
    _sum?: RequestedIssueSumAggregateInputType
    _min?: RequestedIssueMinAggregateInputType
    _max?: RequestedIssueMaxAggregateInputType
  }

  export type RequestedIssueGroupByOutputType = {
    id: number
    issueId: number
    buyerId: number
    isBooked: boolean
    _count: RequestedIssueCountAggregateOutputType | null
    _avg: RequestedIssueAvgAggregateOutputType | null
    _sum: RequestedIssueSumAggregateOutputType | null
    _min: RequestedIssueMinAggregateOutputType | null
    _max: RequestedIssueMaxAggregateOutputType | null
  }

  type GetRequestedIssueGroupByPayload<T extends requestedIssueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequestedIssueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestedIssueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestedIssueGroupByOutputType[P]>
            : GetScalarType<T[P], RequestedIssueGroupByOutputType[P]>
        }
      >
    >


  export type requestedIssueSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    issueId?: boolean
    buyerId?: boolean
    isBooked?: boolean
  }, ExtArgs["result"]["requestedIssue"]>

  export type requestedIssueSelectScalar = {
    id?: boolean
    issueId?: boolean
    buyerId?: boolean
    isBooked?: boolean
  }


  export type $requestedIssuePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "requestedIssue"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: number
      issueId: number
      buyerId: number
      isBooked: boolean
    }, ExtArgs["result"]["requestedIssue"]>
    composites: {}
  }


  type requestedIssueGetPayload<S extends boolean | null | undefined | requestedIssueDefaultArgs> = $Result.GetResult<Prisma.$requestedIssuePayload, S>

  type requestedIssueCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<requestedIssueFindManyArgs, 'select' | 'include'> & {
      select?: RequestedIssueCountAggregateInputType | true
    }

  export interface requestedIssueDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['requestedIssue'], meta: { name: 'requestedIssue' } }
    /**
     * Find zero or one RequestedIssue that matches the filter.
     * @param {requestedIssueFindUniqueArgs} args - Arguments to find a RequestedIssue
     * @example
     * // Get one RequestedIssue
     * const requestedIssue = await prisma.requestedIssue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends requestedIssueFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, requestedIssueFindUniqueArgs<ExtArgs>>
    ): Prisma__requestedIssueClient<$Result.GetResult<Prisma.$requestedIssuePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RequestedIssue that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {requestedIssueFindUniqueOrThrowArgs} args - Arguments to find a RequestedIssue
     * @example
     * // Get one RequestedIssue
     * const requestedIssue = await prisma.requestedIssue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends requestedIssueFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, requestedIssueFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__requestedIssueClient<$Result.GetResult<Prisma.$requestedIssuePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RequestedIssue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requestedIssueFindFirstArgs} args - Arguments to find a RequestedIssue
     * @example
     * // Get one RequestedIssue
     * const requestedIssue = await prisma.requestedIssue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends requestedIssueFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, requestedIssueFindFirstArgs<ExtArgs>>
    ): Prisma__requestedIssueClient<$Result.GetResult<Prisma.$requestedIssuePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RequestedIssue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requestedIssueFindFirstOrThrowArgs} args - Arguments to find a RequestedIssue
     * @example
     * // Get one RequestedIssue
     * const requestedIssue = await prisma.requestedIssue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends requestedIssueFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, requestedIssueFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__requestedIssueClient<$Result.GetResult<Prisma.$requestedIssuePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RequestedIssues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requestedIssueFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestedIssues
     * const requestedIssues = await prisma.requestedIssue.findMany()
     * 
     * // Get first 10 RequestedIssues
     * const requestedIssues = await prisma.requestedIssue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestedIssueWithIdOnly = await prisma.requestedIssue.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends requestedIssueFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, requestedIssueFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$requestedIssuePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RequestedIssue.
     * @param {requestedIssueCreateArgs} args - Arguments to create a RequestedIssue.
     * @example
     * // Create one RequestedIssue
     * const RequestedIssue = await prisma.requestedIssue.create({
     *   data: {
     *     // ... data to create a RequestedIssue
     *   }
     * })
     * 
    **/
    create<T extends requestedIssueCreateArgs<ExtArgs>>(
      args: SelectSubset<T, requestedIssueCreateArgs<ExtArgs>>
    ): Prisma__requestedIssueClient<$Result.GetResult<Prisma.$requestedIssuePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RequestedIssues.
     *     @param {requestedIssueCreateManyArgs} args - Arguments to create many RequestedIssues.
     *     @example
     *     // Create many RequestedIssues
     *     const requestedIssue = await prisma.requestedIssue.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends requestedIssueCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, requestedIssueCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RequestedIssue.
     * @param {requestedIssueDeleteArgs} args - Arguments to delete one RequestedIssue.
     * @example
     * // Delete one RequestedIssue
     * const RequestedIssue = await prisma.requestedIssue.delete({
     *   where: {
     *     // ... filter to delete one RequestedIssue
     *   }
     * })
     * 
    **/
    delete<T extends requestedIssueDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, requestedIssueDeleteArgs<ExtArgs>>
    ): Prisma__requestedIssueClient<$Result.GetResult<Prisma.$requestedIssuePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RequestedIssue.
     * @param {requestedIssueUpdateArgs} args - Arguments to update one RequestedIssue.
     * @example
     * // Update one RequestedIssue
     * const requestedIssue = await prisma.requestedIssue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends requestedIssueUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, requestedIssueUpdateArgs<ExtArgs>>
    ): Prisma__requestedIssueClient<$Result.GetResult<Prisma.$requestedIssuePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RequestedIssues.
     * @param {requestedIssueDeleteManyArgs} args - Arguments to filter RequestedIssues to delete.
     * @example
     * // Delete a few RequestedIssues
     * const { count } = await prisma.requestedIssue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends requestedIssueDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, requestedIssueDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestedIssues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requestedIssueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestedIssues
     * const requestedIssue = await prisma.requestedIssue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends requestedIssueUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, requestedIssueUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RequestedIssue.
     * @param {requestedIssueUpsertArgs} args - Arguments to update or create a RequestedIssue.
     * @example
     * // Update or create a RequestedIssue
     * const requestedIssue = await prisma.requestedIssue.upsert({
     *   create: {
     *     // ... data to create a RequestedIssue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestedIssue we want to update
     *   }
     * })
    **/
    upsert<T extends requestedIssueUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, requestedIssueUpsertArgs<ExtArgs>>
    ): Prisma__requestedIssueClient<$Result.GetResult<Prisma.$requestedIssuePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RequestedIssues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requestedIssueCountArgs} args - Arguments to filter RequestedIssues to count.
     * @example
     * // Count the number of RequestedIssues
     * const count = await prisma.requestedIssue.count({
     *   where: {
     *     // ... the filter for the RequestedIssues we want to count
     *   }
     * })
    **/
    count<T extends requestedIssueCountArgs>(
      args?: Subset<T, requestedIssueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestedIssueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestedIssue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestedIssueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestedIssueAggregateArgs>(args: Subset<T, RequestedIssueAggregateArgs>): Prisma.PrismaPromise<GetRequestedIssueAggregateType<T>>

    /**
     * Group by RequestedIssue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requestedIssueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends requestedIssueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: requestedIssueGroupByArgs['orderBy'] }
        : { orderBy?: requestedIssueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, requestedIssueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestedIssueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the requestedIssue model
   */
  readonly fields: requestedIssueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for requestedIssue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__requestedIssueClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the requestedIssue model
   */ 
  interface requestedIssueFieldRefs {
    readonly id: FieldRef<"requestedIssue", 'Int'>
    readonly issueId: FieldRef<"requestedIssue", 'Int'>
    readonly buyerId: FieldRef<"requestedIssue", 'Int'>
    readonly isBooked: FieldRef<"requestedIssue", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * requestedIssue findUnique
   */
  export type requestedIssueFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requestedIssue
     */
    select?: requestedIssueSelect<ExtArgs> | null
    /**
     * Filter, which requestedIssue to fetch.
     */
    where: requestedIssueWhereUniqueInput
  }


  /**
   * requestedIssue findUniqueOrThrow
   */
  export type requestedIssueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requestedIssue
     */
    select?: requestedIssueSelect<ExtArgs> | null
    /**
     * Filter, which requestedIssue to fetch.
     */
    where: requestedIssueWhereUniqueInput
  }


  /**
   * requestedIssue findFirst
   */
  export type requestedIssueFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requestedIssue
     */
    select?: requestedIssueSelect<ExtArgs> | null
    /**
     * Filter, which requestedIssue to fetch.
     */
    where?: requestedIssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requestedIssues to fetch.
     */
    orderBy?: requestedIssueOrderByWithRelationInput | requestedIssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for requestedIssues.
     */
    cursor?: requestedIssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requestedIssues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requestedIssues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of requestedIssues.
     */
    distinct?: RequestedIssueScalarFieldEnum | RequestedIssueScalarFieldEnum[]
  }


  /**
   * requestedIssue findFirstOrThrow
   */
  export type requestedIssueFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requestedIssue
     */
    select?: requestedIssueSelect<ExtArgs> | null
    /**
     * Filter, which requestedIssue to fetch.
     */
    where?: requestedIssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requestedIssues to fetch.
     */
    orderBy?: requestedIssueOrderByWithRelationInput | requestedIssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for requestedIssues.
     */
    cursor?: requestedIssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requestedIssues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requestedIssues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of requestedIssues.
     */
    distinct?: RequestedIssueScalarFieldEnum | RequestedIssueScalarFieldEnum[]
  }


  /**
   * requestedIssue findMany
   */
  export type requestedIssueFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requestedIssue
     */
    select?: requestedIssueSelect<ExtArgs> | null
    /**
     * Filter, which requestedIssues to fetch.
     */
    where?: requestedIssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requestedIssues to fetch.
     */
    orderBy?: requestedIssueOrderByWithRelationInput | requestedIssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing requestedIssues.
     */
    cursor?: requestedIssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requestedIssues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requestedIssues.
     */
    skip?: number
    distinct?: RequestedIssueScalarFieldEnum | RequestedIssueScalarFieldEnum[]
  }


  /**
   * requestedIssue create
   */
  export type requestedIssueCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requestedIssue
     */
    select?: requestedIssueSelect<ExtArgs> | null
    /**
     * The data needed to create a requestedIssue.
     */
    data: XOR<requestedIssueCreateInput, requestedIssueUncheckedCreateInput>
  }


  /**
   * requestedIssue createMany
   */
  export type requestedIssueCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many requestedIssues.
     */
    data: requestedIssueCreateManyInput | requestedIssueCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * requestedIssue update
   */
  export type requestedIssueUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requestedIssue
     */
    select?: requestedIssueSelect<ExtArgs> | null
    /**
     * The data needed to update a requestedIssue.
     */
    data: XOR<requestedIssueUpdateInput, requestedIssueUncheckedUpdateInput>
    /**
     * Choose, which requestedIssue to update.
     */
    where: requestedIssueWhereUniqueInput
  }


  /**
   * requestedIssue updateMany
   */
  export type requestedIssueUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update requestedIssues.
     */
    data: XOR<requestedIssueUpdateManyMutationInput, requestedIssueUncheckedUpdateManyInput>
    /**
     * Filter which requestedIssues to update
     */
    where?: requestedIssueWhereInput
  }


  /**
   * requestedIssue upsert
   */
  export type requestedIssueUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requestedIssue
     */
    select?: requestedIssueSelect<ExtArgs> | null
    /**
     * The filter to search for the requestedIssue to update in case it exists.
     */
    where: requestedIssueWhereUniqueInput
    /**
     * In case the requestedIssue found by the `where` argument doesn't exist, create a new requestedIssue with this data.
     */
    create: XOR<requestedIssueCreateInput, requestedIssueUncheckedCreateInput>
    /**
     * In case the requestedIssue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<requestedIssueUpdateInput, requestedIssueUncheckedUpdateInput>
  }


  /**
   * requestedIssue delete
   */
  export type requestedIssueDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requestedIssue
     */
    select?: requestedIssueSelect<ExtArgs> | null
    /**
     * Filter which requestedIssue to delete.
     */
    where: requestedIssueWhereUniqueInput
  }


  /**
   * requestedIssue deleteMany
   */
  export type requestedIssueDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which requestedIssues to delete
     */
    where?: requestedIssueWhereInput
  }


  /**
   * requestedIssue without action
   */
  export type requestedIssueDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requestedIssue
     */
    select?: requestedIssueSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    country: 'country',
    magazine: 'magazine',
    startDate: 'startDate',
    endDate: 'endDate'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const Abonnements_sortiesScalarFieldEnum: {
    Pays: 'Pays',
    Magazine: 'Magazine',
    Numero: 'Numero',
    Date_sortie: 'Date_sortie',
    Numeros_ajoutes: 'Numeros_ajoutes'
  };

  export type Abonnements_sortiesScalarFieldEnum = (typeof Abonnements_sortiesScalarFieldEnum)[keyof typeof Abonnements_sortiesScalarFieldEnum]


  export const PurchaseScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    date: 'date',
    description: 'description'
  };

  export type PurchaseScalarFieldEnum = (typeof PurchaseScalarFieldEnum)[keyof typeof PurchaseScalarFieldEnum]


  export const AuthorUserScalarFieldEnum: {
    id: 'id',
    personcode: 'personcode',
    userId: 'userId',
    notation: 'notation'
  };

  export type AuthorUserScalarFieldEnum = (typeof AuthorUserScalarFieldEnum)[keyof typeof AuthorUserScalarFieldEnum]


  export const Bibliotheque_contributeursScalarFieldEnum: {
    ID: 'ID',
    Nom: 'Nom',
    Texte: 'Texte'
  };

  export type Bibliotheque_contributeursScalarFieldEnum = (typeof Bibliotheque_contributeursScalarFieldEnum)[keyof typeof Bibliotheque_contributeursScalarFieldEnum]


  export const BookcasePublicationOrderScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    publicationcode: 'publicationcode',
    order: 'order'
  };

  export type BookcasePublicationOrderScalarFieldEnum = (typeof BookcasePublicationOrderScalarFieldEnum)[keyof typeof BookcasePublicationOrderScalarFieldEnum]


  export const BookstoreScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    coordX: 'coordX',
    coordY: 'coordY'
  };

  export type BookstoreScalarFieldEnum = (typeof BookstoreScalarFieldEnum)[keyof typeof BookstoreScalarFieldEnum]


  export const BookstoreCommentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    comment: 'comment',
    creationDate: 'creationDate',
    isActive: 'isActive',
    bookstoreId: 'bookstoreId'
  };

  export type BookstoreCommentScalarFieldEnum = (typeof BookstoreCommentScalarFieldEnum)[keyof typeof BookstoreCommentScalarFieldEnum]


  export const DemoScalarFieldEnum: {
    id: 'id',
    lastReset: 'lastReset'
  };

  export type DemoScalarFieldEnum = (typeof DemoScalarFieldEnum)[keyof typeof DemoScalarFieldEnum]


  export const MagazinesScalarFieldEnum: {
    PaysAbrege: 'PaysAbrege',
    NomAbrege: 'NomAbrege',
    NomComplet: 'NomComplet',
    RedirigeDepuis: 'RedirigeDepuis',
    NeParaitPlus: 'NeParaitPlus'
  };

  export type MagazinesScalarFieldEnum = (typeof MagazinesScalarFieldEnum)[keyof typeof MagazinesScalarFieldEnum]


  export const IssueScalarFieldEnum: {
    id: 'id',
    country: 'country',
    magazine: 'magazine',
    issuenumber: 'issuenumber',
    condition: 'condition',
    purchaseId: 'purchaseId',
    isOnSale: 'isOnSale',
    isToRead: 'isToRead',
    isSubscription: 'isSubscription',
    userId: 'userId',
    creationDate: 'creationDate'
  };

  export type IssueScalarFieldEnum = (typeof IssueScalarFieldEnum)[keyof typeof IssueScalarFieldEnum]


  export const IssuePopularityScalarFieldEnum: {
    country: 'country',
    magazine: 'magazine',
    issuenumber: 'issuenumber',
    popularity: 'popularity',
    id: 'id'
  };

  export type IssuePopularityScalarFieldEnum = (typeof IssuePopularityScalarFieldEnum)[keyof typeof IssuePopularityScalarFieldEnum]


  export const Tranches_doublonsScalarFieldEnum: {
    ID: 'ID',
    Pays: 'Pays',
    Magazine: 'Magazine',
    Numero: 'Numero',
    NumeroReference: 'NumeroReference',
    TrancheReference: 'TrancheReference'
  };

  export type Tranches_doublonsScalarFieldEnum = (typeof Tranches_doublonsScalarFieldEnum)[keyof typeof Tranches_doublonsScalarFieldEnum]


  export const EdgeScalarFieldEnum: {
    id: 'id',
    publicationcode: 'publicationcode',
    issuenumber: 'issuenumber',
    creationDate: 'creationDate',
    points: 'points',
    slug: 'slug',
    issuecode: 'issuecode'
  };

  export type EdgeScalarFieldEnum = (typeof EdgeScalarFieldEnum)[keyof typeof EdgeScalarFieldEnum]


  export const Tranches_pretes_contributeursScalarFieldEnum: {
    publicationcode: 'publicationcode',
    issuenumber: 'issuenumber',
    contributeur: 'contributeur',
    contribution: 'contribution'
  };

  export type Tranches_pretes_contributeursScalarFieldEnum = (typeof Tranches_pretes_contributeursScalarFieldEnum)[keyof typeof Tranches_pretes_contributeursScalarFieldEnum]


  export const Tranches_pretes_contributionsScalarFieldEnum: {
    ID: 'ID',
    ID_tranche: 'ID_tranche',
    ID_user: 'ID_user',
    dateajout: 'dateajout',
    contribution: 'contribution',
    points_new: 'points_new',
    points_total: 'points_total'
  };

  export type Tranches_pretes_contributionsScalarFieldEnum = (typeof Tranches_pretes_contributionsScalarFieldEnum)[keyof typeof Tranches_pretes_contributionsScalarFieldEnum]


  export const EdgeSpriteScalarFieldEnum: {
    id: 'id',
    edgeId: 'edgeId',
    spriteName: 'spriteName',
    spriteSize: 'spriteSize'
  };

  export type EdgeSpriteScalarFieldEnum = (typeof EdgeSpriteScalarFieldEnum)[keyof typeof EdgeSpriteScalarFieldEnum]


  export const EdgeSpriteSizeScalarFieldEnum: {
    id: 'id',
    spriteName: 'spriteName',
    size: 'size'
  };

  export type EdgeSpriteSizeScalarFieldEnum = (typeof EdgeSpriteSizeScalarFieldEnum)[keyof typeof EdgeSpriteSizeScalarFieldEnum]


  export const EdgeSpriteUrlScalarFieldEnum: {
    id: 'id',
    spriteName: 'spriteName',
    version: 'version'
  };

  export type EdgeSpriteUrlScalarFieldEnum = (typeof EdgeSpriteUrlScalarFieldEnum)[keyof typeof EdgeSpriteUrlScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    allowSharing: 'allowSharing',
    signupDate: 'signupDate',
    email: 'email',
    discordId: 'discordId',
    showRecommendations: 'showRecommendations',
    isBetaUser: 'isBetaUser',
    showPresentationVideo: 'showPresentationVideo',
    showDuplicatesInBookcase: 'showDuplicatesInBookcase',
    bookcaseTexture1: 'bookcaseTexture1',
    bookcaseSubTexture1: 'bookcaseSubTexture1',
    bookcaseTexture2: 'bookcaseTexture2',
    bookcaseSubTexture2: 'bookcaseSubTexture2',
    presentationText: 'presentationText',
    lastAccess: 'lastAccess',
    previousAccess: 'previousAccess',
    marketplaceAcceptsExchanges: 'marketplaceAcceptsExchanges'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserContributionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    date: 'date',
    contribution: 'contribution',
    newPoints: 'newPoints',
    totalPoints: 'totalPoints',
    isEmailSent: 'isEmailSent',
    edgeId: 'edgeId',
    bookstoreId: 'bookstoreId',
    bookstoreCommentId: 'bookstoreCommentId'
  };

  export type UserContributionScalarFieldEnum = (typeof UserContributionScalarFieldEnum)[keyof typeof UserContributionScalarFieldEnum]


  export const UserOptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    optionName: 'optionName',
    optionValue: 'optionValue'
  };

  export type UserOptionScalarFieldEnum = (typeof UserOptionScalarFieldEnum)[keyof typeof UserOptionScalarFieldEnum]


  export const UserPasswordTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token'
  };

  export type UserPasswordTokenScalarFieldEnum = (typeof UserPasswordTokenScalarFieldEnum)[keyof typeof UserPasswordTokenScalarFieldEnum]


  export const UserPermissionScalarFieldEnum: {
    id: 'id',
    username: 'username',
    role: 'role',
    privilege: 'privilege'
  };

  export type UserPermissionScalarFieldEnum = (typeof UserPermissionScalarFieldEnum)[keyof typeof UserPermissionScalarFieldEnum]


  export const Users_pointsScalarFieldEnum: {
    ID: 'ID',
    ID_Utilisateur: 'ID_Utilisateur',
    TypeContribution: 'TypeContribution',
    NbPoints: 'NbPoints'
  };

  export type Users_pointsScalarFieldEnum = (typeof Users_pointsScalarFieldEnum)[keyof typeof Users_pointsScalarFieldEnum]


  export const UserSuggestionNotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    issuecode: 'issuecode',
    text: 'text',
    date: 'date'
  };

  export type UserSuggestionNotificationScalarFieldEnum = (typeof UserSuggestionNotificationScalarFieldEnum)[keyof typeof UserSuggestionNotificationScalarFieldEnum]


  export const RequestedIssueScalarFieldEnum: {
    id: 'id',
    issueId: 'issueId',
    buyerId: 'buyerId',
    isBooked: 'isBooked'
  };

  export type RequestedIssueScalarFieldEnum = (typeof RequestedIssueScalarFieldEnum)[keyof typeof RequestedIssueScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'issue_condition'
   */
  export type Enumissue_conditionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'issue_condition'>
    


  /**
   * Reference to a field of type 'tranches_pretes_contributeurs_contribution'
   */
  export type Enumtranches_pretes_contributeurs_contributionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'tranches_pretes_contributeurs_contribution'>
    


  /**
   * Reference to a field of type 'tranches_pretes_contributions_contribution'
   */
  export type Enumtranches_pretes_contributions_contributionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'tranches_pretes_contributions_contribution'>
    


  /**
   * Reference to a field of type 'userOptionType'
   */
  export type EnumuserOptionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'userOptionType'>
    


  /**
   * Reference to a field of type 'users_permissions_privilege'
   */
  export type Enumusers_permissions_privilegeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'users_permissions_privilege'>
    


  /**
   * Reference to a field of type 'userContributionType'
   */
  export type EnumuserContributionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'userContributionType'>
    
  /**
   * Deep Input Types
   */


  export type subscriptionWhereInput = {
    AND?: subscriptionWhereInput | subscriptionWhereInput[]
    OR?: subscriptionWhereInput[]
    NOT?: subscriptionWhereInput | subscriptionWhereInput[]
    id?: IntFilter<"subscription"> | number
    userId?: IntFilter<"subscription"> | number
    country?: StringFilter<"subscription"> | string
    magazine?: StringFilter<"subscription"> | string
    startDate?: DateTimeFilter<"subscription"> | Date | string
    endDate?: DateTimeFilter<"subscription"> | Date | string
    users?: XOR<UserRelationFilter, userWhereInput>
  }

  export type subscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    country?: SortOrder
    magazine?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    users?: userOrderByWithRelationInput
  }

  export type subscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    country_magazine_userId_startDate_endDate?: subscriptionCountryMagazineUserIdStartDateEndDateCompoundUniqueInput
    AND?: subscriptionWhereInput | subscriptionWhereInput[]
    OR?: subscriptionWhereInput[]
    NOT?: subscriptionWhereInput | subscriptionWhereInput[]
    userId?: IntFilter<"subscription"> | number
    country?: StringFilter<"subscription"> | string
    magazine?: StringFilter<"subscription"> | string
    startDate?: DateTimeFilter<"subscription"> | Date | string
    endDate?: DateTimeFilter<"subscription"> | Date | string
    users?: XOR<UserRelationFilter, userWhereInput>
  }, "id" | "country_magazine_userId_startDate_endDate">

  export type subscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    country?: SortOrder
    magazine?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    _count?: subscriptionCountOrderByAggregateInput
    _avg?: subscriptionAvgOrderByAggregateInput
    _max?: subscriptionMaxOrderByAggregateInput
    _min?: subscriptionMinOrderByAggregateInput
    _sum?: subscriptionSumOrderByAggregateInput
  }

  export type subscriptionScalarWhereWithAggregatesInput = {
    AND?: subscriptionScalarWhereWithAggregatesInput | subscriptionScalarWhereWithAggregatesInput[]
    OR?: subscriptionScalarWhereWithAggregatesInput[]
    NOT?: subscriptionScalarWhereWithAggregatesInput | subscriptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"subscription"> | number
    userId?: IntWithAggregatesFilter<"subscription"> | number
    country?: StringWithAggregatesFilter<"subscription"> | string
    magazine?: StringWithAggregatesFilter<"subscription"> | string
    startDate?: DateTimeWithAggregatesFilter<"subscription"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"subscription"> | Date | string
  }

  export type abonnements_sortiesWhereInput = {
    AND?: abonnements_sortiesWhereInput | abonnements_sortiesWhereInput[]
    OR?: abonnements_sortiesWhereInput[]
    NOT?: abonnements_sortiesWhereInput | abonnements_sortiesWhereInput[]
    Pays?: StringFilter<"abonnements_sorties"> | string
    Magazine?: StringFilter<"abonnements_sorties"> | string
    Numero?: StringFilter<"abonnements_sorties"> | string
    Date_sortie?: DateTimeFilter<"abonnements_sorties"> | Date | string
    Numeros_ajoutes?: BoolFilter<"abonnements_sorties"> | boolean
  }

  export type abonnements_sortiesOrderByWithRelationInput = {
    Pays?: SortOrder
    Magazine?: SortOrder
    Numero?: SortOrder
    Date_sortie?: SortOrder
    Numeros_ajoutes?: SortOrder
  }

  export type abonnements_sortiesWhereUniqueInput = Prisma.AtLeast<{
    Pays_Magazine_Numero?: abonnements_sortiesPaysMagazineNumeroCompoundUniqueInput
    AND?: abonnements_sortiesWhereInput | abonnements_sortiesWhereInput[]
    OR?: abonnements_sortiesWhereInput[]
    NOT?: abonnements_sortiesWhereInput | abonnements_sortiesWhereInput[]
    Pays?: StringFilter<"abonnements_sorties"> | string
    Magazine?: StringFilter<"abonnements_sorties"> | string
    Numero?: StringFilter<"abonnements_sorties"> | string
    Date_sortie?: DateTimeFilter<"abonnements_sorties"> | Date | string
    Numeros_ajoutes?: BoolFilter<"abonnements_sorties"> | boolean
  }, "Pays_Magazine_Numero">

  export type abonnements_sortiesOrderByWithAggregationInput = {
    Pays?: SortOrder
    Magazine?: SortOrder
    Numero?: SortOrder
    Date_sortie?: SortOrder
    Numeros_ajoutes?: SortOrder
    _count?: abonnements_sortiesCountOrderByAggregateInput
    _max?: abonnements_sortiesMaxOrderByAggregateInput
    _min?: abonnements_sortiesMinOrderByAggregateInput
  }

  export type abonnements_sortiesScalarWhereWithAggregatesInput = {
    AND?: abonnements_sortiesScalarWhereWithAggregatesInput | abonnements_sortiesScalarWhereWithAggregatesInput[]
    OR?: abonnements_sortiesScalarWhereWithAggregatesInput[]
    NOT?: abonnements_sortiesScalarWhereWithAggregatesInput | abonnements_sortiesScalarWhereWithAggregatesInput[]
    Pays?: StringWithAggregatesFilter<"abonnements_sorties"> | string
    Magazine?: StringWithAggregatesFilter<"abonnements_sorties"> | string
    Numero?: StringWithAggregatesFilter<"abonnements_sorties"> | string
    Date_sortie?: DateTimeWithAggregatesFilter<"abonnements_sorties"> | Date | string
    Numeros_ajoutes?: BoolWithAggregatesFilter<"abonnements_sorties"> | boolean
  }

  export type purchaseWhereInput = {
    AND?: purchaseWhereInput | purchaseWhereInput[]
    OR?: purchaseWhereInput[]
    NOT?: purchaseWhereInput | purchaseWhereInput[]
    id?: IntFilter<"purchase"> | number
    userId?: IntFilter<"purchase"> | number
    date?: DateTimeFilter<"purchase"> | Date | string
    description?: StringFilter<"purchase"> | string
  }

  export type purchaseOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    description?: SortOrder
  }

  export type purchaseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_date_description?: purchaseUserIdDateDescriptionCompoundUniqueInput
    AND?: purchaseWhereInput | purchaseWhereInput[]
    OR?: purchaseWhereInput[]
    NOT?: purchaseWhereInput | purchaseWhereInput[]
    userId?: IntFilter<"purchase"> | number
    date?: DateTimeFilter<"purchase"> | Date | string
    description?: StringFilter<"purchase"> | string
  }, "id" | "userId_date_description">

  export type purchaseOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    description?: SortOrder
    _count?: purchaseCountOrderByAggregateInput
    _avg?: purchaseAvgOrderByAggregateInput
    _max?: purchaseMaxOrderByAggregateInput
    _min?: purchaseMinOrderByAggregateInput
    _sum?: purchaseSumOrderByAggregateInput
  }

  export type purchaseScalarWhereWithAggregatesInput = {
    AND?: purchaseScalarWhereWithAggregatesInput | purchaseScalarWhereWithAggregatesInput[]
    OR?: purchaseScalarWhereWithAggregatesInput[]
    NOT?: purchaseScalarWhereWithAggregatesInput | purchaseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"purchase"> | number
    userId?: IntWithAggregatesFilter<"purchase"> | number
    date?: DateTimeWithAggregatesFilter<"purchase"> | Date | string
    description?: StringWithAggregatesFilter<"purchase"> | string
  }

  export type authorUserWhereInput = {
    AND?: authorUserWhereInput | authorUserWhereInput[]
    OR?: authorUserWhereInput[]
    NOT?: authorUserWhereInput | authorUserWhereInput[]
    id?: IntFilter<"authorUser"> | number
    personcode?: StringFilter<"authorUser"> | string
    userId?: IntFilter<"authorUser"> | number
    notation?: IntFilter<"authorUser"> | number
  }

  export type authorUserOrderByWithRelationInput = {
    id?: SortOrder
    personcode?: SortOrder
    userId?: SortOrder
    notation?: SortOrder
  }

  export type authorUserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_personcode?: authorUserUserIdPersoncodeCompoundUniqueInput
    AND?: authorUserWhereInput | authorUserWhereInput[]
    OR?: authorUserWhereInput[]
    NOT?: authorUserWhereInput | authorUserWhereInput[]
    personcode?: StringFilter<"authorUser"> | string
    userId?: IntFilter<"authorUser"> | number
    notation?: IntFilter<"authorUser"> | number
  }, "id" | "userId_personcode">

  export type authorUserOrderByWithAggregationInput = {
    id?: SortOrder
    personcode?: SortOrder
    userId?: SortOrder
    notation?: SortOrder
    _count?: authorUserCountOrderByAggregateInput
    _avg?: authorUserAvgOrderByAggregateInput
    _max?: authorUserMaxOrderByAggregateInput
    _min?: authorUserMinOrderByAggregateInput
    _sum?: authorUserSumOrderByAggregateInput
  }

  export type authorUserScalarWhereWithAggregatesInput = {
    AND?: authorUserScalarWhereWithAggregatesInput | authorUserScalarWhereWithAggregatesInput[]
    OR?: authorUserScalarWhereWithAggregatesInput[]
    NOT?: authorUserScalarWhereWithAggregatesInput | authorUserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"authorUser"> | number
    personcode?: StringWithAggregatesFilter<"authorUser"> | string
    userId?: IntWithAggregatesFilter<"authorUser"> | number
    notation?: IntWithAggregatesFilter<"authorUser"> | number
  }

  export type bibliotheque_contributeursWhereInput = {
    AND?: bibliotheque_contributeursWhereInput | bibliotheque_contributeursWhereInput[]
    OR?: bibliotheque_contributeursWhereInput[]
    NOT?: bibliotheque_contributeursWhereInput | bibliotheque_contributeursWhereInput[]
    ID?: IntFilter<"bibliotheque_contributeurs"> | number
    Nom?: StringNullableFilter<"bibliotheque_contributeurs"> | string | null
    Texte?: StringNullableFilter<"bibliotheque_contributeurs"> | string | null
  }

  export type bibliotheque_contributeursOrderByWithRelationInput = {
    ID?: SortOrder
    Nom?: SortOrderInput | SortOrder
    Texte?: SortOrderInput | SortOrder
  }

  export type bibliotheque_contributeursWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: bibliotheque_contributeursWhereInput | bibliotheque_contributeursWhereInput[]
    OR?: bibliotheque_contributeursWhereInput[]
    NOT?: bibliotheque_contributeursWhereInput | bibliotheque_contributeursWhereInput[]
    Nom?: StringNullableFilter<"bibliotheque_contributeurs"> | string | null
    Texte?: StringNullableFilter<"bibliotheque_contributeurs"> | string | null
  }, "ID">

  export type bibliotheque_contributeursOrderByWithAggregationInput = {
    ID?: SortOrder
    Nom?: SortOrderInput | SortOrder
    Texte?: SortOrderInput | SortOrder
    _count?: bibliotheque_contributeursCountOrderByAggregateInput
    _avg?: bibliotheque_contributeursAvgOrderByAggregateInput
    _max?: bibliotheque_contributeursMaxOrderByAggregateInput
    _min?: bibliotheque_contributeursMinOrderByAggregateInput
    _sum?: bibliotheque_contributeursSumOrderByAggregateInput
  }

  export type bibliotheque_contributeursScalarWhereWithAggregatesInput = {
    AND?: bibliotheque_contributeursScalarWhereWithAggregatesInput | bibliotheque_contributeursScalarWhereWithAggregatesInput[]
    OR?: bibliotheque_contributeursScalarWhereWithAggregatesInput[]
    NOT?: bibliotheque_contributeursScalarWhereWithAggregatesInput | bibliotheque_contributeursScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"bibliotheque_contributeurs"> | number
    Nom?: StringNullableWithAggregatesFilter<"bibliotheque_contributeurs"> | string | null
    Texte?: StringNullableWithAggregatesFilter<"bibliotheque_contributeurs"> | string | null
  }

  export type bookcasePublicationOrderWhereInput = {
    AND?: bookcasePublicationOrderWhereInput | bookcasePublicationOrderWhereInput[]
    OR?: bookcasePublicationOrderWhereInput[]
    NOT?: bookcasePublicationOrderWhereInput | bookcasePublicationOrderWhereInput[]
    id?: IntFilter<"bookcasePublicationOrder"> | number
    userId?: IntFilter<"bookcasePublicationOrder"> | number
    publicationcode?: StringFilter<"bookcasePublicationOrder"> | string
    order?: IntFilter<"bookcasePublicationOrder"> | number
  }

  export type bookcasePublicationOrderOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    publicationcode?: SortOrder
    order?: SortOrder
  }

  export type bookcasePublicationOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_publicationcode?: bookcasePublicationOrderUserIdPublicationcodeCompoundUniqueInput
    AND?: bookcasePublicationOrderWhereInput | bookcasePublicationOrderWhereInput[]
    OR?: bookcasePublicationOrderWhereInput[]
    NOT?: bookcasePublicationOrderWhereInput | bookcasePublicationOrderWhereInput[]
    userId?: IntFilter<"bookcasePublicationOrder"> | number
    publicationcode?: StringFilter<"bookcasePublicationOrder"> | string
    order?: IntFilter<"bookcasePublicationOrder"> | number
  }, "id" | "userId_publicationcode">

  export type bookcasePublicationOrderOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    publicationcode?: SortOrder
    order?: SortOrder
    _count?: bookcasePublicationOrderCountOrderByAggregateInput
    _avg?: bookcasePublicationOrderAvgOrderByAggregateInput
    _max?: bookcasePublicationOrderMaxOrderByAggregateInput
    _min?: bookcasePublicationOrderMinOrderByAggregateInput
    _sum?: bookcasePublicationOrderSumOrderByAggregateInput
  }

  export type bookcasePublicationOrderScalarWhereWithAggregatesInput = {
    AND?: bookcasePublicationOrderScalarWhereWithAggregatesInput | bookcasePublicationOrderScalarWhereWithAggregatesInput[]
    OR?: bookcasePublicationOrderScalarWhereWithAggregatesInput[]
    NOT?: bookcasePublicationOrderScalarWhereWithAggregatesInput | bookcasePublicationOrderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"bookcasePublicationOrder"> | number
    userId?: IntWithAggregatesFilter<"bookcasePublicationOrder"> | number
    publicationcode?: StringWithAggregatesFilter<"bookcasePublicationOrder"> | string
    order?: IntWithAggregatesFilter<"bookcasePublicationOrder"> | number
  }

  export type bookstoreWhereInput = {
    AND?: bookstoreWhereInput | bookstoreWhereInput[]
    OR?: bookstoreWhereInput[]
    NOT?: bookstoreWhereInput | bookstoreWhereInput[]
    id?: IntFilter<"bookstore"> | number
    name?: StringFilter<"bookstore"> | string
    address?: StringFilter<"bookstore"> | string
    coordX?: FloatFilter<"bookstore"> | number
    coordY?: FloatFilter<"bookstore"> | number
    comments?: BookstoreCommentListRelationFilter
    users_contributions?: UserContributionListRelationFilter
  }

  export type bookstoreOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    coordX?: SortOrder
    coordY?: SortOrder
    comments?: bookstoreCommentOrderByRelationAggregateInput
    users_contributions?: userContributionOrderByRelationAggregateInput
  }

  export type bookstoreWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: bookstoreWhereInput | bookstoreWhereInput[]
    OR?: bookstoreWhereInput[]
    NOT?: bookstoreWhereInput | bookstoreWhereInput[]
    name?: StringFilter<"bookstore"> | string
    address?: StringFilter<"bookstore"> | string
    coordX?: FloatFilter<"bookstore"> | number
    coordY?: FloatFilter<"bookstore"> | number
    comments?: BookstoreCommentListRelationFilter
    users_contributions?: UserContributionListRelationFilter
  }, "id">

  export type bookstoreOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    coordX?: SortOrder
    coordY?: SortOrder
    _count?: bookstoreCountOrderByAggregateInput
    _avg?: bookstoreAvgOrderByAggregateInput
    _max?: bookstoreMaxOrderByAggregateInput
    _min?: bookstoreMinOrderByAggregateInput
    _sum?: bookstoreSumOrderByAggregateInput
  }

  export type bookstoreScalarWhereWithAggregatesInput = {
    AND?: bookstoreScalarWhereWithAggregatesInput | bookstoreScalarWhereWithAggregatesInput[]
    OR?: bookstoreScalarWhereWithAggregatesInput[]
    NOT?: bookstoreScalarWhereWithAggregatesInput | bookstoreScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"bookstore"> | number
    name?: StringWithAggregatesFilter<"bookstore"> | string
    address?: StringWithAggregatesFilter<"bookstore"> | string
    coordX?: FloatWithAggregatesFilter<"bookstore"> | number
    coordY?: FloatWithAggregatesFilter<"bookstore"> | number
  }

  export type bookstoreCommentWhereInput = {
    AND?: bookstoreCommentWhereInput | bookstoreCommentWhereInput[]
    OR?: bookstoreCommentWhereInput[]
    NOT?: bookstoreCommentWhereInput | bookstoreCommentWhereInput[]
    id?: IntFilter<"bookstoreComment"> | number
    userId?: IntNullableFilter<"bookstoreComment"> | number | null
    comment?: StringFilter<"bookstoreComment"> | string
    creationDate?: DateTimeFilter<"bookstoreComment"> | Date | string
    isActive?: BoolFilter<"bookstoreComment"> | boolean
    bookstoreId?: IntFilter<"bookstoreComment"> | number
    bouquineries?: XOR<BookstoreRelationFilter, bookstoreWhereInput>
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
    users_contributions?: UserContributionListRelationFilter
  }

  export type bookstoreCommentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    comment?: SortOrder
    creationDate?: SortOrder
    isActive?: SortOrder
    bookstoreId?: SortOrder
    bouquineries?: bookstoreOrderByWithRelationInput
    user?: userOrderByWithRelationInput
    users_contributions?: userContributionOrderByRelationAggregateInput
  }

  export type bookstoreCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: bookstoreCommentWhereInput | bookstoreCommentWhereInput[]
    OR?: bookstoreCommentWhereInput[]
    NOT?: bookstoreCommentWhereInput | bookstoreCommentWhereInput[]
    userId?: IntNullableFilter<"bookstoreComment"> | number | null
    comment?: StringFilter<"bookstoreComment"> | string
    creationDate?: DateTimeFilter<"bookstoreComment"> | Date | string
    isActive?: BoolFilter<"bookstoreComment"> | boolean
    bookstoreId?: IntFilter<"bookstoreComment"> | number
    bouquineries?: XOR<BookstoreRelationFilter, bookstoreWhereInput>
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
    users_contributions?: UserContributionListRelationFilter
  }, "id">

  export type bookstoreCommentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    comment?: SortOrder
    creationDate?: SortOrder
    isActive?: SortOrder
    bookstoreId?: SortOrder
    _count?: bookstoreCommentCountOrderByAggregateInput
    _avg?: bookstoreCommentAvgOrderByAggregateInput
    _max?: bookstoreCommentMaxOrderByAggregateInput
    _min?: bookstoreCommentMinOrderByAggregateInput
    _sum?: bookstoreCommentSumOrderByAggregateInput
  }

  export type bookstoreCommentScalarWhereWithAggregatesInput = {
    AND?: bookstoreCommentScalarWhereWithAggregatesInput | bookstoreCommentScalarWhereWithAggregatesInput[]
    OR?: bookstoreCommentScalarWhereWithAggregatesInput[]
    NOT?: bookstoreCommentScalarWhereWithAggregatesInput | bookstoreCommentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"bookstoreComment"> | number
    userId?: IntNullableWithAggregatesFilter<"bookstoreComment"> | number | null
    comment?: StringWithAggregatesFilter<"bookstoreComment"> | string
    creationDate?: DateTimeWithAggregatesFilter<"bookstoreComment"> | Date | string
    isActive?: BoolWithAggregatesFilter<"bookstoreComment"> | boolean
    bookstoreId?: IntWithAggregatesFilter<"bookstoreComment"> | number
  }

  export type demoWhereInput = {
    AND?: demoWhereInput | demoWhereInput[]
    OR?: demoWhereInput[]
    NOT?: demoWhereInput | demoWhereInput[]
    id?: IntFilter<"demo"> | number
    lastReset?: DateTimeFilter<"demo"> | Date | string
  }

  export type demoOrderByWithRelationInput = {
    id?: SortOrder
    lastReset?: SortOrder
  }

  export type demoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: demoWhereInput | demoWhereInput[]
    OR?: demoWhereInput[]
    NOT?: demoWhereInput | demoWhereInput[]
    lastReset?: DateTimeFilter<"demo"> | Date | string
  }, "id">

  export type demoOrderByWithAggregationInput = {
    id?: SortOrder
    lastReset?: SortOrder
    _count?: demoCountOrderByAggregateInput
    _avg?: demoAvgOrderByAggregateInput
    _max?: demoMaxOrderByAggregateInput
    _min?: demoMinOrderByAggregateInput
    _sum?: demoSumOrderByAggregateInput
  }

  export type demoScalarWhereWithAggregatesInput = {
    AND?: demoScalarWhereWithAggregatesInput | demoScalarWhereWithAggregatesInput[]
    OR?: demoScalarWhereWithAggregatesInput[]
    NOT?: demoScalarWhereWithAggregatesInput | demoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"demo"> | number
    lastReset?: DateTimeWithAggregatesFilter<"demo"> | Date | string
  }

  export type magazinesWhereInput = {
    AND?: magazinesWhereInput | magazinesWhereInput[]
    OR?: magazinesWhereInput[]
    NOT?: magazinesWhereInput | magazinesWhereInput[]
    PaysAbrege?: StringFilter<"magazines"> | string
    NomAbrege?: StringFilter<"magazines"> | string
    NomComplet?: StringFilter<"magazines"> | string
    RedirigeDepuis?: StringFilter<"magazines"> | string
    NeParaitPlus?: BoolNullableFilter<"magazines"> | boolean | null
  }

  export type magazinesOrderByWithRelationInput = {
    PaysAbrege?: SortOrder
    NomAbrege?: SortOrder
    NomComplet?: SortOrder
    RedirigeDepuis?: SortOrder
    NeParaitPlus?: SortOrderInput | SortOrder
  }

  export type magazinesWhereUniqueInput = Prisma.AtLeast<{
    PaysAbrege_NomAbrege_RedirigeDepuis?: magazinesPaysAbregeNomAbregeRedirigeDepuisCompoundUniqueInput
    AND?: magazinesWhereInput | magazinesWhereInput[]
    OR?: magazinesWhereInput[]
    NOT?: magazinesWhereInput | magazinesWhereInput[]
    PaysAbrege?: StringFilter<"magazines"> | string
    NomAbrege?: StringFilter<"magazines"> | string
    NomComplet?: StringFilter<"magazines"> | string
    RedirigeDepuis?: StringFilter<"magazines"> | string
    NeParaitPlus?: BoolNullableFilter<"magazines"> | boolean | null
  }, "PaysAbrege_NomAbrege_RedirigeDepuis">

  export type magazinesOrderByWithAggregationInput = {
    PaysAbrege?: SortOrder
    NomAbrege?: SortOrder
    NomComplet?: SortOrder
    RedirigeDepuis?: SortOrder
    NeParaitPlus?: SortOrderInput | SortOrder
    _count?: magazinesCountOrderByAggregateInput
    _max?: magazinesMaxOrderByAggregateInput
    _min?: magazinesMinOrderByAggregateInput
  }

  export type magazinesScalarWhereWithAggregatesInput = {
    AND?: magazinesScalarWhereWithAggregatesInput | magazinesScalarWhereWithAggregatesInput[]
    OR?: magazinesScalarWhereWithAggregatesInput[]
    NOT?: magazinesScalarWhereWithAggregatesInput | magazinesScalarWhereWithAggregatesInput[]
    PaysAbrege?: StringWithAggregatesFilter<"magazines"> | string
    NomAbrege?: StringWithAggregatesFilter<"magazines"> | string
    NomComplet?: StringWithAggregatesFilter<"magazines"> | string
    RedirigeDepuis?: StringWithAggregatesFilter<"magazines"> | string
    NeParaitPlus?: BoolNullableWithAggregatesFilter<"magazines"> | boolean | null
  }

  export type issueWhereInput = {
    AND?: issueWhereInput | issueWhereInput[]
    OR?: issueWhereInput[]
    NOT?: issueWhereInput | issueWhereInput[]
    id?: IntFilter<"issue"> | number
    country?: StringFilter<"issue"> | string
    magazine?: StringFilter<"issue"> | string
    issuenumber?: StringFilter<"issue"> | string
    condition?: Enumissue_conditionFilter<"issue"> | $Enums.issue_condition
    purchaseId?: IntNullableFilter<"issue"> | number | null
    isOnSale?: BoolFilter<"issue"> | boolean
    isToRead?: BoolFilter<"issue"> | boolean
    isSubscription?: BoolFilter<"issue"> | boolean
    userId?: IntFilter<"issue"> | number
    creationDate?: DateTimeNullableFilter<"issue"> | Date | string | null
  }

  export type issueOrderByWithRelationInput = {
    id?: SortOrder
    country?: SortOrder
    magazine?: SortOrder
    issuenumber?: SortOrder
    condition?: SortOrder
    purchaseId?: SortOrderInput | SortOrder
    isOnSale?: SortOrder
    isToRead?: SortOrder
    isSubscription?: SortOrder
    userId?: SortOrder
    creationDate?: SortOrderInput | SortOrder
  }

  export type issueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: issueWhereInput | issueWhereInput[]
    OR?: issueWhereInput[]
    NOT?: issueWhereInput | issueWhereInput[]
    country?: StringFilter<"issue"> | string
    magazine?: StringFilter<"issue"> | string
    issuenumber?: StringFilter<"issue"> | string
    condition?: Enumissue_conditionFilter<"issue"> | $Enums.issue_condition
    purchaseId?: IntNullableFilter<"issue"> | number | null
    isOnSale?: BoolFilter<"issue"> | boolean
    isToRead?: BoolFilter<"issue"> | boolean
    isSubscription?: BoolFilter<"issue"> | boolean
    userId?: IntFilter<"issue"> | number
    creationDate?: DateTimeNullableFilter<"issue"> | Date | string | null
  }, "id">

  export type issueOrderByWithAggregationInput = {
    id?: SortOrder
    country?: SortOrder
    magazine?: SortOrder
    issuenumber?: SortOrder
    condition?: SortOrder
    purchaseId?: SortOrderInput | SortOrder
    isOnSale?: SortOrder
    isToRead?: SortOrder
    isSubscription?: SortOrder
    userId?: SortOrder
    creationDate?: SortOrderInput | SortOrder
    _count?: issueCountOrderByAggregateInput
    _avg?: issueAvgOrderByAggregateInput
    _max?: issueMaxOrderByAggregateInput
    _min?: issueMinOrderByAggregateInput
    _sum?: issueSumOrderByAggregateInput
  }

  export type issueScalarWhereWithAggregatesInput = {
    AND?: issueScalarWhereWithAggregatesInput | issueScalarWhereWithAggregatesInput[]
    OR?: issueScalarWhereWithAggregatesInput[]
    NOT?: issueScalarWhereWithAggregatesInput | issueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"issue"> | number
    country?: StringWithAggregatesFilter<"issue"> | string
    magazine?: StringWithAggregatesFilter<"issue"> | string
    issuenumber?: StringWithAggregatesFilter<"issue"> | string
    condition?: Enumissue_conditionWithAggregatesFilter<"issue"> | $Enums.issue_condition
    purchaseId?: IntNullableWithAggregatesFilter<"issue"> | number | null
    isOnSale?: BoolWithAggregatesFilter<"issue"> | boolean
    isToRead?: BoolWithAggregatesFilter<"issue"> | boolean
    isSubscription?: BoolWithAggregatesFilter<"issue"> | boolean
    userId?: IntWithAggregatesFilter<"issue"> | number
    creationDate?: DateTimeNullableWithAggregatesFilter<"issue"> | Date | string | null
  }

  export type issuePopularityWhereInput = {
    AND?: issuePopularityWhereInput | issuePopularityWhereInput[]
    OR?: issuePopularityWhereInput[]
    NOT?: issuePopularityWhereInput | issuePopularityWhereInput[]
    country?: StringFilter<"issuePopularity"> | string
    magazine?: StringFilter<"issuePopularity"> | string
    issuenumber?: StringFilter<"issuePopularity"> | string
    popularity?: IntFilter<"issuePopularity"> | number
    id?: IntFilter<"issuePopularity"> | number
  }

  export type issuePopularityOrderByWithRelationInput = {
    country?: SortOrder
    magazine?: SortOrder
    issuenumber?: SortOrder
    popularity?: SortOrder
    id?: SortOrder
  }

  export type issuePopularityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    country_magazine_issuenumber?: issuePopularityCountryMagazineIssuenumberCompoundUniqueInput
    AND?: issuePopularityWhereInput | issuePopularityWhereInput[]
    OR?: issuePopularityWhereInput[]
    NOT?: issuePopularityWhereInput | issuePopularityWhereInput[]
    country?: StringFilter<"issuePopularity"> | string
    magazine?: StringFilter<"issuePopularity"> | string
    issuenumber?: StringFilter<"issuePopularity"> | string
    popularity?: IntFilter<"issuePopularity"> | number
  }, "id" | "country_magazine_issuenumber">

  export type issuePopularityOrderByWithAggregationInput = {
    country?: SortOrder
    magazine?: SortOrder
    issuenumber?: SortOrder
    popularity?: SortOrder
    id?: SortOrder
    _count?: issuePopularityCountOrderByAggregateInput
    _avg?: issuePopularityAvgOrderByAggregateInput
    _max?: issuePopularityMaxOrderByAggregateInput
    _min?: issuePopularityMinOrderByAggregateInput
    _sum?: issuePopularitySumOrderByAggregateInput
  }

  export type issuePopularityScalarWhereWithAggregatesInput = {
    AND?: issuePopularityScalarWhereWithAggregatesInput | issuePopularityScalarWhereWithAggregatesInput[]
    OR?: issuePopularityScalarWhereWithAggregatesInput[]
    NOT?: issuePopularityScalarWhereWithAggregatesInput | issuePopularityScalarWhereWithAggregatesInput[]
    country?: StringWithAggregatesFilter<"issuePopularity"> | string
    magazine?: StringWithAggregatesFilter<"issuePopularity"> | string
    issuenumber?: StringWithAggregatesFilter<"issuePopularity"> | string
    popularity?: IntWithAggregatesFilter<"issuePopularity"> | number
    id?: IntWithAggregatesFilter<"issuePopularity"> | number
  }

  export type tranches_doublonsWhereInput = {
    AND?: tranches_doublonsWhereInput | tranches_doublonsWhereInput[]
    OR?: tranches_doublonsWhereInput[]
    NOT?: tranches_doublonsWhereInput | tranches_doublonsWhereInput[]
    ID?: IntFilter<"tranches_doublons"> | number
    Pays?: StringFilter<"tranches_doublons"> | string
    Magazine?: StringFilter<"tranches_doublons"> | string
    Numero?: StringFilter<"tranches_doublons"> | string
    NumeroReference?: StringFilter<"tranches_doublons"> | string
    TrancheReference?: IntNullableFilter<"tranches_doublons"> | number | null
  }

  export type tranches_doublonsOrderByWithRelationInput = {
    ID?: SortOrder
    Pays?: SortOrder
    Magazine?: SortOrder
    Numero?: SortOrder
    NumeroReference?: SortOrder
    TrancheReference?: SortOrderInput | SortOrder
  }

  export type tranches_doublonsWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    Pays_Magazine_Numero?: tranches_doublonsPaysMagazineNumeroCompoundUniqueInput
    AND?: tranches_doublonsWhereInput | tranches_doublonsWhereInput[]
    OR?: tranches_doublonsWhereInput[]
    NOT?: tranches_doublonsWhereInput | tranches_doublonsWhereInput[]
    Pays?: StringFilter<"tranches_doublons"> | string
    Magazine?: StringFilter<"tranches_doublons"> | string
    Numero?: StringFilter<"tranches_doublons"> | string
    NumeroReference?: StringFilter<"tranches_doublons"> | string
    TrancheReference?: IntNullableFilter<"tranches_doublons"> | number | null
  }, "ID" | "Pays_Magazine_Numero">

  export type tranches_doublonsOrderByWithAggregationInput = {
    ID?: SortOrder
    Pays?: SortOrder
    Magazine?: SortOrder
    Numero?: SortOrder
    NumeroReference?: SortOrder
    TrancheReference?: SortOrderInput | SortOrder
    _count?: tranches_doublonsCountOrderByAggregateInput
    _avg?: tranches_doublonsAvgOrderByAggregateInput
    _max?: tranches_doublonsMaxOrderByAggregateInput
    _min?: tranches_doublonsMinOrderByAggregateInput
    _sum?: tranches_doublonsSumOrderByAggregateInput
  }

  export type tranches_doublonsScalarWhereWithAggregatesInput = {
    AND?: tranches_doublonsScalarWhereWithAggregatesInput | tranches_doublonsScalarWhereWithAggregatesInput[]
    OR?: tranches_doublonsScalarWhereWithAggregatesInput[]
    NOT?: tranches_doublonsScalarWhereWithAggregatesInput | tranches_doublonsScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"tranches_doublons"> | number
    Pays?: StringWithAggregatesFilter<"tranches_doublons"> | string
    Magazine?: StringWithAggregatesFilter<"tranches_doublons"> | string
    Numero?: StringWithAggregatesFilter<"tranches_doublons"> | string
    NumeroReference?: StringWithAggregatesFilter<"tranches_doublons"> | string
    TrancheReference?: IntNullableWithAggregatesFilter<"tranches_doublons"> | number | null
  }

  export type edgeWhereInput = {
    AND?: edgeWhereInput | edgeWhereInput[]
    OR?: edgeWhereInput[]
    NOT?: edgeWhereInput | edgeWhereInput[]
    id?: IntFilter<"edge"> | number
    publicationcode?: StringFilter<"edge"> | string
    issuenumber?: StringFilter<"edge"> | string
    creationDate?: DateTimeFilter<"edge"> | Date | string
    points?: IntNullableFilter<"edge"> | number | null
    slug?: StringNullableFilter<"edge"> | string | null
    issuecode?: StringNullableFilter<"edge"> | string | null
    users_contributions?: UserContributionListRelationFilter
  }

  export type edgeOrderByWithRelationInput = {
    id?: SortOrder
    publicationcode?: SortOrder
    issuenumber?: SortOrder
    creationDate?: SortOrder
    points?: SortOrderInput | SortOrder
    slug?: SortOrderInput | SortOrder
    issuecode?: SortOrderInput | SortOrder
    users_contributions?: userContributionOrderByRelationAggregateInput
  }

  export type edgeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    issuecode?: string
    publicationcode_issuenumber?: edgePublicationcodeIssuenumberCompoundUniqueInput
    AND?: edgeWhereInput | edgeWhereInput[]
    OR?: edgeWhereInput[]
    NOT?: edgeWhereInput | edgeWhereInput[]
    publicationcode?: StringFilter<"edge"> | string
    issuenumber?: StringFilter<"edge"> | string
    creationDate?: DateTimeFilter<"edge"> | Date | string
    points?: IntNullableFilter<"edge"> | number | null
    slug?: StringNullableFilter<"edge"> | string | null
    users_contributions?: UserContributionListRelationFilter
  }, "id" | "issuecode" | "publicationcode_issuenumber">

  export type edgeOrderByWithAggregationInput = {
    id?: SortOrder
    publicationcode?: SortOrder
    issuenumber?: SortOrder
    creationDate?: SortOrder
    points?: SortOrderInput | SortOrder
    slug?: SortOrderInput | SortOrder
    issuecode?: SortOrderInput | SortOrder
    _count?: edgeCountOrderByAggregateInput
    _avg?: edgeAvgOrderByAggregateInput
    _max?: edgeMaxOrderByAggregateInput
    _min?: edgeMinOrderByAggregateInput
    _sum?: edgeSumOrderByAggregateInput
  }

  export type edgeScalarWhereWithAggregatesInput = {
    AND?: edgeScalarWhereWithAggregatesInput | edgeScalarWhereWithAggregatesInput[]
    OR?: edgeScalarWhereWithAggregatesInput[]
    NOT?: edgeScalarWhereWithAggregatesInput | edgeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"edge"> | number
    publicationcode?: StringWithAggregatesFilter<"edge"> | string
    issuenumber?: StringWithAggregatesFilter<"edge"> | string
    creationDate?: DateTimeWithAggregatesFilter<"edge"> | Date | string
    points?: IntNullableWithAggregatesFilter<"edge"> | number | null
    slug?: StringNullableWithAggregatesFilter<"edge"> | string | null
    issuecode?: StringNullableWithAggregatesFilter<"edge"> | string | null
  }

  export type tranches_pretes_contributeursWhereInput = {
    AND?: tranches_pretes_contributeursWhereInput | tranches_pretes_contributeursWhereInput[]
    OR?: tranches_pretes_contributeursWhereInput[]
    NOT?: tranches_pretes_contributeursWhereInput | tranches_pretes_contributeursWhereInput[]
    publicationcode?: StringFilter<"tranches_pretes_contributeurs"> | string
    issuenumber?: StringFilter<"tranches_pretes_contributeurs"> | string
    contributeur?: IntFilter<"tranches_pretes_contributeurs"> | number
    contribution?: Enumtranches_pretes_contributeurs_contributionFilter<"tranches_pretes_contributeurs"> | $Enums.tranches_pretes_contributeurs_contribution
  }

  export type tranches_pretes_contributeursOrderByWithRelationInput = {
    publicationcode?: SortOrder
    issuenumber?: SortOrder
    contributeur?: SortOrder
    contribution?: SortOrder
  }

  export type tranches_pretes_contributeursWhereUniqueInput = Prisma.AtLeast<{
    publicationcode_issuenumber_contributeur_contribution?: tranches_pretes_contributeursPublicationcodeIssuenumberContributeurContributionCompoundUniqueInput
    AND?: tranches_pretes_contributeursWhereInput | tranches_pretes_contributeursWhereInput[]
    OR?: tranches_pretes_contributeursWhereInput[]
    NOT?: tranches_pretes_contributeursWhereInput | tranches_pretes_contributeursWhereInput[]
    publicationcode?: StringFilter<"tranches_pretes_contributeurs"> | string
    issuenumber?: StringFilter<"tranches_pretes_contributeurs"> | string
    contributeur?: IntFilter<"tranches_pretes_contributeurs"> | number
    contribution?: Enumtranches_pretes_contributeurs_contributionFilter<"tranches_pretes_contributeurs"> | $Enums.tranches_pretes_contributeurs_contribution
  }, "publicationcode_issuenumber_contributeur_contribution">

  export type tranches_pretes_contributeursOrderByWithAggregationInput = {
    publicationcode?: SortOrder
    issuenumber?: SortOrder
    contributeur?: SortOrder
    contribution?: SortOrder
    _count?: tranches_pretes_contributeursCountOrderByAggregateInput
    _avg?: tranches_pretes_contributeursAvgOrderByAggregateInput
    _max?: tranches_pretes_contributeursMaxOrderByAggregateInput
    _min?: tranches_pretes_contributeursMinOrderByAggregateInput
    _sum?: tranches_pretes_contributeursSumOrderByAggregateInput
  }

  export type tranches_pretes_contributeursScalarWhereWithAggregatesInput = {
    AND?: tranches_pretes_contributeursScalarWhereWithAggregatesInput | tranches_pretes_contributeursScalarWhereWithAggregatesInput[]
    OR?: tranches_pretes_contributeursScalarWhereWithAggregatesInput[]
    NOT?: tranches_pretes_contributeursScalarWhereWithAggregatesInput | tranches_pretes_contributeursScalarWhereWithAggregatesInput[]
    publicationcode?: StringWithAggregatesFilter<"tranches_pretes_contributeurs"> | string
    issuenumber?: StringWithAggregatesFilter<"tranches_pretes_contributeurs"> | string
    contributeur?: IntWithAggregatesFilter<"tranches_pretes_contributeurs"> | number
    contribution?: Enumtranches_pretes_contributeurs_contributionWithAggregatesFilter<"tranches_pretes_contributeurs"> | $Enums.tranches_pretes_contributeurs_contribution
  }

  export type tranches_pretes_contributionsWhereInput = {
    AND?: tranches_pretes_contributionsWhereInput | tranches_pretes_contributionsWhereInput[]
    OR?: tranches_pretes_contributionsWhereInput[]
    NOT?: tranches_pretes_contributionsWhereInput | tranches_pretes_contributionsWhereInput[]
    ID?: IntFilter<"tranches_pretes_contributions"> | number
    ID_tranche?: IntFilter<"tranches_pretes_contributions"> | number
    ID_user?: IntFilter<"tranches_pretes_contributions"> | number
    dateajout?: DateTimeFilter<"tranches_pretes_contributions"> | Date | string
    contribution?: Enumtranches_pretes_contributions_contributionFilter<"tranches_pretes_contributions"> | $Enums.tranches_pretes_contributions_contribution
    points_new?: IntFilter<"tranches_pretes_contributions"> | number
    points_total?: IntFilter<"tranches_pretes_contributions"> | number
  }

  export type tranches_pretes_contributionsOrderByWithRelationInput = {
    ID?: SortOrder
    ID_tranche?: SortOrder
    ID_user?: SortOrder
    dateajout?: SortOrder
    contribution?: SortOrder
    points_new?: SortOrder
    points_total?: SortOrder
  }

  export type tranches_pretes_contributionsWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: tranches_pretes_contributionsWhereInput | tranches_pretes_contributionsWhereInput[]
    OR?: tranches_pretes_contributionsWhereInput[]
    NOT?: tranches_pretes_contributionsWhereInput | tranches_pretes_contributionsWhereInput[]
    ID_tranche?: IntFilter<"tranches_pretes_contributions"> | number
    ID_user?: IntFilter<"tranches_pretes_contributions"> | number
    dateajout?: DateTimeFilter<"tranches_pretes_contributions"> | Date | string
    contribution?: Enumtranches_pretes_contributions_contributionFilter<"tranches_pretes_contributions"> | $Enums.tranches_pretes_contributions_contribution
    points_new?: IntFilter<"tranches_pretes_contributions"> | number
    points_total?: IntFilter<"tranches_pretes_contributions"> | number
  }, "ID">

  export type tranches_pretes_contributionsOrderByWithAggregationInput = {
    ID?: SortOrder
    ID_tranche?: SortOrder
    ID_user?: SortOrder
    dateajout?: SortOrder
    contribution?: SortOrder
    points_new?: SortOrder
    points_total?: SortOrder
    _count?: tranches_pretes_contributionsCountOrderByAggregateInput
    _avg?: tranches_pretes_contributionsAvgOrderByAggregateInput
    _max?: tranches_pretes_contributionsMaxOrderByAggregateInput
    _min?: tranches_pretes_contributionsMinOrderByAggregateInput
    _sum?: tranches_pretes_contributionsSumOrderByAggregateInput
  }

  export type tranches_pretes_contributionsScalarWhereWithAggregatesInput = {
    AND?: tranches_pretes_contributionsScalarWhereWithAggregatesInput | tranches_pretes_contributionsScalarWhereWithAggregatesInput[]
    OR?: tranches_pretes_contributionsScalarWhereWithAggregatesInput[]
    NOT?: tranches_pretes_contributionsScalarWhereWithAggregatesInput | tranches_pretes_contributionsScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"tranches_pretes_contributions"> | number
    ID_tranche?: IntWithAggregatesFilter<"tranches_pretes_contributions"> | number
    ID_user?: IntWithAggregatesFilter<"tranches_pretes_contributions"> | number
    dateajout?: DateTimeWithAggregatesFilter<"tranches_pretes_contributions"> | Date | string
    contribution?: Enumtranches_pretes_contributions_contributionWithAggregatesFilter<"tranches_pretes_contributions"> | $Enums.tranches_pretes_contributions_contribution
    points_new?: IntWithAggregatesFilter<"tranches_pretes_contributions"> | number
    points_total?: IntWithAggregatesFilter<"tranches_pretes_contributions"> | number
  }

  export type edgeSpriteWhereInput = {
    AND?: edgeSpriteWhereInput | edgeSpriteWhereInput[]
    OR?: edgeSpriteWhereInput[]
    NOT?: edgeSpriteWhereInput | edgeSpriteWhereInput[]
    id?: IntFilter<"edgeSprite"> | number
    edgeId?: IntFilter<"edgeSprite"> | number
    spriteName?: StringFilter<"edgeSprite"> | string
    spriteSize?: IntNullableFilter<"edgeSprite"> | number | null
  }

  export type edgeSpriteOrderByWithRelationInput = {
    id?: SortOrder
    edgeId?: SortOrder
    spriteName?: SortOrder
    spriteSize?: SortOrderInput | SortOrder
  }

  export type edgeSpriteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    edgeId_spriteName?: edgeSpriteEdgeIdSpriteNameCompoundUniqueInput
    AND?: edgeSpriteWhereInput | edgeSpriteWhereInput[]
    OR?: edgeSpriteWhereInput[]
    NOT?: edgeSpriteWhereInput | edgeSpriteWhereInput[]
    edgeId?: IntFilter<"edgeSprite"> | number
    spriteName?: StringFilter<"edgeSprite"> | string
    spriteSize?: IntNullableFilter<"edgeSprite"> | number | null
  }, "id" | "edgeId_spriteName">

  export type edgeSpriteOrderByWithAggregationInput = {
    id?: SortOrder
    edgeId?: SortOrder
    spriteName?: SortOrder
    spriteSize?: SortOrderInput | SortOrder
    _count?: edgeSpriteCountOrderByAggregateInput
    _avg?: edgeSpriteAvgOrderByAggregateInput
    _max?: edgeSpriteMaxOrderByAggregateInput
    _min?: edgeSpriteMinOrderByAggregateInput
    _sum?: edgeSpriteSumOrderByAggregateInput
  }

  export type edgeSpriteScalarWhereWithAggregatesInput = {
    AND?: edgeSpriteScalarWhereWithAggregatesInput | edgeSpriteScalarWhereWithAggregatesInput[]
    OR?: edgeSpriteScalarWhereWithAggregatesInput[]
    NOT?: edgeSpriteScalarWhereWithAggregatesInput | edgeSpriteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"edgeSprite"> | number
    edgeId?: IntWithAggregatesFilter<"edgeSprite"> | number
    spriteName?: StringWithAggregatesFilter<"edgeSprite"> | string
    spriteSize?: IntNullableWithAggregatesFilter<"edgeSprite"> | number | null
  }

  export type edgeSpriteSizeWhereInput = {
    AND?: edgeSpriteSizeWhereInput | edgeSpriteSizeWhereInput[]
    OR?: edgeSpriteSizeWhereInput[]
    NOT?: edgeSpriteSizeWhereInput | edgeSpriteSizeWhereInput[]
    id?: IntFilter<"edgeSpriteSize"> | number
    spriteName?: StringNullableFilter<"edgeSpriteSize"> | string | null
    size?: IntNullableFilter<"edgeSpriteSize"> | number | null
  }

  export type edgeSpriteSizeOrderByWithRelationInput = {
    id?: SortOrder
    spriteName?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
  }

  export type edgeSpriteSizeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: edgeSpriteSizeWhereInput | edgeSpriteSizeWhereInput[]
    OR?: edgeSpriteSizeWhereInput[]
    NOT?: edgeSpriteSizeWhereInput | edgeSpriteSizeWhereInput[]
    spriteName?: StringNullableFilter<"edgeSpriteSize"> | string | null
    size?: IntNullableFilter<"edgeSpriteSize"> | number | null
  }, "id">

  export type edgeSpriteSizeOrderByWithAggregationInput = {
    id?: SortOrder
    spriteName?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    _count?: edgeSpriteSizeCountOrderByAggregateInput
    _avg?: edgeSpriteSizeAvgOrderByAggregateInput
    _max?: edgeSpriteSizeMaxOrderByAggregateInput
    _min?: edgeSpriteSizeMinOrderByAggregateInput
    _sum?: edgeSpriteSizeSumOrderByAggregateInput
  }

  export type edgeSpriteSizeScalarWhereWithAggregatesInput = {
    AND?: edgeSpriteSizeScalarWhereWithAggregatesInput | edgeSpriteSizeScalarWhereWithAggregatesInput[]
    OR?: edgeSpriteSizeScalarWhereWithAggregatesInput[]
    NOT?: edgeSpriteSizeScalarWhereWithAggregatesInput | edgeSpriteSizeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"edgeSpriteSize"> | number
    spriteName?: StringNullableWithAggregatesFilter<"edgeSpriteSize"> | string | null
    size?: IntNullableWithAggregatesFilter<"edgeSpriteSize"> | number | null
  }

  export type edgeSpriteUrlWhereInput = {
    AND?: edgeSpriteUrlWhereInput | edgeSpriteUrlWhereInput[]
    OR?: edgeSpriteUrlWhereInput[]
    NOT?: edgeSpriteUrlWhereInput | edgeSpriteUrlWhereInput[]
    id?: IntFilter<"edgeSpriteUrl"> | number
    spriteName?: StringFilter<"edgeSpriteUrl"> | string
    version?: StringFilter<"edgeSpriteUrl"> | string
  }

  export type edgeSpriteUrlOrderByWithRelationInput = {
    id?: SortOrder
    spriteName?: SortOrder
    version?: SortOrder
  }

  export type edgeSpriteUrlWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    spriteName_version?: edgeSpriteUrlSpriteNameVersionCompoundUniqueInput
    AND?: edgeSpriteUrlWhereInput | edgeSpriteUrlWhereInput[]
    OR?: edgeSpriteUrlWhereInput[]
    NOT?: edgeSpriteUrlWhereInput | edgeSpriteUrlWhereInput[]
    spriteName?: StringFilter<"edgeSpriteUrl"> | string
    version?: StringFilter<"edgeSpriteUrl"> | string
  }, "id" | "spriteName_version">

  export type edgeSpriteUrlOrderByWithAggregationInput = {
    id?: SortOrder
    spriteName?: SortOrder
    version?: SortOrder
    _count?: edgeSpriteUrlCountOrderByAggregateInput
    _avg?: edgeSpriteUrlAvgOrderByAggregateInput
    _max?: edgeSpriteUrlMaxOrderByAggregateInput
    _min?: edgeSpriteUrlMinOrderByAggregateInput
    _sum?: edgeSpriteUrlSumOrderByAggregateInput
  }

  export type edgeSpriteUrlScalarWhereWithAggregatesInput = {
    AND?: edgeSpriteUrlScalarWhereWithAggregatesInput | edgeSpriteUrlScalarWhereWithAggregatesInput[]
    OR?: edgeSpriteUrlScalarWhereWithAggregatesInput[]
    NOT?: edgeSpriteUrlScalarWhereWithAggregatesInput | edgeSpriteUrlScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"edgeSpriteUrl"> | number
    spriteName?: StringWithAggregatesFilter<"edgeSpriteUrl"> | string
    version?: StringWithAggregatesFilter<"edgeSpriteUrl"> | string
  }

  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    id?: IntFilter<"user"> | number
    username?: StringFilter<"user"> | string
    password?: StringFilter<"user"> | string
    allowSharing?: BoolFilter<"user"> | boolean
    signupDate?: DateTimeFilter<"user"> | Date | string
    email?: StringFilter<"user"> | string
    discordId?: IntNullableFilter<"user"> | number | null
    showRecommendations?: BoolFilter<"user"> | boolean
    isBetaUser?: BoolFilter<"user"> | boolean
    showPresentationVideo?: BoolFilter<"user"> | boolean
    showDuplicatesInBookcase?: BoolFilter<"user"> | boolean
    bookcaseTexture1?: StringFilter<"user"> | string
    bookcaseSubTexture1?: StringFilter<"user"> | string
    bookcaseTexture2?: StringFilter<"user"> | string
    bookcaseSubTexture2?: StringFilter<"user"> | string
    presentationText?: StringNullableFilter<"user"> | string | null
    lastAccess?: DateTimeNullableFilter<"user"> | Date | string | null
    previousAccess?: DateTimeNullableFilter<"user"> | Date | string | null
    marketplaceAcceptsExchanges?: BoolFilter<"user"> | boolean
    abonnements?: SubscriptionListRelationFilter
    bouquineries_commentaires?: BookstoreCommentListRelationFilter
    users_contributions?: UserContributionListRelationFilter
    users_options?: UserOptionListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    allowSharing?: SortOrder
    signupDate?: SortOrder
    email?: SortOrder
    discordId?: SortOrderInput | SortOrder
    showRecommendations?: SortOrder
    isBetaUser?: SortOrder
    showPresentationVideo?: SortOrder
    showDuplicatesInBookcase?: SortOrder
    bookcaseTexture1?: SortOrder
    bookcaseSubTexture1?: SortOrder
    bookcaseTexture2?: SortOrder
    bookcaseSubTexture2?: SortOrder
    presentationText?: SortOrderInput | SortOrder
    lastAccess?: SortOrderInput | SortOrder
    previousAccess?: SortOrderInput | SortOrder
    marketplaceAcceptsExchanges?: SortOrder
    abonnements?: subscriptionOrderByRelationAggregateInput
    bouquineries_commentaires?: bookstoreCommentOrderByRelationAggregateInput
    users_contributions?: userContributionOrderByRelationAggregateInput
    users_options?: userOptionOrderByRelationAggregateInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    password?: StringFilter<"user"> | string
    allowSharing?: BoolFilter<"user"> | boolean
    signupDate?: DateTimeFilter<"user"> | Date | string
    email?: StringFilter<"user"> | string
    discordId?: IntNullableFilter<"user"> | number | null
    showRecommendations?: BoolFilter<"user"> | boolean
    isBetaUser?: BoolFilter<"user"> | boolean
    showPresentationVideo?: BoolFilter<"user"> | boolean
    showDuplicatesInBookcase?: BoolFilter<"user"> | boolean
    bookcaseTexture1?: StringFilter<"user"> | string
    bookcaseSubTexture1?: StringFilter<"user"> | string
    bookcaseTexture2?: StringFilter<"user"> | string
    bookcaseSubTexture2?: StringFilter<"user"> | string
    presentationText?: StringNullableFilter<"user"> | string | null
    lastAccess?: DateTimeNullableFilter<"user"> | Date | string | null
    previousAccess?: DateTimeNullableFilter<"user"> | Date | string | null
    marketplaceAcceptsExchanges?: BoolFilter<"user"> | boolean
    abonnements?: SubscriptionListRelationFilter
    bouquineries_commentaires?: BookstoreCommentListRelationFilter
    users_contributions?: UserContributionListRelationFilter
    users_options?: UserOptionListRelationFilter
  }, "id" | "username">

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    allowSharing?: SortOrder
    signupDate?: SortOrder
    email?: SortOrder
    discordId?: SortOrderInput | SortOrder
    showRecommendations?: SortOrder
    isBetaUser?: SortOrder
    showPresentationVideo?: SortOrder
    showDuplicatesInBookcase?: SortOrder
    bookcaseTexture1?: SortOrder
    bookcaseSubTexture1?: SortOrder
    bookcaseTexture2?: SortOrder
    bookcaseSubTexture2?: SortOrder
    presentationText?: SortOrderInput | SortOrder
    lastAccess?: SortOrderInput | SortOrder
    previousAccess?: SortOrderInput | SortOrder
    marketplaceAcceptsExchanges?: SortOrder
    _count?: userCountOrderByAggregateInput
    _avg?: userAvgOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
    _sum?: userSumOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user"> | number
    username?: StringWithAggregatesFilter<"user"> | string
    password?: StringWithAggregatesFilter<"user"> | string
    allowSharing?: BoolWithAggregatesFilter<"user"> | boolean
    signupDate?: DateTimeWithAggregatesFilter<"user"> | Date | string
    email?: StringWithAggregatesFilter<"user"> | string
    discordId?: IntNullableWithAggregatesFilter<"user"> | number | null
    showRecommendations?: BoolWithAggregatesFilter<"user"> | boolean
    isBetaUser?: BoolWithAggregatesFilter<"user"> | boolean
    showPresentationVideo?: BoolWithAggregatesFilter<"user"> | boolean
    showDuplicatesInBookcase?: BoolWithAggregatesFilter<"user"> | boolean
    bookcaseTexture1?: StringWithAggregatesFilter<"user"> | string
    bookcaseSubTexture1?: StringWithAggregatesFilter<"user"> | string
    bookcaseTexture2?: StringWithAggregatesFilter<"user"> | string
    bookcaseSubTexture2?: StringWithAggregatesFilter<"user"> | string
    presentationText?: StringNullableWithAggregatesFilter<"user"> | string | null
    lastAccess?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
    previousAccess?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
    marketplaceAcceptsExchanges?: BoolWithAggregatesFilter<"user"> | boolean
  }

  export type userContributionWhereInput = {
    AND?: userContributionWhereInput | userContributionWhereInput[]
    OR?: userContributionWhereInput[]
    NOT?: userContributionWhereInput | userContributionWhereInput[]
    id?: IntFilter<"userContribution"> | number
    userId?: IntFilter<"userContribution"> | number
    date?: DateTimeFilter<"userContribution"> | Date | string
    contribution?: StringFilter<"userContribution"> | string
    newPoints?: IntFilter<"userContribution"> | number
    totalPoints?: IntFilter<"userContribution"> | number
    isEmailSent?: BoolFilter<"userContribution"> | boolean
    edgeId?: IntNullableFilter<"userContribution"> | number | null
    bookstoreId?: IntNullableFilter<"userContribution"> | number | null
    bookstoreCommentId?: IntNullableFilter<"userContribution"> | number | null
    tranches_pretes?: XOR<EdgeNullableRelationFilter, edgeWhereInput> | null
    bouquineries?: XOR<BookstoreNullableRelationFilter, bookstoreWhereInput> | null
    users?: XOR<UserRelationFilter, userWhereInput>
    bouquineries_commentaires?: XOR<BookstoreCommentNullableRelationFilter, bookstoreCommentWhereInput> | null
  }

  export type userContributionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    contribution?: SortOrder
    newPoints?: SortOrder
    totalPoints?: SortOrder
    isEmailSent?: SortOrder
    edgeId?: SortOrderInput | SortOrder
    bookstoreId?: SortOrderInput | SortOrder
    bookstoreCommentId?: SortOrderInput | SortOrder
    tranches_pretes?: edgeOrderByWithRelationInput
    bouquineries?: bookstoreOrderByWithRelationInput
    users?: userOrderByWithRelationInput
    bouquineries_commentaires?: bookstoreCommentOrderByWithRelationInput
  }

  export type userContributionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: userContributionWhereInput | userContributionWhereInput[]
    OR?: userContributionWhereInput[]
    NOT?: userContributionWhereInput | userContributionWhereInput[]
    userId?: IntFilter<"userContribution"> | number
    date?: DateTimeFilter<"userContribution"> | Date | string
    contribution?: StringFilter<"userContribution"> | string
    newPoints?: IntFilter<"userContribution"> | number
    totalPoints?: IntFilter<"userContribution"> | number
    isEmailSent?: BoolFilter<"userContribution"> | boolean
    edgeId?: IntNullableFilter<"userContribution"> | number | null
    bookstoreId?: IntNullableFilter<"userContribution"> | number | null
    bookstoreCommentId?: IntNullableFilter<"userContribution"> | number | null
    tranches_pretes?: XOR<EdgeNullableRelationFilter, edgeWhereInput> | null
    bouquineries?: XOR<BookstoreNullableRelationFilter, bookstoreWhereInput> | null
    users?: XOR<UserRelationFilter, userWhereInput>
    bouquineries_commentaires?: XOR<BookstoreCommentNullableRelationFilter, bookstoreCommentWhereInput> | null
  }, "id">

  export type userContributionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    contribution?: SortOrder
    newPoints?: SortOrder
    totalPoints?: SortOrder
    isEmailSent?: SortOrder
    edgeId?: SortOrderInput | SortOrder
    bookstoreId?: SortOrderInput | SortOrder
    bookstoreCommentId?: SortOrderInput | SortOrder
    _count?: userContributionCountOrderByAggregateInput
    _avg?: userContributionAvgOrderByAggregateInput
    _max?: userContributionMaxOrderByAggregateInput
    _min?: userContributionMinOrderByAggregateInput
    _sum?: userContributionSumOrderByAggregateInput
  }

  export type userContributionScalarWhereWithAggregatesInput = {
    AND?: userContributionScalarWhereWithAggregatesInput | userContributionScalarWhereWithAggregatesInput[]
    OR?: userContributionScalarWhereWithAggregatesInput[]
    NOT?: userContributionScalarWhereWithAggregatesInput | userContributionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"userContribution"> | number
    userId?: IntWithAggregatesFilter<"userContribution"> | number
    date?: DateTimeWithAggregatesFilter<"userContribution"> | Date | string
    contribution?: StringWithAggregatesFilter<"userContribution"> | string
    newPoints?: IntWithAggregatesFilter<"userContribution"> | number
    totalPoints?: IntWithAggregatesFilter<"userContribution"> | number
    isEmailSent?: BoolWithAggregatesFilter<"userContribution"> | boolean
    edgeId?: IntNullableWithAggregatesFilter<"userContribution"> | number | null
    bookstoreId?: IntNullableWithAggregatesFilter<"userContribution"> | number | null
    bookstoreCommentId?: IntNullableWithAggregatesFilter<"userContribution"> | number | null
  }

  export type userOptionWhereInput = {
    AND?: userOptionWhereInput | userOptionWhereInput[]
    OR?: userOptionWhereInput[]
    NOT?: userOptionWhereInput | userOptionWhereInput[]
    id?: IntFilter<"userOption"> | number
    userId?: IntFilter<"userOption"> | number
    optionName?: EnumuserOptionTypeFilter<"userOption"> | $Enums.userOptionType
    optionValue?: StringFilter<"userOption"> | string
    users?: XOR<UserRelationFilter, userWhereInput>
  }

  export type userOptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    optionName?: SortOrder
    optionValue?: SortOrder
    users?: userOrderByWithRelationInput
  }

  export type userOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_optionName_optionValue?: userOptionUserIdOptionNameOptionValueCompoundUniqueInput
    AND?: userOptionWhereInput | userOptionWhereInput[]
    OR?: userOptionWhereInput[]
    NOT?: userOptionWhereInput | userOptionWhereInput[]
    userId?: IntFilter<"userOption"> | number
    optionName?: EnumuserOptionTypeFilter<"userOption"> | $Enums.userOptionType
    optionValue?: StringFilter<"userOption"> | string
    users?: XOR<UserRelationFilter, userWhereInput>
  }, "id" | "userId_optionName_optionValue">

  export type userOptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    optionName?: SortOrder
    optionValue?: SortOrder
    _count?: userOptionCountOrderByAggregateInput
    _avg?: userOptionAvgOrderByAggregateInput
    _max?: userOptionMaxOrderByAggregateInput
    _min?: userOptionMinOrderByAggregateInput
    _sum?: userOptionSumOrderByAggregateInput
  }

  export type userOptionScalarWhereWithAggregatesInput = {
    AND?: userOptionScalarWhereWithAggregatesInput | userOptionScalarWhereWithAggregatesInput[]
    OR?: userOptionScalarWhereWithAggregatesInput[]
    NOT?: userOptionScalarWhereWithAggregatesInput | userOptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"userOption"> | number
    userId?: IntWithAggregatesFilter<"userOption"> | number
    optionName?: EnumuserOptionTypeWithAggregatesFilter<"userOption"> | $Enums.userOptionType
    optionValue?: StringWithAggregatesFilter<"userOption"> | string
  }

  export type userPasswordTokenWhereInput = {
    AND?: userPasswordTokenWhereInput | userPasswordTokenWhereInput[]
    OR?: userPasswordTokenWhereInput[]
    NOT?: userPasswordTokenWhereInput | userPasswordTokenWhereInput[]
    id?: IntFilter<"userPasswordToken"> | number
    userId?: IntFilter<"userPasswordToken"> | number
    token?: StringFilter<"userPasswordToken"> | string
  }

  export type userPasswordTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
  }

  export type userPasswordTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_token?: userPasswordTokenUserIdTokenCompoundUniqueInput
    AND?: userPasswordTokenWhereInput | userPasswordTokenWhereInput[]
    OR?: userPasswordTokenWhereInput[]
    NOT?: userPasswordTokenWhereInput | userPasswordTokenWhereInput[]
    userId?: IntFilter<"userPasswordToken"> | number
    token?: StringFilter<"userPasswordToken"> | string
  }, "id" | "userId_token">

  export type userPasswordTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    _count?: userPasswordTokenCountOrderByAggregateInput
    _avg?: userPasswordTokenAvgOrderByAggregateInput
    _max?: userPasswordTokenMaxOrderByAggregateInput
    _min?: userPasswordTokenMinOrderByAggregateInput
    _sum?: userPasswordTokenSumOrderByAggregateInput
  }

  export type userPasswordTokenScalarWhereWithAggregatesInput = {
    AND?: userPasswordTokenScalarWhereWithAggregatesInput | userPasswordTokenScalarWhereWithAggregatesInput[]
    OR?: userPasswordTokenScalarWhereWithAggregatesInput[]
    NOT?: userPasswordTokenScalarWhereWithAggregatesInput | userPasswordTokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"userPasswordToken"> | number
    userId?: IntWithAggregatesFilter<"userPasswordToken"> | number
    token?: StringWithAggregatesFilter<"userPasswordToken"> | string
  }

  export type userPermissionWhereInput = {
    AND?: userPermissionWhereInput | userPermissionWhereInput[]
    OR?: userPermissionWhereInput[]
    NOT?: userPermissionWhereInput | userPermissionWhereInput[]
    id?: IntFilter<"userPermission"> | number
    username?: StringFilter<"userPermission"> | string
    role?: StringFilter<"userPermission"> | string
    privilege?: Enumusers_permissions_privilegeFilter<"userPermission"> | $Enums.users_permissions_privilege
  }

  export type userPermissionOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    role?: SortOrder
    privilege?: SortOrder
  }

  export type userPermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username_role_privilege?: userPermissionUsernameRolePrivilegeCompoundUniqueInput
    AND?: userPermissionWhereInput | userPermissionWhereInput[]
    OR?: userPermissionWhereInput[]
    NOT?: userPermissionWhereInput | userPermissionWhereInput[]
    username?: StringFilter<"userPermission"> | string
    role?: StringFilter<"userPermission"> | string
    privilege?: Enumusers_permissions_privilegeFilter<"userPermission"> | $Enums.users_permissions_privilege
  }, "id" | "username_role_privilege">

  export type userPermissionOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    role?: SortOrder
    privilege?: SortOrder
    _count?: userPermissionCountOrderByAggregateInput
    _avg?: userPermissionAvgOrderByAggregateInput
    _max?: userPermissionMaxOrderByAggregateInput
    _min?: userPermissionMinOrderByAggregateInput
    _sum?: userPermissionSumOrderByAggregateInput
  }

  export type userPermissionScalarWhereWithAggregatesInput = {
    AND?: userPermissionScalarWhereWithAggregatesInput | userPermissionScalarWhereWithAggregatesInput[]
    OR?: userPermissionScalarWhereWithAggregatesInput[]
    NOT?: userPermissionScalarWhereWithAggregatesInput | userPermissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"userPermission"> | number
    username?: StringWithAggregatesFilter<"userPermission"> | string
    role?: StringWithAggregatesFilter<"userPermission"> | string
    privilege?: Enumusers_permissions_privilegeWithAggregatesFilter<"userPermission"> | $Enums.users_permissions_privilege
  }

  export type users_pointsWhereInput = {
    AND?: users_pointsWhereInput | users_pointsWhereInput[]
    OR?: users_pointsWhereInput[]
    NOT?: users_pointsWhereInput | users_pointsWhereInput[]
    ID?: IntFilter<"users_points"> | number
    ID_Utilisateur?: IntFilter<"users_points"> | number
    TypeContribution?: EnumuserContributionTypeFilter<"users_points"> | $Enums.userContributionType
    NbPoints?: IntNullableFilter<"users_points"> | number | null
  }

  export type users_pointsOrderByWithRelationInput = {
    ID?: SortOrder
    ID_Utilisateur?: SortOrder
    TypeContribution?: SortOrder
    NbPoints?: SortOrderInput | SortOrder
  }

  export type users_pointsWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: users_pointsWhereInput | users_pointsWhereInput[]
    OR?: users_pointsWhereInput[]
    NOT?: users_pointsWhereInput | users_pointsWhereInput[]
    ID_Utilisateur?: IntFilter<"users_points"> | number
    TypeContribution?: EnumuserContributionTypeFilter<"users_points"> | $Enums.userContributionType
    NbPoints?: IntNullableFilter<"users_points"> | number | null
  }, "ID">

  export type users_pointsOrderByWithAggregationInput = {
    ID?: SortOrder
    ID_Utilisateur?: SortOrder
    TypeContribution?: SortOrder
    NbPoints?: SortOrderInput | SortOrder
    _count?: users_pointsCountOrderByAggregateInput
    _avg?: users_pointsAvgOrderByAggregateInput
    _max?: users_pointsMaxOrderByAggregateInput
    _min?: users_pointsMinOrderByAggregateInput
    _sum?: users_pointsSumOrderByAggregateInput
  }

  export type users_pointsScalarWhereWithAggregatesInput = {
    AND?: users_pointsScalarWhereWithAggregatesInput | users_pointsScalarWhereWithAggregatesInput[]
    OR?: users_pointsScalarWhereWithAggregatesInput[]
    NOT?: users_pointsScalarWhereWithAggregatesInput | users_pointsScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"users_points"> | number
    ID_Utilisateur?: IntWithAggregatesFilter<"users_points"> | number
    TypeContribution?: EnumuserContributionTypeWithAggregatesFilter<"users_points"> | $Enums.userContributionType
    NbPoints?: IntNullableWithAggregatesFilter<"users_points"> | number | null
  }

  export type userSuggestionNotificationWhereInput = {
    AND?: userSuggestionNotificationWhereInput | userSuggestionNotificationWhereInput[]
    OR?: userSuggestionNotificationWhereInput[]
    NOT?: userSuggestionNotificationWhereInput | userSuggestionNotificationWhereInput[]
    id?: IntFilter<"userSuggestionNotification"> | number
    userId?: IntFilter<"userSuggestionNotification"> | number
    issuecode?: StringFilter<"userSuggestionNotification"> | string
    text?: StringNullableFilter<"userSuggestionNotification"> | string | null
    date?: DateTimeNullableFilter<"userSuggestionNotification"> | Date | string | null
  }

  export type userSuggestionNotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    issuecode?: SortOrder
    text?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
  }

  export type userSuggestionNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_issuecode?: userSuggestionNotificationUserIdIssuecodeCompoundUniqueInput
    AND?: userSuggestionNotificationWhereInput | userSuggestionNotificationWhereInput[]
    OR?: userSuggestionNotificationWhereInput[]
    NOT?: userSuggestionNotificationWhereInput | userSuggestionNotificationWhereInput[]
    userId?: IntFilter<"userSuggestionNotification"> | number
    issuecode?: StringFilter<"userSuggestionNotification"> | string
    text?: StringNullableFilter<"userSuggestionNotification"> | string | null
    date?: DateTimeNullableFilter<"userSuggestionNotification"> | Date | string | null
  }, "id" | "userId_issuecode">

  export type userSuggestionNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    issuecode?: SortOrder
    text?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    _count?: userSuggestionNotificationCountOrderByAggregateInput
    _avg?: userSuggestionNotificationAvgOrderByAggregateInput
    _max?: userSuggestionNotificationMaxOrderByAggregateInput
    _min?: userSuggestionNotificationMinOrderByAggregateInput
    _sum?: userSuggestionNotificationSumOrderByAggregateInput
  }

  export type userSuggestionNotificationScalarWhereWithAggregatesInput = {
    AND?: userSuggestionNotificationScalarWhereWithAggregatesInput | userSuggestionNotificationScalarWhereWithAggregatesInput[]
    OR?: userSuggestionNotificationScalarWhereWithAggregatesInput[]
    NOT?: userSuggestionNotificationScalarWhereWithAggregatesInput | userSuggestionNotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"userSuggestionNotification"> | number
    userId?: IntWithAggregatesFilter<"userSuggestionNotification"> | number
    issuecode?: StringWithAggregatesFilter<"userSuggestionNotification"> | string
    text?: StringNullableWithAggregatesFilter<"userSuggestionNotification"> | string | null
    date?: DateTimeNullableWithAggregatesFilter<"userSuggestionNotification"> | Date | string | null
  }

  export type requestedIssueWhereInput = {
    AND?: requestedIssueWhereInput | requestedIssueWhereInput[]
    OR?: requestedIssueWhereInput[]
    NOT?: requestedIssueWhereInput | requestedIssueWhereInput[]
    id?: IntFilter<"requestedIssue"> | number
    issueId?: IntFilter<"requestedIssue"> | number
    buyerId?: IntFilter<"requestedIssue"> | number
    isBooked?: BoolFilter<"requestedIssue"> | boolean
  }

  export type requestedIssueOrderByWithRelationInput = {
    id?: SortOrder
    issueId?: SortOrder
    buyerId?: SortOrder
    isBooked?: SortOrder
  }

  export type requestedIssueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    issueId_buyerId?: requestedIssueIssueIdBuyerIdCompoundUniqueInput
    AND?: requestedIssueWhereInput | requestedIssueWhereInput[]
    OR?: requestedIssueWhereInput[]
    NOT?: requestedIssueWhereInput | requestedIssueWhereInput[]
    issueId?: IntFilter<"requestedIssue"> | number
    buyerId?: IntFilter<"requestedIssue"> | number
    isBooked?: BoolFilter<"requestedIssue"> | boolean
  }, "id" | "issueId_buyerId">

  export type requestedIssueOrderByWithAggregationInput = {
    id?: SortOrder
    issueId?: SortOrder
    buyerId?: SortOrder
    isBooked?: SortOrder
    _count?: requestedIssueCountOrderByAggregateInput
    _avg?: requestedIssueAvgOrderByAggregateInput
    _max?: requestedIssueMaxOrderByAggregateInput
    _min?: requestedIssueMinOrderByAggregateInput
    _sum?: requestedIssueSumOrderByAggregateInput
  }

  export type requestedIssueScalarWhereWithAggregatesInput = {
    AND?: requestedIssueScalarWhereWithAggregatesInput | requestedIssueScalarWhereWithAggregatesInput[]
    OR?: requestedIssueScalarWhereWithAggregatesInput[]
    NOT?: requestedIssueScalarWhereWithAggregatesInput | requestedIssueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"requestedIssue"> | number
    issueId?: IntWithAggregatesFilter<"requestedIssue"> | number
    buyerId?: IntWithAggregatesFilter<"requestedIssue"> | number
    isBooked?: BoolWithAggregatesFilter<"requestedIssue"> | boolean
  }

  export type subscriptionCreateInput = {
    country: string
    magazine: string
    startDate: Date | string
    endDate: Date | string
    users: userCreateNestedOneWithoutAbonnementsInput
  }

  export type subscriptionUncheckedCreateInput = {
    id?: number
    userId: number
    country: string
    magazine: string
    startDate: Date | string
    endDate: Date | string
  }

  export type subscriptionUpdateInput = {
    country?: StringFieldUpdateOperationsInput | string
    magazine?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: userUpdateOneRequiredWithoutAbonnementsNestedInput
  }

  export type subscriptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    magazine?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subscriptionCreateManyInput = {
    id?: number
    userId: number
    country: string
    magazine: string
    startDate: Date | string
    endDate: Date | string
  }

  export type subscriptionUpdateManyMutationInput = {
    country?: StringFieldUpdateOperationsInput | string
    magazine?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subscriptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    magazine?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type abonnements_sortiesCreateInput = {
    Pays: string
    Magazine: string
    Numero: string
    Date_sortie: Date | string
    Numeros_ajoutes?: boolean
  }

  export type abonnements_sortiesUncheckedCreateInput = {
    Pays: string
    Magazine: string
    Numero: string
    Date_sortie: Date | string
    Numeros_ajoutes?: boolean
  }

  export type abonnements_sortiesUpdateInput = {
    Pays?: StringFieldUpdateOperationsInput | string
    Magazine?: StringFieldUpdateOperationsInput | string
    Numero?: StringFieldUpdateOperationsInput | string
    Date_sortie?: DateTimeFieldUpdateOperationsInput | Date | string
    Numeros_ajoutes?: BoolFieldUpdateOperationsInput | boolean
  }

  export type abonnements_sortiesUncheckedUpdateInput = {
    Pays?: StringFieldUpdateOperationsInput | string
    Magazine?: StringFieldUpdateOperationsInput | string
    Numero?: StringFieldUpdateOperationsInput | string
    Date_sortie?: DateTimeFieldUpdateOperationsInput | Date | string
    Numeros_ajoutes?: BoolFieldUpdateOperationsInput | boolean
  }

  export type abonnements_sortiesCreateManyInput = {
    Pays: string
    Magazine: string
    Numero: string
    Date_sortie: Date | string
    Numeros_ajoutes?: boolean
  }

  export type abonnements_sortiesUpdateManyMutationInput = {
    Pays?: StringFieldUpdateOperationsInput | string
    Magazine?: StringFieldUpdateOperationsInput | string
    Numero?: StringFieldUpdateOperationsInput | string
    Date_sortie?: DateTimeFieldUpdateOperationsInput | Date | string
    Numeros_ajoutes?: BoolFieldUpdateOperationsInput | boolean
  }

  export type abonnements_sortiesUncheckedUpdateManyInput = {
    Pays?: StringFieldUpdateOperationsInput | string
    Magazine?: StringFieldUpdateOperationsInput | string
    Numero?: StringFieldUpdateOperationsInput | string
    Date_sortie?: DateTimeFieldUpdateOperationsInput | Date | string
    Numeros_ajoutes?: BoolFieldUpdateOperationsInput | boolean
  }

  export type purchaseCreateInput = {
    userId: number
    date: Date | string
    description: string
  }

  export type purchaseUncheckedCreateInput = {
    id?: number
    userId: number
    date: Date | string
    description: string
  }

  export type purchaseUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type purchaseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type purchaseCreateManyInput = {
    id?: number
    userId: number
    date: Date | string
    description: string
  }

  export type purchaseUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type purchaseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type authorUserCreateInput = {
    personcode: string
    userId: number
    notation?: number
  }

  export type authorUserUncheckedCreateInput = {
    id?: number
    personcode: string
    userId: number
    notation?: number
  }

  export type authorUserUpdateInput = {
    personcode?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    notation?: IntFieldUpdateOperationsInput | number
  }

  export type authorUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    personcode?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    notation?: IntFieldUpdateOperationsInput | number
  }

  export type authorUserCreateManyInput = {
    id?: number
    personcode: string
    userId: number
    notation?: number
  }

  export type authorUserUpdateManyMutationInput = {
    personcode?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    notation?: IntFieldUpdateOperationsInput | number
  }

  export type authorUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    personcode?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    notation?: IntFieldUpdateOperationsInput | number
  }

  export type bibliotheque_contributeursCreateInput = {
    Nom?: string | null
    Texte?: string | null
  }

  export type bibliotheque_contributeursUncheckedCreateInput = {
    ID?: number
    Nom?: string | null
    Texte?: string | null
  }

  export type bibliotheque_contributeursUpdateInput = {
    Nom?: NullableStringFieldUpdateOperationsInput | string | null
    Texte?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type bibliotheque_contributeursUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Nom?: NullableStringFieldUpdateOperationsInput | string | null
    Texte?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type bibliotheque_contributeursCreateManyInput = {
    ID?: number
    Nom?: string | null
    Texte?: string | null
  }

  export type bibliotheque_contributeursUpdateManyMutationInput = {
    Nom?: NullableStringFieldUpdateOperationsInput | string | null
    Texte?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type bibliotheque_contributeursUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Nom?: NullableStringFieldUpdateOperationsInput | string | null
    Texte?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type bookcasePublicationOrderCreateInput = {
    userId: number
    publicationcode: string
    order: number
  }

  export type bookcasePublicationOrderUncheckedCreateInput = {
    id?: number
    userId: number
    publicationcode: string
    order: number
  }

  export type bookcasePublicationOrderUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    publicationcode?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type bookcasePublicationOrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    publicationcode?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type bookcasePublicationOrderCreateManyInput = {
    id?: number
    userId: number
    publicationcode: string
    order: number
  }

  export type bookcasePublicationOrderUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    publicationcode?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type bookcasePublicationOrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    publicationcode?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type bookstoreCreateInput = {
    name: string
    address: string
    coordX: number
    coordY: number
    comments?: bookstoreCommentCreateNestedManyWithoutBouquineriesInput
    users_contributions?: userContributionCreateNestedManyWithoutBouquineriesInput
  }

  export type bookstoreUncheckedCreateInput = {
    id?: number
    name: string
    address: string
    coordX: number
    coordY: number
    comments?: bookstoreCommentUncheckedCreateNestedManyWithoutBouquineriesInput
    users_contributions?: userContributionUncheckedCreateNestedManyWithoutBouquineriesInput
  }

  export type bookstoreUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    coordX?: FloatFieldUpdateOperationsInput | number
    coordY?: FloatFieldUpdateOperationsInput | number
    comments?: bookstoreCommentUpdateManyWithoutBouquineriesNestedInput
    users_contributions?: userContributionUpdateManyWithoutBouquineriesNestedInput
  }

  export type bookstoreUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    coordX?: FloatFieldUpdateOperationsInput | number
    coordY?: FloatFieldUpdateOperationsInput | number
    comments?: bookstoreCommentUncheckedUpdateManyWithoutBouquineriesNestedInput
    users_contributions?: userContributionUncheckedUpdateManyWithoutBouquineriesNestedInput
  }

  export type bookstoreCreateManyInput = {
    id?: number
    name: string
    address: string
    coordX: number
    coordY: number
  }

  export type bookstoreUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    coordX?: FloatFieldUpdateOperationsInput | number
    coordY?: FloatFieldUpdateOperationsInput | number
  }

  export type bookstoreUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    coordX?: FloatFieldUpdateOperationsInput | number
    coordY?: FloatFieldUpdateOperationsInput | number
  }

  export type bookstoreCommentCreateInput = {
    comment: string
    creationDate?: Date | string
    isActive?: boolean
    bouquineries: bookstoreCreateNestedOneWithoutCommentsInput
    user?: userCreateNestedOneWithoutBouquineries_commentairesInput
    users_contributions?: userContributionCreateNestedManyWithoutBouquineries_commentairesInput
  }

  export type bookstoreCommentUncheckedCreateInput = {
    id?: number
    userId?: number | null
    comment: string
    creationDate?: Date | string
    isActive?: boolean
    bookstoreId: number
    users_contributions?: userContributionUncheckedCreateNestedManyWithoutBouquineries_commentairesInput
  }

  export type bookstoreCommentUpdateInput = {
    comment?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    bouquineries?: bookstoreUpdateOneRequiredWithoutCommentsNestedInput
    user?: userUpdateOneWithoutBouquineries_commentairesNestedInput
    users_contributions?: userContributionUpdateManyWithoutBouquineries_commentairesNestedInput
  }

  export type bookstoreCommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    bookstoreId?: IntFieldUpdateOperationsInput | number
    users_contributions?: userContributionUncheckedUpdateManyWithoutBouquineries_commentairesNestedInput
  }

  export type bookstoreCommentCreateManyInput = {
    id?: number
    userId?: number | null
    comment: string
    creationDate?: Date | string
    isActive?: boolean
    bookstoreId: number
  }

  export type bookstoreCommentUpdateManyMutationInput = {
    comment?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type bookstoreCommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    bookstoreId?: IntFieldUpdateOperationsInput | number
  }

  export type demoCreateInput = {
    id?: number
    lastReset: Date | string
  }

  export type demoUncheckedCreateInput = {
    id?: number
    lastReset: Date | string
  }

  export type demoUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    lastReset?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type demoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    lastReset?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type demoCreateManyInput = {
    id?: number
    lastReset: Date | string
  }

  export type demoUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    lastReset?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type demoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    lastReset?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type magazinesCreateInput = {
    PaysAbrege: string
    NomAbrege: string
    NomComplet: string
    RedirigeDepuis: string
    NeParaitPlus?: boolean | null
  }

  export type magazinesUncheckedCreateInput = {
    PaysAbrege: string
    NomAbrege: string
    NomComplet: string
    RedirigeDepuis: string
    NeParaitPlus?: boolean | null
  }

  export type magazinesUpdateInput = {
    PaysAbrege?: StringFieldUpdateOperationsInput | string
    NomAbrege?: StringFieldUpdateOperationsInput | string
    NomComplet?: StringFieldUpdateOperationsInput | string
    RedirigeDepuis?: StringFieldUpdateOperationsInput | string
    NeParaitPlus?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type magazinesUncheckedUpdateInput = {
    PaysAbrege?: StringFieldUpdateOperationsInput | string
    NomAbrege?: StringFieldUpdateOperationsInput | string
    NomComplet?: StringFieldUpdateOperationsInput | string
    RedirigeDepuis?: StringFieldUpdateOperationsInput | string
    NeParaitPlus?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type magazinesCreateManyInput = {
    PaysAbrege: string
    NomAbrege: string
    NomComplet: string
    RedirigeDepuis: string
    NeParaitPlus?: boolean | null
  }

  export type magazinesUpdateManyMutationInput = {
    PaysAbrege?: StringFieldUpdateOperationsInput | string
    NomAbrege?: StringFieldUpdateOperationsInput | string
    NomComplet?: StringFieldUpdateOperationsInput | string
    RedirigeDepuis?: StringFieldUpdateOperationsInput | string
    NeParaitPlus?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type magazinesUncheckedUpdateManyInput = {
    PaysAbrege?: StringFieldUpdateOperationsInput | string
    NomAbrege?: StringFieldUpdateOperationsInput | string
    NomComplet?: StringFieldUpdateOperationsInput | string
    RedirigeDepuis?: StringFieldUpdateOperationsInput | string
    NeParaitPlus?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type issueCreateInput = {
    country: string
    magazine: string
    issuenumber: string
    condition?: $Enums.issue_condition
    purchaseId?: number | null
    isOnSale: boolean
    isToRead?: boolean
    isSubscription?: boolean
    userId: number
    creationDate?: Date | string | null
  }

  export type issueUncheckedCreateInput = {
    id?: number
    country: string
    magazine: string
    issuenumber: string
    condition?: $Enums.issue_condition
    purchaseId?: number | null
    isOnSale: boolean
    isToRead?: boolean
    isSubscription?: boolean
    userId: number
    creationDate?: Date | string | null
  }

  export type issueUpdateInput = {
    country?: StringFieldUpdateOperationsInput | string
    magazine?: StringFieldUpdateOperationsInput | string
    issuenumber?: StringFieldUpdateOperationsInput | string
    condition?: Enumissue_conditionFieldUpdateOperationsInput | $Enums.issue_condition
    purchaseId?: NullableIntFieldUpdateOperationsInput | number | null
    isOnSale?: BoolFieldUpdateOperationsInput | boolean
    isToRead?: BoolFieldUpdateOperationsInput | boolean
    isSubscription?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    creationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type issueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    magazine?: StringFieldUpdateOperationsInput | string
    issuenumber?: StringFieldUpdateOperationsInput | string
    condition?: Enumissue_conditionFieldUpdateOperationsInput | $Enums.issue_condition
    purchaseId?: NullableIntFieldUpdateOperationsInput | number | null
    isOnSale?: BoolFieldUpdateOperationsInput | boolean
    isToRead?: BoolFieldUpdateOperationsInput | boolean
    isSubscription?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    creationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type issueCreateManyInput = {
    id?: number
    country: string
    magazine: string
    issuenumber: string
    condition?: $Enums.issue_condition
    purchaseId?: number | null
    isOnSale: boolean
    isToRead?: boolean
    isSubscription?: boolean
    userId: number
    creationDate?: Date | string | null
  }

  export type issueUpdateManyMutationInput = {
    country?: StringFieldUpdateOperationsInput | string
    magazine?: StringFieldUpdateOperationsInput | string
    issuenumber?: StringFieldUpdateOperationsInput | string
    condition?: Enumissue_conditionFieldUpdateOperationsInput | $Enums.issue_condition
    purchaseId?: NullableIntFieldUpdateOperationsInput | number | null
    isOnSale?: BoolFieldUpdateOperationsInput | boolean
    isToRead?: BoolFieldUpdateOperationsInput | boolean
    isSubscription?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    creationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type issueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    magazine?: StringFieldUpdateOperationsInput | string
    issuenumber?: StringFieldUpdateOperationsInput | string
    condition?: Enumissue_conditionFieldUpdateOperationsInput | $Enums.issue_condition
    purchaseId?: NullableIntFieldUpdateOperationsInput | number | null
    isOnSale?: BoolFieldUpdateOperationsInput | boolean
    isToRead?: BoolFieldUpdateOperationsInput | boolean
    isSubscription?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    creationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type issuePopularityCreateInput = {
    country: string
    magazine: string
    issuenumber: string
    popularity: number
  }

  export type issuePopularityUncheckedCreateInput = {
    country: string
    magazine: string
    issuenumber: string
    popularity: number
    id?: number
  }

  export type issuePopularityUpdateInput = {
    country?: StringFieldUpdateOperationsInput | string
    magazine?: StringFieldUpdateOperationsInput | string
    issuenumber?: StringFieldUpdateOperationsInput | string
    popularity?: IntFieldUpdateOperationsInput | number
  }

  export type issuePopularityUncheckedUpdateInput = {
    country?: StringFieldUpdateOperationsInput | string
    magazine?: StringFieldUpdateOperationsInput | string
    issuenumber?: StringFieldUpdateOperationsInput | string
    popularity?: IntFieldUpdateOperationsInput | number
    id?: IntFieldUpdateOperationsInput | number
  }

  export type issuePopularityCreateManyInput = {
    country: string
    magazine: string
    issuenumber: string
    popularity: number
    id?: number
  }

  export type issuePopularityUpdateManyMutationInput = {
    country?: StringFieldUpdateOperationsInput | string
    magazine?: StringFieldUpdateOperationsInput | string
    issuenumber?: StringFieldUpdateOperationsInput | string
    popularity?: IntFieldUpdateOperationsInput | number
  }

  export type issuePopularityUncheckedUpdateManyInput = {
    country?: StringFieldUpdateOperationsInput | string
    magazine?: StringFieldUpdateOperationsInput | string
    issuenumber?: StringFieldUpdateOperationsInput | string
    popularity?: IntFieldUpdateOperationsInput | number
    id?: IntFieldUpdateOperationsInput | number
  }

  export type tranches_doublonsCreateInput = {
    Pays: string
    Magazine: string
    Numero: string
    NumeroReference: string
    TrancheReference?: number | null
  }

  export type tranches_doublonsUncheckedCreateInput = {
    ID?: number
    Pays: string
    Magazine: string
    Numero: string
    NumeroReference: string
    TrancheReference?: number | null
  }

  export type tranches_doublonsUpdateInput = {
    Pays?: StringFieldUpdateOperationsInput | string
    Magazine?: StringFieldUpdateOperationsInput | string
    Numero?: StringFieldUpdateOperationsInput | string
    NumeroReference?: StringFieldUpdateOperationsInput | string
    TrancheReference?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tranches_doublonsUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Pays?: StringFieldUpdateOperationsInput | string
    Magazine?: StringFieldUpdateOperationsInput | string
    Numero?: StringFieldUpdateOperationsInput | string
    NumeroReference?: StringFieldUpdateOperationsInput | string
    TrancheReference?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tranches_doublonsCreateManyInput = {
    ID?: number
    Pays: string
    Magazine: string
    Numero: string
    NumeroReference: string
    TrancheReference?: number | null
  }

  export type tranches_doublonsUpdateManyMutationInput = {
    Pays?: StringFieldUpdateOperationsInput | string
    Magazine?: StringFieldUpdateOperationsInput | string
    Numero?: StringFieldUpdateOperationsInput | string
    NumeroReference?: StringFieldUpdateOperationsInput | string
    TrancheReference?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tranches_doublonsUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Pays?: StringFieldUpdateOperationsInput | string
    Magazine?: StringFieldUpdateOperationsInput | string
    Numero?: StringFieldUpdateOperationsInput | string
    NumeroReference?: StringFieldUpdateOperationsInput | string
    TrancheReference?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type edgeCreateInput = {
    publicationcode: string
    issuenumber: string
    creationDate?: Date | string
    points?: number | null
    slug?: string | null
    issuecode?: string | null
    users_contributions?: userContributionCreateNestedManyWithoutTranches_pretesInput
  }

  export type edgeUncheckedCreateInput = {
    id?: number
    publicationcode: string
    issuenumber: string
    creationDate?: Date | string
    points?: number | null
    slug?: string | null
    issuecode?: string | null
    users_contributions?: userContributionUncheckedCreateNestedManyWithoutTranches_pretesInput
  }

  export type edgeUpdateInput = {
    publicationcode?: StringFieldUpdateOperationsInput | string
    issuenumber?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: NullableIntFieldUpdateOperationsInput | number | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    issuecode?: NullableStringFieldUpdateOperationsInput | string | null
    users_contributions?: userContributionUpdateManyWithoutTranches_pretesNestedInput
  }

  export type edgeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicationcode?: StringFieldUpdateOperationsInput | string
    issuenumber?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: NullableIntFieldUpdateOperationsInput | number | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    issuecode?: NullableStringFieldUpdateOperationsInput | string | null
    users_contributions?: userContributionUncheckedUpdateManyWithoutTranches_pretesNestedInput
  }

  export type edgeCreateManyInput = {
    id?: number
    publicationcode: string
    issuenumber: string
    creationDate?: Date | string
    points?: number | null
    slug?: string | null
    issuecode?: string | null
  }

  export type edgeUpdateManyMutationInput = {
    publicationcode?: StringFieldUpdateOperationsInput | string
    issuenumber?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: NullableIntFieldUpdateOperationsInput | number | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    issuecode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type edgeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicationcode?: StringFieldUpdateOperationsInput | string
    issuenumber?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: NullableIntFieldUpdateOperationsInput | number | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    issuecode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tranches_pretes_contributeursCreateInput = {
    publicationcode: string
    issuenumber: string
    contributeur: number
    contribution?: $Enums.tranches_pretes_contributeurs_contribution
  }

  export type tranches_pretes_contributeursUncheckedCreateInput = {
    publicationcode: string
    issuenumber: string
    contributeur: number
    contribution?: $Enums.tranches_pretes_contributeurs_contribution
  }

  export type tranches_pretes_contributeursUpdateInput = {
    publicationcode?: StringFieldUpdateOperationsInput | string
    issuenumber?: StringFieldUpdateOperationsInput | string
    contributeur?: IntFieldUpdateOperationsInput | number
    contribution?: Enumtranches_pretes_contributeurs_contributionFieldUpdateOperationsInput | $Enums.tranches_pretes_contributeurs_contribution
  }

  export type tranches_pretes_contributeursUncheckedUpdateInput = {
    publicationcode?: StringFieldUpdateOperationsInput | string
    issuenumber?: StringFieldUpdateOperationsInput | string
    contributeur?: IntFieldUpdateOperationsInput | number
    contribution?: Enumtranches_pretes_contributeurs_contributionFieldUpdateOperationsInput | $Enums.tranches_pretes_contributeurs_contribution
  }

  export type tranches_pretes_contributeursCreateManyInput = {
    publicationcode: string
    issuenumber: string
    contributeur: number
    contribution?: $Enums.tranches_pretes_contributeurs_contribution
  }

  export type tranches_pretes_contributeursUpdateManyMutationInput = {
    publicationcode?: StringFieldUpdateOperationsInput | string
    issuenumber?: StringFieldUpdateOperationsInput | string
    contributeur?: IntFieldUpdateOperationsInput | number
    contribution?: Enumtranches_pretes_contributeurs_contributionFieldUpdateOperationsInput | $Enums.tranches_pretes_contributeurs_contribution
  }

  export type tranches_pretes_contributeursUncheckedUpdateManyInput = {
    publicationcode?: StringFieldUpdateOperationsInput | string
    issuenumber?: StringFieldUpdateOperationsInput | string
    contributeur?: IntFieldUpdateOperationsInput | number
    contribution?: Enumtranches_pretes_contributeurs_contributionFieldUpdateOperationsInput | $Enums.tranches_pretes_contributeurs_contribution
  }

  export type tranches_pretes_contributionsCreateInput = {
    ID_tranche: number
    ID_user: number
    dateajout?: Date | string
    contribution: $Enums.tranches_pretes_contributions_contribution
    points_new: number
    points_total: number
  }

  export type tranches_pretes_contributionsUncheckedCreateInput = {
    ID?: number
    ID_tranche: number
    ID_user: number
    dateajout?: Date | string
    contribution: $Enums.tranches_pretes_contributions_contribution
    points_new: number
    points_total: number
  }

  export type tranches_pretes_contributionsUpdateInput = {
    ID_tranche?: IntFieldUpdateOperationsInput | number
    ID_user?: IntFieldUpdateOperationsInput | number
    dateajout?: DateTimeFieldUpdateOperationsInput | Date | string
    contribution?: Enumtranches_pretes_contributions_contributionFieldUpdateOperationsInput | $Enums.tranches_pretes_contributions_contribution
    points_new?: IntFieldUpdateOperationsInput | number
    points_total?: IntFieldUpdateOperationsInput | number
  }

  export type tranches_pretes_contributionsUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    ID_tranche?: IntFieldUpdateOperationsInput | number
    ID_user?: IntFieldUpdateOperationsInput | number
    dateajout?: DateTimeFieldUpdateOperationsInput | Date | string
    contribution?: Enumtranches_pretes_contributions_contributionFieldUpdateOperationsInput | $Enums.tranches_pretes_contributions_contribution
    points_new?: IntFieldUpdateOperationsInput | number
    points_total?: IntFieldUpdateOperationsInput | number
  }

  export type tranches_pretes_contributionsCreateManyInput = {
    ID?: number
    ID_tranche: number
    ID_user: number
    dateajout?: Date | string
    contribution: $Enums.tranches_pretes_contributions_contribution
    points_new: number
    points_total: number
  }

  export type tranches_pretes_contributionsUpdateManyMutationInput = {
    ID_tranche?: IntFieldUpdateOperationsInput | number
    ID_user?: IntFieldUpdateOperationsInput | number
    dateajout?: DateTimeFieldUpdateOperationsInput | Date | string
    contribution?: Enumtranches_pretes_contributions_contributionFieldUpdateOperationsInput | $Enums.tranches_pretes_contributions_contribution
    points_new?: IntFieldUpdateOperationsInput | number
    points_total?: IntFieldUpdateOperationsInput | number
  }

  export type tranches_pretes_contributionsUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    ID_tranche?: IntFieldUpdateOperationsInput | number
    ID_user?: IntFieldUpdateOperationsInput | number
    dateajout?: DateTimeFieldUpdateOperationsInput | Date | string
    contribution?: Enumtranches_pretes_contributions_contributionFieldUpdateOperationsInput | $Enums.tranches_pretes_contributions_contribution
    points_new?: IntFieldUpdateOperationsInput | number
    points_total?: IntFieldUpdateOperationsInput | number
  }

  export type edgeSpriteCreateInput = {
    edgeId: number
    spriteName: string
    spriteSize?: number | null
  }

  export type edgeSpriteUncheckedCreateInput = {
    id?: number
    edgeId: number
    spriteName: string
    spriteSize?: number | null
  }

  export type edgeSpriteUpdateInput = {
    edgeId?: IntFieldUpdateOperationsInput | number
    spriteName?: StringFieldUpdateOperationsInput | string
    spriteSize?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type edgeSpriteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    edgeId?: IntFieldUpdateOperationsInput | number
    spriteName?: StringFieldUpdateOperationsInput | string
    spriteSize?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type edgeSpriteCreateManyInput = {
    id?: number
    edgeId: number
    spriteName: string
    spriteSize?: number | null
  }

  export type edgeSpriteUpdateManyMutationInput = {
    edgeId?: IntFieldUpdateOperationsInput | number
    spriteName?: StringFieldUpdateOperationsInput | string
    spriteSize?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type edgeSpriteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    edgeId?: IntFieldUpdateOperationsInput | number
    spriteName?: StringFieldUpdateOperationsInput | string
    spriteSize?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type edgeSpriteSizeCreateInput = {
    spriteName?: string | null
    size?: number | null
  }

  export type edgeSpriteSizeUncheckedCreateInput = {
    id?: number
    spriteName?: string | null
    size?: number | null
  }

  export type edgeSpriteSizeUpdateInput = {
    spriteName?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type edgeSpriteSizeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    spriteName?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type edgeSpriteSizeCreateManyInput = {
    id?: number
    spriteName?: string | null
    size?: number | null
  }

  export type edgeSpriteSizeUpdateManyMutationInput = {
    spriteName?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type edgeSpriteSizeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    spriteName?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type edgeSpriteUrlCreateInput = {
    spriteName: string
    version: string
  }

  export type edgeSpriteUrlUncheckedCreateInput = {
    id?: number
    spriteName: string
    version: string
  }

  export type edgeSpriteUrlUpdateInput = {
    spriteName?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
  }

  export type edgeSpriteUrlUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    spriteName?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
  }

  export type edgeSpriteUrlCreateManyInput = {
    id?: number
    spriteName: string
    version: string
  }

  export type edgeSpriteUrlUpdateManyMutationInput = {
    spriteName?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
  }

  export type edgeSpriteUrlUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    spriteName?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
  }

  export type userCreateInput = {
    username: string
    password: string
    allowSharing?: boolean
    signupDate: Date | string
    email: string
    discordId?: number | null
    showRecommendations?: boolean
    isBetaUser?: boolean
    showPresentationVideo?: boolean
    showDuplicatesInBookcase?: boolean
    bookcaseTexture1?: string
    bookcaseSubTexture1?: string
    bookcaseTexture2?: string
    bookcaseSubTexture2?: string
    presentationText?: string | null
    lastAccess?: Date | string | null
    previousAccess?: Date | string | null
    marketplaceAcceptsExchanges?: boolean
    abonnements?: subscriptionCreateNestedManyWithoutUsersInput
    bouquineries_commentaires?: bookstoreCommentCreateNestedManyWithoutUserInput
    users_contributions?: userContributionCreateNestedManyWithoutUsersInput
    users_options?: userOptionCreateNestedManyWithoutUsersInput
  }

  export type userUncheckedCreateInput = {
    id?: number
    username: string
    password: string
    allowSharing?: boolean
    signupDate: Date | string
    email: string
    discordId?: number | null
    showRecommendations?: boolean
    isBetaUser?: boolean
    showPresentationVideo?: boolean
    showDuplicatesInBookcase?: boolean
    bookcaseTexture1?: string
    bookcaseSubTexture1?: string
    bookcaseTexture2?: string
    bookcaseSubTexture2?: string
    presentationText?: string | null
    lastAccess?: Date | string | null
    previousAccess?: Date | string | null
    marketplaceAcceptsExchanges?: boolean
    abonnements?: subscriptionUncheckedCreateNestedManyWithoutUsersInput
    bouquineries_commentaires?: bookstoreCommentUncheckedCreateNestedManyWithoutUserInput
    users_contributions?: userContributionUncheckedCreateNestedManyWithoutUsersInput
    users_options?: userOptionUncheckedCreateNestedManyWithoutUsersInput
  }

  export type userUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    allowSharing?: BoolFieldUpdateOperationsInput | boolean
    signupDate?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    discordId?: NullableIntFieldUpdateOperationsInput | number | null
    showRecommendations?: BoolFieldUpdateOperationsInput | boolean
    isBetaUser?: BoolFieldUpdateOperationsInput | boolean
    showPresentationVideo?: BoolFieldUpdateOperationsInput | boolean
    showDuplicatesInBookcase?: BoolFieldUpdateOperationsInput | boolean
    bookcaseTexture1?: StringFieldUpdateOperationsInput | string
    bookcaseSubTexture1?: StringFieldUpdateOperationsInput | string
    bookcaseTexture2?: StringFieldUpdateOperationsInput | string
    bookcaseSubTexture2?: StringFieldUpdateOperationsInput | string
    presentationText?: NullableStringFieldUpdateOperationsInput | string | null
    lastAccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousAccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketplaceAcceptsExchanges?: BoolFieldUpdateOperationsInput | boolean
    abonnements?: subscriptionUpdateManyWithoutUsersNestedInput
    bouquineries_commentaires?: bookstoreCommentUpdateManyWithoutUserNestedInput
    users_contributions?: userContributionUpdateManyWithoutUsersNestedInput
    users_options?: userOptionUpdateManyWithoutUsersNestedInput
  }

  export type userUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    allowSharing?: BoolFieldUpdateOperationsInput | boolean
    signupDate?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    discordId?: NullableIntFieldUpdateOperationsInput | number | null
    showRecommendations?: BoolFieldUpdateOperationsInput | boolean
    isBetaUser?: BoolFieldUpdateOperationsInput | boolean
    showPresentationVideo?: BoolFieldUpdateOperationsInput | boolean
    showDuplicatesInBookcase?: BoolFieldUpdateOperationsInput | boolean
    bookcaseTexture1?: StringFieldUpdateOperationsInput | string
    bookcaseSubTexture1?: StringFieldUpdateOperationsInput | string
    bookcaseTexture2?: StringFieldUpdateOperationsInput | string
    bookcaseSubTexture2?: StringFieldUpdateOperationsInput | string
    presentationText?: NullableStringFieldUpdateOperationsInput | string | null
    lastAccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousAccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketplaceAcceptsExchanges?: BoolFieldUpdateOperationsInput | boolean
    abonnements?: subscriptionUncheckedUpdateManyWithoutUsersNestedInput
    bouquineries_commentaires?: bookstoreCommentUncheckedUpdateManyWithoutUserNestedInput
    users_contributions?: userContributionUncheckedUpdateManyWithoutUsersNestedInput
    users_options?: userOptionUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type userCreateManyInput = {
    id?: number
    username: string
    password: string
    allowSharing?: boolean
    signupDate: Date | string
    email: string
    discordId?: number | null
    showRecommendations?: boolean
    isBetaUser?: boolean
    showPresentationVideo?: boolean
    showDuplicatesInBookcase?: boolean
    bookcaseTexture1?: string
    bookcaseSubTexture1?: string
    bookcaseTexture2?: string
    bookcaseSubTexture2?: string
    presentationText?: string | null
    lastAccess?: Date | string | null
    previousAccess?: Date | string | null
    marketplaceAcceptsExchanges?: boolean
  }

  export type userUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    allowSharing?: BoolFieldUpdateOperationsInput | boolean
    signupDate?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    discordId?: NullableIntFieldUpdateOperationsInput | number | null
    showRecommendations?: BoolFieldUpdateOperationsInput | boolean
    isBetaUser?: BoolFieldUpdateOperationsInput | boolean
    showPresentationVideo?: BoolFieldUpdateOperationsInput | boolean
    showDuplicatesInBookcase?: BoolFieldUpdateOperationsInput | boolean
    bookcaseTexture1?: StringFieldUpdateOperationsInput | string
    bookcaseSubTexture1?: StringFieldUpdateOperationsInput | string
    bookcaseTexture2?: StringFieldUpdateOperationsInput | string
    bookcaseSubTexture2?: StringFieldUpdateOperationsInput | string
    presentationText?: NullableStringFieldUpdateOperationsInput | string | null
    lastAccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousAccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketplaceAcceptsExchanges?: BoolFieldUpdateOperationsInput | boolean
  }

  export type userUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    allowSharing?: BoolFieldUpdateOperationsInput | boolean
    signupDate?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    discordId?: NullableIntFieldUpdateOperationsInput | number | null
    showRecommendations?: BoolFieldUpdateOperationsInput | boolean
    isBetaUser?: BoolFieldUpdateOperationsInput | boolean
    showPresentationVideo?: BoolFieldUpdateOperationsInput | boolean
    showDuplicatesInBookcase?: BoolFieldUpdateOperationsInput | boolean
    bookcaseTexture1?: StringFieldUpdateOperationsInput | string
    bookcaseSubTexture1?: StringFieldUpdateOperationsInput | string
    bookcaseTexture2?: StringFieldUpdateOperationsInput | string
    bookcaseSubTexture2?: StringFieldUpdateOperationsInput | string
    presentationText?: NullableStringFieldUpdateOperationsInput | string | null
    lastAccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousAccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketplaceAcceptsExchanges?: BoolFieldUpdateOperationsInput | boolean
  }

  export type userContributionCreateInput = {
    date?: Date | string
    contribution: string
    newPoints: number
    totalPoints: number
    isEmailSent: boolean
    tranches_pretes?: edgeCreateNestedOneWithoutUsers_contributionsInput
    bouquineries?: bookstoreCreateNestedOneWithoutUsers_contributionsInput
    users: userCreateNestedOneWithoutUsers_contributionsInput
    bouquineries_commentaires?: bookstoreCommentCreateNestedOneWithoutUsers_contributionsInput
  }

  export type userContributionUncheckedCreateInput = {
    id?: number
    userId: number
    date?: Date | string
    contribution: string
    newPoints: number
    totalPoints: number
    isEmailSent: boolean
    edgeId?: number | null
    bookstoreId?: number | null
    bookstoreCommentId?: number | null
  }

  export type userContributionUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    contribution?: StringFieldUpdateOperationsInput | string
    newPoints?: IntFieldUpdateOperationsInput | number
    totalPoints?: IntFieldUpdateOperationsInput | number
    isEmailSent?: BoolFieldUpdateOperationsInput | boolean
    tranches_pretes?: edgeUpdateOneWithoutUsers_contributionsNestedInput
    bouquineries?: bookstoreUpdateOneWithoutUsers_contributionsNestedInput
    users?: userUpdateOneRequiredWithoutUsers_contributionsNestedInput
    bouquineries_commentaires?: bookstoreCommentUpdateOneWithoutUsers_contributionsNestedInput
  }

  export type userContributionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    contribution?: StringFieldUpdateOperationsInput | string
    newPoints?: IntFieldUpdateOperationsInput | number
    totalPoints?: IntFieldUpdateOperationsInput | number
    isEmailSent?: BoolFieldUpdateOperationsInput | boolean
    edgeId?: NullableIntFieldUpdateOperationsInput | number | null
    bookstoreId?: NullableIntFieldUpdateOperationsInput | number | null
    bookstoreCommentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type userContributionCreateManyInput = {
    id?: number
    userId: number
    date?: Date | string
    contribution: string
    newPoints: number
    totalPoints: number
    isEmailSent: boolean
    edgeId?: number | null
    bookstoreId?: number | null
    bookstoreCommentId?: number | null
  }

  export type userContributionUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    contribution?: StringFieldUpdateOperationsInput | string
    newPoints?: IntFieldUpdateOperationsInput | number
    totalPoints?: IntFieldUpdateOperationsInput | number
    isEmailSent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type userContributionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    contribution?: StringFieldUpdateOperationsInput | string
    newPoints?: IntFieldUpdateOperationsInput | number
    totalPoints?: IntFieldUpdateOperationsInput | number
    isEmailSent?: BoolFieldUpdateOperationsInput | boolean
    edgeId?: NullableIntFieldUpdateOperationsInput | number | null
    bookstoreId?: NullableIntFieldUpdateOperationsInput | number | null
    bookstoreCommentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type userOptionCreateInput = {
    optionName: $Enums.userOptionType
    optionValue: string
    users: userCreateNestedOneWithoutUsers_optionsInput
  }

  export type userOptionUncheckedCreateInput = {
    id?: number
    userId: number
    optionName: $Enums.userOptionType
    optionValue: string
  }

  export type userOptionUpdateInput = {
    optionName?: EnumuserOptionTypeFieldUpdateOperationsInput | $Enums.userOptionType
    optionValue?: StringFieldUpdateOperationsInput | string
    users?: userUpdateOneRequiredWithoutUsers_optionsNestedInput
  }

  export type userOptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    optionName?: EnumuserOptionTypeFieldUpdateOperationsInput | $Enums.userOptionType
    optionValue?: StringFieldUpdateOperationsInput | string
  }

  export type userOptionCreateManyInput = {
    id?: number
    userId: number
    optionName: $Enums.userOptionType
    optionValue: string
  }

  export type userOptionUpdateManyMutationInput = {
    optionName?: EnumuserOptionTypeFieldUpdateOperationsInput | $Enums.userOptionType
    optionValue?: StringFieldUpdateOperationsInput | string
  }

  export type userOptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    optionName?: EnumuserOptionTypeFieldUpdateOperationsInput | $Enums.userOptionType
    optionValue?: StringFieldUpdateOperationsInput | string
  }

  export type userPasswordTokenCreateInput = {
    userId: number
    token: string
  }

  export type userPasswordTokenUncheckedCreateInput = {
    id?: number
    userId: number
    token: string
  }

  export type userPasswordTokenUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
  }

  export type userPasswordTokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
  }

  export type userPasswordTokenCreateManyInput = {
    id?: number
    userId: number
    token: string
  }

  export type userPasswordTokenUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
  }

  export type userPasswordTokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
  }

  export type userPermissionCreateInput = {
    username: string
    role: string
    privilege: $Enums.users_permissions_privilege
  }

  export type userPermissionUncheckedCreateInput = {
    id?: number
    username: string
    role: string
    privilege: $Enums.users_permissions_privilege
  }

  export type userPermissionUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    privilege?: Enumusers_permissions_privilegeFieldUpdateOperationsInput | $Enums.users_permissions_privilege
  }

  export type userPermissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    privilege?: Enumusers_permissions_privilegeFieldUpdateOperationsInput | $Enums.users_permissions_privilege
  }

  export type userPermissionCreateManyInput = {
    id?: number
    username: string
    role: string
    privilege: $Enums.users_permissions_privilege
  }

  export type userPermissionUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    privilege?: Enumusers_permissions_privilegeFieldUpdateOperationsInput | $Enums.users_permissions_privilege
  }

  export type userPermissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    privilege?: Enumusers_permissions_privilegeFieldUpdateOperationsInput | $Enums.users_permissions_privilege
  }

  export type users_pointsCreateInput = {
    ID_Utilisateur: number
    TypeContribution: $Enums.userContributionType
    NbPoints?: number | null
  }

  export type users_pointsUncheckedCreateInput = {
    ID?: number
    ID_Utilisateur: number
    TypeContribution: $Enums.userContributionType
    NbPoints?: number | null
  }

  export type users_pointsUpdateInput = {
    ID_Utilisateur?: IntFieldUpdateOperationsInput | number
    TypeContribution?: EnumuserContributionTypeFieldUpdateOperationsInput | $Enums.userContributionType
    NbPoints?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type users_pointsUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    ID_Utilisateur?: IntFieldUpdateOperationsInput | number
    TypeContribution?: EnumuserContributionTypeFieldUpdateOperationsInput | $Enums.userContributionType
    NbPoints?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type users_pointsCreateManyInput = {
    ID?: number
    ID_Utilisateur: number
    TypeContribution: $Enums.userContributionType
    NbPoints?: number | null
  }

  export type users_pointsUpdateManyMutationInput = {
    ID_Utilisateur?: IntFieldUpdateOperationsInput | number
    TypeContribution?: EnumuserContributionTypeFieldUpdateOperationsInput | $Enums.userContributionType
    NbPoints?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type users_pointsUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    ID_Utilisateur?: IntFieldUpdateOperationsInput | number
    TypeContribution?: EnumuserContributionTypeFieldUpdateOperationsInput | $Enums.userContributionType
    NbPoints?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type userSuggestionNotificationCreateInput = {
    userId: number
    issuecode: string
    text?: string | null
    date?: Date | string | null
  }

  export type userSuggestionNotificationUncheckedCreateInput = {
    id?: number
    userId: number
    issuecode: string
    text?: string | null
    date?: Date | string | null
  }

  export type userSuggestionNotificationUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    issuecode?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userSuggestionNotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    issuecode?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userSuggestionNotificationCreateManyInput = {
    id?: number
    userId: number
    issuecode: string
    text?: string | null
    date?: Date | string | null
  }

  export type userSuggestionNotificationUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    issuecode?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userSuggestionNotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    issuecode?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type requestedIssueCreateInput = {
    issueId: number
    buyerId: number
    isBooked?: boolean
  }

  export type requestedIssueUncheckedCreateInput = {
    id?: number
    issueId: number
    buyerId: number
    isBooked?: boolean
  }

  export type requestedIssueUpdateInput = {
    issueId?: IntFieldUpdateOperationsInput | number
    buyerId?: IntFieldUpdateOperationsInput | number
    isBooked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type requestedIssueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    issueId?: IntFieldUpdateOperationsInput | number
    buyerId?: IntFieldUpdateOperationsInput | number
    isBooked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type requestedIssueCreateManyInput = {
    id?: number
    issueId: number
    buyerId: number
    isBooked?: boolean
  }

  export type requestedIssueUpdateManyMutationInput = {
    issueId?: IntFieldUpdateOperationsInput | number
    buyerId?: IntFieldUpdateOperationsInput | number
    isBooked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type requestedIssueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    issueId?: IntFieldUpdateOperationsInput | number
    buyerId?: IntFieldUpdateOperationsInput | number
    isBooked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type subscriptionCountryMagazineUserIdStartDateEndDateCompoundUniqueInput = {
    country: string
    magazine: string
    userId: number
    startDate: Date | string
    endDate: Date | string
  }

  export type subscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    country?: SortOrder
    magazine?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type subscriptionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type subscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    country?: SortOrder
    magazine?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type subscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    country?: SortOrder
    magazine?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type subscriptionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type abonnements_sortiesPaysMagazineNumeroCompoundUniqueInput = {
    Pays: string
    Magazine: string
    Numero: string
  }

  export type abonnements_sortiesCountOrderByAggregateInput = {
    Pays?: SortOrder
    Magazine?: SortOrder
    Numero?: SortOrder
    Date_sortie?: SortOrder
    Numeros_ajoutes?: SortOrder
  }

  export type abonnements_sortiesMaxOrderByAggregateInput = {
    Pays?: SortOrder
    Magazine?: SortOrder
    Numero?: SortOrder
    Date_sortie?: SortOrder
    Numeros_ajoutes?: SortOrder
  }

  export type abonnements_sortiesMinOrderByAggregateInput = {
    Pays?: SortOrder
    Magazine?: SortOrder
    Numero?: SortOrder
    Date_sortie?: SortOrder
    Numeros_ajoutes?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type purchaseUserIdDateDescriptionCompoundUniqueInput = {
    userId: number
    date: Date | string
    description: string
  }

  export type purchaseCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    description?: SortOrder
  }

  export type purchaseAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type purchaseMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    description?: SortOrder
  }

  export type purchaseMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    description?: SortOrder
  }

  export type purchaseSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type authorUserUserIdPersoncodeCompoundUniqueInput = {
    userId: number
    personcode: string
  }

  export type authorUserCountOrderByAggregateInput = {
    id?: SortOrder
    personcode?: SortOrder
    userId?: SortOrder
    notation?: SortOrder
  }

  export type authorUserAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    notation?: SortOrder
  }

  export type authorUserMaxOrderByAggregateInput = {
    id?: SortOrder
    personcode?: SortOrder
    userId?: SortOrder
    notation?: SortOrder
  }

  export type authorUserMinOrderByAggregateInput = {
    id?: SortOrder
    personcode?: SortOrder
    userId?: SortOrder
    notation?: SortOrder
  }

  export type authorUserSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    notation?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type bibliotheque_contributeursCountOrderByAggregateInput = {
    ID?: SortOrder
    Nom?: SortOrder
    Texte?: SortOrder
  }

  export type bibliotheque_contributeursAvgOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type bibliotheque_contributeursMaxOrderByAggregateInput = {
    ID?: SortOrder
    Nom?: SortOrder
    Texte?: SortOrder
  }

  export type bibliotheque_contributeursMinOrderByAggregateInput = {
    ID?: SortOrder
    Nom?: SortOrder
    Texte?: SortOrder
  }

  export type bibliotheque_contributeursSumOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type bookcasePublicationOrderUserIdPublicationcodeCompoundUniqueInput = {
    userId: number
    publicationcode: string
  }

  export type bookcasePublicationOrderCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    publicationcode?: SortOrder
    order?: SortOrder
  }

  export type bookcasePublicationOrderAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    order?: SortOrder
  }

  export type bookcasePublicationOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    publicationcode?: SortOrder
    order?: SortOrder
  }

  export type bookcasePublicationOrderMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    publicationcode?: SortOrder
    order?: SortOrder
  }

  export type bookcasePublicationOrderSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    order?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type BookstoreCommentListRelationFilter = {
    every?: bookstoreCommentWhereInput
    some?: bookstoreCommentWhereInput
    none?: bookstoreCommentWhereInput
  }

  export type UserContributionListRelationFilter = {
    every?: userContributionWhereInput
    some?: userContributionWhereInput
    none?: userContributionWhereInput
  }

  export type bookstoreCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userContributionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type bookstoreCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    coordX?: SortOrder
    coordY?: SortOrder
  }

  export type bookstoreAvgOrderByAggregateInput = {
    id?: SortOrder
    coordX?: SortOrder
    coordY?: SortOrder
  }

  export type bookstoreMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    coordX?: SortOrder
    coordY?: SortOrder
  }

  export type bookstoreMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    coordX?: SortOrder
    coordY?: SortOrder
  }

  export type bookstoreSumOrderByAggregateInput = {
    id?: SortOrder
    coordX?: SortOrder
    coordY?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BookstoreRelationFilter = {
    is?: bookstoreWhereInput
    isNot?: bookstoreWhereInput
  }

  export type UserNullableRelationFilter = {
    is?: userWhereInput | null
    isNot?: userWhereInput | null
  }

  export type bookstoreCommentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    comment?: SortOrder
    creationDate?: SortOrder
    isActive?: SortOrder
    bookstoreId?: SortOrder
  }

  export type bookstoreCommentAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bookstoreId?: SortOrder
  }

  export type bookstoreCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    comment?: SortOrder
    creationDate?: SortOrder
    isActive?: SortOrder
    bookstoreId?: SortOrder
  }

  export type bookstoreCommentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    comment?: SortOrder
    creationDate?: SortOrder
    isActive?: SortOrder
    bookstoreId?: SortOrder
  }

  export type bookstoreCommentSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bookstoreId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type demoCountOrderByAggregateInput = {
    id?: SortOrder
    lastReset?: SortOrder
  }

  export type demoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type demoMaxOrderByAggregateInput = {
    id?: SortOrder
    lastReset?: SortOrder
  }

  export type demoMinOrderByAggregateInput = {
    id?: SortOrder
    lastReset?: SortOrder
  }

  export type demoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type magazinesPaysAbregeNomAbregeRedirigeDepuisCompoundUniqueInput = {
    PaysAbrege: string
    NomAbrege: string
    RedirigeDepuis: string
  }

  export type magazinesCountOrderByAggregateInput = {
    PaysAbrege?: SortOrder
    NomAbrege?: SortOrder
    NomComplet?: SortOrder
    RedirigeDepuis?: SortOrder
    NeParaitPlus?: SortOrder
  }

  export type magazinesMaxOrderByAggregateInput = {
    PaysAbrege?: SortOrder
    NomAbrege?: SortOrder
    NomComplet?: SortOrder
    RedirigeDepuis?: SortOrder
    NeParaitPlus?: SortOrder
  }

  export type magazinesMinOrderByAggregateInput = {
    PaysAbrege?: SortOrder
    NomAbrege?: SortOrder
    NomComplet?: SortOrder
    RedirigeDepuis?: SortOrder
    NeParaitPlus?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type Enumissue_conditionFilter<$PrismaModel = never> = {
    equals?: $Enums.issue_condition | Enumissue_conditionFieldRefInput<$PrismaModel>
    in?: $Enums.issue_condition[]
    notIn?: $Enums.issue_condition[]
    not?: NestedEnumissue_conditionFilter<$PrismaModel> | $Enums.issue_condition
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type issueCountOrderByAggregateInput = {
    id?: SortOrder
    country?: SortOrder
    magazine?: SortOrder
    issuenumber?: SortOrder
    condition?: SortOrder
    purchaseId?: SortOrder
    isOnSale?: SortOrder
    isToRead?: SortOrder
    isSubscription?: SortOrder
    userId?: SortOrder
    creationDate?: SortOrder
  }

  export type issueAvgOrderByAggregateInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    userId?: SortOrder
  }

  export type issueMaxOrderByAggregateInput = {
    id?: SortOrder
    country?: SortOrder
    magazine?: SortOrder
    issuenumber?: SortOrder
    condition?: SortOrder
    purchaseId?: SortOrder
    isOnSale?: SortOrder
    isToRead?: SortOrder
    isSubscription?: SortOrder
    userId?: SortOrder
    creationDate?: SortOrder
  }

  export type issueMinOrderByAggregateInput = {
    id?: SortOrder
    country?: SortOrder
    magazine?: SortOrder
    issuenumber?: SortOrder
    condition?: SortOrder
    purchaseId?: SortOrder
    isOnSale?: SortOrder
    isToRead?: SortOrder
    isSubscription?: SortOrder
    userId?: SortOrder
    creationDate?: SortOrder
  }

  export type issueSumOrderByAggregateInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    userId?: SortOrder
  }

  export type Enumissue_conditionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.issue_condition | Enumissue_conditionFieldRefInput<$PrismaModel>
    in?: $Enums.issue_condition[]
    notIn?: $Enums.issue_condition[]
    not?: NestedEnumissue_conditionWithAggregatesFilter<$PrismaModel> | $Enums.issue_condition
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumissue_conditionFilter<$PrismaModel>
    _max?: NestedEnumissue_conditionFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type issuePopularityCountryMagazineIssuenumberCompoundUniqueInput = {
    country: string
    magazine: string
    issuenumber: string
  }

  export type issuePopularityCountOrderByAggregateInput = {
    country?: SortOrder
    magazine?: SortOrder
    issuenumber?: SortOrder
    popularity?: SortOrder
    id?: SortOrder
  }

  export type issuePopularityAvgOrderByAggregateInput = {
    popularity?: SortOrder
    id?: SortOrder
  }

  export type issuePopularityMaxOrderByAggregateInput = {
    country?: SortOrder
    magazine?: SortOrder
    issuenumber?: SortOrder
    popularity?: SortOrder
    id?: SortOrder
  }

  export type issuePopularityMinOrderByAggregateInput = {
    country?: SortOrder
    magazine?: SortOrder
    issuenumber?: SortOrder
    popularity?: SortOrder
    id?: SortOrder
  }

  export type issuePopularitySumOrderByAggregateInput = {
    popularity?: SortOrder
    id?: SortOrder
  }

  export type tranches_doublonsPaysMagazineNumeroCompoundUniqueInput = {
    Pays: string
    Magazine: string
    Numero: string
  }

  export type tranches_doublonsCountOrderByAggregateInput = {
    ID?: SortOrder
    Pays?: SortOrder
    Magazine?: SortOrder
    Numero?: SortOrder
    NumeroReference?: SortOrder
    TrancheReference?: SortOrder
  }

  export type tranches_doublonsAvgOrderByAggregateInput = {
    ID?: SortOrder
    TrancheReference?: SortOrder
  }

  export type tranches_doublonsMaxOrderByAggregateInput = {
    ID?: SortOrder
    Pays?: SortOrder
    Magazine?: SortOrder
    Numero?: SortOrder
    NumeroReference?: SortOrder
    TrancheReference?: SortOrder
  }

  export type tranches_doublonsMinOrderByAggregateInput = {
    ID?: SortOrder
    Pays?: SortOrder
    Magazine?: SortOrder
    Numero?: SortOrder
    NumeroReference?: SortOrder
    TrancheReference?: SortOrder
  }

  export type tranches_doublonsSumOrderByAggregateInput = {
    ID?: SortOrder
    TrancheReference?: SortOrder
  }

  export type edgePublicationcodeIssuenumberCompoundUniqueInput = {
    publicationcode: string
    issuenumber: string
  }

  export type edgeCountOrderByAggregateInput = {
    id?: SortOrder
    publicationcode?: SortOrder
    issuenumber?: SortOrder
    creationDate?: SortOrder
    points?: SortOrder
    slug?: SortOrder
    issuecode?: SortOrder
  }

  export type edgeAvgOrderByAggregateInput = {
    id?: SortOrder
    points?: SortOrder
  }

  export type edgeMaxOrderByAggregateInput = {
    id?: SortOrder
    publicationcode?: SortOrder
    issuenumber?: SortOrder
    creationDate?: SortOrder
    points?: SortOrder
    slug?: SortOrder
    issuecode?: SortOrder
  }

  export type edgeMinOrderByAggregateInput = {
    id?: SortOrder
    publicationcode?: SortOrder
    issuenumber?: SortOrder
    creationDate?: SortOrder
    points?: SortOrder
    slug?: SortOrder
    issuecode?: SortOrder
  }

  export type edgeSumOrderByAggregateInput = {
    id?: SortOrder
    points?: SortOrder
  }

  export type Enumtranches_pretes_contributeurs_contributionFilter<$PrismaModel = never> = {
    equals?: $Enums.tranches_pretes_contributeurs_contribution | Enumtranches_pretes_contributeurs_contributionFieldRefInput<$PrismaModel>
    in?: $Enums.tranches_pretes_contributeurs_contribution[]
    notIn?: $Enums.tranches_pretes_contributeurs_contribution[]
    not?: NestedEnumtranches_pretes_contributeurs_contributionFilter<$PrismaModel> | $Enums.tranches_pretes_contributeurs_contribution
  }

  export type tranches_pretes_contributeursPublicationcodeIssuenumberContributeurContributionCompoundUniqueInput = {
    publicationcode: string
    issuenumber: string
    contributeur: number
    contribution: $Enums.tranches_pretes_contributeurs_contribution
  }

  export type tranches_pretes_contributeursCountOrderByAggregateInput = {
    publicationcode?: SortOrder
    issuenumber?: SortOrder
    contributeur?: SortOrder
    contribution?: SortOrder
  }

  export type tranches_pretes_contributeursAvgOrderByAggregateInput = {
    contributeur?: SortOrder
  }

  export type tranches_pretes_contributeursMaxOrderByAggregateInput = {
    publicationcode?: SortOrder
    issuenumber?: SortOrder
    contributeur?: SortOrder
    contribution?: SortOrder
  }

  export type tranches_pretes_contributeursMinOrderByAggregateInput = {
    publicationcode?: SortOrder
    issuenumber?: SortOrder
    contributeur?: SortOrder
    contribution?: SortOrder
  }

  export type tranches_pretes_contributeursSumOrderByAggregateInput = {
    contributeur?: SortOrder
  }

  export type Enumtranches_pretes_contributeurs_contributionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.tranches_pretes_contributeurs_contribution | Enumtranches_pretes_contributeurs_contributionFieldRefInput<$PrismaModel>
    in?: $Enums.tranches_pretes_contributeurs_contribution[]
    notIn?: $Enums.tranches_pretes_contributeurs_contribution[]
    not?: NestedEnumtranches_pretes_contributeurs_contributionWithAggregatesFilter<$PrismaModel> | $Enums.tranches_pretes_contributeurs_contribution
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtranches_pretes_contributeurs_contributionFilter<$PrismaModel>
    _max?: NestedEnumtranches_pretes_contributeurs_contributionFilter<$PrismaModel>
  }

  export type Enumtranches_pretes_contributions_contributionFilter<$PrismaModel = never> = {
    equals?: $Enums.tranches_pretes_contributions_contribution | Enumtranches_pretes_contributions_contributionFieldRefInput<$PrismaModel>
    in?: $Enums.tranches_pretes_contributions_contribution[]
    notIn?: $Enums.tranches_pretes_contributions_contribution[]
    not?: NestedEnumtranches_pretes_contributions_contributionFilter<$PrismaModel> | $Enums.tranches_pretes_contributions_contribution
  }

  export type tranches_pretes_contributionsCountOrderByAggregateInput = {
    ID?: SortOrder
    ID_tranche?: SortOrder
    ID_user?: SortOrder
    dateajout?: SortOrder
    contribution?: SortOrder
    points_new?: SortOrder
    points_total?: SortOrder
  }

  export type tranches_pretes_contributionsAvgOrderByAggregateInput = {
    ID?: SortOrder
    ID_tranche?: SortOrder
    ID_user?: SortOrder
    points_new?: SortOrder
    points_total?: SortOrder
  }

  export type tranches_pretes_contributionsMaxOrderByAggregateInput = {
    ID?: SortOrder
    ID_tranche?: SortOrder
    ID_user?: SortOrder
    dateajout?: SortOrder
    contribution?: SortOrder
    points_new?: SortOrder
    points_total?: SortOrder
  }

  export type tranches_pretes_contributionsMinOrderByAggregateInput = {
    ID?: SortOrder
    ID_tranche?: SortOrder
    ID_user?: SortOrder
    dateajout?: SortOrder
    contribution?: SortOrder
    points_new?: SortOrder
    points_total?: SortOrder
  }

  export type tranches_pretes_contributionsSumOrderByAggregateInput = {
    ID?: SortOrder
    ID_tranche?: SortOrder
    ID_user?: SortOrder
    points_new?: SortOrder
    points_total?: SortOrder
  }

  export type Enumtranches_pretes_contributions_contributionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.tranches_pretes_contributions_contribution | Enumtranches_pretes_contributions_contributionFieldRefInput<$PrismaModel>
    in?: $Enums.tranches_pretes_contributions_contribution[]
    notIn?: $Enums.tranches_pretes_contributions_contribution[]
    not?: NestedEnumtranches_pretes_contributions_contributionWithAggregatesFilter<$PrismaModel> | $Enums.tranches_pretes_contributions_contribution
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtranches_pretes_contributions_contributionFilter<$PrismaModel>
    _max?: NestedEnumtranches_pretes_contributions_contributionFilter<$PrismaModel>
  }

  export type edgeSpriteEdgeIdSpriteNameCompoundUniqueInput = {
    edgeId: number
    spriteName: string
  }

  export type edgeSpriteCountOrderByAggregateInput = {
    id?: SortOrder
    edgeId?: SortOrder
    spriteName?: SortOrder
    spriteSize?: SortOrder
  }

  export type edgeSpriteAvgOrderByAggregateInput = {
    id?: SortOrder
    edgeId?: SortOrder
    spriteSize?: SortOrder
  }

  export type edgeSpriteMaxOrderByAggregateInput = {
    id?: SortOrder
    edgeId?: SortOrder
    spriteName?: SortOrder
    spriteSize?: SortOrder
  }

  export type edgeSpriteMinOrderByAggregateInput = {
    id?: SortOrder
    edgeId?: SortOrder
    spriteName?: SortOrder
    spriteSize?: SortOrder
  }

  export type edgeSpriteSumOrderByAggregateInput = {
    id?: SortOrder
    edgeId?: SortOrder
    spriteSize?: SortOrder
  }

  export type edgeSpriteSizeCountOrderByAggregateInput = {
    id?: SortOrder
    spriteName?: SortOrder
    size?: SortOrder
  }

  export type edgeSpriteSizeAvgOrderByAggregateInput = {
    id?: SortOrder
    size?: SortOrder
  }

  export type edgeSpriteSizeMaxOrderByAggregateInput = {
    id?: SortOrder
    spriteName?: SortOrder
    size?: SortOrder
  }

  export type edgeSpriteSizeMinOrderByAggregateInput = {
    id?: SortOrder
    spriteName?: SortOrder
    size?: SortOrder
  }

  export type edgeSpriteSizeSumOrderByAggregateInput = {
    id?: SortOrder
    size?: SortOrder
  }

  export type edgeSpriteUrlSpriteNameVersionCompoundUniqueInput = {
    spriteName: string
    version: string
  }

  export type edgeSpriteUrlCountOrderByAggregateInput = {
    id?: SortOrder
    spriteName?: SortOrder
    version?: SortOrder
  }

  export type edgeSpriteUrlAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type edgeSpriteUrlMaxOrderByAggregateInput = {
    id?: SortOrder
    spriteName?: SortOrder
    version?: SortOrder
  }

  export type edgeSpriteUrlMinOrderByAggregateInput = {
    id?: SortOrder
    spriteName?: SortOrder
    version?: SortOrder
  }

  export type edgeSpriteUrlSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SubscriptionListRelationFilter = {
    every?: subscriptionWhereInput
    some?: subscriptionWhereInput
    none?: subscriptionWhereInput
  }

  export type UserOptionListRelationFilter = {
    every?: userOptionWhereInput
    some?: userOptionWhereInput
    none?: userOptionWhereInput
  }

  export type subscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    allowSharing?: SortOrder
    signupDate?: SortOrder
    email?: SortOrder
    discordId?: SortOrder
    showRecommendations?: SortOrder
    isBetaUser?: SortOrder
    showPresentationVideo?: SortOrder
    showDuplicatesInBookcase?: SortOrder
    bookcaseTexture1?: SortOrder
    bookcaseSubTexture1?: SortOrder
    bookcaseTexture2?: SortOrder
    bookcaseSubTexture2?: SortOrder
    presentationText?: SortOrder
    lastAccess?: SortOrder
    previousAccess?: SortOrder
    marketplaceAcceptsExchanges?: SortOrder
  }

  export type userAvgOrderByAggregateInput = {
    id?: SortOrder
    discordId?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    allowSharing?: SortOrder
    signupDate?: SortOrder
    email?: SortOrder
    discordId?: SortOrder
    showRecommendations?: SortOrder
    isBetaUser?: SortOrder
    showPresentationVideo?: SortOrder
    showDuplicatesInBookcase?: SortOrder
    bookcaseTexture1?: SortOrder
    bookcaseSubTexture1?: SortOrder
    bookcaseTexture2?: SortOrder
    bookcaseSubTexture2?: SortOrder
    presentationText?: SortOrder
    lastAccess?: SortOrder
    previousAccess?: SortOrder
    marketplaceAcceptsExchanges?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    allowSharing?: SortOrder
    signupDate?: SortOrder
    email?: SortOrder
    discordId?: SortOrder
    showRecommendations?: SortOrder
    isBetaUser?: SortOrder
    showPresentationVideo?: SortOrder
    showDuplicatesInBookcase?: SortOrder
    bookcaseTexture1?: SortOrder
    bookcaseSubTexture1?: SortOrder
    bookcaseTexture2?: SortOrder
    bookcaseSubTexture2?: SortOrder
    presentationText?: SortOrder
    lastAccess?: SortOrder
    previousAccess?: SortOrder
    marketplaceAcceptsExchanges?: SortOrder
  }

  export type userSumOrderByAggregateInput = {
    id?: SortOrder
    discordId?: SortOrder
  }

  export type EdgeNullableRelationFilter = {
    is?: edgeWhereInput | null
    isNot?: edgeWhereInput | null
  }

  export type BookstoreNullableRelationFilter = {
    is?: bookstoreWhereInput | null
    isNot?: bookstoreWhereInput | null
  }

  export type BookstoreCommentNullableRelationFilter = {
    is?: bookstoreCommentWhereInput | null
    isNot?: bookstoreCommentWhereInput | null
  }

  export type userContributionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    contribution?: SortOrder
    newPoints?: SortOrder
    totalPoints?: SortOrder
    isEmailSent?: SortOrder
    edgeId?: SortOrder
    bookstoreId?: SortOrder
    bookstoreCommentId?: SortOrder
  }

  export type userContributionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    newPoints?: SortOrder
    totalPoints?: SortOrder
    edgeId?: SortOrder
    bookstoreId?: SortOrder
    bookstoreCommentId?: SortOrder
  }

  export type userContributionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    contribution?: SortOrder
    newPoints?: SortOrder
    totalPoints?: SortOrder
    isEmailSent?: SortOrder
    edgeId?: SortOrder
    bookstoreId?: SortOrder
    bookstoreCommentId?: SortOrder
  }

  export type userContributionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    contribution?: SortOrder
    newPoints?: SortOrder
    totalPoints?: SortOrder
    isEmailSent?: SortOrder
    edgeId?: SortOrder
    bookstoreId?: SortOrder
    bookstoreCommentId?: SortOrder
  }

  export type userContributionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    newPoints?: SortOrder
    totalPoints?: SortOrder
    edgeId?: SortOrder
    bookstoreId?: SortOrder
    bookstoreCommentId?: SortOrder
  }

  export type EnumuserOptionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.userOptionType | EnumuserOptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.userOptionType[]
    notIn?: $Enums.userOptionType[]
    not?: NestedEnumuserOptionTypeFilter<$PrismaModel> | $Enums.userOptionType
  }

  export type userOptionUserIdOptionNameOptionValueCompoundUniqueInput = {
    userId: number
    optionName: $Enums.userOptionType
    optionValue: string
  }

  export type userOptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    optionName?: SortOrder
    optionValue?: SortOrder
  }

  export type userOptionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type userOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    optionName?: SortOrder
    optionValue?: SortOrder
  }

  export type userOptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    optionName?: SortOrder
    optionValue?: SortOrder
  }

  export type userOptionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumuserOptionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.userOptionType | EnumuserOptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.userOptionType[]
    notIn?: $Enums.userOptionType[]
    not?: NestedEnumuserOptionTypeWithAggregatesFilter<$PrismaModel> | $Enums.userOptionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuserOptionTypeFilter<$PrismaModel>
    _max?: NestedEnumuserOptionTypeFilter<$PrismaModel>
  }

  export type userPasswordTokenUserIdTokenCompoundUniqueInput = {
    userId: number
    token: string
  }

  export type userPasswordTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
  }

  export type userPasswordTokenAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type userPasswordTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
  }

  export type userPasswordTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
  }

  export type userPasswordTokenSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type Enumusers_permissions_privilegeFilter<$PrismaModel = never> = {
    equals?: $Enums.users_permissions_privilege | Enumusers_permissions_privilegeFieldRefInput<$PrismaModel>
    in?: $Enums.users_permissions_privilege[]
    notIn?: $Enums.users_permissions_privilege[]
    not?: NestedEnumusers_permissions_privilegeFilter<$PrismaModel> | $Enums.users_permissions_privilege
  }

  export type userPermissionUsernameRolePrivilegeCompoundUniqueInput = {
    username: string
    role: string
    privilege: $Enums.users_permissions_privilege
  }

  export type userPermissionCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    role?: SortOrder
    privilege?: SortOrder
  }

  export type userPermissionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type userPermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    role?: SortOrder
    privilege?: SortOrder
  }

  export type userPermissionMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    role?: SortOrder
    privilege?: SortOrder
  }

  export type userPermissionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Enumusers_permissions_privilegeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.users_permissions_privilege | Enumusers_permissions_privilegeFieldRefInput<$PrismaModel>
    in?: $Enums.users_permissions_privilege[]
    notIn?: $Enums.users_permissions_privilege[]
    not?: NestedEnumusers_permissions_privilegeWithAggregatesFilter<$PrismaModel> | $Enums.users_permissions_privilege
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumusers_permissions_privilegeFilter<$PrismaModel>
    _max?: NestedEnumusers_permissions_privilegeFilter<$PrismaModel>
  }

  export type EnumuserContributionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.userContributionType | EnumuserContributionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.userContributionType[]
    notIn?: $Enums.userContributionType[]
    not?: NestedEnumuserContributionTypeFilter<$PrismaModel> | $Enums.userContributionType
  }

  export type users_pointsCountOrderByAggregateInput = {
    ID?: SortOrder
    ID_Utilisateur?: SortOrder
    TypeContribution?: SortOrder
    NbPoints?: SortOrder
  }

  export type users_pointsAvgOrderByAggregateInput = {
    ID?: SortOrder
    ID_Utilisateur?: SortOrder
    NbPoints?: SortOrder
  }

  export type users_pointsMaxOrderByAggregateInput = {
    ID?: SortOrder
    ID_Utilisateur?: SortOrder
    TypeContribution?: SortOrder
    NbPoints?: SortOrder
  }

  export type users_pointsMinOrderByAggregateInput = {
    ID?: SortOrder
    ID_Utilisateur?: SortOrder
    TypeContribution?: SortOrder
    NbPoints?: SortOrder
  }

  export type users_pointsSumOrderByAggregateInput = {
    ID?: SortOrder
    ID_Utilisateur?: SortOrder
    NbPoints?: SortOrder
  }

  export type EnumuserContributionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.userContributionType | EnumuserContributionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.userContributionType[]
    notIn?: $Enums.userContributionType[]
    not?: NestedEnumuserContributionTypeWithAggregatesFilter<$PrismaModel> | $Enums.userContributionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuserContributionTypeFilter<$PrismaModel>
    _max?: NestedEnumuserContributionTypeFilter<$PrismaModel>
  }

  export type userSuggestionNotificationUserIdIssuecodeCompoundUniqueInput = {
    userId: number
    issuecode: string
  }

  export type userSuggestionNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    issuecode?: SortOrder
    text?: SortOrder
    date?: SortOrder
  }

  export type userSuggestionNotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type userSuggestionNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    issuecode?: SortOrder
    text?: SortOrder
    date?: SortOrder
  }

  export type userSuggestionNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    issuecode?: SortOrder
    text?: SortOrder
    date?: SortOrder
  }

  export type userSuggestionNotificationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type requestedIssueIssueIdBuyerIdCompoundUniqueInput = {
    issueId: number
    buyerId: number
  }

  export type requestedIssueCountOrderByAggregateInput = {
    id?: SortOrder
    issueId?: SortOrder
    buyerId?: SortOrder
    isBooked?: SortOrder
  }

  export type requestedIssueAvgOrderByAggregateInput = {
    id?: SortOrder
    issueId?: SortOrder
    buyerId?: SortOrder
  }

  export type requestedIssueMaxOrderByAggregateInput = {
    id?: SortOrder
    issueId?: SortOrder
    buyerId?: SortOrder
    isBooked?: SortOrder
  }

  export type requestedIssueMinOrderByAggregateInput = {
    id?: SortOrder
    issueId?: SortOrder
    buyerId?: SortOrder
    isBooked?: SortOrder
  }

  export type requestedIssueSumOrderByAggregateInput = {
    id?: SortOrder
    issueId?: SortOrder
    buyerId?: SortOrder
  }

  export type userCreateNestedOneWithoutAbonnementsInput = {
    create?: XOR<userCreateWithoutAbonnementsInput, userUncheckedCreateWithoutAbonnementsInput>
    connectOrCreate?: userCreateOrConnectWithoutAbonnementsInput
    connect?: userWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type userUpdateOneRequiredWithoutAbonnementsNestedInput = {
    create?: XOR<userCreateWithoutAbonnementsInput, userUncheckedCreateWithoutAbonnementsInput>
    connectOrCreate?: userCreateOrConnectWithoutAbonnementsInput
    upsert?: userUpsertWithoutAbonnementsInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutAbonnementsInput, userUpdateWithoutAbonnementsInput>, userUncheckedUpdateWithoutAbonnementsInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type bookstoreCommentCreateNestedManyWithoutBouquineriesInput = {
    create?: XOR<bookstoreCommentCreateWithoutBouquineriesInput, bookstoreCommentUncheckedCreateWithoutBouquineriesInput> | bookstoreCommentCreateWithoutBouquineriesInput[] | bookstoreCommentUncheckedCreateWithoutBouquineriesInput[]
    connectOrCreate?: bookstoreCommentCreateOrConnectWithoutBouquineriesInput | bookstoreCommentCreateOrConnectWithoutBouquineriesInput[]
    createMany?: bookstoreCommentCreateManyBouquineriesInputEnvelope
    connect?: bookstoreCommentWhereUniqueInput | bookstoreCommentWhereUniqueInput[]
  }

  export type userContributionCreateNestedManyWithoutBouquineriesInput = {
    create?: XOR<userContributionCreateWithoutBouquineriesInput, userContributionUncheckedCreateWithoutBouquineriesInput> | userContributionCreateWithoutBouquineriesInput[] | userContributionUncheckedCreateWithoutBouquineriesInput[]
    connectOrCreate?: userContributionCreateOrConnectWithoutBouquineriesInput | userContributionCreateOrConnectWithoutBouquineriesInput[]
    createMany?: userContributionCreateManyBouquineriesInputEnvelope
    connect?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
  }

  export type bookstoreCommentUncheckedCreateNestedManyWithoutBouquineriesInput = {
    create?: XOR<bookstoreCommentCreateWithoutBouquineriesInput, bookstoreCommentUncheckedCreateWithoutBouquineriesInput> | bookstoreCommentCreateWithoutBouquineriesInput[] | bookstoreCommentUncheckedCreateWithoutBouquineriesInput[]
    connectOrCreate?: bookstoreCommentCreateOrConnectWithoutBouquineriesInput | bookstoreCommentCreateOrConnectWithoutBouquineriesInput[]
    createMany?: bookstoreCommentCreateManyBouquineriesInputEnvelope
    connect?: bookstoreCommentWhereUniqueInput | bookstoreCommentWhereUniqueInput[]
  }

  export type userContributionUncheckedCreateNestedManyWithoutBouquineriesInput = {
    create?: XOR<userContributionCreateWithoutBouquineriesInput, userContributionUncheckedCreateWithoutBouquineriesInput> | userContributionCreateWithoutBouquineriesInput[] | userContributionUncheckedCreateWithoutBouquineriesInput[]
    connectOrCreate?: userContributionCreateOrConnectWithoutBouquineriesInput | userContributionCreateOrConnectWithoutBouquineriesInput[]
    createMany?: userContributionCreateManyBouquineriesInputEnvelope
    connect?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type bookstoreCommentUpdateManyWithoutBouquineriesNestedInput = {
    create?: XOR<bookstoreCommentCreateWithoutBouquineriesInput, bookstoreCommentUncheckedCreateWithoutBouquineriesInput> | bookstoreCommentCreateWithoutBouquineriesInput[] | bookstoreCommentUncheckedCreateWithoutBouquineriesInput[]
    connectOrCreate?: bookstoreCommentCreateOrConnectWithoutBouquineriesInput | bookstoreCommentCreateOrConnectWithoutBouquineriesInput[]
    upsert?: bookstoreCommentUpsertWithWhereUniqueWithoutBouquineriesInput | bookstoreCommentUpsertWithWhereUniqueWithoutBouquineriesInput[]
    createMany?: bookstoreCommentCreateManyBouquineriesInputEnvelope
    set?: bookstoreCommentWhereUniqueInput | bookstoreCommentWhereUniqueInput[]
    disconnect?: bookstoreCommentWhereUniqueInput | bookstoreCommentWhereUniqueInput[]
    delete?: bookstoreCommentWhereUniqueInput | bookstoreCommentWhereUniqueInput[]
    connect?: bookstoreCommentWhereUniqueInput | bookstoreCommentWhereUniqueInput[]
    update?: bookstoreCommentUpdateWithWhereUniqueWithoutBouquineriesInput | bookstoreCommentUpdateWithWhereUniqueWithoutBouquineriesInput[]
    updateMany?: bookstoreCommentUpdateManyWithWhereWithoutBouquineriesInput | bookstoreCommentUpdateManyWithWhereWithoutBouquineriesInput[]
    deleteMany?: bookstoreCommentScalarWhereInput | bookstoreCommentScalarWhereInput[]
  }

  export type userContributionUpdateManyWithoutBouquineriesNestedInput = {
    create?: XOR<userContributionCreateWithoutBouquineriesInput, userContributionUncheckedCreateWithoutBouquineriesInput> | userContributionCreateWithoutBouquineriesInput[] | userContributionUncheckedCreateWithoutBouquineriesInput[]
    connectOrCreate?: userContributionCreateOrConnectWithoutBouquineriesInput | userContributionCreateOrConnectWithoutBouquineriesInput[]
    upsert?: userContributionUpsertWithWhereUniqueWithoutBouquineriesInput | userContributionUpsertWithWhereUniqueWithoutBouquineriesInput[]
    createMany?: userContributionCreateManyBouquineriesInputEnvelope
    set?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
    disconnect?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
    delete?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
    connect?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
    update?: userContributionUpdateWithWhereUniqueWithoutBouquineriesInput | userContributionUpdateWithWhereUniqueWithoutBouquineriesInput[]
    updateMany?: userContributionUpdateManyWithWhereWithoutBouquineriesInput | userContributionUpdateManyWithWhereWithoutBouquineriesInput[]
    deleteMany?: userContributionScalarWhereInput | userContributionScalarWhereInput[]
  }

  export type bookstoreCommentUncheckedUpdateManyWithoutBouquineriesNestedInput = {
    create?: XOR<bookstoreCommentCreateWithoutBouquineriesInput, bookstoreCommentUncheckedCreateWithoutBouquineriesInput> | bookstoreCommentCreateWithoutBouquineriesInput[] | bookstoreCommentUncheckedCreateWithoutBouquineriesInput[]
    connectOrCreate?: bookstoreCommentCreateOrConnectWithoutBouquineriesInput | bookstoreCommentCreateOrConnectWithoutBouquineriesInput[]
    upsert?: bookstoreCommentUpsertWithWhereUniqueWithoutBouquineriesInput | bookstoreCommentUpsertWithWhereUniqueWithoutBouquineriesInput[]
    createMany?: bookstoreCommentCreateManyBouquineriesInputEnvelope
    set?: bookstoreCommentWhereUniqueInput | bookstoreCommentWhereUniqueInput[]
    disconnect?: bookstoreCommentWhereUniqueInput | bookstoreCommentWhereUniqueInput[]
    delete?: bookstoreCommentWhereUniqueInput | bookstoreCommentWhereUniqueInput[]
    connect?: bookstoreCommentWhereUniqueInput | bookstoreCommentWhereUniqueInput[]
    update?: bookstoreCommentUpdateWithWhereUniqueWithoutBouquineriesInput | bookstoreCommentUpdateWithWhereUniqueWithoutBouquineriesInput[]
    updateMany?: bookstoreCommentUpdateManyWithWhereWithoutBouquineriesInput | bookstoreCommentUpdateManyWithWhereWithoutBouquineriesInput[]
    deleteMany?: bookstoreCommentScalarWhereInput | bookstoreCommentScalarWhereInput[]
  }

  export type userContributionUncheckedUpdateManyWithoutBouquineriesNestedInput = {
    create?: XOR<userContributionCreateWithoutBouquineriesInput, userContributionUncheckedCreateWithoutBouquineriesInput> | userContributionCreateWithoutBouquineriesInput[] | userContributionUncheckedCreateWithoutBouquineriesInput[]
    connectOrCreate?: userContributionCreateOrConnectWithoutBouquineriesInput | userContributionCreateOrConnectWithoutBouquineriesInput[]
    upsert?: userContributionUpsertWithWhereUniqueWithoutBouquineriesInput | userContributionUpsertWithWhereUniqueWithoutBouquineriesInput[]
    createMany?: userContributionCreateManyBouquineriesInputEnvelope
    set?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
    disconnect?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
    delete?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
    connect?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
    update?: userContributionUpdateWithWhereUniqueWithoutBouquineriesInput | userContributionUpdateWithWhereUniqueWithoutBouquineriesInput[]
    updateMany?: userContributionUpdateManyWithWhereWithoutBouquineriesInput | userContributionUpdateManyWithWhereWithoutBouquineriesInput[]
    deleteMany?: userContributionScalarWhereInput | userContributionScalarWhereInput[]
  }

  export type bookstoreCreateNestedOneWithoutCommentsInput = {
    create?: XOR<bookstoreCreateWithoutCommentsInput, bookstoreUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: bookstoreCreateOrConnectWithoutCommentsInput
    connect?: bookstoreWhereUniqueInput
  }

  export type userCreateNestedOneWithoutBouquineries_commentairesInput = {
    create?: XOR<userCreateWithoutBouquineries_commentairesInput, userUncheckedCreateWithoutBouquineries_commentairesInput>
    connectOrCreate?: userCreateOrConnectWithoutBouquineries_commentairesInput
    connect?: userWhereUniqueInput
  }

  export type userContributionCreateNestedManyWithoutBouquineries_commentairesInput = {
    create?: XOR<userContributionCreateWithoutBouquineries_commentairesInput, userContributionUncheckedCreateWithoutBouquineries_commentairesInput> | userContributionCreateWithoutBouquineries_commentairesInput[] | userContributionUncheckedCreateWithoutBouquineries_commentairesInput[]
    connectOrCreate?: userContributionCreateOrConnectWithoutBouquineries_commentairesInput | userContributionCreateOrConnectWithoutBouquineries_commentairesInput[]
    createMany?: userContributionCreateManyBouquineries_commentairesInputEnvelope
    connect?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
  }

  export type userContributionUncheckedCreateNestedManyWithoutBouquineries_commentairesInput = {
    create?: XOR<userContributionCreateWithoutBouquineries_commentairesInput, userContributionUncheckedCreateWithoutBouquineries_commentairesInput> | userContributionCreateWithoutBouquineries_commentairesInput[] | userContributionUncheckedCreateWithoutBouquineries_commentairesInput[]
    connectOrCreate?: userContributionCreateOrConnectWithoutBouquineries_commentairesInput | userContributionCreateOrConnectWithoutBouquineries_commentairesInput[]
    createMany?: userContributionCreateManyBouquineries_commentairesInputEnvelope
    connect?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
  }

  export type bookstoreUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<bookstoreCreateWithoutCommentsInput, bookstoreUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: bookstoreCreateOrConnectWithoutCommentsInput
    upsert?: bookstoreUpsertWithoutCommentsInput
    connect?: bookstoreWhereUniqueInput
    update?: XOR<XOR<bookstoreUpdateToOneWithWhereWithoutCommentsInput, bookstoreUpdateWithoutCommentsInput>, bookstoreUncheckedUpdateWithoutCommentsInput>
  }

  export type userUpdateOneWithoutBouquineries_commentairesNestedInput = {
    create?: XOR<userCreateWithoutBouquineries_commentairesInput, userUncheckedCreateWithoutBouquineries_commentairesInput>
    connectOrCreate?: userCreateOrConnectWithoutBouquineries_commentairesInput
    upsert?: userUpsertWithoutBouquineries_commentairesInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutBouquineries_commentairesInput, userUpdateWithoutBouquineries_commentairesInput>, userUncheckedUpdateWithoutBouquineries_commentairesInput>
  }

  export type userContributionUpdateManyWithoutBouquineries_commentairesNestedInput = {
    create?: XOR<userContributionCreateWithoutBouquineries_commentairesInput, userContributionUncheckedCreateWithoutBouquineries_commentairesInput> | userContributionCreateWithoutBouquineries_commentairesInput[] | userContributionUncheckedCreateWithoutBouquineries_commentairesInput[]
    connectOrCreate?: userContributionCreateOrConnectWithoutBouquineries_commentairesInput | userContributionCreateOrConnectWithoutBouquineries_commentairesInput[]
    upsert?: userContributionUpsertWithWhereUniqueWithoutBouquineries_commentairesInput | userContributionUpsertWithWhereUniqueWithoutBouquineries_commentairesInput[]
    createMany?: userContributionCreateManyBouquineries_commentairesInputEnvelope
    set?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
    disconnect?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
    delete?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
    connect?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
    update?: userContributionUpdateWithWhereUniqueWithoutBouquineries_commentairesInput | userContributionUpdateWithWhereUniqueWithoutBouquineries_commentairesInput[]
    updateMany?: userContributionUpdateManyWithWhereWithoutBouquineries_commentairesInput | userContributionUpdateManyWithWhereWithoutBouquineries_commentairesInput[]
    deleteMany?: userContributionScalarWhereInput | userContributionScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type userContributionUncheckedUpdateManyWithoutBouquineries_commentairesNestedInput = {
    create?: XOR<userContributionCreateWithoutBouquineries_commentairesInput, userContributionUncheckedCreateWithoutBouquineries_commentairesInput> | userContributionCreateWithoutBouquineries_commentairesInput[] | userContributionUncheckedCreateWithoutBouquineries_commentairesInput[]
    connectOrCreate?: userContributionCreateOrConnectWithoutBouquineries_commentairesInput | userContributionCreateOrConnectWithoutBouquineries_commentairesInput[]
    upsert?: userContributionUpsertWithWhereUniqueWithoutBouquineries_commentairesInput | userContributionUpsertWithWhereUniqueWithoutBouquineries_commentairesInput[]
    createMany?: userContributionCreateManyBouquineries_commentairesInputEnvelope
    set?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
    disconnect?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
    delete?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
    connect?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
    update?: userContributionUpdateWithWhereUniqueWithoutBouquineries_commentairesInput | userContributionUpdateWithWhereUniqueWithoutBouquineries_commentairesInput[]
    updateMany?: userContributionUpdateManyWithWhereWithoutBouquineries_commentairesInput | userContributionUpdateManyWithWhereWithoutBouquineries_commentairesInput[]
    deleteMany?: userContributionScalarWhereInput | userContributionScalarWhereInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type Enumissue_conditionFieldUpdateOperationsInput = {
    set?: $Enums.issue_condition
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type userContributionCreateNestedManyWithoutTranches_pretesInput = {
    create?: XOR<userContributionCreateWithoutTranches_pretesInput, userContributionUncheckedCreateWithoutTranches_pretesInput> | userContributionCreateWithoutTranches_pretesInput[] | userContributionUncheckedCreateWithoutTranches_pretesInput[]
    connectOrCreate?: userContributionCreateOrConnectWithoutTranches_pretesInput | userContributionCreateOrConnectWithoutTranches_pretesInput[]
    createMany?: userContributionCreateManyTranches_pretesInputEnvelope
    connect?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
  }

  export type userContributionUncheckedCreateNestedManyWithoutTranches_pretesInput = {
    create?: XOR<userContributionCreateWithoutTranches_pretesInput, userContributionUncheckedCreateWithoutTranches_pretesInput> | userContributionCreateWithoutTranches_pretesInput[] | userContributionUncheckedCreateWithoutTranches_pretesInput[]
    connectOrCreate?: userContributionCreateOrConnectWithoutTranches_pretesInput | userContributionCreateOrConnectWithoutTranches_pretesInput[]
    createMany?: userContributionCreateManyTranches_pretesInputEnvelope
    connect?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
  }

  export type userContributionUpdateManyWithoutTranches_pretesNestedInput = {
    create?: XOR<userContributionCreateWithoutTranches_pretesInput, userContributionUncheckedCreateWithoutTranches_pretesInput> | userContributionCreateWithoutTranches_pretesInput[] | userContributionUncheckedCreateWithoutTranches_pretesInput[]
    connectOrCreate?: userContributionCreateOrConnectWithoutTranches_pretesInput | userContributionCreateOrConnectWithoutTranches_pretesInput[]
    upsert?: userContributionUpsertWithWhereUniqueWithoutTranches_pretesInput | userContributionUpsertWithWhereUniqueWithoutTranches_pretesInput[]
    createMany?: userContributionCreateManyTranches_pretesInputEnvelope
    set?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
    disconnect?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
    delete?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
    connect?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
    update?: userContributionUpdateWithWhereUniqueWithoutTranches_pretesInput | userContributionUpdateWithWhereUniqueWithoutTranches_pretesInput[]
    updateMany?: userContributionUpdateManyWithWhereWithoutTranches_pretesInput | userContributionUpdateManyWithWhereWithoutTranches_pretesInput[]
    deleteMany?: userContributionScalarWhereInput | userContributionScalarWhereInput[]
  }

  export type userContributionUncheckedUpdateManyWithoutTranches_pretesNestedInput = {
    create?: XOR<userContributionCreateWithoutTranches_pretesInput, userContributionUncheckedCreateWithoutTranches_pretesInput> | userContributionCreateWithoutTranches_pretesInput[] | userContributionUncheckedCreateWithoutTranches_pretesInput[]
    connectOrCreate?: userContributionCreateOrConnectWithoutTranches_pretesInput | userContributionCreateOrConnectWithoutTranches_pretesInput[]
    upsert?: userContributionUpsertWithWhereUniqueWithoutTranches_pretesInput | userContributionUpsertWithWhereUniqueWithoutTranches_pretesInput[]
    createMany?: userContributionCreateManyTranches_pretesInputEnvelope
    set?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
    disconnect?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
    delete?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
    connect?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
    update?: userContributionUpdateWithWhereUniqueWithoutTranches_pretesInput | userContributionUpdateWithWhereUniqueWithoutTranches_pretesInput[]
    updateMany?: userContributionUpdateManyWithWhereWithoutTranches_pretesInput | userContributionUpdateManyWithWhereWithoutTranches_pretesInput[]
    deleteMany?: userContributionScalarWhereInput | userContributionScalarWhereInput[]
  }

  export type Enumtranches_pretes_contributeurs_contributionFieldUpdateOperationsInput = {
    set?: $Enums.tranches_pretes_contributeurs_contribution
  }

  export type Enumtranches_pretes_contributions_contributionFieldUpdateOperationsInput = {
    set?: $Enums.tranches_pretes_contributions_contribution
  }

  export type subscriptionCreateNestedManyWithoutUsersInput = {
    create?: XOR<subscriptionCreateWithoutUsersInput, subscriptionUncheckedCreateWithoutUsersInput> | subscriptionCreateWithoutUsersInput[] | subscriptionUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: subscriptionCreateOrConnectWithoutUsersInput | subscriptionCreateOrConnectWithoutUsersInput[]
    createMany?: subscriptionCreateManyUsersInputEnvelope
    connect?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
  }

  export type bookstoreCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<bookstoreCommentCreateWithoutUserInput, bookstoreCommentUncheckedCreateWithoutUserInput> | bookstoreCommentCreateWithoutUserInput[] | bookstoreCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: bookstoreCommentCreateOrConnectWithoutUserInput | bookstoreCommentCreateOrConnectWithoutUserInput[]
    createMany?: bookstoreCommentCreateManyUserInputEnvelope
    connect?: bookstoreCommentWhereUniqueInput | bookstoreCommentWhereUniqueInput[]
  }

  export type userContributionCreateNestedManyWithoutUsersInput = {
    create?: XOR<userContributionCreateWithoutUsersInput, userContributionUncheckedCreateWithoutUsersInput> | userContributionCreateWithoutUsersInput[] | userContributionUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: userContributionCreateOrConnectWithoutUsersInput | userContributionCreateOrConnectWithoutUsersInput[]
    createMany?: userContributionCreateManyUsersInputEnvelope
    connect?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
  }

  export type userOptionCreateNestedManyWithoutUsersInput = {
    create?: XOR<userOptionCreateWithoutUsersInput, userOptionUncheckedCreateWithoutUsersInput> | userOptionCreateWithoutUsersInput[] | userOptionUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: userOptionCreateOrConnectWithoutUsersInput | userOptionCreateOrConnectWithoutUsersInput[]
    createMany?: userOptionCreateManyUsersInputEnvelope
    connect?: userOptionWhereUniqueInput | userOptionWhereUniqueInput[]
  }

  export type subscriptionUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<subscriptionCreateWithoutUsersInput, subscriptionUncheckedCreateWithoutUsersInput> | subscriptionCreateWithoutUsersInput[] | subscriptionUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: subscriptionCreateOrConnectWithoutUsersInput | subscriptionCreateOrConnectWithoutUsersInput[]
    createMany?: subscriptionCreateManyUsersInputEnvelope
    connect?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
  }

  export type bookstoreCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<bookstoreCommentCreateWithoutUserInput, bookstoreCommentUncheckedCreateWithoutUserInput> | bookstoreCommentCreateWithoutUserInput[] | bookstoreCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: bookstoreCommentCreateOrConnectWithoutUserInput | bookstoreCommentCreateOrConnectWithoutUserInput[]
    createMany?: bookstoreCommentCreateManyUserInputEnvelope
    connect?: bookstoreCommentWhereUniqueInput | bookstoreCommentWhereUniqueInput[]
  }

  export type userContributionUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<userContributionCreateWithoutUsersInput, userContributionUncheckedCreateWithoutUsersInput> | userContributionCreateWithoutUsersInput[] | userContributionUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: userContributionCreateOrConnectWithoutUsersInput | userContributionCreateOrConnectWithoutUsersInput[]
    createMany?: userContributionCreateManyUsersInputEnvelope
    connect?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
  }

  export type userOptionUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<userOptionCreateWithoutUsersInput, userOptionUncheckedCreateWithoutUsersInput> | userOptionCreateWithoutUsersInput[] | userOptionUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: userOptionCreateOrConnectWithoutUsersInput | userOptionCreateOrConnectWithoutUsersInput[]
    createMany?: userOptionCreateManyUsersInputEnvelope
    connect?: userOptionWhereUniqueInput | userOptionWhereUniqueInput[]
  }

  export type subscriptionUpdateManyWithoutUsersNestedInput = {
    create?: XOR<subscriptionCreateWithoutUsersInput, subscriptionUncheckedCreateWithoutUsersInput> | subscriptionCreateWithoutUsersInput[] | subscriptionUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: subscriptionCreateOrConnectWithoutUsersInput | subscriptionCreateOrConnectWithoutUsersInput[]
    upsert?: subscriptionUpsertWithWhereUniqueWithoutUsersInput | subscriptionUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: subscriptionCreateManyUsersInputEnvelope
    set?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    disconnect?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    delete?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    connect?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    update?: subscriptionUpdateWithWhereUniqueWithoutUsersInput | subscriptionUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: subscriptionUpdateManyWithWhereWithoutUsersInput | subscriptionUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: subscriptionScalarWhereInput | subscriptionScalarWhereInput[]
  }

  export type bookstoreCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<bookstoreCommentCreateWithoutUserInput, bookstoreCommentUncheckedCreateWithoutUserInput> | bookstoreCommentCreateWithoutUserInput[] | bookstoreCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: bookstoreCommentCreateOrConnectWithoutUserInput | bookstoreCommentCreateOrConnectWithoutUserInput[]
    upsert?: bookstoreCommentUpsertWithWhereUniqueWithoutUserInput | bookstoreCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: bookstoreCommentCreateManyUserInputEnvelope
    set?: bookstoreCommentWhereUniqueInput | bookstoreCommentWhereUniqueInput[]
    disconnect?: bookstoreCommentWhereUniqueInput | bookstoreCommentWhereUniqueInput[]
    delete?: bookstoreCommentWhereUniqueInput | bookstoreCommentWhereUniqueInput[]
    connect?: bookstoreCommentWhereUniqueInput | bookstoreCommentWhereUniqueInput[]
    update?: bookstoreCommentUpdateWithWhereUniqueWithoutUserInput | bookstoreCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: bookstoreCommentUpdateManyWithWhereWithoutUserInput | bookstoreCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: bookstoreCommentScalarWhereInput | bookstoreCommentScalarWhereInput[]
  }

  export type userContributionUpdateManyWithoutUsersNestedInput = {
    create?: XOR<userContributionCreateWithoutUsersInput, userContributionUncheckedCreateWithoutUsersInput> | userContributionCreateWithoutUsersInput[] | userContributionUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: userContributionCreateOrConnectWithoutUsersInput | userContributionCreateOrConnectWithoutUsersInput[]
    upsert?: userContributionUpsertWithWhereUniqueWithoutUsersInput | userContributionUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: userContributionCreateManyUsersInputEnvelope
    set?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
    disconnect?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
    delete?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
    connect?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
    update?: userContributionUpdateWithWhereUniqueWithoutUsersInput | userContributionUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: userContributionUpdateManyWithWhereWithoutUsersInput | userContributionUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: userContributionScalarWhereInput | userContributionScalarWhereInput[]
  }

  export type userOptionUpdateManyWithoutUsersNestedInput = {
    create?: XOR<userOptionCreateWithoutUsersInput, userOptionUncheckedCreateWithoutUsersInput> | userOptionCreateWithoutUsersInput[] | userOptionUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: userOptionCreateOrConnectWithoutUsersInput | userOptionCreateOrConnectWithoutUsersInput[]
    upsert?: userOptionUpsertWithWhereUniqueWithoutUsersInput | userOptionUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: userOptionCreateManyUsersInputEnvelope
    set?: userOptionWhereUniqueInput | userOptionWhereUniqueInput[]
    disconnect?: userOptionWhereUniqueInput | userOptionWhereUniqueInput[]
    delete?: userOptionWhereUniqueInput | userOptionWhereUniqueInput[]
    connect?: userOptionWhereUniqueInput | userOptionWhereUniqueInput[]
    update?: userOptionUpdateWithWhereUniqueWithoutUsersInput | userOptionUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: userOptionUpdateManyWithWhereWithoutUsersInput | userOptionUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: userOptionScalarWhereInput | userOptionScalarWhereInput[]
  }

  export type subscriptionUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<subscriptionCreateWithoutUsersInput, subscriptionUncheckedCreateWithoutUsersInput> | subscriptionCreateWithoutUsersInput[] | subscriptionUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: subscriptionCreateOrConnectWithoutUsersInput | subscriptionCreateOrConnectWithoutUsersInput[]
    upsert?: subscriptionUpsertWithWhereUniqueWithoutUsersInput | subscriptionUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: subscriptionCreateManyUsersInputEnvelope
    set?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    disconnect?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    delete?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    connect?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    update?: subscriptionUpdateWithWhereUniqueWithoutUsersInput | subscriptionUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: subscriptionUpdateManyWithWhereWithoutUsersInput | subscriptionUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: subscriptionScalarWhereInput | subscriptionScalarWhereInput[]
  }

  export type bookstoreCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<bookstoreCommentCreateWithoutUserInput, bookstoreCommentUncheckedCreateWithoutUserInput> | bookstoreCommentCreateWithoutUserInput[] | bookstoreCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: bookstoreCommentCreateOrConnectWithoutUserInput | bookstoreCommentCreateOrConnectWithoutUserInput[]
    upsert?: bookstoreCommentUpsertWithWhereUniqueWithoutUserInput | bookstoreCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: bookstoreCommentCreateManyUserInputEnvelope
    set?: bookstoreCommentWhereUniqueInput | bookstoreCommentWhereUniqueInput[]
    disconnect?: bookstoreCommentWhereUniqueInput | bookstoreCommentWhereUniqueInput[]
    delete?: bookstoreCommentWhereUniqueInput | bookstoreCommentWhereUniqueInput[]
    connect?: bookstoreCommentWhereUniqueInput | bookstoreCommentWhereUniqueInput[]
    update?: bookstoreCommentUpdateWithWhereUniqueWithoutUserInput | bookstoreCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: bookstoreCommentUpdateManyWithWhereWithoutUserInput | bookstoreCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: bookstoreCommentScalarWhereInput | bookstoreCommentScalarWhereInput[]
  }

  export type userContributionUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<userContributionCreateWithoutUsersInput, userContributionUncheckedCreateWithoutUsersInput> | userContributionCreateWithoutUsersInput[] | userContributionUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: userContributionCreateOrConnectWithoutUsersInput | userContributionCreateOrConnectWithoutUsersInput[]
    upsert?: userContributionUpsertWithWhereUniqueWithoutUsersInput | userContributionUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: userContributionCreateManyUsersInputEnvelope
    set?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
    disconnect?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
    delete?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
    connect?: userContributionWhereUniqueInput | userContributionWhereUniqueInput[]
    update?: userContributionUpdateWithWhereUniqueWithoutUsersInput | userContributionUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: userContributionUpdateManyWithWhereWithoutUsersInput | userContributionUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: userContributionScalarWhereInput | userContributionScalarWhereInput[]
  }

  export type userOptionUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<userOptionCreateWithoutUsersInput, userOptionUncheckedCreateWithoutUsersInput> | userOptionCreateWithoutUsersInput[] | userOptionUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: userOptionCreateOrConnectWithoutUsersInput | userOptionCreateOrConnectWithoutUsersInput[]
    upsert?: userOptionUpsertWithWhereUniqueWithoutUsersInput | userOptionUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: userOptionCreateManyUsersInputEnvelope
    set?: userOptionWhereUniqueInput | userOptionWhereUniqueInput[]
    disconnect?: userOptionWhereUniqueInput | userOptionWhereUniqueInput[]
    delete?: userOptionWhereUniqueInput | userOptionWhereUniqueInput[]
    connect?: userOptionWhereUniqueInput | userOptionWhereUniqueInput[]
    update?: userOptionUpdateWithWhereUniqueWithoutUsersInput | userOptionUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: userOptionUpdateManyWithWhereWithoutUsersInput | userOptionUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: userOptionScalarWhereInput | userOptionScalarWhereInput[]
  }

  export type edgeCreateNestedOneWithoutUsers_contributionsInput = {
    create?: XOR<edgeCreateWithoutUsers_contributionsInput, edgeUncheckedCreateWithoutUsers_contributionsInput>
    connectOrCreate?: edgeCreateOrConnectWithoutUsers_contributionsInput
    connect?: edgeWhereUniqueInput
  }

  export type bookstoreCreateNestedOneWithoutUsers_contributionsInput = {
    create?: XOR<bookstoreCreateWithoutUsers_contributionsInput, bookstoreUncheckedCreateWithoutUsers_contributionsInput>
    connectOrCreate?: bookstoreCreateOrConnectWithoutUsers_contributionsInput
    connect?: bookstoreWhereUniqueInput
  }

  export type userCreateNestedOneWithoutUsers_contributionsInput = {
    create?: XOR<userCreateWithoutUsers_contributionsInput, userUncheckedCreateWithoutUsers_contributionsInput>
    connectOrCreate?: userCreateOrConnectWithoutUsers_contributionsInput
    connect?: userWhereUniqueInput
  }

  export type bookstoreCommentCreateNestedOneWithoutUsers_contributionsInput = {
    create?: XOR<bookstoreCommentCreateWithoutUsers_contributionsInput, bookstoreCommentUncheckedCreateWithoutUsers_contributionsInput>
    connectOrCreate?: bookstoreCommentCreateOrConnectWithoutUsers_contributionsInput
    connect?: bookstoreCommentWhereUniqueInput
  }

  export type edgeUpdateOneWithoutUsers_contributionsNestedInput = {
    create?: XOR<edgeCreateWithoutUsers_contributionsInput, edgeUncheckedCreateWithoutUsers_contributionsInput>
    connectOrCreate?: edgeCreateOrConnectWithoutUsers_contributionsInput
    upsert?: edgeUpsertWithoutUsers_contributionsInput
    disconnect?: edgeWhereInput | boolean
    delete?: edgeWhereInput | boolean
    connect?: edgeWhereUniqueInput
    update?: XOR<XOR<edgeUpdateToOneWithWhereWithoutUsers_contributionsInput, edgeUpdateWithoutUsers_contributionsInput>, edgeUncheckedUpdateWithoutUsers_contributionsInput>
  }

  export type bookstoreUpdateOneWithoutUsers_contributionsNestedInput = {
    create?: XOR<bookstoreCreateWithoutUsers_contributionsInput, bookstoreUncheckedCreateWithoutUsers_contributionsInput>
    connectOrCreate?: bookstoreCreateOrConnectWithoutUsers_contributionsInput
    upsert?: bookstoreUpsertWithoutUsers_contributionsInput
    disconnect?: bookstoreWhereInput | boolean
    delete?: bookstoreWhereInput | boolean
    connect?: bookstoreWhereUniqueInput
    update?: XOR<XOR<bookstoreUpdateToOneWithWhereWithoutUsers_contributionsInput, bookstoreUpdateWithoutUsers_contributionsInput>, bookstoreUncheckedUpdateWithoutUsers_contributionsInput>
  }

  export type userUpdateOneRequiredWithoutUsers_contributionsNestedInput = {
    create?: XOR<userCreateWithoutUsers_contributionsInput, userUncheckedCreateWithoutUsers_contributionsInput>
    connectOrCreate?: userCreateOrConnectWithoutUsers_contributionsInput
    upsert?: userUpsertWithoutUsers_contributionsInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutUsers_contributionsInput, userUpdateWithoutUsers_contributionsInput>, userUncheckedUpdateWithoutUsers_contributionsInput>
  }

  export type bookstoreCommentUpdateOneWithoutUsers_contributionsNestedInput = {
    create?: XOR<bookstoreCommentCreateWithoutUsers_contributionsInput, bookstoreCommentUncheckedCreateWithoutUsers_contributionsInput>
    connectOrCreate?: bookstoreCommentCreateOrConnectWithoutUsers_contributionsInput
    upsert?: bookstoreCommentUpsertWithoutUsers_contributionsInput
    disconnect?: bookstoreCommentWhereInput | boolean
    delete?: bookstoreCommentWhereInput | boolean
    connect?: bookstoreCommentWhereUniqueInput
    update?: XOR<XOR<bookstoreCommentUpdateToOneWithWhereWithoutUsers_contributionsInput, bookstoreCommentUpdateWithoutUsers_contributionsInput>, bookstoreCommentUncheckedUpdateWithoutUsers_contributionsInput>
  }

  export type userCreateNestedOneWithoutUsers_optionsInput = {
    create?: XOR<userCreateWithoutUsers_optionsInput, userUncheckedCreateWithoutUsers_optionsInput>
    connectOrCreate?: userCreateOrConnectWithoutUsers_optionsInput
    connect?: userWhereUniqueInput
  }

  export type EnumuserOptionTypeFieldUpdateOperationsInput = {
    set?: $Enums.userOptionType
  }

  export type userUpdateOneRequiredWithoutUsers_optionsNestedInput = {
    create?: XOR<userCreateWithoutUsers_optionsInput, userUncheckedCreateWithoutUsers_optionsInput>
    connectOrCreate?: userCreateOrConnectWithoutUsers_optionsInput
    upsert?: userUpsertWithoutUsers_optionsInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutUsers_optionsInput, userUpdateWithoutUsers_optionsInput>, userUncheckedUpdateWithoutUsers_optionsInput>
  }

  export type Enumusers_permissions_privilegeFieldUpdateOperationsInput = {
    set?: $Enums.users_permissions_privilege
  }

  export type EnumuserContributionTypeFieldUpdateOperationsInput = {
    set?: $Enums.userContributionType
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumissue_conditionFilter<$PrismaModel = never> = {
    equals?: $Enums.issue_condition | Enumissue_conditionFieldRefInput<$PrismaModel>
    in?: $Enums.issue_condition[]
    notIn?: $Enums.issue_condition[]
    not?: NestedEnumissue_conditionFilter<$PrismaModel> | $Enums.issue_condition
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumissue_conditionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.issue_condition | Enumissue_conditionFieldRefInput<$PrismaModel>
    in?: $Enums.issue_condition[]
    notIn?: $Enums.issue_condition[]
    not?: NestedEnumissue_conditionWithAggregatesFilter<$PrismaModel> | $Enums.issue_condition
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumissue_conditionFilter<$PrismaModel>
    _max?: NestedEnumissue_conditionFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumtranches_pretes_contributeurs_contributionFilter<$PrismaModel = never> = {
    equals?: $Enums.tranches_pretes_contributeurs_contribution | Enumtranches_pretes_contributeurs_contributionFieldRefInput<$PrismaModel>
    in?: $Enums.tranches_pretes_contributeurs_contribution[]
    notIn?: $Enums.tranches_pretes_contributeurs_contribution[]
    not?: NestedEnumtranches_pretes_contributeurs_contributionFilter<$PrismaModel> | $Enums.tranches_pretes_contributeurs_contribution
  }

  export type NestedEnumtranches_pretes_contributeurs_contributionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.tranches_pretes_contributeurs_contribution | Enumtranches_pretes_contributeurs_contributionFieldRefInput<$PrismaModel>
    in?: $Enums.tranches_pretes_contributeurs_contribution[]
    notIn?: $Enums.tranches_pretes_contributeurs_contribution[]
    not?: NestedEnumtranches_pretes_contributeurs_contributionWithAggregatesFilter<$PrismaModel> | $Enums.tranches_pretes_contributeurs_contribution
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtranches_pretes_contributeurs_contributionFilter<$PrismaModel>
    _max?: NestedEnumtranches_pretes_contributeurs_contributionFilter<$PrismaModel>
  }

  export type NestedEnumtranches_pretes_contributions_contributionFilter<$PrismaModel = never> = {
    equals?: $Enums.tranches_pretes_contributions_contribution | Enumtranches_pretes_contributions_contributionFieldRefInput<$PrismaModel>
    in?: $Enums.tranches_pretes_contributions_contribution[]
    notIn?: $Enums.tranches_pretes_contributions_contribution[]
    not?: NestedEnumtranches_pretes_contributions_contributionFilter<$PrismaModel> | $Enums.tranches_pretes_contributions_contribution
  }

  export type NestedEnumtranches_pretes_contributions_contributionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.tranches_pretes_contributions_contribution | Enumtranches_pretes_contributions_contributionFieldRefInput<$PrismaModel>
    in?: $Enums.tranches_pretes_contributions_contribution[]
    notIn?: $Enums.tranches_pretes_contributions_contribution[]
    not?: NestedEnumtranches_pretes_contributions_contributionWithAggregatesFilter<$PrismaModel> | $Enums.tranches_pretes_contributions_contribution
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtranches_pretes_contributions_contributionFilter<$PrismaModel>
    _max?: NestedEnumtranches_pretes_contributions_contributionFilter<$PrismaModel>
  }

  export type NestedEnumuserOptionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.userOptionType | EnumuserOptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.userOptionType[]
    notIn?: $Enums.userOptionType[]
    not?: NestedEnumuserOptionTypeFilter<$PrismaModel> | $Enums.userOptionType
  }

  export type NestedEnumuserOptionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.userOptionType | EnumuserOptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.userOptionType[]
    notIn?: $Enums.userOptionType[]
    not?: NestedEnumuserOptionTypeWithAggregatesFilter<$PrismaModel> | $Enums.userOptionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuserOptionTypeFilter<$PrismaModel>
    _max?: NestedEnumuserOptionTypeFilter<$PrismaModel>
  }

  export type NestedEnumusers_permissions_privilegeFilter<$PrismaModel = never> = {
    equals?: $Enums.users_permissions_privilege | Enumusers_permissions_privilegeFieldRefInput<$PrismaModel>
    in?: $Enums.users_permissions_privilege[]
    notIn?: $Enums.users_permissions_privilege[]
    not?: NestedEnumusers_permissions_privilegeFilter<$PrismaModel> | $Enums.users_permissions_privilege
  }

  export type NestedEnumusers_permissions_privilegeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.users_permissions_privilege | Enumusers_permissions_privilegeFieldRefInput<$PrismaModel>
    in?: $Enums.users_permissions_privilege[]
    notIn?: $Enums.users_permissions_privilege[]
    not?: NestedEnumusers_permissions_privilegeWithAggregatesFilter<$PrismaModel> | $Enums.users_permissions_privilege
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumusers_permissions_privilegeFilter<$PrismaModel>
    _max?: NestedEnumusers_permissions_privilegeFilter<$PrismaModel>
  }

  export type NestedEnumuserContributionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.userContributionType | EnumuserContributionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.userContributionType[]
    notIn?: $Enums.userContributionType[]
    not?: NestedEnumuserContributionTypeFilter<$PrismaModel> | $Enums.userContributionType
  }

  export type NestedEnumuserContributionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.userContributionType | EnumuserContributionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.userContributionType[]
    notIn?: $Enums.userContributionType[]
    not?: NestedEnumuserContributionTypeWithAggregatesFilter<$PrismaModel> | $Enums.userContributionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuserContributionTypeFilter<$PrismaModel>
    _max?: NestedEnumuserContributionTypeFilter<$PrismaModel>
  }

  export type userCreateWithoutAbonnementsInput = {
    username: string
    password: string
    allowSharing?: boolean
    signupDate: Date | string
    email: string
    discordId?: number | null
    showRecommendations?: boolean
    isBetaUser?: boolean
    showPresentationVideo?: boolean
    showDuplicatesInBookcase?: boolean
    bookcaseTexture1?: string
    bookcaseSubTexture1?: string
    bookcaseTexture2?: string
    bookcaseSubTexture2?: string
    presentationText?: string | null
    lastAccess?: Date | string | null
    previousAccess?: Date | string | null
    marketplaceAcceptsExchanges?: boolean
    bouquineries_commentaires?: bookstoreCommentCreateNestedManyWithoutUserInput
    users_contributions?: userContributionCreateNestedManyWithoutUsersInput
    users_options?: userOptionCreateNestedManyWithoutUsersInput
  }

  export type userUncheckedCreateWithoutAbonnementsInput = {
    id?: number
    username: string
    password: string
    allowSharing?: boolean
    signupDate: Date | string
    email: string
    discordId?: number | null
    showRecommendations?: boolean
    isBetaUser?: boolean
    showPresentationVideo?: boolean
    showDuplicatesInBookcase?: boolean
    bookcaseTexture1?: string
    bookcaseSubTexture1?: string
    bookcaseTexture2?: string
    bookcaseSubTexture2?: string
    presentationText?: string | null
    lastAccess?: Date | string | null
    previousAccess?: Date | string | null
    marketplaceAcceptsExchanges?: boolean
    bouquineries_commentaires?: bookstoreCommentUncheckedCreateNestedManyWithoutUserInput
    users_contributions?: userContributionUncheckedCreateNestedManyWithoutUsersInput
    users_options?: userOptionUncheckedCreateNestedManyWithoutUsersInput
  }

  export type userCreateOrConnectWithoutAbonnementsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutAbonnementsInput, userUncheckedCreateWithoutAbonnementsInput>
  }

  export type userUpsertWithoutAbonnementsInput = {
    update: XOR<userUpdateWithoutAbonnementsInput, userUncheckedUpdateWithoutAbonnementsInput>
    create: XOR<userCreateWithoutAbonnementsInput, userUncheckedCreateWithoutAbonnementsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutAbonnementsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutAbonnementsInput, userUncheckedUpdateWithoutAbonnementsInput>
  }

  export type userUpdateWithoutAbonnementsInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    allowSharing?: BoolFieldUpdateOperationsInput | boolean
    signupDate?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    discordId?: NullableIntFieldUpdateOperationsInput | number | null
    showRecommendations?: BoolFieldUpdateOperationsInput | boolean
    isBetaUser?: BoolFieldUpdateOperationsInput | boolean
    showPresentationVideo?: BoolFieldUpdateOperationsInput | boolean
    showDuplicatesInBookcase?: BoolFieldUpdateOperationsInput | boolean
    bookcaseTexture1?: StringFieldUpdateOperationsInput | string
    bookcaseSubTexture1?: StringFieldUpdateOperationsInput | string
    bookcaseTexture2?: StringFieldUpdateOperationsInput | string
    bookcaseSubTexture2?: StringFieldUpdateOperationsInput | string
    presentationText?: NullableStringFieldUpdateOperationsInput | string | null
    lastAccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousAccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketplaceAcceptsExchanges?: BoolFieldUpdateOperationsInput | boolean
    bouquineries_commentaires?: bookstoreCommentUpdateManyWithoutUserNestedInput
    users_contributions?: userContributionUpdateManyWithoutUsersNestedInput
    users_options?: userOptionUpdateManyWithoutUsersNestedInput
  }

  export type userUncheckedUpdateWithoutAbonnementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    allowSharing?: BoolFieldUpdateOperationsInput | boolean
    signupDate?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    discordId?: NullableIntFieldUpdateOperationsInput | number | null
    showRecommendations?: BoolFieldUpdateOperationsInput | boolean
    isBetaUser?: BoolFieldUpdateOperationsInput | boolean
    showPresentationVideo?: BoolFieldUpdateOperationsInput | boolean
    showDuplicatesInBookcase?: BoolFieldUpdateOperationsInput | boolean
    bookcaseTexture1?: StringFieldUpdateOperationsInput | string
    bookcaseSubTexture1?: StringFieldUpdateOperationsInput | string
    bookcaseTexture2?: StringFieldUpdateOperationsInput | string
    bookcaseSubTexture2?: StringFieldUpdateOperationsInput | string
    presentationText?: NullableStringFieldUpdateOperationsInput | string | null
    lastAccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousAccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketplaceAcceptsExchanges?: BoolFieldUpdateOperationsInput | boolean
    bouquineries_commentaires?: bookstoreCommentUncheckedUpdateManyWithoutUserNestedInput
    users_contributions?: userContributionUncheckedUpdateManyWithoutUsersNestedInput
    users_options?: userOptionUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type bookstoreCommentCreateWithoutBouquineriesInput = {
    comment: string
    creationDate?: Date | string
    isActive?: boolean
    user?: userCreateNestedOneWithoutBouquineries_commentairesInput
    users_contributions?: userContributionCreateNestedManyWithoutBouquineries_commentairesInput
  }

  export type bookstoreCommentUncheckedCreateWithoutBouquineriesInput = {
    id?: number
    userId?: number | null
    comment: string
    creationDate?: Date | string
    isActive?: boolean
    users_contributions?: userContributionUncheckedCreateNestedManyWithoutBouquineries_commentairesInput
  }

  export type bookstoreCommentCreateOrConnectWithoutBouquineriesInput = {
    where: bookstoreCommentWhereUniqueInput
    create: XOR<bookstoreCommentCreateWithoutBouquineriesInput, bookstoreCommentUncheckedCreateWithoutBouquineriesInput>
  }

  export type bookstoreCommentCreateManyBouquineriesInputEnvelope = {
    data: bookstoreCommentCreateManyBouquineriesInput | bookstoreCommentCreateManyBouquineriesInput[]
    skipDuplicates?: boolean
  }

  export type userContributionCreateWithoutBouquineriesInput = {
    date?: Date | string
    contribution: string
    newPoints: number
    totalPoints: number
    isEmailSent: boolean
    tranches_pretes?: edgeCreateNestedOneWithoutUsers_contributionsInput
    users: userCreateNestedOneWithoutUsers_contributionsInput
    bouquineries_commentaires?: bookstoreCommentCreateNestedOneWithoutUsers_contributionsInput
  }

  export type userContributionUncheckedCreateWithoutBouquineriesInput = {
    id?: number
    userId: number
    date?: Date | string
    contribution: string
    newPoints: number
    totalPoints: number
    isEmailSent: boolean
    edgeId?: number | null
    bookstoreCommentId?: number | null
  }

  export type userContributionCreateOrConnectWithoutBouquineriesInput = {
    where: userContributionWhereUniqueInput
    create: XOR<userContributionCreateWithoutBouquineriesInput, userContributionUncheckedCreateWithoutBouquineriesInput>
  }

  export type userContributionCreateManyBouquineriesInputEnvelope = {
    data: userContributionCreateManyBouquineriesInput | userContributionCreateManyBouquineriesInput[]
    skipDuplicates?: boolean
  }

  export type bookstoreCommentUpsertWithWhereUniqueWithoutBouquineriesInput = {
    where: bookstoreCommentWhereUniqueInput
    update: XOR<bookstoreCommentUpdateWithoutBouquineriesInput, bookstoreCommentUncheckedUpdateWithoutBouquineriesInput>
    create: XOR<bookstoreCommentCreateWithoutBouquineriesInput, bookstoreCommentUncheckedCreateWithoutBouquineriesInput>
  }

  export type bookstoreCommentUpdateWithWhereUniqueWithoutBouquineriesInput = {
    where: bookstoreCommentWhereUniqueInput
    data: XOR<bookstoreCommentUpdateWithoutBouquineriesInput, bookstoreCommentUncheckedUpdateWithoutBouquineriesInput>
  }

  export type bookstoreCommentUpdateManyWithWhereWithoutBouquineriesInput = {
    where: bookstoreCommentScalarWhereInput
    data: XOR<bookstoreCommentUpdateManyMutationInput, bookstoreCommentUncheckedUpdateManyWithoutBouquineriesInput>
  }

  export type bookstoreCommentScalarWhereInput = {
    AND?: bookstoreCommentScalarWhereInput | bookstoreCommentScalarWhereInput[]
    OR?: bookstoreCommentScalarWhereInput[]
    NOT?: bookstoreCommentScalarWhereInput | bookstoreCommentScalarWhereInput[]
    id?: IntFilter<"bookstoreComment"> | number
    userId?: IntNullableFilter<"bookstoreComment"> | number | null
    comment?: StringFilter<"bookstoreComment"> | string
    creationDate?: DateTimeFilter<"bookstoreComment"> | Date | string
    isActive?: BoolFilter<"bookstoreComment"> | boolean
    bookstoreId?: IntFilter<"bookstoreComment"> | number
  }

  export type userContributionUpsertWithWhereUniqueWithoutBouquineriesInput = {
    where: userContributionWhereUniqueInput
    update: XOR<userContributionUpdateWithoutBouquineriesInput, userContributionUncheckedUpdateWithoutBouquineriesInput>
    create: XOR<userContributionCreateWithoutBouquineriesInput, userContributionUncheckedCreateWithoutBouquineriesInput>
  }

  export type userContributionUpdateWithWhereUniqueWithoutBouquineriesInput = {
    where: userContributionWhereUniqueInput
    data: XOR<userContributionUpdateWithoutBouquineriesInput, userContributionUncheckedUpdateWithoutBouquineriesInput>
  }

  export type userContributionUpdateManyWithWhereWithoutBouquineriesInput = {
    where: userContributionScalarWhereInput
    data: XOR<userContributionUpdateManyMutationInput, userContributionUncheckedUpdateManyWithoutBouquineriesInput>
  }

  export type userContributionScalarWhereInput = {
    AND?: userContributionScalarWhereInput | userContributionScalarWhereInput[]
    OR?: userContributionScalarWhereInput[]
    NOT?: userContributionScalarWhereInput | userContributionScalarWhereInput[]
    id?: IntFilter<"userContribution"> | number
    userId?: IntFilter<"userContribution"> | number
    date?: DateTimeFilter<"userContribution"> | Date | string
    contribution?: StringFilter<"userContribution"> | string
    newPoints?: IntFilter<"userContribution"> | number
    totalPoints?: IntFilter<"userContribution"> | number
    isEmailSent?: BoolFilter<"userContribution"> | boolean
    edgeId?: IntNullableFilter<"userContribution"> | number | null
    bookstoreId?: IntNullableFilter<"userContribution"> | number | null
    bookstoreCommentId?: IntNullableFilter<"userContribution"> | number | null
  }

  export type bookstoreCreateWithoutCommentsInput = {
    name: string
    address: string
    coordX: number
    coordY: number
    users_contributions?: userContributionCreateNestedManyWithoutBouquineriesInput
  }

  export type bookstoreUncheckedCreateWithoutCommentsInput = {
    id?: number
    name: string
    address: string
    coordX: number
    coordY: number
    users_contributions?: userContributionUncheckedCreateNestedManyWithoutBouquineriesInput
  }

  export type bookstoreCreateOrConnectWithoutCommentsInput = {
    where: bookstoreWhereUniqueInput
    create: XOR<bookstoreCreateWithoutCommentsInput, bookstoreUncheckedCreateWithoutCommentsInput>
  }

  export type userCreateWithoutBouquineries_commentairesInput = {
    username: string
    password: string
    allowSharing?: boolean
    signupDate: Date | string
    email: string
    discordId?: number | null
    showRecommendations?: boolean
    isBetaUser?: boolean
    showPresentationVideo?: boolean
    showDuplicatesInBookcase?: boolean
    bookcaseTexture1?: string
    bookcaseSubTexture1?: string
    bookcaseTexture2?: string
    bookcaseSubTexture2?: string
    presentationText?: string | null
    lastAccess?: Date | string | null
    previousAccess?: Date | string | null
    marketplaceAcceptsExchanges?: boolean
    abonnements?: subscriptionCreateNestedManyWithoutUsersInput
    users_contributions?: userContributionCreateNestedManyWithoutUsersInput
    users_options?: userOptionCreateNestedManyWithoutUsersInput
  }

  export type userUncheckedCreateWithoutBouquineries_commentairesInput = {
    id?: number
    username: string
    password: string
    allowSharing?: boolean
    signupDate: Date | string
    email: string
    discordId?: number | null
    showRecommendations?: boolean
    isBetaUser?: boolean
    showPresentationVideo?: boolean
    showDuplicatesInBookcase?: boolean
    bookcaseTexture1?: string
    bookcaseSubTexture1?: string
    bookcaseTexture2?: string
    bookcaseSubTexture2?: string
    presentationText?: string | null
    lastAccess?: Date | string | null
    previousAccess?: Date | string | null
    marketplaceAcceptsExchanges?: boolean
    abonnements?: subscriptionUncheckedCreateNestedManyWithoutUsersInput
    users_contributions?: userContributionUncheckedCreateNestedManyWithoutUsersInput
    users_options?: userOptionUncheckedCreateNestedManyWithoutUsersInput
  }

  export type userCreateOrConnectWithoutBouquineries_commentairesInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutBouquineries_commentairesInput, userUncheckedCreateWithoutBouquineries_commentairesInput>
  }

  export type userContributionCreateWithoutBouquineries_commentairesInput = {
    date?: Date | string
    contribution: string
    newPoints: number
    totalPoints: number
    isEmailSent: boolean
    tranches_pretes?: edgeCreateNestedOneWithoutUsers_contributionsInput
    bouquineries?: bookstoreCreateNestedOneWithoutUsers_contributionsInput
    users: userCreateNestedOneWithoutUsers_contributionsInput
  }

  export type userContributionUncheckedCreateWithoutBouquineries_commentairesInput = {
    id?: number
    userId: number
    date?: Date | string
    contribution: string
    newPoints: number
    totalPoints: number
    isEmailSent: boolean
    edgeId?: number | null
    bookstoreId?: number | null
  }

  export type userContributionCreateOrConnectWithoutBouquineries_commentairesInput = {
    where: userContributionWhereUniqueInput
    create: XOR<userContributionCreateWithoutBouquineries_commentairesInput, userContributionUncheckedCreateWithoutBouquineries_commentairesInput>
  }

  export type userContributionCreateManyBouquineries_commentairesInputEnvelope = {
    data: userContributionCreateManyBouquineries_commentairesInput | userContributionCreateManyBouquineries_commentairesInput[]
    skipDuplicates?: boolean
  }

  export type bookstoreUpsertWithoutCommentsInput = {
    update: XOR<bookstoreUpdateWithoutCommentsInput, bookstoreUncheckedUpdateWithoutCommentsInput>
    create: XOR<bookstoreCreateWithoutCommentsInput, bookstoreUncheckedCreateWithoutCommentsInput>
    where?: bookstoreWhereInput
  }

  export type bookstoreUpdateToOneWithWhereWithoutCommentsInput = {
    where?: bookstoreWhereInput
    data: XOR<bookstoreUpdateWithoutCommentsInput, bookstoreUncheckedUpdateWithoutCommentsInput>
  }

  export type bookstoreUpdateWithoutCommentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    coordX?: FloatFieldUpdateOperationsInput | number
    coordY?: FloatFieldUpdateOperationsInput | number
    users_contributions?: userContributionUpdateManyWithoutBouquineriesNestedInput
  }

  export type bookstoreUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    coordX?: FloatFieldUpdateOperationsInput | number
    coordY?: FloatFieldUpdateOperationsInput | number
    users_contributions?: userContributionUncheckedUpdateManyWithoutBouquineriesNestedInput
  }

  export type userUpsertWithoutBouquineries_commentairesInput = {
    update: XOR<userUpdateWithoutBouquineries_commentairesInput, userUncheckedUpdateWithoutBouquineries_commentairesInput>
    create: XOR<userCreateWithoutBouquineries_commentairesInput, userUncheckedCreateWithoutBouquineries_commentairesInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutBouquineries_commentairesInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutBouquineries_commentairesInput, userUncheckedUpdateWithoutBouquineries_commentairesInput>
  }

  export type userUpdateWithoutBouquineries_commentairesInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    allowSharing?: BoolFieldUpdateOperationsInput | boolean
    signupDate?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    discordId?: NullableIntFieldUpdateOperationsInput | number | null
    showRecommendations?: BoolFieldUpdateOperationsInput | boolean
    isBetaUser?: BoolFieldUpdateOperationsInput | boolean
    showPresentationVideo?: BoolFieldUpdateOperationsInput | boolean
    showDuplicatesInBookcase?: BoolFieldUpdateOperationsInput | boolean
    bookcaseTexture1?: StringFieldUpdateOperationsInput | string
    bookcaseSubTexture1?: StringFieldUpdateOperationsInput | string
    bookcaseTexture2?: StringFieldUpdateOperationsInput | string
    bookcaseSubTexture2?: StringFieldUpdateOperationsInput | string
    presentationText?: NullableStringFieldUpdateOperationsInput | string | null
    lastAccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousAccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketplaceAcceptsExchanges?: BoolFieldUpdateOperationsInput | boolean
    abonnements?: subscriptionUpdateManyWithoutUsersNestedInput
    users_contributions?: userContributionUpdateManyWithoutUsersNestedInput
    users_options?: userOptionUpdateManyWithoutUsersNestedInput
  }

  export type userUncheckedUpdateWithoutBouquineries_commentairesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    allowSharing?: BoolFieldUpdateOperationsInput | boolean
    signupDate?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    discordId?: NullableIntFieldUpdateOperationsInput | number | null
    showRecommendations?: BoolFieldUpdateOperationsInput | boolean
    isBetaUser?: BoolFieldUpdateOperationsInput | boolean
    showPresentationVideo?: BoolFieldUpdateOperationsInput | boolean
    showDuplicatesInBookcase?: BoolFieldUpdateOperationsInput | boolean
    bookcaseTexture1?: StringFieldUpdateOperationsInput | string
    bookcaseSubTexture1?: StringFieldUpdateOperationsInput | string
    bookcaseTexture2?: StringFieldUpdateOperationsInput | string
    bookcaseSubTexture2?: StringFieldUpdateOperationsInput | string
    presentationText?: NullableStringFieldUpdateOperationsInput | string | null
    lastAccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousAccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketplaceAcceptsExchanges?: BoolFieldUpdateOperationsInput | boolean
    abonnements?: subscriptionUncheckedUpdateManyWithoutUsersNestedInput
    users_contributions?: userContributionUncheckedUpdateManyWithoutUsersNestedInput
    users_options?: userOptionUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type userContributionUpsertWithWhereUniqueWithoutBouquineries_commentairesInput = {
    where: userContributionWhereUniqueInput
    update: XOR<userContributionUpdateWithoutBouquineries_commentairesInput, userContributionUncheckedUpdateWithoutBouquineries_commentairesInput>
    create: XOR<userContributionCreateWithoutBouquineries_commentairesInput, userContributionUncheckedCreateWithoutBouquineries_commentairesInput>
  }

  export type userContributionUpdateWithWhereUniqueWithoutBouquineries_commentairesInput = {
    where: userContributionWhereUniqueInput
    data: XOR<userContributionUpdateWithoutBouquineries_commentairesInput, userContributionUncheckedUpdateWithoutBouquineries_commentairesInput>
  }

  export type userContributionUpdateManyWithWhereWithoutBouquineries_commentairesInput = {
    where: userContributionScalarWhereInput
    data: XOR<userContributionUpdateManyMutationInput, userContributionUncheckedUpdateManyWithoutBouquineries_commentairesInput>
  }

  export type userContributionCreateWithoutTranches_pretesInput = {
    date?: Date | string
    contribution: string
    newPoints: number
    totalPoints: number
    isEmailSent: boolean
    bouquineries?: bookstoreCreateNestedOneWithoutUsers_contributionsInput
    users: userCreateNestedOneWithoutUsers_contributionsInput
    bouquineries_commentaires?: bookstoreCommentCreateNestedOneWithoutUsers_contributionsInput
  }

  export type userContributionUncheckedCreateWithoutTranches_pretesInput = {
    id?: number
    userId: number
    date?: Date | string
    contribution: string
    newPoints: number
    totalPoints: number
    isEmailSent: boolean
    bookstoreId?: number | null
    bookstoreCommentId?: number | null
  }

  export type userContributionCreateOrConnectWithoutTranches_pretesInput = {
    where: userContributionWhereUniqueInput
    create: XOR<userContributionCreateWithoutTranches_pretesInput, userContributionUncheckedCreateWithoutTranches_pretesInput>
  }

  export type userContributionCreateManyTranches_pretesInputEnvelope = {
    data: userContributionCreateManyTranches_pretesInput | userContributionCreateManyTranches_pretesInput[]
    skipDuplicates?: boolean
  }

  export type userContributionUpsertWithWhereUniqueWithoutTranches_pretesInput = {
    where: userContributionWhereUniqueInput
    update: XOR<userContributionUpdateWithoutTranches_pretesInput, userContributionUncheckedUpdateWithoutTranches_pretesInput>
    create: XOR<userContributionCreateWithoutTranches_pretesInput, userContributionUncheckedCreateWithoutTranches_pretesInput>
  }

  export type userContributionUpdateWithWhereUniqueWithoutTranches_pretesInput = {
    where: userContributionWhereUniqueInput
    data: XOR<userContributionUpdateWithoutTranches_pretesInput, userContributionUncheckedUpdateWithoutTranches_pretesInput>
  }

  export type userContributionUpdateManyWithWhereWithoutTranches_pretesInput = {
    where: userContributionScalarWhereInput
    data: XOR<userContributionUpdateManyMutationInput, userContributionUncheckedUpdateManyWithoutTranches_pretesInput>
  }

  export type subscriptionCreateWithoutUsersInput = {
    country: string
    magazine: string
    startDate: Date | string
    endDate: Date | string
  }

  export type subscriptionUncheckedCreateWithoutUsersInput = {
    id?: number
    country: string
    magazine: string
    startDate: Date | string
    endDate: Date | string
  }

  export type subscriptionCreateOrConnectWithoutUsersInput = {
    where: subscriptionWhereUniqueInput
    create: XOR<subscriptionCreateWithoutUsersInput, subscriptionUncheckedCreateWithoutUsersInput>
  }

  export type subscriptionCreateManyUsersInputEnvelope = {
    data: subscriptionCreateManyUsersInput | subscriptionCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type bookstoreCommentCreateWithoutUserInput = {
    comment: string
    creationDate?: Date | string
    isActive?: boolean
    bouquineries: bookstoreCreateNestedOneWithoutCommentsInput
    users_contributions?: userContributionCreateNestedManyWithoutBouquineries_commentairesInput
  }

  export type bookstoreCommentUncheckedCreateWithoutUserInput = {
    id?: number
    comment: string
    creationDate?: Date | string
    isActive?: boolean
    bookstoreId: number
    users_contributions?: userContributionUncheckedCreateNestedManyWithoutBouquineries_commentairesInput
  }

  export type bookstoreCommentCreateOrConnectWithoutUserInput = {
    where: bookstoreCommentWhereUniqueInput
    create: XOR<bookstoreCommentCreateWithoutUserInput, bookstoreCommentUncheckedCreateWithoutUserInput>
  }

  export type bookstoreCommentCreateManyUserInputEnvelope = {
    data: bookstoreCommentCreateManyUserInput | bookstoreCommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type userContributionCreateWithoutUsersInput = {
    date?: Date | string
    contribution: string
    newPoints: number
    totalPoints: number
    isEmailSent: boolean
    tranches_pretes?: edgeCreateNestedOneWithoutUsers_contributionsInput
    bouquineries?: bookstoreCreateNestedOneWithoutUsers_contributionsInput
    bouquineries_commentaires?: bookstoreCommentCreateNestedOneWithoutUsers_contributionsInput
  }

  export type userContributionUncheckedCreateWithoutUsersInput = {
    id?: number
    date?: Date | string
    contribution: string
    newPoints: number
    totalPoints: number
    isEmailSent: boolean
    edgeId?: number | null
    bookstoreId?: number | null
    bookstoreCommentId?: number | null
  }

  export type userContributionCreateOrConnectWithoutUsersInput = {
    where: userContributionWhereUniqueInput
    create: XOR<userContributionCreateWithoutUsersInput, userContributionUncheckedCreateWithoutUsersInput>
  }

  export type userContributionCreateManyUsersInputEnvelope = {
    data: userContributionCreateManyUsersInput | userContributionCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type userOptionCreateWithoutUsersInput = {
    optionName: $Enums.userOptionType
    optionValue: string
  }

  export type userOptionUncheckedCreateWithoutUsersInput = {
    id?: number
    optionName: $Enums.userOptionType
    optionValue: string
  }

  export type userOptionCreateOrConnectWithoutUsersInput = {
    where: userOptionWhereUniqueInput
    create: XOR<userOptionCreateWithoutUsersInput, userOptionUncheckedCreateWithoutUsersInput>
  }

  export type userOptionCreateManyUsersInputEnvelope = {
    data: userOptionCreateManyUsersInput | userOptionCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type subscriptionUpsertWithWhereUniqueWithoutUsersInput = {
    where: subscriptionWhereUniqueInput
    update: XOR<subscriptionUpdateWithoutUsersInput, subscriptionUncheckedUpdateWithoutUsersInput>
    create: XOR<subscriptionCreateWithoutUsersInput, subscriptionUncheckedCreateWithoutUsersInput>
  }

  export type subscriptionUpdateWithWhereUniqueWithoutUsersInput = {
    where: subscriptionWhereUniqueInput
    data: XOR<subscriptionUpdateWithoutUsersInput, subscriptionUncheckedUpdateWithoutUsersInput>
  }

  export type subscriptionUpdateManyWithWhereWithoutUsersInput = {
    where: subscriptionScalarWhereInput
    data: XOR<subscriptionUpdateManyMutationInput, subscriptionUncheckedUpdateManyWithoutUsersInput>
  }

  export type subscriptionScalarWhereInput = {
    AND?: subscriptionScalarWhereInput | subscriptionScalarWhereInput[]
    OR?: subscriptionScalarWhereInput[]
    NOT?: subscriptionScalarWhereInput | subscriptionScalarWhereInput[]
    id?: IntFilter<"subscription"> | number
    userId?: IntFilter<"subscription"> | number
    country?: StringFilter<"subscription"> | string
    magazine?: StringFilter<"subscription"> | string
    startDate?: DateTimeFilter<"subscription"> | Date | string
    endDate?: DateTimeFilter<"subscription"> | Date | string
  }

  export type bookstoreCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: bookstoreCommentWhereUniqueInput
    update: XOR<bookstoreCommentUpdateWithoutUserInput, bookstoreCommentUncheckedUpdateWithoutUserInput>
    create: XOR<bookstoreCommentCreateWithoutUserInput, bookstoreCommentUncheckedCreateWithoutUserInput>
  }

  export type bookstoreCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: bookstoreCommentWhereUniqueInput
    data: XOR<bookstoreCommentUpdateWithoutUserInput, bookstoreCommentUncheckedUpdateWithoutUserInput>
  }

  export type bookstoreCommentUpdateManyWithWhereWithoutUserInput = {
    where: bookstoreCommentScalarWhereInput
    data: XOR<bookstoreCommentUpdateManyMutationInput, bookstoreCommentUncheckedUpdateManyWithoutUserInput>
  }

  export type userContributionUpsertWithWhereUniqueWithoutUsersInput = {
    where: userContributionWhereUniqueInput
    update: XOR<userContributionUpdateWithoutUsersInput, userContributionUncheckedUpdateWithoutUsersInput>
    create: XOR<userContributionCreateWithoutUsersInput, userContributionUncheckedCreateWithoutUsersInput>
  }

  export type userContributionUpdateWithWhereUniqueWithoutUsersInput = {
    where: userContributionWhereUniqueInput
    data: XOR<userContributionUpdateWithoutUsersInput, userContributionUncheckedUpdateWithoutUsersInput>
  }

  export type userContributionUpdateManyWithWhereWithoutUsersInput = {
    where: userContributionScalarWhereInput
    data: XOR<userContributionUpdateManyMutationInput, userContributionUncheckedUpdateManyWithoutUsersInput>
  }

  export type userOptionUpsertWithWhereUniqueWithoutUsersInput = {
    where: userOptionWhereUniqueInput
    update: XOR<userOptionUpdateWithoutUsersInput, userOptionUncheckedUpdateWithoutUsersInput>
    create: XOR<userOptionCreateWithoutUsersInput, userOptionUncheckedCreateWithoutUsersInput>
  }

  export type userOptionUpdateWithWhereUniqueWithoutUsersInput = {
    where: userOptionWhereUniqueInput
    data: XOR<userOptionUpdateWithoutUsersInput, userOptionUncheckedUpdateWithoutUsersInput>
  }

  export type userOptionUpdateManyWithWhereWithoutUsersInput = {
    where: userOptionScalarWhereInput
    data: XOR<userOptionUpdateManyMutationInput, userOptionUncheckedUpdateManyWithoutUsersInput>
  }

  export type userOptionScalarWhereInput = {
    AND?: userOptionScalarWhereInput | userOptionScalarWhereInput[]
    OR?: userOptionScalarWhereInput[]
    NOT?: userOptionScalarWhereInput | userOptionScalarWhereInput[]
    id?: IntFilter<"userOption"> | number
    userId?: IntFilter<"userOption"> | number
    optionName?: EnumuserOptionTypeFilter<"userOption"> | $Enums.userOptionType
    optionValue?: StringFilter<"userOption"> | string
  }

  export type edgeCreateWithoutUsers_contributionsInput = {
    publicationcode: string
    issuenumber: string
    creationDate?: Date | string
    points?: number | null
    slug?: string | null
    issuecode?: string | null
  }

  export type edgeUncheckedCreateWithoutUsers_contributionsInput = {
    id?: number
    publicationcode: string
    issuenumber: string
    creationDate?: Date | string
    points?: number | null
    slug?: string | null
    issuecode?: string | null
  }

  export type edgeCreateOrConnectWithoutUsers_contributionsInput = {
    where: edgeWhereUniqueInput
    create: XOR<edgeCreateWithoutUsers_contributionsInput, edgeUncheckedCreateWithoutUsers_contributionsInput>
  }

  export type bookstoreCreateWithoutUsers_contributionsInput = {
    name: string
    address: string
    coordX: number
    coordY: number
    comments?: bookstoreCommentCreateNestedManyWithoutBouquineriesInput
  }

  export type bookstoreUncheckedCreateWithoutUsers_contributionsInput = {
    id?: number
    name: string
    address: string
    coordX: number
    coordY: number
    comments?: bookstoreCommentUncheckedCreateNestedManyWithoutBouquineriesInput
  }

  export type bookstoreCreateOrConnectWithoutUsers_contributionsInput = {
    where: bookstoreWhereUniqueInput
    create: XOR<bookstoreCreateWithoutUsers_contributionsInput, bookstoreUncheckedCreateWithoutUsers_contributionsInput>
  }

  export type userCreateWithoutUsers_contributionsInput = {
    username: string
    password: string
    allowSharing?: boolean
    signupDate: Date | string
    email: string
    discordId?: number | null
    showRecommendations?: boolean
    isBetaUser?: boolean
    showPresentationVideo?: boolean
    showDuplicatesInBookcase?: boolean
    bookcaseTexture1?: string
    bookcaseSubTexture1?: string
    bookcaseTexture2?: string
    bookcaseSubTexture2?: string
    presentationText?: string | null
    lastAccess?: Date | string | null
    previousAccess?: Date | string | null
    marketplaceAcceptsExchanges?: boolean
    abonnements?: subscriptionCreateNestedManyWithoutUsersInput
    bouquineries_commentaires?: bookstoreCommentCreateNestedManyWithoutUserInput
    users_options?: userOptionCreateNestedManyWithoutUsersInput
  }

  export type userUncheckedCreateWithoutUsers_contributionsInput = {
    id?: number
    username: string
    password: string
    allowSharing?: boolean
    signupDate: Date | string
    email: string
    discordId?: number | null
    showRecommendations?: boolean
    isBetaUser?: boolean
    showPresentationVideo?: boolean
    showDuplicatesInBookcase?: boolean
    bookcaseTexture1?: string
    bookcaseSubTexture1?: string
    bookcaseTexture2?: string
    bookcaseSubTexture2?: string
    presentationText?: string | null
    lastAccess?: Date | string | null
    previousAccess?: Date | string | null
    marketplaceAcceptsExchanges?: boolean
    abonnements?: subscriptionUncheckedCreateNestedManyWithoutUsersInput
    bouquineries_commentaires?: bookstoreCommentUncheckedCreateNestedManyWithoutUserInput
    users_options?: userOptionUncheckedCreateNestedManyWithoutUsersInput
  }

  export type userCreateOrConnectWithoutUsers_contributionsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUsers_contributionsInput, userUncheckedCreateWithoutUsers_contributionsInput>
  }

  export type bookstoreCommentCreateWithoutUsers_contributionsInput = {
    comment: string
    creationDate?: Date | string
    isActive?: boolean
    bouquineries: bookstoreCreateNestedOneWithoutCommentsInput
    user?: userCreateNestedOneWithoutBouquineries_commentairesInput
  }

  export type bookstoreCommentUncheckedCreateWithoutUsers_contributionsInput = {
    id?: number
    userId?: number | null
    comment: string
    creationDate?: Date | string
    isActive?: boolean
    bookstoreId: number
  }

  export type bookstoreCommentCreateOrConnectWithoutUsers_contributionsInput = {
    where: bookstoreCommentWhereUniqueInput
    create: XOR<bookstoreCommentCreateWithoutUsers_contributionsInput, bookstoreCommentUncheckedCreateWithoutUsers_contributionsInput>
  }

  export type edgeUpsertWithoutUsers_contributionsInput = {
    update: XOR<edgeUpdateWithoutUsers_contributionsInput, edgeUncheckedUpdateWithoutUsers_contributionsInput>
    create: XOR<edgeCreateWithoutUsers_contributionsInput, edgeUncheckedCreateWithoutUsers_contributionsInput>
    where?: edgeWhereInput
  }

  export type edgeUpdateToOneWithWhereWithoutUsers_contributionsInput = {
    where?: edgeWhereInput
    data: XOR<edgeUpdateWithoutUsers_contributionsInput, edgeUncheckedUpdateWithoutUsers_contributionsInput>
  }

  export type edgeUpdateWithoutUsers_contributionsInput = {
    publicationcode?: StringFieldUpdateOperationsInput | string
    issuenumber?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: NullableIntFieldUpdateOperationsInput | number | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    issuecode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type edgeUncheckedUpdateWithoutUsers_contributionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicationcode?: StringFieldUpdateOperationsInput | string
    issuenumber?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: NullableIntFieldUpdateOperationsInput | number | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    issuecode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type bookstoreUpsertWithoutUsers_contributionsInput = {
    update: XOR<bookstoreUpdateWithoutUsers_contributionsInput, bookstoreUncheckedUpdateWithoutUsers_contributionsInput>
    create: XOR<bookstoreCreateWithoutUsers_contributionsInput, bookstoreUncheckedCreateWithoutUsers_contributionsInput>
    where?: bookstoreWhereInput
  }

  export type bookstoreUpdateToOneWithWhereWithoutUsers_contributionsInput = {
    where?: bookstoreWhereInput
    data: XOR<bookstoreUpdateWithoutUsers_contributionsInput, bookstoreUncheckedUpdateWithoutUsers_contributionsInput>
  }

  export type bookstoreUpdateWithoutUsers_contributionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    coordX?: FloatFieldUpdateOperationsInput | number
    coordY?: FloatFieldUpdateOperationsInput | number
    comments?: bookstoreCommentUpdateManyWithoutBouquineriesNestedInput
  }

  export type bookstoreUncheckedUpdateWithoutUsers_contributionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    coordX?: FloatFieldUpdateOperationsInput | number
    coordY?: FloatFieldUpdateOperationsInput | number
    comments?: bookstoreCommentUncheckedUpdateManyWithoutBouquineriesNestedInput
  }

  export type userUpsertWithoutUsers_contributionsInput = {
    update: XOR<userUpdateWithoutUsers_contributionsInput, userUncheckedUpdateWithoutUsers_contributionsInput>
    create: XOR<userCreateWithoutUsers_contributionsInput, userUncheckedCreateWithoutUsers_contributionsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutUsers_contributionsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutUsers_contributionsInput, userUncheckedUpdateWithoutUsers_contributionsInput>
  }

  export type userUpdateWithoutUsers_contributionsInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    allowSharing?: BoolFieldUpdateOperationsInput | boolean
    signupDate?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    discordId?: NullableIntFieldUpdateOperationsInput | number | null
    showRecommendations?: BoolFieldUpdateOperationsInput | boolean
    isBetaUser?: BoolFieldUpdateOperationsInput | boolean
    showPresentationVideo?: BoolFieldUpdateOperationsInput | boolean
    showDuplicatesInBookcase?: BoolFieldUpdateOperationsInput | boolean
    bookcaseTexture1?: StringFieldUpdateOperationsInput | string
    bookcaseSubTexture1?: StringFieldUpdateOperationsInput | string
    bookcaseTexture2?: StringFieldUpdateOperationsInput | string
    bookcaseSubTexture2?: StringFieldUpdateOperationsInput | string
    presentationText?: NullableStringFieldUpdateOperationsInput | string | null
    lastAccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousAccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketplaceAcceptsExchanges?: BoolFieldUpdateOperationsInput | boolean
    abonnements?: subscriptionUpdateManyWithoutUsersNestedInput
    bouquineries_commentaires?: bookstoreCommentUpdateManyWithoutUserNestedInput
    users_options?: userOptionUpdateManyWithoutUsersNestedInput
  }

  export type userUncheckedUpdateWithoutUsers_contributionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    allowSharing?: BoolFieldUpdateOperationsInput | boolean
    signupDate?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    discordId?: NullableIntFieldUpdateOperationsInput | number | null
    showRecommendations?: BoolFieldUpdateOperationsInput | boolean
    isBetaUser?: BoolFieldUpdateOperationsInput | boolean
    showPresentationVideo?: BoolFieldUpdateOperationsInput | boolean
    showDuplicatesInBookcase?: BoolFieldUpdateOperationsInput | boolean
    bookcaseTexture1?: StringFieldUpdateOperationsInput | string
    bookcaseSubTexture1?: StringFieldUpdateOperationsInput | string
    bookcaseTexture2?: StringFieldUpdateOperationsInput | string
    bookcaseSubTexture2?: StringFieldUpdateOperationsInput | string
    presentationText?: NullableStringFieldUpdateOperationsInput | string | null
    lastAccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousAccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketplaceAcceptsExchanges?: BoolFieldUpdateOperationsInput | boolean
    abonnements?: subscriptionUncheckedUpdateManyWithoutUsersNestedInput
    bouquineries_commentaires?: bookstoreCommentUncheckedUpdateManyWithoutUserNestedInput
    users_options?: userOptionUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type bookstoreCommentUpsertWithoutUsers_contributionsInput = {
    update: XOR<bookstoreCommentUpdateWithoutUsers_contributionsInput, bookstoreCommentUncheckedUpdateWithoutUsers_contributionsInput>
    create: XOR<bookstoreCommentCreateWithoutUsers_contributionsInput, bookstoreCommentUncheckedCreateWithoutUsers_contributionsInput>
    where?: bookstoreCommentWhereInput
  }

  export type bookstoreCommentUpdateToOneWithWhereWithoutUsers_contributionsInput = {
    where?: bookstoreCommentWhereInput
    data: XOR<bookstoreCommentUpdateWithoutUsers_contributionsInput, bookstoreCommentUncheckedUpdateWithoutUsers_contributionsInput>
  }

  export type bookstoreCommentUpdateWithoutUsers_contributionsInput = {
    comment?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    bouquineries?: bookstoreUpdateOneRequiredWithoutCommentsNestedInput
    user?: userUpdateOneWithoutBouquineries_commentairesNestedInput
  }

  export type bookstoreCommentUncheckedUpdateWithoutUsers_contributionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    bookstoreId?: IntFieldUpdateOperationsInput | number
  }

  export type userCreateWithoutUsers_optionsInput = {
    username: string
    password: string
    allowSharing?: boolean
    signupDate: Date | string
    email: string
    discordId?: number | null
    showRecommendations?: boolean
    isBetaUser?: boolean
    showPresentationVideo?: boolean
    showDuplicatesInBookcase?: boolean
    bookcaseTexture1?: string
    bookcaseSubTexture1?: string
    bookcaseTexture2?: string
    bookcaseSubTexture2?: string
    presentationText?: string | null
    lastAccess?: Date | string | null
    previousAccess?: Date | string | null
    marketplaceAcceptsExchanges?: boolean
    abonnements?: subscriptionCreateNestedManyWithoutUsersInput
    bouquineries_commentaires?: bookstoreCommentCreateNestedManyWithoutUserInput
    users_contributions?: userContributionCreateNestedManyWithoutUsersInput
  }

  export type userUncheckedCreateWithoutUsers_optionsInput = {
    id?: number
    username: string
    password: string
    allowSharing?: boolean
    signupDate: Date | string
    email: string
    discordId?: number | null
    showRecommendations?: boolean
    isBetaUser?: boolean
    showPresentationVideo?: boolean
    showDuplicatesInBookcase?: boolean
    bookcaseTexture1?: string
    bookcaseSubTexture1?: string
    bookcaseTexture2?: string
    bookcaseSubTexture2?: string
    presentationText?: string | null
    lastAccess?: Date | string | null
    previousAccess?: Date | string | null
    marketplaceAcceptsExchanges?: boolean
    abonnements?: subscriptionUncheckedCreateNestedManyWithoutUsersInput
    bouquineries_commentaires?: bookstoreCommentUncheckedCreateNestedManyWithoutUserInput
    users_contributions?: userContributionUncheckedCreateNestedManyWithoutUsersInput
  }

  export type userCreateOrConnectWithoutUsers_optionsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUsers_optionsInput, userUncheckedCreateWithoutUsers_optionsInput>
  }

  export type userUpsertWithoutUsers_optionsInput = {
    update: XOR<userUpdateWithoutUsers_optionsInput, userUncheckedUpdateWithoutUsers_optionsInput>
    create: XOR<userCreateWithoutUsers_optionsInput, userUncheckedCreateWithoutUsers_optionsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutUsers_optionsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutUsers_optionsInput, userUncheckedUpdateWithoutUsers_optionsInput>
  }

  export type userUpdateWithoutUsers_optionsInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    allowSharing?: BoolFieldUpdateOperationsInput | boolean
    signupDate?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    discordId?: NullableIntFieldUpdateOperationsInput | number | null
    showRecommendations?: BoolFieldUpdateOperationsInput | boolean
    isBetaUser?: BoolFieldUpdateOperationsInput | boolean
    showPresentationVideo?: BoolFieldUpdateOperationsInput | boolean
    showDuplicatesInBookcase?: BoolFieldUpdateOperationsInput | boolean
    bookcaseTexture1?: StringFieldUpdateOperationsInput | string
    bookcaseSubTexture1?: StringFieldUpdateOperationsInput | string
    bookcaseTexture2?: StringFieldUpdateOperationsInput | string
    bookcaseSubTexture2?: StringFieldUpdateOperationsInput | string
    presentationText?: NullableStringFieldUpdateOperationsInput | string | null
    lastAccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousAccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketplaceAcceptsExchanges?: BoolFieldUpdateOperationsInput | boolean
    abonnements?: subscriptionUpdateManyWithoutUsersNestedInput
    bouquineries_commentaires?: bookstoreCommentUpdateManyWithoutUserNestedInput
    users_contributions?: userContributionUpdateManyWithoutUsersNestedInput
  }

  export type userUncheckedUpdateWithoutUsers_optionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    allowSharing?: BoolFieldUpdateOperationsInput | boolean
    signupDate?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    discordId?: NullableIntFieldUpdateOperationsInput | number | null
    showRecommendations?: BoolFieldUpdateOperationsInput | boolean
    isBetaUser?: BoolFieldUpdateOperationsInput | boolean
    showPresentationVideo?: BoolFieldUpdateOperationsInput | boolean
    showDuplicatesInBookcase?: BoolFieldUpdateOperationsInput | boolean
    bookcaseTexture1?: StringFieldUpdateOperationsInput | string
    bookcaseSubTexture1?: StringFieldUpdateOperationsInput | string
    bookcaseTexture2?: StringFieldUpdateOperationsInput | string
    bookcaseSubTexture2?: StringFieldUpdateOperationsInput | string
    presentationText?: NullableStringFieldUpdateOperationsInput | string | null
    lastAccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousAccess?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketplaceAcceptsExchanges?: BoolFieldUpdateOperationsInput | boolean
    abonnements?: subscriptionUncheckedUpdateManyWithoutUsersNestedInput
    bouquineries_commentaires?: bookstoreCommentUncheckedUpdateManyWithoutUserNestedInput
    users_contributions?: userContributionUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type bookstoreCommentCreateManyBouquineriesInput = {
    id?: number
    userId?: number | null
    comment: string
    creationDate?: Date | string
    isActive?: boolean
  }

  export type userContributionCreateManyBouquineriesInput = {
    id?: number
    userId: number
    date?: Date | string
    contribution: string
    newPoints: number
    totalPoints: number
    isEmailSent: boolean
    edgeId?: number | null
    bookstoreCommentId?: number | null
  }

  export type bookstoreCommentUpdateWithoutBouquineriesInput = {
    comment?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: userUpdateOneWithoutBouquineries_commentairesNestedInput
    users_contributions?: userContributionUpdateManyWithoutBouquineries_commentairesNestedInput
  }

  export type bookstoreCommentUncheckedUpdateWithoutBouquineriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    users_contributions?: userContributionUncheckedUpdateManyWithoutBouquineries_commentairesNestedInput
  }

  export type bookstoreCommentUncheckedUpdateManyWithoutBouquineriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type userContributionUpdateWithoutBouquineriesInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    contribution?: StringFieldUpdateOperationsInput | string
    newPoints?: IntFieldUpdateOperationsInput | number
    totalPoints?: IntFieldUpdateOperationsInput | number
    isEmailSent?: BoolFieldUpdateOperationsInput | boolean
    tranches_pretes?: edgeUpdateOneWithoutUsers_contributionsNestedInput
    users?: userUpdateOneRequiredWithoutUsers_contributionsNestedInput
    bouquineries_commentaires?: bookstoreCommentUpdateOneWithoutUsers_contributionsNestedInput
  }

  export type userContributionUncheckedUpdateWithoutBouquineriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    contribution?: StringFieldUpdateOperationsInput | string
    newPoints?: IntFieldUpdateOperationsInput | number
    totalPoints?: IntFieldUpdateOperationsInput | number
    isEmailSent?: BoolFieldUpdateOperationsInput | boolean
    edgeId?: NullableIntFieldUpdateOperationsInput | number | null
    bookstoreCommentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type userContributionUncheckedUpdateManyWithoutBouquineriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    contribution?: StringFieldUpdateOperationsInput | string
    newPoints?: IntFieldUpdateOperationsInput | number
    totalPoints?: IntFieldUpdateOperationsInput | number
    isEmailSent?: BoolFieldUpdateOperationsInput | boolean
    edgeId?: NullableIntFieldUpdateOperationsInput | number | null
    bookstoreCommentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type userContributionCreateManyBouquineries_commentairesInput = {
    id?: number
    userId: number
    date?: Date | string
    contribution: string
    newPoints: number
    totalPoints: number
    isEmailSent: boolean
    edgeId?: number | null
    bookstoreId?: number | null
  }

  export type userContributionUpdateWithoutBouquineries_commentairesInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    contribution?: StringFieldUpdateOperationsInput | string
    newPoints?: IntFieldUpdateOperationsInput | number
    totalPoints?: IntFieldUpdateOperationsInput | number
    isEmailSent?: BoolFieldUpdateOperationsInput | boolean
    tranches_pretes?: edgeUpdateOneWithoutUsers_contributionsNestedInput
    bouquineries?: bookstoreUpdateOneWithoutUsers_contributionsNestedInput
    users?: userUpdateOneRequiredWithoutUsers_contributionsNestedInput
  }

  export type userContributionUncheckedUpdateWithoutBouquineries_commentairesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    contribution?: StringFieldUpdateOperationsInput | string
    newPoints?: IntFieldUpdateOperationsInput | number
    totalPoints?: IntFieldUpdateOperationsInput | number
    isEmailSent?: BoolFieldUpdateOperationsInput | boolean
    edgeId?: NullableIntFieldUpdateOperationsInput | number | null
    bookstoreId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type userContributionUncheckedUpdateManyWithoutBouquineries_commentairesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    contribution?: StringFieldUpdateOperationsInput | string
    newPoints?: IntFieldUpdateOperationsInput | number
    totalPoints?: IntFieldUpdateOperationsInput | number
    isEmailSent?: BoolFieldUpdateOperationsInput | boolean
    edgeId?: NullableIntFieldUpdateOperationsInput | number | null
    bookstoreId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type userContributionCreateManyTranches_pretesInput = {
    id?: number
    userId: number
    date?: Date | string
    contribution: string
    newPoints: number
    totalPoints: number
    isEmailSent: boolean
    bookstoreId?: number | null
    bookstoreCommentId?: number | null
  }

  export type userContributionUpdateWithoutTranches_pretesInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    contribution?: StringFieldUpdateOperationsInput | string
    newPoints?: IntFieldUpdateOperationsInput | number
    totalPoints?: IntFieldUpdateOperationsInput | number
    isEmailSent?: BoolFieldUpdateOperationsInput | boolean
    bouquineries?: bookstoreUpdateOneWithoutUsers_contributionsNestedInput
    users?: userUpdateOneRequiredWithoutUsers_contributionsNestedInput
    bouquineries_commentaires?: bookstoreCommentUpdateOneWithoutUsers_contributionsNestedInput
  }

  export type userContributionUncheckedUpdateWithoutTranches_pretesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    contribution?: StringFieldUpdateOperationsInput | string
    newPoints?: IntFieldUpdateOperationsInput | number
    totalPoints?: IntFieldUpdateOperationsInput | number
    isEmailSent?: BoolFieldUpdateOperationsInput | boolean
    bookstoreId?: NullableIntFieldUpdateOperationsInput | number | null
    bookstoreCommentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type userContributionUncheckedUpdateManyWithoutTranches_pretesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    contribution?: StringFieldUpdateOperationsInput | string
    newPoints?: IntFieldUpdateOperationsInput | number
    totalPoints?: IntFieldUpdateOperationsInput | number
    isEmailSent?: BoolFieldUpdateOperationsInput | boolean
    bookstoreId?: NullableIntFieldUpdateOperationsInput | number | null
    bookstoreCommentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type subscriptionCreateManyUsersInput = {
    id?: number
    country: string
    magazine: string
    startDate: Date | string
    endDate: Date | string
  }

  export type bookstoreCommentCreateManyUserInput = {
    id?: number
    comment: string
    creationDate?: Date | string
    isActive?: boolean
    bookstoreId: number
  }

  export type userContributionCreateManyUsersInput = {
    id?: number
    date?: Date | string
    contribution: string
    newPoints: number
    totalPoints: number
    isEmailSent: boolean
    edgeId?: number | null
    bookstoreId?: number | null
    bookstoreCommentId?: number | null
  }

  export type userOptionCreateManyUsersInput = {
    id?: number
    optionName: $Enums.userOptionType
    optionValue: string
  }

  export type subscriptionUpdateWithoutUsersInput = {
    country?: StringFieldUpdateOperationsInput | string
    magazine?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subscriptionUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    magazine?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subscriptionUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    magazine?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bookstoreCommentUpdateWithoutUserInput = {
    comment?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    bouquineries?: bookstoreUpdateOneRequiredWithoutCommentsNestedInput
    users_contributions?: userContributionUpdateManyWithoutBouquineries_commentairesNestedInput
  }

  export type bookstoreCommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    bookstoreId?: IntFieldUpdateOperationsInput | number
    users_contributions?: userContributionUncheckedUpdateManyWithoutBouquineries_commentairesNestedInput
  }

  export type bookstoreCommentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    creationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    bookstoreId?: IntFieldUpdateOperationsInput | number
  }

  export type userContributionUpdateWithoutUsersInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    contribution?: StringFieldUpdateOperationsInput | string
    newPoints?: IntFieldUpdateOperationsInput | number
    totalPoints?: IntFieldUpdateOperationsInput | number
    isEmailSent?: BoolFieldUpdateOperationsInput | boolean
    tranches_pretes?: edgeUpdateOneWithoutUsers_contributionsNestedInput
    bouquineries?: bookstoreUpdateOneWithoutUsers_contributionsNestedInput
    bouquineries_commentaires?: bookstoreCommentUpdateOneWithoutUsers_contributionsNestedInput
  }

  export type userContributionUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    contribution?: StringFieldUpdateOperationsInput | string
    newPoints?: IntFieldUpdateOperationsInput | number
    totalPoints?: IntFieldUpdateOperationsInput | number
    isEmailSent?: BoolFieldUpdateOperationsInput | boolean
    edgeId?: NullableIntFieldUpdateOperationsInput | number | null
    bookstoreId?: NullableIntFieldUpdateOperationsInput | number | null
    bookstoreCommentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type userContributionUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    contribution?: StringFieldUpdateOperationsInput | string
    newPoints?: IntFieldUpdateOperationsInput | number
    totalPoints?: IntFieldUpdateOperationsInput | number
    isEmailSent?: BoolFieldUpdateOperationsInput | boolean
    edgeId?: NullableIntFieldUpdateOperationsInput | number | null
    bookstoreId?: NullableIntFieldUpdateOperationsInput | number | null
    bookstoreCommentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type userOptionUpdateWithoutUsersInput = {
    optionName?: EnumuserOptionTypeFieldUpdateOperationsInput | $Enums.userOptionType
    optionValue?: StringFieldUpdateOperationsInput | string
  }

  export type userOptionUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    optionName?: EnumuserOptionTypeFieldUpdateOperationsInput | $Enums.userOptionType
    optionValue?: StringFieldUpdateOperationsInput | string
  }

  export type userOptionUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    optionName?: EnumuserOptionTypeFieldUpdateOperationsInput | $Enums.userOptionType
    optionValue?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use BookstoreCountOutputTypeDefaultArgs instead
     */
    export type BookstoreCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = BookstoreCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookstoreCommentCountOutputTypeDefaultArgs instead
     */
    export type BookstoreCommentCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = BookstoreCommentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EdgeCountOutputTypeDefaultArgs instead
     */
    export type EdgeCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = EdgeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use subscriptionDefaultArgs instead
     */
    export type subscriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = subscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use abonnements_sortiesDefaultArgs instead
     */
    export type abonnements_sortiesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = abonnements_sortiesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use purchaseDefaultArgs instead
     */
    export type purchaseArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = purchaseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use authorUserDefaultArgs instead
     */
    export type authorUserArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = authorUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bibliotheque_contributeursDefaultArgs instead
     */
    export type bibliotheque_contributeursArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = bibliotheque_contributeursDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bookcasePublicationOrderDefaultArgs instead
     */
    export type bookcasePublicationOrderArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = bookcasePublicationOrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bookstoreDefaultArgs instead
     */
    export type bookstoreArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = bookstoreDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bookstoreCommentDefaultArgs instead
     */
    export type bookstoreCommentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = bookstoreCommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use demoDefaultArgs instead
     */
    export type demoArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = demoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use magazinesDefaultArgs instead
     */
    export type magazinesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = magazinesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use issueDefaultArgs instead
     */
    export type issueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = issueDefaultArgs<ExtArgs>
    /**
     * @deprecated Use issuePopularityDefaultArgs instead
     */
    export type issuePopularityArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = issuePopularityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tranches_doublonsDefaultArgs instead
     */
    export type tranches_doublonsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = tranches_doublonsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use edgeDefaultArgs instead
     */
    export type edgeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = edgeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tranches_pretes_contributeursDefaultArgs instead
     */
    export type tranches_pretes_contributeursArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = tranches_pretes_contributeursDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tranches_pretes_contributionsDefaultArgs instead
     */
    export type tranches_pretes_contributionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = tranches_pretes_contributionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use edgeSpriteDefaultArgs instead
     */
    export type edgeSpriteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = edgeSpriteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use edgeSpriteSizeDefaultArgs instead
     */
    export type edgeSpriteSizeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = edgeSpriteSizeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use edgeSpriteUrlDefaultArgs instead
     */
    export type edgeSpriteUrlArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = edgeSpriteUrlDefaultArgs<ExtArgs>
    /**
     * @deprecated Use userDefaultArgs instead
     */
    export type userArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = userDefaultArgs<ExtArgs>
    /**
     * @deprecated Use userContributionDefaultArgs instead
     */
    export type userContributionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = userContributionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use userOptionDefaultArgs instead
     */
    export type userOptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = userOptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use userPasswordTokenDefaultArgs instead
     */
    export type userPasswordTokenArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = userPasswordTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use userPermissionDefaultArgs instead
     */
    export type userPermissionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = userPermissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use users_pointsDefaultArgs instead
     */
    export type users_pointsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = users_pointsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use userSuggestionNotificationDefaultArgs instead
     */
    export type userSuggestionNotificationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = userSuggestionNotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use requestedIssueDefaultArgs instead
     */
    export type requestedIssueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = requestedIssueDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}