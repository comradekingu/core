
/**
 * Client
**/

import * as runtime from './runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model datasets_entryurls
 * 
 */
export type datasets_entryurls = $Result.DefaultSelection<Prisma.$datasets_entryurlsPayload>
/**
 * Model inducks_appearance
 * 
 */
export type inducks_appearance = $Result.DefaultSelection<Prisma.$inducks_appearancePayload>
/**
 * Model inducks_character
 * 
 */
export type inducks_character = $Result.DefaultSelection<Prisma.$inducks_characterPayload>
/**
 * Model inducks_characteralias
 * 
 */
export type inducks_characteralias = $Result.DefaultSelection<Prisma.$inducks_characteraliasPayload>
/**
 * Model inducks_characterdetail
 * 
 */
export type inducks_characterdetail = $Result.DefaultSelection<Prisma.$inducks_characterdetailPayload>
/**
 * Model inducks_charactername
 * 
 */
export type inducks_charactername = $Result.DefaultSelection<Prisma.$inducks_characternamePayload>
/**
 * Model inducks_characterreference
 * 
 */
export type inducks_characterreference = $Result.DefaultSelection<Prisma.$inducks_characterreferencePayload>
/**
 * Model inducks_characterurl
 * 
 */
export type inducks_characterurl = $Result.DefaultSelection<Prisma.$inducks_characterurlPayload>
/**
 * Model inducks_country
 * 
 */
export type inducks_country = $Result.DefaultSelection<Prisma.$inducks_countryPayload>
/**
 * Model inducks_countryname
 * 
 */
export type inducks_countryname = $Result.DefaultSelection<Prisma.$inducks_countrynamePayload>
/**
 * Model inducks_currency
 * 
 */
export type inducks_currency = $Result.DefaultSelection<Prisma.$inducks_currencyPayload>
/**
 * Model inducks_currencyname
 * 
 */
export type inducks_currencyname = $Result.DefaultSelection<Prisma.$inducks_currencynamePayload>
/**
 * Model inducks_entry
 * 
 */
export type inducks_entry = $Result.DefaultSelection<Prisma.$inducks_entryPayload>
/**
 * Model inducks_entry_nofulltext
 * 
 */
export type inducks_entry_nofulltext = $Result.DefaultSelection<Prisma.$inducks_entry_nofulltextPayload>
/**
 * Model inducks_entrycharactername
 * 
 */
export type inducks_entrycharactername = $Result.DefaultSelection<Prisma.$inducks_entrycharacternamePayload>
/**
 * Model inducks_entryjob
 * 
 */
export type inducks_entryjob = $Result.DefaultSelection<Prisma.$inducks_entryjobPayload>
/**
 * Model inducks_entryurl
 * 
 */
export type inducks_entryurl = $Result.DefaultSelection<Prisma.$inducks_entryurlPayload>
/**
 * Model inducks_equiv
 * 
 */
export type inducks_equiv = $Result.DefaultSelection<Prisma.$inducks_equivPayload>
/**
 * Model inducks_herocharacter
 * 
 */
export type inducks_herocharacter = $Result.DefaultSelection<Prisma.$inducks_herocharacterPayload>
/**
 * Model inducks_inputfile
 * 
 */
export type inducks_inputfile = $Result.DefaultSelection<Prisma.$inducks_inputfilePayload>
/**
 * Model inducks_issue
 * 
 */
export type inducks_issue = $Result.DefaultSelection<Prisma.$inducks_issuePayload>
/**
 * Model inducks_issuecollecting
 * 
 */
export type inducks_issuecollecting = $Result.DefaultSelection<Prisma.$inducks_issuecollectingPayload>
/**
 * Model inducks_issuedate
 * 
 */
export type inducks_issuedate = $Result.DefaultSelection<Prisma.$inducks_issuedatePayload>
/**
 * Model inducks_issuejob
 * 
 */
export type inducks_issuejob = $Result.DefaultSelection<Prisma.$inducks_issuejobPayload>
/**
 * Model inducks_issueprice
 * 
 */
export type inducks_issueprice = $Result.DefaultSelection<Prisma.$inducks_issuepricePayload>
/**
 * Model inducks_issuequotation
 * 
 */
export type inducks_issuequotation = $Result.DefaultSelection<Prisma.$inducks_issuequotationPayload>
/**
 * Model inducks_issuerange
 * 
 */
export type inducks_issuerange = $Result.DefaultSelection<Prisma.$inducks_issuerangePayload>
/**
 * Model inducks_issueurl
 * 
 */
export type inducks_issueurl = $Result.DefaultSelection<Prisma.$inducks_issueurlPayload>
/**
 * Model inducks_language
 * 
 */
export type inducks_language = $Result.DefaultSelection<Prisma.$inducks_languagePayload>
/**
 * Model inducks_languagename
 * 
 */
export type inducks_languagename = $Result.DefaultSelection<Prisma.$inducks_languagenamePayload>
/**
 * Model inducks_log
 * 
 */
export type inducks_log = $Result.DefaultSelection<Prisma.$inducks_logPayload>
/**
 * Model inducks_logdata
 * 
 */
export type inducks_logdata = $Result.DefaultSelection<Prisma.$inducks_logdataPayload>
/**
 * Model inducks_logocharacter
 * 
 */
export type inducks_logocharacter = $Result.DefaultSelection<Prisma.$inducks_logocharacterPayload>
/**
 * Model inducks_movie
 * 
 */
export type inducks_movie = $Result.DefaultSelection<Prisma.$inducks_moviePayload>
/**
 * Model inducks_moviecharacter
 * 
 */
export type inducks_moviecharacter = $Result.DefaultSelection<Prisma.$inducks_moviecharacterPayload>
/**
 * Model inducks_moviejob
 * 
 */
export type inducks_moviejob = $Result.DefaultSelection<Prisma.$inducks_moviejobPayload>
/**
 * Model inducks_moviereference
 * 
 */
export type inducks_moviereference = $Result.DefaultSelection<Prisma.$inducks_moviereferencePayload>
/**
 * Model inducks_person
 * 
 */
export type inducks_person = $Result.DefaultSelection<Prisma.$inducks_personPayload>
/**
 * Model inducks_personurl
 * 
 */
export type inducks_personurl = $Result.DefaultSelection<Prisma.$inducks_personurlPayload>
/**
 * Model inducks_publication
 * 
 */
export type inducks_publication = $Result.DefaultSelection<Prisma.$inducks_publicationPayload>
/**
 * Model inducks_publicationcategory
 * 
 */
export type inducks_publicationcategory = $Result.DefaultSelection<Prisma.$inducks_publicationcategoryPayload>
/**
 * Model inducks_publicationname
 * 
 */
export type inducks_publicationname = $Result.DefaultSelection<Prisma.$inducks_publicationnamePayload>
/**
 * Model inducks_publicationurl
 * 
 */
export type inducks_publicationurl = $Result.DefaultSelection<Prisma.$inducks_publicationurlPayload>
/**
 * Model inducks_publisher
 * 
 */
export type inducks_publisher = $Result.DefaultSelection<Prisma.$inducks_publisherPayload>
/**
 * Model inducks_publishingjob
 * 
 */
export type inducks_publishingjob = $Result.DefaultSelection<Prisma.$inducks_publishingjobPayload>
/**
 * Model inducks_referencereason
 * 
 */
export type inducks_referencereason = $Result.DefaultSelection<Prisma.$inducks_referencereasonPayload>
/**
 * Model inducks_referencereasonname
 * 
 */
export type inducks_referencereasonname = $Result.DefaultSelection<Prisma.$inducks_referencereasonnamePayload>
/**
 * Model inducks_site
 * 
 */
export type inducks_site = $Result.DefaultSelection<Prisma.$inducks_sitePayload>
/**
 * Model inducks_statcharactercharacter
 * 
 */
export type inducks_statcharactercharacter = $Result.DefaultSelection<Prisma.$inducks_statcharactercharacterPayload>
/**
 * Model inducks_statcharactercountry
 * 
 */
export type inducks_statcharactercountry = $Result.DefaultSelection<Prisma.$inducks_statcharactercountryPayload>
/**
 * Model inducks_statcharacterstory
 * 
 */
export type inducks_statcharacterstory = $Result.DefaultSelection<Prisma.$inducks_statcharacterstoryPayload>
/**
 * Model inducks_statpersoncharacter
 * 
 */
export type inducks_statpersoncharacter = $Result.DefaultSelection<Prisma.$inducks_statpersoncharacterPayload>
/**
 * Model inducks_statpersoncountry
 * 
 */
export type inducks_statpersoncountry = $Result.DefaultSelection<Prisma.$inducks_statpersoncountryPayload>
/**
 * Model inducks_statpersonperson
 * 
 */
export type inducks_statpersonperson = $Result.DefaultSelection<Prisma.$inducks_statpersonpersonPayload>
/**
 * Model inducks_statpersonstory
 * 
 */
export type inducks_statpersonstory = $Result.DefaultSelection<Prisma.$inducks_statpersonstoryPayload>
/**
 * Model inducks_story
 * 
 */
export type inducks_story = $Result.DefaultSelection<Prisma.$inducks_storyPayload>
/**
 * Model inducks_storycodes
 * 
 */
export type inducks_storycodes = $Result.DefaultSelection<Prisma.$inducks_storycodesPayload>
/**
 * Model inducks_storydescription
 * 
 */
export type inducks_storydescription = $Result.DefaultSelection<Prisma.$inducks_storydescriptionPayload>
/**
 * Model inducks_storyheader
 * 
 */
export type inducks_storyheader = $Result.DefaultSelection<Prisma.$inducks_storyheaderPayload>
/**
 * Model inducks_storyjob
 * 
 */
export type inducks_storyjob = $Result.DefaultSelection<Prisma.$inducks_storyjobPayload>
/**
 * Model inducks_storyreference
 * 
 */
export type inducks_storyreference = $Result.DefaultSelection<Prisma.$inducks_storyreferencePayload>
/**
 * Model inducks_storysubseries
 * 
 */
export type inducks_storysubseries = $Result.DefaultSelection<Prisma.$inducks_storysubseriesPayload>
/**
 * Model inducks_storyurl
 * 
 */
export type inducks_storyurl = $Result.DefaultSelection<Prisma.$inducks_storyurlPayload>
/**
 * Model inducks_storyversion
 * 
 */
export type inducks_storyversion = $Result.DefaultSelection<Prisma.$inducks_storyversionPayload>
/**
 * Model inducks_storyversion_nofulltext
 * 
 */
export type inducks_storyversion_nofulltext = $Result.DefaultSelection<Prisma.$inducks_storyversion_nofulltextPayload>
/**
 * Model inducks_studio
 * 
 */
export type inducks_studio = $Result.DefaultSelection<Prisma.$inducks_studioPayload>
/**
 * Model inducks_studiowork
 * 
 */
export type inducks_studiowork = $Result.DefaultSelection<Prisma.$inducks_studioworkPayload>
/**
 * Model inducks_subseries
 * 
 */
export type inducks_subseries = $Result.DefaultSelection<Prisma.$inducks_subseriesPayload>
/**
 * Model inducks_subseriesname
 * 
 */
export type inducks_subseriesname = $Result.DefaultSelection<Prisma.$inducks_subseriesnamePayload>
/**
 * Model inducks_substory
 * 
 */
export type inducks_substory = $Result.DefaultSelection<Prisma.$inducks_substoryPayload>
/**
 * Model inducks_team
 * 
 */
export type inducks_team = $Result.DefaultSelection<Prisma.$inducks_teamPayload>
/**
 * Model inducks_teammember
 * 
 */
export type inducks_teammember = $Result.DefaultSelection<Prisma.$inducks_teammemberPayload>
/**
 * Model inducks_ucrelation
 * 
 */
export type inducks_ucrelation = $Result.DefaultSelection<Prisma.$inducks_ucrelationPayload>
/**
 * Model inducks_universe
 * 
 */
export type inducks_universe = $Result.DefaultSelection<Prisma.$inducks_universePayload>
/**
 * Model inducks_universename
 * 
 */
export type inducks_universename = $Result.DefaultSelection<Prisma.$inducks_universenamePayload>
/**
 * Model numeros_cpt
 * 
 */
export type numeros_cpt = $Result.DefaultSelection<Prisma.$numeros_cptPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const inducks_appearance_doubt: {
  Y: 'Y',
  N: 'N'
};

export type inducks_appearance_doubt = (typeof inducks_appearance_doubt)[keyof typeof inducks_appearance_doubt]


export const inducks_character_official: {
  Y: 'Y',
  N: 'N'
};

export type inducks_character_official = (typeof inducks_character_official)[keyof typeof inducks_character_official]


export const inducks_character_onetime: {
  Y: 'Y',
  N: 'N'
};

export type inducks_character_onetime = (typeof inducks_character_onetime)[keyof typeof inducks_character_onetime]


export const inducks_character_heroonly: {
  Y: 'Y',
  N: 'N'
};

export type inducks_character_heroonly = (typeof inducks_character_heroonly)[keyof typeof inducks_character_heroonly]


export const inducks_charactername_preferred: {
  Y: 'Y',
  N: 'N'
};

export type inducks_charactername_preferred = (typeof inducks_charactername_preferred)[keyof typeof inducks_charactername_preferred]


export const inducks_characterreference_isgroupofcharacters: {
  Y: 'Y',
  N: 'N'
};

export type inducks_characterreference_isgroupofcharacters = (typeof inducks_characterreference_isgroupofcharacters)[keyof typeof inducks_characterreference_isgroupofcharacters]


export const inducks_entry_reallytitle: {
  Y: 'Y',
  N: 'N'
};

export type inducks_entry_reallytitle = (typeof inducks_entry_reallytitle)[keyof typeof inducks_entry_reallytitle]


export const inducks_entry_mirrored: {
  Y: 'Y',
  N: 'N'
};

export type inducks_entry_mirrored = (typeof inducks_entry_mirrored)[keyof typeof inducks_entry_mirrored]


export const inducks_entry_sideways: {
  Y: 'Y',
  N: 'N'
};

export type inducks_entry_sideways = (typeof inducks_entry_sideways)[keyof typeof inducks_entry_sideways]


export const inducks_entry_identificationuncertain: {
  Y: 'Y',
  N: 'N'
};

export type inducks_entry_identificationuncertain = (typeof inducks_entry_identificationuncertain)[keyof typeof inducks_entry_identificationuncertain]


export const inducks_entry_error: {
  Y: 'Y',
  N: 'N'
};

export type inducks_entry_error = (typeof inducks_entry_error)[keyof typeof inducks_entry_error]


export const inducks_entry_nofulltext_reallytitle: {
  Y: 'Y',
  N: 'N'
};

export type inducks_entry_nofulltext_reallytitle = (typeof inducks_entry_nofulltext_reallytitle)[keyof typeof inducks_entry_nofulltext_reallytitle]


export const inducks_entry_nofulltext_mirrored: {
  Y: 'Y',
  N: 'N'
};

export type inducks_entry_nofulltext_mirrored = (typeof inducks_entry_nofulltext_mirrored)[keyof typeof inducks_entry_nofulltext_mirrored]


export const inducks_entry_nofulltext_sideways: {
  Y: 'Y',
  N: 'N'
};

export type inducks_entry_nofulltext_sideways = (typeof inducks_entry_nofulltext_sideways)[keyof typeof inducks_entry_nofulltext_sideways]


export const inducks_entry_nofulltext_identificationuncertain: {
  Y: 'Y',
  N: 'N'
};

export type inducks_entry_nofulltext_identificationuncertain = (typeof inducks_entry_nofulltext_identificationuncertain)[keyof typeof inducks_entry_nofulltext_identificationuncertain]


export const inducks_entry_nofulltext_error: {
  Y: 'Y',
  N: 'N'
};

export type inducks_entry_nofulltext_error = (typeof inducks_entry_nofulltext_error)[keyof typeof inducks_entry_nofulltext_error]


export const inducks_entryjob_doubt: {
  Y: 'Y',
  N: 'N'
};

export type inducks_entryjob_doubt = (typeof inducks_entryjob_doubt)[keyof typeof inducks_entryjob_doubt]


export const inducks_entryurl_public: {
  Y: 'Y',
  N: 'N'
};

export type inducks_entryurl_public = (typeof inducks_entryurl_public)[keyof typeof inducks_entryurl_public]


export const inducks_herocharacter_doubt: {
  Y: 'Y',
  N: 'N'
};

export type inducks_herocharacter_doubt = (typeof inducks_herocharacter_doubt)[keyof typeof inducks_herocharacter_doubt]


export const inducks_inputfile_locked: {
  Y: 'Y',
  N: 'N'
};

export type inducks_inputfile_locked = (typeof inducks_inputfile_locked)[keyof typeof inducks_inputfile_locked]


export const inducks_inputfile_secundary: {
  Y: 'Y',
  N: 'N'
};

export type inducks_inputfile_secundary = (typeof inducks_inputfile_secundary)[keyof typeof inducks_inputfile_secundary]


export const inducks_issue_fullyindexed: {
  Y: 'Y',
  N: 'N'
};

export type inducks_issue_fullyindexed = (typeof inducks_issue_fullyindexed)[keyof typeof inducks_issue_fullyindexed]


export const inducks_issue_error: {
  Y: 'Y',
  N: 'N'
};

export type inducks_issue_error = (typeof inducks_issue_error)[keyof typeof inducks_issue_error]


export const inducks_issue_locked: {
  Y: 'Y',
  N: 'N'
};

export type inducks_issue_locked = (typeof inducks_issue_locked)[keyof typeof inducks_issue_locked]


export const inducks_issue_inxforbidden: {
  Y: 'Y',
  N: 'N'
};

export type inducks_issue_inxforbidden = (typeof inducks_issue_inxforbidden)[keyof typeof inducks_issue_inxforbidden]


export const inducks_issuedate_doubt: {
  Y: 'Y',
  N: 'N'
};

export type inducks_issuedate_doubt = (typeof inducks_issuedate_doubt)[keyof typeof inducks_issuedate_doubt]


export const inducks_issuejob_doubt: {
  Y: 'Y',
  N: 'N'
};

export type inducks_issuejob_doubt = (typeof inducks_issuejob_doubt)[keyof typeof inducks_issuejob_doubt]


export const inducks_issuerange_numbersarefake: {
  Y: 'Y',
  N: 'N'
};

export type inducks_issuerange_numbersarefake = (typeof inducks_issuerange_numbersarefake)[keyof typeof inducks_issuerange_numbersarefake]


export const inducks_issuerange_error: {
  Y: 'Y',
  N: 'N'
};

export type inducks_issuerange_error = (typeof inducks_issuerange_error)[keyof typeof inducks_issuerange_error]


export const inducks_log_marked: {
  Y: 'Y',
  N: 'N'
};

export type inducks_log_marked = (typeof inducks_log_marked)[keyof typeof inducks_log_marked]


export const inducks_logocharacter_reallyintitle: {
  Y: 'Y',
  N: 'N'
};

export type inducks_logocharacter_reallyintitle = (typeof inducks_logocharacter_reallyintitle)[keyof typeof inducks_logocharacter_reallyintitle]


export const inducks_movie_locked: {
  Y: 'Y',
  N: 'N'
};

export type inducks_movie_locked = (typeof inducks_movie_locked)[keyof typeof inducks_movie_locked]


export const inducks_moviecharacter_istitlecharacter: {
  Y: 'Y',
  N: 'N'
};

export type inducks_moviecharacter_istitlecharacter = (typeof inducks_moviecharacter_istitlecharacter)[keyof typeof inducks_moviecharacter_istitlecharacter]


export const inducks_moviejob_indirect: {
  Y: 'Y',
  N: 'N'
};

export type inducks_moviejob_indirect = (typeof inducks_moviejob_indirect)[keyof typeof inducks_moviejob_indirect]


export const inducks_moviejob_doubt: {
  Y: 'Y',
  N: 'N'
};

export type inducks_moviejob_doubt = (typeof inducks_moviejob_doubt)[keyof typeof inducks_moviejob_doubt]


export const inducks_moviereference_frommovietostory: {
  Y: 'Y',
  N: 'N'
};

export type inducks_moviereference_frommovietostory = (typeof inducks_moviereference_frommovietostory)[keyof typeof inducks_moviereference_frommovietostory]


export const inducks_person_official: {
  Y: 'Y',
  N: 'N'
};

export type inducks_person_official = (typeof inducks_person_official)[keyof typeof inducks_person_official]


export const inducks_person_unknownstudiomember: {
  Y: 'Y',
  N: 'N'
};

export type inducks_person_unknownstudiomember = (typeof inducks_person_unknownstudiomember)[keyof typeof inducks_person_unknownstudiomember]


export const inducks_person_isfake: {
  Y: 'Y',
  N: 'N'
};

export type inducks_person_isfake = (typeof inducks_person_isfake)[keyof typeof inducks_person_isfake]


export const inducks_publication_numbersarefake: {
  Y: 'Y',
  N: 'N'
};

export type inducks_publication_numbersarefake = (typeof inducks_publication_numbersarefake)[keyof typeof inducks_publication_numbersarefake]


export const inducks_publication_error: {
  Y: 'Y',
  N: 'N'
};

export type inducks_publication_error = (typeof inducks_publication_error)[keyof typeof inducks_publication_error]


export const inducks_publication_locked: {
  Y: 'Y',
  N: 'N'
};

export type inducks_publication_locked = (typeof inducks_publication_locked)[keyof typeof inducks_publication_locked]


export const inducks_publication_inxforbidden: {
  Y: 'Y',
  N: 'N'
};

export type inducks_publication_inxforbidden = (typeof inducks_publication_inxforbidden)[keyof typeof inducks_publication_inxforbidden]


export const inducks_site_images: {
  Y: 'Y',
  N: 'N'
};

export type inducks_site_images = (typeof inducks_site_images)[keyof typeof inducks_site_images]


export const inducks_story_error: {
  Y: 'Y',
  N: 'N'
};

export type inducks_story_error = (typeof inducks_story_error)[keyof typeof inducks_story_error]


export const inducks_story_locked: {
  Y: 'Y',
  N: 'N'
};

export type inducks_story_locked = (typeof inducks_story_locked)[keyof typeof inducks_story_locked]


export const inducks_storyjob_indirect: {
  Y: 'Y',
  N: 'N'
};

export type inducks_storyjob_indirect = (typeof inducks_storyjob_indirect)[keyof typeof inducks_storyjob_indirect]


export const inducks_storyjob_doubt: {
  Y: 'Y',
  N: 'N'
};

export type inducks_storyjob_doubt = (typeof inducks_storyjob_doubt)[keyof typeof inducks_storyjob_doubt]


export const inducks_storyversion_brokenpageunspecified: {
  Y: 'Y',
  N: 'N'
};

export type inducks_storyversion_brokenpageunspecified = (typeof inducks_storyversion_brokenpageunspecified)[keyof typeof inducks_storyversion_brokenpageunspecified]


export const inducks_storyversion_appisxapp: {
  Y: 'Y',
  N: 'N'
};

export type inducks_storyversion_appisxapp = (typeof inducks_storyversion_appisxapp)[keyof typeof inducks_storyversion_appisxapp]


export const inducks_storyversion_nofulltext_brokenpageunspecified: {
  Y: 'Y',
  N: 'N'
};

export type inducks_storyversion_nofulltext_brokenpageunspecified = (typeof inducks_storyversion_nofulltext_brokenpageunspecified)[keyof typeof inducks_storyversion_nofulltext_brokenpageunspecified]


export const inducks_storyversion_nofulltext_appisxapp: {
  Y: 'Y',
  N: 'N'
};

export type inducks_storyversion_nofulltext_appisxapp = (typeof inducks_storyversion_nofulltext_appisxapp)[keyof typeof inducks_storyversion_nofulltext_appisxapp]


export const inducks_subseries_official: {
  Y: 'Y',
  N: 'N'
};

export type inducks_subseries_official = (typeof inducks_subseries_official)[keyof typeof inducks_subseries_official]


export const inducks_subseriesname_preferred: {
  Y: 'Y',
  N: 'N'
};

export type inducks_subseriesname_preferred = (typeof inducks_subseriesname_preferred)[keyof typeof inducks_subseriesname_preferred]


export const inducks_substory_error: {
  Y: 'Y',
  N: 'N'
};

export type inducks_substory_error = (typeof inducks_substory_error)[keyof typeof inducks_substory_error]


export const inducks_substory_locked: {
  Y: 'Y',
  N: 'N'
};

export type inducks_substory_locked = (typeof inducks_substory_locked)[keyof typeof inducks_substory_locked]

}

export type inducks_appearance_doubt = $Enums.inducks_appearance_doubt

export const inducks_appearance_doubt: typeof $Enums.inducks_appearance_doubt

export type inducks_character_official = $Enums.inducks_character_official

export const inducks_character_official: typeof $Enums.inducks_character_official

export type inducks_character_onetime = $Enums.inducks_character_onetime

export const inducks_character_onetime: typeof $Enums.inducks_character_onetime

export type inducks_character_heroonly = $Enums.inducks_character_heroonly

export const inducks_character_heroonly: typeof $Enums.inducks_character_heroonly

export type inducks_charactername_preferred = $Enums.inducks_charactername_preferred

export const inducks_charactername_preferred: typeof $Enums.inducks_charactername_preferred

export type inducks_characterreference_isgroupofcharacters = $Enums.inducks_characterreference_isgroupofcharacters

export const inducks_characterreference_isgroupofcharacters: typeof $Enums.inducks_characterreference_isgroupofcharacters

export type inducks_entry_reallytitle = $Enums.inducks_entry_reallytitle

export const inducks_entry_reallytitle: typeof $Enums.inducks_entry_reallytitle

export type inducks_entry_mirrored = $Enums.inducks_entry_mirrored

export const inducks_entry_mirrored: typeof $Enums.inducks_entry_mirrored

export type inducks_entry_sideways = $Enums.inducks_entry_sideways

export const inducks_entry_sideways: typeof $Enums.inducks_entry_sideways

export type inducks_entry_identificationuncertain = $Enums.inducks_entry_identificationuncertain

export const inducks_entry_identificationuncertain: typeof $Enums.inducks_entry_identificationuncertain

export type inducks_entry_error = $Enums.inducks_entry_error

export const inducks_entry_error: typeof $Enums.inducks_entry_error

export type inducks_entry_nofulltext_reallytitle = $Enums.inducks_entry_nofulltext_reallytitle

export const inducks_entry_nofulltext_reallytitle: typeof $Enums.inducks_entry_nofulltext_reallytitle

export type inducks_entry_nofulltext_mirrored = $Enums.inducks_entry_nofulltext_mirrored

export const inducks_entry_nofulltext_mirrored: typeof $Enums.inducks_entry_nofulltext_mirrored

export type inducks_entry_nofulltext_sideways = $Enums.inducks_entry_nofulltext_sideways

export const inducks_entry_nofulltext_sideways: typeof $Enums.inducks_entry_nofulltext_sideways

export type inducks_entry_nofulltext_identificationuncertain = $Enums.inducks_entry_nofulltext_identificationuncertain

export const inducks_entry_nofulltext_identificationuncertain: typeof $Enums.inducks_entry_nofulltext_identificationuncertain

export type inducks_entry_nofulltext_error = $Enums.inducks_entry_nofulltext_error

export const inducks_entry_nofulltext_error: typeof $Enums.inducks_entry_nofulltext_error

export type inducks_entryjob_doubt = $Enums.inducks_entryjob_doubt

export const inducks_entryjob_doubt: typeof $Enums.inducks_entryjob_doubt

export type inducks_entryurl_public = $Enums.inducks_entryurl_public

export const inducks_entryurl_public: typeof $Enums.inducks_entryurl_public

export type inducks_herocharacter_doubt = $Enums.inducks_herocharacter_doubt

export const inducks_herocharacter_doubt: typeof $Enums.inducks_herocharacter_doubt

export type inducks_inputfile_locked = $Enums.inducks_inputfile_locked

export const inducks_inputfile_locked: typeof $Enums.inducks_inputfile_locked

export type inducks_inputfile_secundary = $Enums.inducks_inputfile_secundary

export const inducks_inputfile_secundary: typeof $Enums.inducks_inputfile_secundary

export type inducks_issue_fullyindexed = $Enums.inducks_issue_fullyindexed

export const inducks_issue_fullyindexed: typeof $Enums.inducks_issue_fullyindexed

export type inducks_issue_error = $Enums.inducks_issue_error

export const inducks_issue_error: typeof $Enums.inducks_issue_error

export type inducks_issue_locked = $Enums.inducks_issue_locked

export const inducks_issue_locked: typeof $Enums.inducks_issue_locked

export type inducks_issue_inxforbidden = $Enums.inducks_issue_inxforbidden

export const inducks_issue_inxforbidden: typeof $Enums.inducks_issue_inxforbidden

export type inducks_issuedate_doubt = $Enums.inducks_issuedate_doubt

export const inducks_issuedate_doubt: typeof $Enums.inducks_issuedate_doubt

export type inducks_issuejob_doubt = $Enums.inducks_issuejob_doubt

export const inducks_issuejob_doubt: typeof $Enums.inducks_issuejob_doubt

export type inducks_issuerange_numbersarefake = $Enums.inducks_issuerange_numbersarefake

export const inducks_issuerange_numbersarefake: typeof $Enums.inducks_issuerange_numbersarefake

export type inducks_issuerange_error = $Enums.inducks_issuerange_error

export const inducks_issuerange_error: typeof $Enums.inducks_issuerange_error

export type inducks_log_marked = $Enums.inducks_log_marked

export const inducks_log_marked: typeof $Enums.inducks_log_marked

export type inducks_logocharacter_reallyintitle = $Enums.inducks_logocharacter_reallyintitle

export const inducks_logocharacter_reallyintitle: typeof $Enums.inducks_logocharacter_reallyintitle

export type inducks_movie_locked = $Enums.inducks_movie_locked

export const inducks_movie_locked: typeof $Enums.inducks_movie_locked

export type inducks_moviecharacter_istitlecharacter = $Enums.inducks_moviecharacter_istitlecharacter

export const inducks_moviecharacter_istitlecharacter: typeof $Enums.inducks_moviecharacter_istitlecharacter

export type inducks_moviejob_indirect = $Enums.inducks_moviejob_indirect

export const inducks_moviejob_indirect: typeof $Enums.inducks_moviejob_indirect

export type inducks_moviejob_doubt = $Enums.inducks_moviejob_doubt

export const inducks_moviejob_doubt: typeof $Enums.inducks_moviejob_doubt

export type inducks_moviereference_frommovietostory = $Enums.inducks_moviereference_frommovietostory

export const inducks_moviereference_frommovietostory: typeof $Enums.inducks_moviereference_frommovietostory

export type inducks_person_official = $Enums.inducks_person_official

export const inducks_person_official: typeof $Enums.inducks_person_official

export type inducks_person_unknownstudiomember = $Enums.inducks_person_unknownstudiomember

export const inducks_person_unknownstudiomember: typeof $Enums.inducks_person_unknownstudiomember

export type inducks_person_isfake = $Enums.inducks_person_isfake

export const inducks_person_isfake: typeof $Enums.inducks_person_isfake

export type inducks_publication_numbersarefake = $Enums.inducks_publication_numbersarefake

export const inducks_publication_numbersarefake: typeof $Enums.inducks_publication_numbersarefake

export type inducks_publication_error = $Enums.inducks_publication_error

export const inducks_publication_error: typeof $Enums.inducks_publication_error

export type inducks_publication_locked = $Enums.inducks_publication_locked

export const inducks_publication_locked: typeof $Enums.inducks_publication_locked

export type inducks_publication_inxforbidden = $Enums.inducks_publication_inxforbidden

export const inducks_publication_inxforbidden: typeof $Enums.inducks_publication_inxforbidden

export type inducks_site_images = $Enums.inducks_site_images

export const inducks_site_images: typeof $Enums.inducks_site_images

export type inducks_story_error = $Enums.inducks_story_error

export const inducks_story_error: typeof $Enums.inducks_story_error

export type inducks_story_locked = $Enums.inducks_story_locked

export const inducks_story_locked: typeof $Enums.inducks_story_locked

export type inducks_storyjob_indirect = $Enums.inducks_storyjob_indirect

export const inducks_storyjob_indirect: typeof $Enums.inducks_storyjob_indirect

export type inducks_storyjob_doubt = $Enums.inducks_storyjob_doubt

export const inducks_storyjob_doubt: typeof $Enums.inducks_storyjob_doubt

export type inducks_storyversion_brokenpageunspecified = $Enums.inducks_storyversion_brokenpageunspecified

export const inducks_storyversion_brokenpageunspecified: typeof $Enums.inducks_storyversion_brokenpageunspecified

export type inducks_storyversion_appisxapp = $Enums.inducks_storyversion_appisxapp

export const inducks_storyversion_appisxapp: typeof $Enums.inducks_storyversion_appisxapp

export type inducks_storyversion_nofulltext_brokenpageunspecified = $Enums.inducks_storyversion_nofulltext_brokenpageunspecified

export const inducks_storyversion_nofulltext_brokenpageunspecified: typeof $Enums.inducks_storyversion_nofulltext_brokenpageunspecified

export type inducks_storyversion_nofulltext_appisxapp = $Enums.inducks_storyversion_nofulltext_appisxapp

export const inducks_storyversion_nofulltext_appisxapp: typeof $Enums.inducks_storyversion_nofulltext_appisxapp

export type inducks_subseries_official = $Enums.inducks_subseries_official

export const inducks_subseries_official: typeof $Enums.inducks_subseries_official

export type inducks_subseriesname_preferred = $Enums.inducks_subseriesname_preferred

export const inducks_subseriesname_preferred: typeof $Enums.inducks_subseriesname_preferred

export type inducks_substory_error = $Enums.inducks_substory_error

export const inducks_substory_error: typeof $Enums.inducks_substory_error

export type inducks_substory_locked = $Enums.inducks_substory_locked

export const inducks_substory_locked: typeof $Enums.inducks_substory_locked

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Datasets_entryurls
 * const datasets_entryurls = await prisma.datasets_entryurls.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Datasets_entryurls
   * const datasets_entryurls = await prisma.datasets_entryurls.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.datasets_entryurls`: Exposes CRUD operations for the **datasets_entryurls** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Datasets_entryurls
    * const datasets_entryurls = await prisma.datasets_entryurls.findMany()
    * ```
    */
  get datasets_entryurls(): Prisma.datasets_entryurlsDelegate<ExtArgs>;

  /**
   * `prisma.inducks_appearance`: Exposes CRUD operations for the **inducks_appearance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_appearances
    * const inducks_appearances = await prisma.inducks_appearance.findMany()
    * ```
    */
  get inducks_appearance(): Prisma.inducks_appearanceDelegate<ExtArgs>;

  /**
   * `prisma.inducks_character`: Exposes CRUD operations for the **inducks_character** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_characters
    * const inducks_characters = await prisma.inducks_character.findMany()
    * ```
    */
  get inducks_character(): Prisma.inducks_characterDelegate<ExtArgs>;

  /**
   * `prisma.inducks_characteralias`: Exposes CRUD operations for the **inducks_characteralias** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_characteraliases
    * const inducks_characteraliases = await prisma.inducks_characteralias.findMany()
    * ```
    */
  get inducks_characteralias(): Prisma.inducks_characteraliasDelegate<ExtArgs>;

  /**
   * `prisma.inducks_characterdetail`: Exposes CRUD operations for the **inducks_characterdetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_characterdetails
    * const inducks_characterdetails = await prisma.inducks_characterdetail.findMany()
    * ```
    */
  get inducks_characterdetail(): Prisma.inducks_characterdetailDelegate<ExtArgs>;

  /**
   * `prisma.inducks_charactername`: Exposes CRUD operations for the **inducks_charactername** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_characternames
    * const inducks_characternames = await prisma.inducks_charactername.findMany()
    * ```
    */
  get inducks_charactername(): Prisma.inducks_characternameDelegate<ExtArgs>;

  /**
   * `prisma.inducks_characterreference`: Exposes CRUD operations for the **inducks_characterreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_characterreferences
    * const inducks_characterreferences = await prisma.inducks_characterreference.findMany()
    * ```
    */
  get inducks_characterreference(): Prisma.inducks_characterreferenceDelegate<ExtArgs>;

  /**
   * `prisma.inducks_characterurl`: Exposes CRUD operations for the **inducks_characterurl** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_characterurls
    * const inducks_characterurls = await prisma.inducks_characterurl.findMany()
    * ```
    */
  get inducks_characterurl(): Prisma.inducks_characterurlDelegate<ExtArgs>;

  /**
   * `prisma.inducks_country`: Exposes CRUD operations for the **inducks_country** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_countries
    * const inducks_countries = await prisma.inducks_country.findMany()
    * ```
    */
  get inducks_country(): Prisma.inducks_countryDelegate<ExtArgs>;

  /**
   * `prisma.inducks_countryname`: Exposes CRUD operations for the **inducks_countryname** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_countrynames
    * const inducks_countrynames = await prisma.inducks_countryname.findMany()
    * ```
    */
  get inducks_countryname(): Prisma.inducks_countrynameDelegate<ExtArgs>;

  /**
   * `prisma.inducks_currency`: Exposes CRUD operations for the **inducks_currency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_currencies
    * const inducks_currencies = await prisma.inducks_currency.findMany()
    * ```
    */
  get inducks_currency(): Prisma.inducks_currencyDelegate<ExtArgs>;

  /**
   * `prisma.inducks_currencyname`: Exposes CRUD operations for the **inducks_currencyname** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_currencynames
    * const inducks_currencynames = await prisma.inducks_currencyname.findMany()
    * ```
    */
  get inducks_currencyname(): Prisma.inducks_currencynameDelegate<ExtArgs>;

  /**
   * `prisma.inducks_entry`: Exposes CRUD operations for the **inducks_entry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_entries
    * const inducks_entries = await prisma.inducks_entry.findMany()
    * ```
    */
  get inducks_entry(): Prisma.inducks_entryDelegate<ExtArgs>;

  /**
   * `prisma.inducks_entry_nofulltext`: Exposes CRUD operations for the **inducks_entry_nofulltext** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_entry_nofulltexts
    * const inducks_entry_nofulltexts = await prisma.inducks_entry_nofulltext.findMany()
    * ```
    */
  get inducks_entry_nofulltext(): Prisma.inducks_entry_nofulltextDelegate<ExtArgs>;

  /**
   * `prisma.inducks_entrycharactername`: Exposes CRUD operations for the **inducks_entrycharactername** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_entrycharacternames
    * const inducks_entrycharacternames = await prisma.inducks_entrycharactername.findMany()
    * ```
    */
  get inducks_entrycharactername(): Prisma.inducks_entrycharacternameDelegate<ExtArgs>;

  /**
   * `prisma.inducks_entryjob`: Exposes CRUD operations for the **inducks_entryjob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_entryjobs
    * const inducks_entryjobs = await prisma.inducks_entryjob.findMany()
    * ```
    */
  get inducks_entryjob(): Prisma.inducks_entryjobDelegate<ExtArgs>;

  /**
   * `prisma.inducks_entryurl`: Exposes CRUD operations for the **inducks_entryurl** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_entryurls
    * const inducks_entryurls = await prisma.inducks_entryurl.findMany()
    * ```
    */
  get inducks_entryurl(): Prisma.inducks_entryurlDelegate<ExtArgs>;

  /**
   * `prisma.inducks_equiv`: Exposes CRUD operations for the **inducks_equiv** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_equivs
    * const inducks_equivs = await prisma.inducks_equiv.findMany()
    * ```
    */
  get inducks_equiv(): Prisma.inducks_equivDelegate<ExtArgs>;

  /**
   * `prisma.inducks_herocharacter`: Exposes CRUD operations for the **inducks_herocharacter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_herocharacters
    * const inducks_herocharacters = await prisma.inducks_herocharacter.findMany()
    * ```
    */
  get inducks_herocharacter(): Prisma.inducks_herocharacterDelegate<ExtArgs>;

  /**
   * `prisma.inducks_inputfile`: Exposes CRUD operations for the **inducks_inputfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_inputfiles
    * const inducks_inputfiles = await prisma.inducks_inputfile.findMany()
    * ```
    */
  get inducks_inputfile(): Prisma.inducks_inputfileDelegate<ExtArgs>;

  /**
   * `prisma.inducks_issue`: Exposes CRUD operations for the **inducks_issue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_issues
    * const inducks_issues = await prisma.inducks_issue.findMany()
    * ```
    */
  get inducks_issue(): Prisma.inducks_issueDelegate<ExtArgs>;

  /**
   * `prisma.inducks_issuecollecting`: Exposes CRUD operations for the **inducks_issuecollecting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_issuecollectings
    * const inducks_issuecollectings = await prisma.inducks_issuecollecting.findMany()
    * ```
    */
  get inducks_issuecollecting(): Prisma.inducks_issuecollectingDelegate<ExtArgs>;

  /**
   * `prisma.inducks_issuedate`: Exposes CRUD operations for the **inducks_issuedate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_issuedates
    * const inducks_issuedates = await prisma.inducks_issuedate.findMany()
    * ```
    */
  get inducks_issuedate(): Prisma.inducks_issuedateDelegate<ExtArgs>;

  /**
   * `prisma.inducks_issuejob`: Exposes CRUD operations for the **inducks_issuejob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_issuejobs
    * const inducks_issuejobs = await prisma.inducks_issuejob.findMany()
    * ```
    */
  get inducks_issuejob(): Prisma.inducks_issuejobDelegate<ExtArgs>;

  /**
   * `prisma.inducks_issueprice`: Exposes CRUD operations for the **inducks_issueprice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_issueprices
    * const inducks_issueprices = await prisma.inducks_issueprice.findMany()
    * ```
    */
  get inducks_issueprice(): Prisma.inducks_issuepriceDelegate<ExtArgs>;

  /**
   * `prisma.inducks_issuequotation`: Exposes CRUD operations for the **inducks_issuequotation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_issuequotations
    * const inducks_issuequotations = await prisma.inducks_issuequotation.findMany()
    * ```
    */
  get inducks_issuequotation(): Prisma.inducks_issuequotationDelegate<ExtArgs>;

  /**
   * `prisma.inducks_issuerange`: Exposes CRUD operations for the **inducks_issuerange** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_issueranges
    * const inducks_issueranges = await prisma.inducks_issuerange.findMany()
    * ```
    */
  get inducks_issuerange(): Prisma.inducks_issuerangeDelegate<ExtArgs>;

  /**
   * `prisma.inducks_issueurl`: Exposes CRUD operations for the **inducks_issueurl** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_issueurls
    * const inducks_issueurls = await prisma.inducks_issueurl.findMany()
    * ```
    */
  get inducks_issueurl(): Prisma.inducks_issueurlDelegate<ExtArgs>;

  /**
   * `prisma.inducks_language`: Exposes CRUD operations for the **inducks_language** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_languages
    * const inducks_languages = await prisma.inducks_language.findMany()
    * ```
    */
  get inducks_language(): Prisma.inducks_languageDelegate<ExtArgs>;

  /**
   * `prisma.inducks_languagename`: Exposes CRUD operations for the **inducks_languagename** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_languagenames
    * const inducks_languagenames = await prisma.inducks_languagename.findMany()
    * ```
    */
  get inducks_languagename(): Prisma.inducks_languagenameDelegate<ExtArgs>;

  /**
   * `prisma.inducks_log`: Exposes CRUD operations for the **inducks_log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_logs
    * const inducks_logs = await prisma.inducks_log.findMany()
    * ```
    */
  get inducks_log(): Prisma.inducks_logDelegate<ExtArgs>;

  /**
   * `prisma.inducks_logdata`: Exposes CRUD operations for the **inducks_logdata** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_logdata
    * const inducks_logdata = await prisma.inducks_logdata.findMany()
    * ```
    */
  get inducks_logdata(): Prisma.inducks_logdataDelegate<ExtArgs>;

  /**
   * `prisma.inducks_logocharacter`: Exposes CRUD operations for the **inducks_logocharacter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_logocharacters
    * const inducks_logocharacters = await prisma.inducks_logocharacter.findMany()
    * ```
    */
  get inducks_logocharacter(): Prisma.inducks_logocharacterDelegate<ExtArgs>;

  /**
   * `prisma.inducks_movie`: Exposes CRUD operations for the **inducks_movie** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_movies
    * const inducks_movies = await prisma.inducks_movie.findMany()
    * ```
    */
  get inducks_movie(): Prisma.inducks_movieDelegate<ExtArgs>;

  /**
   * `prisma.inducks_moviecharacter`: Exposes CRUD operations for the **inducks_moviecharacter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_moviecharacters
    * const inducks_moviecharacters = await prisma.inducks_moviecharacter.findMany()
    * ```
    */
  get inducks_moviecharacter(): Prisma.inducks_moviecharacterDelegate<ExtArgs>;

  /**
   * `prisma.inducks_moviejob`: Exposes CRUD operations for the **inducks_moviejob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_moviejobs
    * const inducks_moviejobs = await prisma.inducks_moviejob.findMany()
    * ```
    */
  get inducks_moviejob(): Prisma.inducks_moviejobDelegate<ExtArgs>;

  /**
   * `prisma.inducks_moviereference`: Exposes CRUD operations for the **inducks_moviereference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_moviereferences
    * const inducks_moviereferences = await prisma.inducks_moviereference.findMany()
    * ```
    */
  get inducks_moviereference(): Prisma.inducks_moviereferenceDelegate<ExtArgs>;

  /**
   * `prisma.inducks_person`: Exposes CRUD operations for the **inducks_person** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_people
    * const inducks_people = await prisma.inducks_person.findMany()
    * ```
    */
  get inducks_person(): Prisma.inducks_personDelegate<ExtArgs>;

  /**
   * `prisma.inducks_personurl`: Exposes CRUD operations for the **inducks_personurl** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_personurls
    * const inducks_personurls = await prisma.inducks_personurl.findMany()
    * ```
    */
  get inducks_personurl(): Prisma.inducks_personurlDelegate<ExtArgs>;

  /**
   * `prisma.inducks_publication`: Exposes CRUD operations for the **inducks_publication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_publications
    * const inducks_publications = await prisma.inducks_publication.findMany()
    * ```
    */
  get inducks_publication(): Prisma.inducks_publicationDelegate<ExtArgs>;

  /**
   * `prisma.inducks_publicationcategory`: Exposes CRUD operations for the **inducks_publicationcategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_publicationcategories
    * const inducks_publicationcategories = await prisma.inducks_publicationcategory.findMany()
    * ```
    */
  get inducks_publicationcategory(): Prisma.inducks_publicationcategoryDelegate<ExtArgs>;

  /**
   * `prisma.inducks_publicationname`: Exposes CRUD operations for the **inducks_publicationname** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_publicationnames
    * const inducks_publicationnames = await prisma.inducks_publicationname.findMany()
    * ```
    */
  get inducks_publicationname(): Prisma.inducks_publicationnameDelegate<ExtArgs>;

  /**
   * `prisma.inducks_publicationurl`: Exposes CRUD operations for the **inducks_publicationurl** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_publicationurls
    * const inducks_publicationurls = await prisma.inducks_publicationurl.findMany()
    * ```
    */
  get inducks_publicationurl(): Prisma.inducks_publicationurlDelegate<ExtArgs>;

  /**
   * `prisma.inducks_publisher`: Exposes CRUD operations for the **inducks_publisher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_publishers
    * const inducks_publishers = await prisma.inducks_publisher.findMany()
    * ```
    */
  get inducks_publisher(): Prisma.inducks_publisherDelegate<ExtArgs>;

  /**
   * `prisma.inducks_publishingjob`: Exposes CRUD operations for the **inducks_publishingjob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_publishingjobs
    * const inducks_publishingjobs = await prisma.inducks_publishingjob.findMany()
    * ```
    */
  get inducks_publishingjob(): Prisma.inducks_publishingjobDelegate<ExtArgs>;

  /**
   * `prisma.inducks_referencereason`: Exposes CRUD operations for the **inducks_referencereason** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_referencereasons
    * const inducks_referencereasons = await prisma.inducks_referencereason.findMany()
    * ```
    */
  get inducks_referencereason(): Prisma.inducks_referencereasonDelegate<ExtArgs>;

  /**
   * `prisma.inducks_referencereasonname`: Exposes CRUD operations for the **inducks_referencereasonname** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_referencereasonnames
    * const inducks_referencereasonnames = await prisma.inducks_referencereasonname.findMany()
    * ```
    */
  get inducks_referencereasonname(): Prisma.inducks_referencereasonnameDelegate<ExtArgs>;

  /**
   * `prisma.inducks_site`: Exposes CRUD operations for the **inducks_site** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_sites
    * const inducks_sites = await prisma.inducks_site.findMany()
    * ```
    */
  get inducks_site(): Prisma.inducks_siteDelegate<ExtArgs>;

  /**
   * `prisma.inducks_statcharactercharacter`: Exposes CRUD operations for the **inducks_statcharactercharacter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_statcharactercharacters
    * const inducks_statcharactercharacters = await prisma.inducks_statcharactercharacter.findMany()
    * ```
    */
  get inducks_statcharactercharacter(): Prisma.inducks_statcharactercharacterDelegate<ExtArgs>;

  /**
   * `prisma.inducks_statcharactercountry`: Exposes CRUD operations for the **inducks_statcharactercountry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_statcharactercountries
    * const inducks_statcharactercountries = await prisma.inducks_statcharactercountry.findMany()
    * ```
    */
  get inducks_statcharactercountry(): Prisma.inducks_statcharactercountryDelegate<ExtArgs>;

  /**
   * `prisma.inducks_statcharacterstory`: Exposes CRUD operations for the **inducks_statcharacterstory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_statcharacterstories
    * const inducks_statcharacterstories = await prisma.inducks_statcharacterstory.findMany()
    * ```
    */
  get inducks_statcharacterstory(): Prisma.inducks_statcharacterstoryDelegate<ExtArgs>;

  /**
   * `prisma.inducks_statpersoncharacter`: Exposes CRUD operations for the **inducks_statpersoncharacter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_statpersoncharacters
    * const inducks_statpersoncharacters = await prisma.inducks_statpersoncharacter.findMany()
    * ```
    */
  get inducks_statpersoncharacter(): Prisma.inducks_statpersoncharacterDelegate<ExtArgs>;

  /**
   * `prisma.inducks_statpersoncountry`: Exposes CRUD operations for the **inducks_statpersoncountry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_statpersoncountries
    * const inducks_statpersoncountries = await prisma.inducks_statpersoncountry.findMany()
    * ```
    */
  get inducks_statpersoncountry(): Prisma.inducks_statpersoncountryDelegate<ExtArgs>;

  /**
   * `prisma.inducks_statpersonperson`: Exposes CRUD operations for the **inducks_statpersonperson** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_statpersonpeople
    * const inducks_statpersonpeople = await prisma.inducks_statpersonperson.findMany()
    * ```
    */
  get inducks_statpersonperson(): Prisma.inducks_statpersonpersonDelegate<ExtArgs>;

  /**
   * `prisma.inducks_statpersonstory`: Exposes CRUD operations for the **inducks_statpersonstory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_statpersonstories
    * const inducks_statpersonstories = await prisma.inducks_statpersonstory.findMany()
    * ```
    */
  get inducks_statpersonstory(): Prisma.inducks_statpersonstoryDelegate<ExtArgs>;

  /**
   * `prisma.inducks_story`: Exposes CRUD operations for the **inducks_story** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_stories
    * const inducks_stories = await prisma.inducks_story.findMany()
    * ```
    */
  get inducks_story(): Prisma.inducks_storyDelegate<ExtArgs>;

  /**
   * `prisma.inducks_storycodes`: Exposes CRUD operations for the **inducks_storycodes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_storycodes
    * const inducks_storycodes = await prisma.inducks_storycodes.findMany()
    * ```
    */
  get inducks_storycodes(): Prisma.inducks_storycodesDelegate<ExtArgs>;

  /**
   * `prisma.inducks_storydescription`: Exposes CRUD operations for the **inducks_storydescription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_storydescriptions
    * const inducks_storydescriptions = await prisma.inducks_storydescription.findMany()
    * ```
    */
  get inducks_storydescription(): Prisma.inducks_storydescriptionDelegate<ExtArgs>;

  /**
   * `prisma.inducks_storyheader`: Exposes CRUD operations for the **inducks_storyheader** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_storyheaders
    * const inducks_storyheaders = await prisma.inducks_storyheader.findMany()
    * ```
    */
  get inducks_storyheader(): Prisma.inducks_storyheaderDelegate<ExtArgs>;

  /**
   * `prisma.inducks_storyjob`: Exposes CRUD operations for the **inducks_storyjob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_storyjobs
    * const inducks_storyjobs = await prisma.inducks_storyjob.findMany()
    * ```
    */
  get inducks_storyjob(): Prisma.inducks_storyjobDelegate<ExtArgs>;

  /**
   * `prisma.inducks_storyreference`: Exposes CRUD operations for the **inducks_storyreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_storyreferences
    * const inducks_storyreferences = await prisma.inducks_storyreference.findMany()
    * ```
    */
  get inducks_storyreference(): Prisma.inducks_storyreferenceDelegate<ExtArgs>;

  /**
   * `prisma.inducks_storysubseries`: Exposes CRUD operations for the **inducks_storysubseries** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_storysubseries
    * const inducks_storysubseries = await prisma.inducks_storysubseries.findMany()
    * ```
    */
  get inducks_storysubseries(): Prisma.inducks_storysubseriesDelegate<ExtArgs>;

  /**
   * `prisma.inducks_storyurl`: Exposes CRUD operations for the **inducks_storyurl** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_storyurls
    * const inducks_storyurls = await prisma.inducks_storyurl.findMany()
    * ```
    */
  get inducks_storyurl(): Prisma.inducks_storyurlDelegate<ExtArgs>;

  /**
   * `prisma.inducks_storyversion`: Exposes CRUD operations for the **inducks_storyversion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_storyversions
    * const inducks_storyversions = await prisma.inducks_storyversion.findMany()
    * ```
    */
  get inducks_storyversion(): Prisma.inducks_storyversionDelegate<ExtArgs>;

  /**
   * `prisma.inducks_storyversion_nofulltext`: Exposes CRUD operations for the **inducks_storyversion_nofulltext** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_storyversion_nofulltexts
    * const inducks_storyversion_nofulltexts = await prisma.inducks_storyversion_nofulltext.findMany()
    * ```
    */
  get inducks_storyversion_nofulltext(): Prisma.inducks_storyversion_nofulltextDelegate<ExtArgs>;

  /**
   * `prisma.inducks_studio`: Exposes CRUD operations for the **inducks_studio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_studios
    * const inducks_studios = await prisma.inducks_studio.findMany()
    * ```
    */
  get inducks_studio(): Prisma.inducks_studioDelegate<ExtArgs>;

  /**
   * `prisma.inducks_studiowork`: Exposes CRUD operations for the **inducks_studiowork** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_studioworks
    * const inducks_studioworks = await prisma.inducks_studiowork.findMany()
    * ```
    */
  get inducks_studiowork(): Prisma.inducks_studioworkDelegate<ExtArgs>;

  /**
   * `prisma.inducks_subseries`: Exposes CRUD operations for the **inducks_subseries** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_subseries
    * const inducks_subseries = await prisma.inducks_subseries.findMany()
    * ```
    */
  get inducks_subseries(): Prisma.inducks_subseriesDelegate<ExtArgs>;

  /**
   * `prisma.inducks_subseriesname`: Exposes CRUD operations for the **inducks_subseriesname** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_subseriesnames
    * const inducks_subseriesnames = await prisma.inducks_subseriesname.findMany()
    * ```
    */
  get inducks_subseriesname(): Prisma.inducks_subseriesnameDelegate<ExtArgs>;

  /**
   * `prisma.inducks_substory`: Exposes CRUD operations for the **inducks_substory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_substories
    * const inducks_substories = await prisma.inducks_substory.findMany()
    * ```
    */
  get inducks_substory(): Prisma.inducks_substoryDelegate<ExtArgs>;

  /**
   * `prisma.inducks_team`: Exposes CRUD operations for the **inducks_team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_teams
    * const inducks_teams = await prisma.inducks_team.findMany()
    * ```
    */
  get inducks_team(): Prisma.inducks_teamDelegate<ExtArgs>;

  /**
   * `prisma.inducks_teammember`: Exposes CRUD operations for the **inducks_teammember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_teammembers
    * const inducks_teammembers = await prisma.inducks_teammember.findMany()
    * ```
    */
  get inducks_teammember(): Prisma.inducks_teammemberDelegate<ExtArgs>;

  /**
   * `prisma.inducks_ucrelation`: Exposes CRUD operations for the **inducks_ucrelation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_ucrelations
    * const inducks_ucrelations = await prisma.inducks_ucrelation.findMany()
    * ```
    */
  get inducks_ucrelation(): Prisma.inducks_ucrelationDelegate<ExtArgs>;

  /**
   * `prisma.inducks_universe`: Exposes CRUD operations for the **inducks_universe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_universes
    * const inducks_universes = await prisma.inducks_universe.findMany()
    * ```
    */
  get inducks_universe(): Prisma.inducks_universeDelegate<ExtArgs>;

  /**
   * `prisma.inducks_universename`: Exposes CRUD operations for the **inducks_universename** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inducks_universenames
    * const inducks_universenames = await prisma.inducks_universename.findMany()
    * ```
    */
  get inducks_universename(): Prisma.inducks_universenameDelegate<ExtArgs>;

  /**
   * `prisma.numeros_cpt`: Exposes CRUD operations for the **numeros_cpt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Numeros_cpts
    * const numeros_cpts = await prisma.numeros_cpt.findMany()
    * ```
    */
  get numeros_cpt(): Prisma.numeros_cptDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.2.0
   * Query Engine version: 2804dc98259d2ea960602aca6b8e7fdc03c1758f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    datasets_entryurls: 'datasets_entryurls',
    inducks_appearance: 'inducks_appearance',
    inducks_character: 'inducks_character',
    inducks_characteralias: 'inducks_characteralias',
    inducks_characterdetail: 'inducks_characterdetail',
    inducks_charactername: 'inducks_charactername',
    inducks_characterreference: 'inducks_characterreference',
    inducks_characterurl: 'inducks_characterurl',
    inducks_country: 'inducks_country',
    inducks_countryname: 'inducks_countryname',
    inducks_currency: 'inducks_currency',
    inducks_currencyname: 'inducks_currencyname',
    inducks_entry: 'inducks_entry',
    inducks_entry_nofulltext: 'inducks_entry_nofulltext',
    inducks_entrycharactername: 'inducks_entrycharactername',
    inducks_entryjob: 'inducks_entryjob',
    inducks_entryurl: 'inducks_entryurl',
    inducks_equiv: 'inducks_equiv',
    inducks_herocharacter: 'inducks_herocharacter',
    inducks_inputfile: 'inducks_inputfile',
    inducks_issue: 'inducks_issue',
    inducks_issuecollecting: 'inducks_issuecollecting',
    inducks_issuedate: 'inducks_issuedate',
    inducks_issuejob: 'inducks_issuejob',
    inducks_issueprice: 'inducks_issueprice',
    inducks_issuequotation: 'inducks_issuequotation',
    inducks_issuerange: 'inducks_issuerange',
    inducks_issueurl: 'inducks_issueurl',
    inducks_language: 'inducks_language',
    inducks_languagename: 'inducks_languagename',
    inducks_log: 'inducks_log',
    inducks_logdata: 'inducks_logdata',
    inducks_logocharacter: 'inducks_logocharacter',
    inducks_movie: 'inducks_movie',
    inducks_moviecharacter: 'inducks_moviecharacter',
    inducks_moviejob: 'inducks_moviejob',
    inducks_moviereference: 'inducks_moviereference',
    inducks_person: 'inducks_person',
    inducks_personurl: 'inducks_personurl',
    inducks_publication: 'inducks_publication',
    inducks_publicationcategory: 'inducks_publicationcategory',
    inducks_publicationname: 'inducks_publicationname',
    inducks_publicationurl: 'inducks_publicationurl',
    inducks_publisher: 'inducks_publisher',
    inducks_publishingjob: 'inducks_publishingjob',
    inducks_referencereason: 'inducks_referencereason',
    inducks_referencereasonname: 'inducks_referencereasonname',
    inducks_site: 'inducks_site',
    inducks_statcharactercharacter: 'inducks_statcharactercharacter',
    inducks_statcharactercountry: 'inducks_statcharactercountry',
    inducks_statcharacterstory: 'inducks_statcharacterstory',
    inducks_statpersoncharacter: 'inducks_statpersoncharacter',
    inducks_statpersoncountry: 'inducks_statpersoncountry',
    inducks_statpersonperson: 'inducks_statpersonperson',
    inducks_statpersonstory: 'inducks_statpersonstory',
    inducks_story: 'inducks_story',
    inducks_storycodes: 'inducks_storycodes',
    inducks_storydescription: 'inducks_storydescription',
    inducks_storyheader: 'inducks_storyheader',
    inducks_storyjob: 'inducks_storyjob',
    inducks_storyreference: 'inducks_storyreference',
    inducks_storysubseries: 'inducks_storysubseries',
    inducks_storyurl: 'inducks_storyurl',
    inducks_storyversion: 'inducks_storyversion',
    inducks_storyversion_nofulltext: 'inducks_storyversion_nofulltext',
    inducks_studio: 'inducks_studio',
    inducks_studiowork: 'inducks_studiowork',
    inducks_subseries: 'inducks_subseries',
    inducks_subseriesname: 'inducks_subseriesname',
    inducks_substory: 'inducks_substory',
    inducks_team: 'inducks_team',
    inducks_teammember: 'inducks_teammember',
    inducks_ucrelation: 'inducks_ucrelation',
    inducks_universe: 'inducks_universe',
    inducks_universename: 'inducks_universename',
    numeros_cpt: 'numeros_cpt'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'datasets_entryurls' | 'inducks_appearance' | 'inducks_character' | 'inducks_characteralias' | 'inducks_characterdetail' | 'inducks_charactername' | 'inducks_characterreference' | 'inducks_characterurl' | 'inducks_country' | 'inducks_countryname' | 'inducks_currency' | 'inducks_currencyname' | 'inducks_entry' | 'inducks_entry_nofulltext' | 'inducks_entrycharactername' | 'inducks_entryjob' | 'inducks_entryurl' | 'inducks_equiv' | 'inducks_herocharacter' | 'inducks_inputfile' | 'inducks_issue' | 'inducks_issuecollecting' | 'inducks_issuedate' | 'inducks_issuejob' | 'inducks_issueprice' | 'inducks_issuequotation' | 'inducks_issuerange' | 'inducks_issueurl' | 'inducks_language' | 'inducks_languagename' | 'inducks_log' | 'inducks_logdata' | 'inducks_logocharacter' | 'inducks_movie' | 'inducks_moviecharacter' | 'inducks_moviejob' | 'inducks_moviereference' | 'inducks_person' | 'inducks_personurl' | 'inducks_publication' | 'inducks_publicationcategory' | 'inducks_publicationname' | 'inducks_publicationurl' | 'inducks_publisher' | 'inducks_publishingjob' | 'inducks_referencereason' | 'inducks_referencereasonname' | 'inducks_site' | 'inducks_statcharactercharacter' | 'inducks_statcharactercountry' | 'inducks_statcharacterstory' | 'inducks_statpersoncharacter' | 'inducks_statpersoncountry' | 'inducks_statpersonperson' | 'inducks_statpersonstory' | 'inducks_story' | 'inducks_storycodes' | 'inducks_storydescription' | 'inducks_storyheader' | 'inducks_storyjob' | 'inducks_storyreference' | 'inducks_storysubseries' | 'inducks_storyurl' | 'inducks_storyversion' | 'inducks_storyversion_nofulltext' | 'inducks_studio' | 'inducks_studiowork' | 'inducks_subseries' | 'inducks_subseriesname' | 'inducks_substory' | 'inducks_team' | 'inducks_teammember' | 'inducks_ucrelation' | 'inducks_universe' | 'inducks_universename' | 'numeros_cpt'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      datasets_entryurls: {
        payload: Prisma.$datasets_entryurlsPayload<ExtArgs>
        fields: Prisma.datasets_entryurlsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.datasets_entryurlsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$datasets_entryurlsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.datasets_entryurlsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$datasets_entryurlsPayload>
          }
          findFirst: {
            args: Prisma.datasets_entryurlsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$datasets_entryurlsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.datasets_entryurlsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$datasets_entryurlsPayload>
          }
          findMany: {
            args: Prisma.datasets_entryurlsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$datasets_entryurlsPayload>[]
          }
          create: {
            args: Prisma.datasets_entryurlsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$datasets_entryurlsPayload>
          }
          createMany: {
            args: Prisma.datasets_entryurlsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.datasets_entryurlsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$datasets_entryurlsPayload>
          }
          update: {
            args: Prisma.datasets_entryurlsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$datasets_entryurlsPayload>
          }
          deleteMany: {
            args: Prisma.datasets_entryurlsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.datasets_entryurlsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.datasets_entryurlsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$datasets_entryurlsPayload>
          }
          aggregate: {
            args: Prisma.Datasets_entryurlsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDatasets_entryurls>
          }
          groupBy: {
            args: Prisma.datasets_entryurlsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Datasets_entryurlsGroupByOutputType>[]
          }
          count: {
            args: Prisma.datasets_entryurlsCountArgs<ExtArgs>,
            result: $Utils.Optional<Datasets_entryurlsCountAggregateOutputType> | number
          }
        }
      }
      inducks_appearance: {
        payload: Prisma.$inducks_appearancePayload<ExtArgs>
        fields: Prisma.inducks_appearanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_appearanceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_appearancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_appearanceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_appearancePayload>
          }
          findFirst: {
            args: Prisma.inducks_appearanceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_appearancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_appearanceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_appearancePayload>
          }
          findMany: {
            args: Prisma.inducks_appearanceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_appearancePayload>[]
          }
          create: {
            args: Prisma.inducks_appearanceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_appearancePayload>
          }
          createMany: {
            args: Prisma.inducks_appearanceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_appearanceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_appearancePayload>
          }
          update: {
            args: Prisma.inducks_appearanceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_appearancePayload>
          }
          deleteMany: {
            args: Prisma.inducks_appearanceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_appearanceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_appearanceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_appearancePayload>
          }
          aggregate: {
            args: Prisma.Inducks_appearanceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_appearance>
          }
          groupBy: {
            args: Prisma.inducks_appearanceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_appearanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_appearanceCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_appearanceCountAggregateOutputType> | number
          }
        }
      }
      inducks_character: {
        payload: Prisma.$inducks_characterPayload<ExtArgs>
        fields: Prisma.inducks_characterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_characterFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_characterFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characterPayload>
          }
          findFirst: {
            args: Prisma.inducks_characterFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_characterFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characterPayload>
          }
          findMany: {
            args: Prisma.inducks_characterFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characterPayload>[]
          }
          create: {
            args: Prisma.inducks_characterCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characterPayload>
          }
          createMany: {
            args: Prisma.inducks_characterCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_characterDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characterPayload>
          }
          update: {
            args: Prisma.inducks_characterUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characterPayload>
          }
          deleteMany: {
            args: Prisma.inducks_characterDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_characterUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_characterUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characterPayload>
          }
          aggregate: {
            args: Prisma.Inducks_characterAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_character>
          }
          groupBy: {
            args: Prisma.inducks_characterGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_characterGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_characterCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_characterCountAggregateOutputType> | number
          }
        }
      }
      inducks_characteralias: {
        payload: Prisma.$inducks_characteraliasPayload<ExtArgs>
        fields: Prisma.inducks_characteraliasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_characteraliasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characteraliasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_characteraliasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characteraliasPayload>
          }
          findFirst: {
            args: Prisma.inducks_characteraliasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characteraliasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_characteraliasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characteraliasPayload>
          }
          findMany: {
            args: Prisma.inducks_characteraliasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characteraliasPayload>[]
          }
          create: {
            args: Prisma.inducks_characteraliasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characteraliasPayload>
          }
          createMany: {
            args: Prisma.inducks_characteraliasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_characteraliasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characteraliasPayload>
          }
          update: {
            args: Prisma.inducks_characteraliasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characteraliasPayload>
          }
          deleteMany: {
            args: Prisma.inducks_characteraliasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_characteraliasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_characteraliasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characteraliasPayload>
          }
          aggregate: {
            args: Prisma.Inducks_characteraliasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_characteralias>
          }
          groupBy: {
            args: Prisma.inducks_characteraliasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_characteraliasGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_characteraliasCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_characteraliasCountAggregateOutputType> | number
          }
        }
      }
      inducks_characterdetail: {
        payload: Prisma.$inducks_characterdetailPayload<ExtArgs>
        fields: Prisma.inducks_characterdetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_characterdetailFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characterdetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_characterdetailFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characterdetailPayload>
          }
          findFirst: {
            args: Prisma.inducks_characterdetailFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characterdetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_characterdetailFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characterdetailPayload>
          }
          findMany: {
            args: Prisma.inducks_characterdetailFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characterdetailPayload>[]
          }
          create: {
            args: Prisma.inducks_characterdetailCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characterdetailPayload>
          }
          createMany: {
            args: Prisma.inducks_characterdetailCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_characterdetailDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characterdetailPayload>
          }
          update: {
            args: Prisma.inducks_characterdetailUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characterdetailPayload>
          }
          deleteMany: {
            args: Prisma.inducks_characterdetailDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_characterdetailUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_characterdetailUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characterdetailPayload>
          }
          aggregate: {
            args: Prisma.Inducks_characterdetailAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_characterdetail>
          }
          groupBy: {
            args: Prisma.inducks_characterdetailGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_characterdetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_characterdetailCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_characterdetailCountAggregateOutputType> | number
          }
        }
      }
      inducks_charactername: {
        payload: Prisma.$inducks_characternamePayload<ExtArgs>
        fields: Prisma.inducks_characternameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_characternameFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characternamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_characternameFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characternamePayload>
          }
          findFirst: {
            args: Prisma.inducks_characternameFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characternamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_characternameFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characternamePayload>
          }
          findMany: {
            args: Prisma.inducks_characternameFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characternamePayload>[]
          }
          create: {
            args: Prisma.inducks_characternameCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characternamePayload>
          }
          createMany: {
            args: Prisma.inducks_characternameCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_characternameDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characternamePayload>
          }
          update: {
            args: Prisma.inducks_characternameUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characternamePayload>
          }
          deleteMany: {
            args: Prisma.inducks_characternameDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_characternameUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_characternameUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characternamePayload>
          }
          aggregate: {
            args: Prisma.Inducks_characternameAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_charactername>
          }
          groupBy: {
            args: Prisma.inducks_characternameGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_characternameGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_characternameCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_characternameCountAggregateOutputType> | number
          }
        }
      }
      inducks_characterreference: {
        payload: Prisma.$inducks_characterreferencePayload<ExtArgs>
        fields: Prisma.inducks_characterreferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_characterreferenceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characterreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_characterreferenceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characterreferencePayload>
          }
          findFirst: {
            args: Prisma.inducks_characterreferenceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characterreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_characterreferenceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characterreferencePayload>
          }
          findMany: {
            args: Prisma.inducks_characterreferenceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characterreferencePayload>[]
          }
          create: {
            args: Prisma.inducks_characterreferenceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characterreferencePayload>
          }
          createMany: {
            args: Prisma.inducks_characterreferenceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_characterreferenceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characterreferencePayload>
          }
          update: {
            args: Prisma.inducks_characterreferenceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characterreferencePayload>
          }
          deleteMany: {
            args: Prisma.inducks_characterreferenceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_characterreferenceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_characterreferenceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characterreferencePayload>
          }
          aggregate: {
            args: Prisma.Inducks_characterreferenceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_characterreference>
          }
          groupBy: {
            args: Prisma.inducks_characterreferenceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_characterreferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_characterreferenceCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_characterreferenceCountAggregateOutputType> | number
          }
        }
      }
      inducks_characterurl: {
        payload: Prisma.$inducks_characterurlPayload<ExtArgs>
        fields: Prisma.inducks_characterurlFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_characterurlFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characterurlPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_characterurlFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characterurlPayload>
          }
          findFirst: {
            args: Prisma.inducks_characterurlFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characterurlPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_characterurlFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characterurlPayload>
          }
          findMany: {
            args: Prisma.inducks_characterurlFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characterurlPayload>[]
          }
          create: {
            args: Prisma.inducks_characterurlCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characterurlPayload>
          }
          createMany: {
            args: Prisma.inducks_characterurlCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_characterurlDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characterurlPayload>
          }
          update: {
            args: Prisma.inducks_characterurlUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characterurlPayload>
          }
          deleteMany: {
            args: Prisma.inducks_characterurlDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_characterurlUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_characterurlUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_characterurlPayload>
          }
          aggregate: {
            args: Prisma.Inducks_characterurlAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_characterurl>
          }
          groupBy: {
            args: Prisma.inducks_characterurlGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_characterurlGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_characterurlCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_characterurlCountAggregateOutputType> | number
          }
        }
      }
      inducks_country: {
        payload: Prisma.$inducks_countryPayload<ExtArgs>
        fields: Prisma.inducks_countryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_countryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_countryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_countryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_countryPayload>
          }
          findFirst: {
            args: Prisma.inducks_countryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_countryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_countryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_countryPayload>
          }
          findMany: {
            args: Prisma.inducks_countryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_countryPayload>[]
          }
          create: {
            args: Prisma.inducks_countryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_countryPayload>
          }
          createMany: {
            args: Prisma.inducks_countryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_countryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_countryPayload>
          }
          update: {
            args: Prisma.inducks_countryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_countryPayload>
          }
          deleteMany: {
            args: Prisma.inducks_countryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_countryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_countryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_countryPayload>
          }
          aggregate: {
            args: Prisma.Inducks_countryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_country>
          }
          groupBy: {
            args: Prisma.inducks_countryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_countryGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_countryCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_countryCountAggregateOutputType> | number
          }
        }
      }
      inducks_countryname: {
        payload: Prisma.$inducks_countrynamePayload<ExtArgs>
        fields: Prisma.inducks_countrynameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_countrynameFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_countrynamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_countrynameFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_countrynamePayload>
          }
          findFirst: {
            args: Prisma.inducks_countrynameFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_countrynamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_countrynameFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_countrynamePayload>
          }
          findMany: {
            args: Prisma.inducks_countrynameFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_countrynamePayload>[]
          }
          create: {
            args: Prisma.inducks_countrynameCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_countrynamePayload>
          }
          createMany: {
            args: Prisma.inducks_countrynameCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_countrynameDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_countrynamePayload>
          }
          update: {
            args: Prisma.inducks_countrynameUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_countrynamePayload>
          }
          deleteMany: {
            args: Prisma.inducks_countrynameDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_countrynameUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_countrynameUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_countrynamePayload>
          }
          aggregate: {
            args: Prisma.Inducks_countrynameAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_countryname>
          }
          groupBy: {
            args: Prisma.inducks_countrynameGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_countrynameGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_countrynameCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_countrynameCountAggregateOutputType> | number
          }
        }
      }
      inducks_currency: {
        payload: Prisma.$inducks_currencyPayload<ExtArgs>
        fields: Prisma.inducks_currencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_currencyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_currencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_currencyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_currencyPayload>
          }
          findFirst: {
            args: Prisma.inducks_currencyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_currencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_currencyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_currencyPayload>
          }
          findMany: {
            args: Prisma.inducks_currencyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_currencyPayload>[]
          }
          create: {
            args: Prisma.inducks_currencyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_currencyPayload>
          }
          createMany: {
            args: Prisma.inducks_currencyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_currencyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_currencyPayload>
          }
          update: {
            args: Prisma.inducks_currencyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_currencyPayload>
          }
          deleteMany: {
            args: Prisma.inducks_currencyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_currencyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_currencyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_currencyPayload>
          }
          aggregate: {
            args: Prisma.Inducks_currencyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_currency>
          }
          groupBy: {
            args: Prisma.inducks_currencyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_currencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_currencyCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_currencyCountAggregateOutputType> | number
          }
        }
      }
      inducks_currencyname: {
        payload: Prisma.$inducks_currencynamePayload<ExtArgs>
        fields: Prisma.inducks_currencynameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_currencynameFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_currencynamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_currencynameFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_currencynamePayload>
          }
          findFirst: {
            args: Prisma.inducks_currencynameFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_currencynamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_currencynameFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_currencynamePayload>
          }
          findMany: {
            args: Prisma.inducks_currencynameFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_currencynamePayload>[]
          }
          create: {
            args: Prisma.inducks_currencynameCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_currencynamePayload>
          }
          createMany: {
            args: Prisma.inducks_currencynameCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_currencynameDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_currencynamePayload>
          }
          update: {
            args: Prisma.inducks_currencynameUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_currencynamePayload>
          }
          deleteMany: {
            args: Prisma.inducks_currencynameDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_currencynameUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_currencynameUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_currencynamePayload>
          }
          aggregate: {
            args: Prisma.Inducks_currencynameAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_currencyname>
          }
          groupBy: {
            args: Prisma.inducks_currencynameGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_currencynameGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_currencynameCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_currencynameCountAggregateOutputType> | number
          }
        }
      }
      inducks_entry: {
        payload: Prisma.$inducks_entryPayload<ExtArgs>
        fields: Prisma.inducks_entryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_entryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_entryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entryPayload>
          }
          findFirst: {
            args: Prisma.inducks_entryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_entryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entryPayload>
          }
          findMany: {
            args: Prisma.inducks_entryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entryPayload>[]
          }
          create: {
            args: Prisma.inducks_entryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entryPayload>
          }
          createMany: {
            args: Prisma.inducks_entryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_entryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entryPayload>
          }
          update: {
            args: Prisma.inducks_entryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entryPayload>
          }
          deleteMany: {
            args: Prisma.inducks_entryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_entryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_entryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entryPayload>
          }
          aggregate: {
            args: Prisma.Inducks_entryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_entry>
          }
          groupBy: {
            args: Prisma.inducks_entryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_entryGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_entryCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_entryCountAggregateOutputType> | number
          }
        }
      }
      inducks_entry_nofulltext: {
        payload: Prisma.$inducks_entry_nofulltextPayload<ExtArgs>
        fields: Prisma.inducks_entry_nofulltextFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_entry_nofulltextFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entry_nofulltextPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_entry_nofulltextFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entry_nofulltextPayload>
          }
          findFirst: {
            args: Prisma.inducks_entry_nofulltextFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entry_nofulltextPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_entry_nofulltextFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entry_nofulltextPayload>
          }
          findMany: {
            args: Prisma.inducks_entry_nofulltextFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entry_nofulltextPayload>[]
          }
          create: {
            args: Prisma.inducks_entry_nofulltextCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entry_nofulltextPayload>
          }
          createMany: {
            args: Prisma.inducks_entry_nofulltextCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_entry_nofulltextDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entry_nofulltextPayload>
          }
          update: {
            args: Prisma.inducks_entry_nofulltextUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entry_nofulltextPayload>
          }
          deleteMany: {
            args: Prisma.inducks_entry_nofulltextDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_entry_nofulltextUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_entry_nofulltextUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entry_nofulltextPayload>
          }
          aggregate: {
            args: Prisma.Inducks_entry_nofulltextAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_entry_nofulltext>
          }
          groupBy: {
            args: Prisma.inducks_entry_nofulltextGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_entry_nofulltextGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_entry_nofulltextCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_entry_nofulltextCountAggregateOutputType> | number
          }
        }
      }
      inducks_entrycharactername: {
        payload: Prisma.$inducks_entrycharacternamePayload<ExtArgs>
        fields: Prisma.inducks_entrycharacternameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_entrycharacternameFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entrycharacternamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_entrycharacternameFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entrycharacternamePayload>
          }
          findFirst: {
            args: Prisma.inducks_entrycharacternameFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entrycharacternamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_entrycharacternameFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entrycharacternamePayload>
          }
          findMany: {
            args: Prisma.inducks_entrycharacternameFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entrycharacternamePayload>[]
          }
          create: {
            args: Prisma.inducks_entrycharacternameCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entrycharacternamePayload>
          }
          createMany: {
            args: Prisma.inducks_entrycharacternameCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_entrycharacternameDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entrycharacternamePayload>
          }
          update: {
            args: Prisma.inducks_entrycharacternameUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entrycharacternamePayload>
          }
          deleteMany: {
            args: Prisma.inducks_entrycharacternameDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_entrycharacternameUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_entrycharacternameUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entrycharacternamePayload>
          }
          aggregate: {
            args: Prisma.Inducks_entrycharacternameAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_entrycharactername>
          }
          groupBy: {
            args: Prisma.inducks_entrycharacternameGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_entrycharacternameGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_entrycharacternameCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_entrycharacternameCountAggregateOutputType> | number
          }
        }
      }
      inducks_entryjob: {
        payload: Prisma.$inducks_entryjobPayload<ExtArgs>
        fields: Prisma.inducks_entryjobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_entryjobFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entryjobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_entryjobFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entryjobPayload>
          }
          findFirst: {
            args: Prisma.inducks_entryjobFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entryjobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_entryjobFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entryjobPayload>
          }
          findMany: {
            args: Prisma.inducks_entryjobFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entryjobPayload>[]
          }
          create: {
            args: Prisma.inducks_entryjobCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entryjobPayload>
          }
          createMany: {
            args: Prisma.inducks_entryjobCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_entryjobDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entryjobPayload>
          }
          update: {
            args: Prisma.inducks_entryjobUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entryjobPayload>
          }
          deleteMany: {
            args: Prisma.inducks_entryjobDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_entryjobUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_entryjobUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entryjobPayload>
          }
          aggregate: {
            args: Prisma.Inducks_entryjobAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_entryjob>
          }
          groupBy: {
            args: Prisma.inducks_entryjobGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_entryjobGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_entryjobCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_entryjobCountAggregateOutputType> | number
          }
        }
      }
      inducks_entryurl: {
        payload: Prisma.$inducks_entryurlPayload<ExtArgs>
        fields: Prisma.inducks_entryurlFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_entryurlFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entryurlPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_entryurlFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entryurlPayload>
          }
          findFirst: {
            args: Prisma.inducks_entryurlFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entryurlPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_entryurlFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entryurlPayload>
          }
          findMany: {
            args: Prisma.inducks_entryurlFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entryurlPayload>[]
          }
          create: {
            args: Prisma.inducks_entryurlCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entryurlPayload>
          }
          createMany: {
            args: Prisma.inducks_entryurlCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_entryurlDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entryurlPayload>
          }
          update: {
            args: Prisma.inducks_entryurlUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entryurlPayload>
          }
          deleteMany: {
            args: Prisma.inducks_entryurlDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_entryurlUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_entryurlUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_entryurlPayload>
          }
          aggregate: {
            args: Prisma.Inducks_entryurlAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_entryurl>
          }
          groupBy: {
            args: Prisma.inducks_entryurlGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_entryurlGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_entryurlCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_entryurlCountAggregateOutputType> | number
          }
        }
      }
      inducks_equiv: {
        payload: Prisma.$inducks_equivPayload<ExtArgs>
        fields: Prisma.inducks_equivFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_equivFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_equivPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_equivFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_equivPayload>
          }
          findFirst: {
            args: Prisma.inducks_equivFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_equivPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_equivFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_equivPayload>
          }
          findMany: {
            args: Prisma.inducks_equivFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_equivPayload>[]
          }
          create: {
            args: Prisma.inducks_equivCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_equivPayload>
          }
          createMany: {
            args: Prisma.inducks_equivCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_equivDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_equivPayload>
          }
          update: {
            args: Prisma.inducks_equivUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_equivPayload>
          }
          deleteMany: {
            args: Prisma.inducks_equivDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_equivUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_equivUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_equivPayload>
          }
          aggregate: {
            args: Prisma.Inducks_equivAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_equiv>
          }
          groupBy: {
            args: Prisma.inducks_equivGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_equivGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_equivCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_equivCountAggregateOutputType> | number
          }
        }
      }
      inducks_herocharacter: {
        payload: Prisma.$inducks_herocharacterPayload<ExtArgs>
        fields: Prisma.inducks_herocharacterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_herocharacterFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_herocharacterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_herocharacterFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_herocharacterPayload>
          }
          findFirst: {
            args: Prisma.inducks_herocharacterFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_herocharacterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_herocharacterFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_herocharacterPayload>
          }
          findMany: {
            args: Prisma.inducks_herocharacterFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_herocharacterPayload>[]
          }
          create: {
            args: Prisma.inducks_herocharacterCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_herocharacterPayload>
          }
          createMany: {
            args: Prisma.inducks_herocharacterCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_herocharacterDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_herocharacterPayload>
          }
          update: {
            args: Prisma.inducks_herocharacterUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_herocharacterPayload>
          }
          deleteMany: {
            args: Prisma.inducks_herocharacterDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_herocharacterUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_herocharacterUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_herocharacterPayload>
          }
          aggregate: {
            args: Prisma.Inducks_herocharacterAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_herocharacter>
          }
          groupBy: {
            args: Prisma.inducks_herocharacterGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_herocharacterGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_herocharacterCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_herocharacterCountAggregateOutputType> | number
          }
        }
      }
      inducks_inputfile: {
        payload: Prisma.$inducks_inputfilePayload<ExtArgs>
        fields: Prisma.inducks_inputfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_inputfileFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_inputfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_inputfileFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_inputfilePayload>
          }
          findFirst: {
            args: Prisma.inducks_inputfileFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_inputfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_inputfileFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_inputfilePayload>
          }
          findMany: {
            args: Prisma.inducks_inputfileFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_inputfilePayload>[]
          }
          create: {
            args: Prisma.inducks_inputfileCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_inputfilePayload>
          }
          createMany: {
            args: Prisma.inducks_inputfileCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_inputfileDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_inputfilePayload>
          }
          update: {
            args: Prisma.inducks_inputfileUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_inputfilePayload>
          }
          deleteMany: {
            args: Prisma.inducks_inputfileDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_inputfileUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_inputfileUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_inputfilePayload>
          }
          aggregate: {
            args: Prisma.Inducks_inputfileAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_inputfile>
          }
          groupBy: {
            args: Prisma.inducks_inputfileGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_inputfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_inputfileCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_inputfileCountAggregateOutputType> | number
          }
        }
      }
      inducks_issue: {
        payload: Prisma.$inducks_issuePayload<ExtArgs>
        fields: Prisma.inducks_issueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_issueFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_issueFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuePayload>
          }
          findFirst: {
            args: Prisma.inducks_issueFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_issueFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuePayload>
          }
          findMany: {
            args: Prisma.inducks_issueFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuePayload>[]
          }
          create: {
            args: Prisma.inducks_issueCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuePayload>
          }
          createMany: {
            args: Prisma.inducks_issueCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_issueDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuePayload>
          }
          update: {
            args: Prisma.inducks_issueUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuePayload>
          }
          deleteMany: {
            args: Prisma.inducks_issueDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_issueUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_issueUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuePayload>
          }
          aggregate: {
            args: Prisma.Inducks_issueAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_issue>
          }
          groupBy: {
            args: Prisma.inducks_issueGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_issueGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_issueCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_issueCountAggregateOutputType> | number
          }
        }
      }
      inducks_issuecollecting: {
        payload: Prisma.$inducks_issuecollectingPayload<ExtArgs>
        fields: Prisma.inducks_issuecollectingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_issuecollectingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuecollectingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_issuecollectingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuecollectingPayload>
          }
          findFirst: {
            args: Prisma.inducks_issuecollectingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuecollectingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_issuecollectingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuecollectingPayload>
          }
          findMany: {
            args: Prisma.inducks_issuecollectingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuecollectingPayload>[]
          }
          create: {
            args: Prisma.inducks_issuecollectingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuecollectingPayload>
          }
          createMany: {
            args: Prisma.inducks_issuecollectingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_issuecollectingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuecollectingPayload>
          }
          update: {
            args: Prisma.inducks_issuecollectingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuecollectingPayload>
          }
          deleteMany: {
            args: Prisma.inducks_issuecollectingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_issuecollectingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_issuecollectingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuecollectingPayload>
          }
          aggregate: {
            args: Prisma.Inducks_issuecollectingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_issuecollecting>
          }
          groupBy: {
            args: Prisma.inducks_issuecollectingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_issuecollectingGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_issuecollectingCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_issuecollectingCountAggregateOutputType> | number
          }
        }
      }
      inducks_issuedate: {
        payload: Prisma.$inducks_issuedatePayload<ExtArgs>
        fields: Prisma.inducks_issuedateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_issuedateFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuedatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_issuedateFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuedatePayload>
          }
          findFirst: {
            args: Prisma.inducks_issuedateFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuedatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_issuedateFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuedatePayload>
          }
          findMany: {
            args: Prisma.inducks_issuedateFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuedatePayload>[]
          }
          create: {
            args: Prisma.inducks_issuedateCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuedatePayload>
          }
          createMany: {
            args: Prisma.inducks_issuedateCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_issuedateDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuedatePayload>
          }
          update: {
            args: Prisma.inducks_issuedateUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuedatePayload>
          }
          deleteMany: {
            args: Prisma.inducks_issuedateDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_issuedateUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_issuedateUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuedatePayload>
          }
          aggregate: {
            args: Prisma.Inducks_issuedateAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_issuedate>
          }
          groupBy: {
            args: Prisma.inducks_issuedateGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_issuedateGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_issuedateCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_issuedateCountAggregateOutputType> | number
          }
        }
      }
      inducks_issuejob: {
        payload: Prisma.$inducks_issuejobPayload<ExtArgs>
        fields: Prisma.inducks_issuejobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_issuejobFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuejobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_issuejobFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuejobPayload>
          }
          findFirst: {
            args: Prisma.inducks_issuejobFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuejobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_issuejobFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuejobPayload>
          }
          findMany: {
            args: Prisma.inducks_issuejobFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuejobPayload>[]
          }
          create: {
            args: Prisma.inducks_issuejobCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuejobPayload>
          }
          createMany: {
            args: Prisma.inducks_issuejobCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_issuejobDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuejobPayload>
          }
          update: {
            args: Prisma.inducks_issuejobUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuejobPayload>
          }
          deleteMany: {
            args: Prisma.inducks_issuejobDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_issuejobUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_issuejobUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuejobPayload>
          }
          aggregate: {
            args: Prisma.Inducks_issuejobAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_issuejob>
          }
          groupBy: {
            args: Prisma.inducks_issuejobGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_issuejobGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_issuejobCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_issuejobCountAggregateOutputType> | number
          }
        }
      }
      inducks_issueprice: {
        payload: Prisma.$inducks_issuepricePayload<ExtArgs>
        fields: Prisma.inducks_issuepriceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_issuepriceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuepricePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_issuepriceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuepricePayload>
          }
          findFirst: {
            args: Prisma.inducks_issuepriceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuepricePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_issuepriceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuepricePayload>
          }
          findMany: {
            args: Prisma.inducks_issuepriceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuepricePayload>[]
          }
          create: {
            args: Prisma.inducks_issuepriceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuepricePayload>
          }
          createMany: {
            args: Prisma.inducks_issuepriceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_issuepriceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuepricePayload>
          }
          update: {
            args: Prisma.inducks_issuepriceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuepricePayload>
          }
          deleteMany: {
            args: Prisma.inducks_issuepriceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_issuepriceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_issuepriceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuepricePayload>
          }
          aggregate: {
            args: Prisma.Inducks_issuepriceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_issueprice>
          }
          groupBy: {
            args: Prisma.inducks_issuepriceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_issuepriceGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_issuepriceCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_issuepriceCountAggregateOutputType> | number
          }
        }
      }
      inducks_issuequotation: {
        payload: Prisma.$inducks_issuequotationPayload<ExtArgs>
        fields: Prisma.inducks_issuequotationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_issuequotationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuequotationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_issuequotationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuequotationPayload>
          }
          findFirst: {
            args: Prisma.inducks_issuequotationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuequotationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_issuequotationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuequotationPayload>
          }
          findMany: {
            args: Prisma.inducks_issuequotationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuequotationPayload>[]
          }
          create: {
            args: Prisma.inducks_issuequotationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuequotationPayload>
          }
          createMany: {
            args: Prisma.inducks_issuequotationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_issuequotationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuequotationPayload>
          }
          update: {
            args: Prisma.inducks_issuequotationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuequotationPayload>
          }
          deleteMany: {
            args: Prisma.inducks_issuequotationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_issuequotationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_issuequotationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuequotationPayload>
          }
          aggregate: {
            args: Prisma.Inducks_issuequotationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_issuequotation>
          }
          groupBy: {
            args: Prisma.inducks_issuequotationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_issuequotationGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_issuequotationCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_issuequotationCountAggregateOutputType> | number
          }
        }
      }
      inducks_issuerange: {
        payload: Prisma.$inducks_issuerangePayload<ExtArgs>
        fields: Prisma.inducks_issuerangeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_issuerangeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuerangePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_issuerangeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuerangePayload>
          }
          findFirst: {
            args: Prisma.inducks_issuerangeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuerangePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_issuerangeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuerangePayload>
          }
          findMany: {
            args: Prisma.inducks_issuerangeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuerangePayload>[]
          }
          create: {
            args: Prisma.inducks_issuerangeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuerangePayload>
          }
          createMany: {
            args: Prisma.inducks_issuerangeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_issuerangeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuerangePayload>
          }
          update: {
            args: Prisma.inducks_issuerangeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuerangePayload>
          }
          deleteMany: {
            args: Prisma.inducks_issuerangeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_issuerangeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_issuerangeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issuerangePayload>
          }
          aggregate: {
            args: Prisma.Inducks_issuerangeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_issuerange>
          }
          groupBy: {
            args: Prisma.inducks_issuerangeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_issuerangeGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_issuerangeCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_issuerangeCountAggregateOutputType> | number
          }
        }
      }
      inducks_issueurl: {
        payload: Prisma.$inducks_issueurlPayload<ExtArgs>
        fields: Prisma.inducks_issueurlFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_issueurlFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issueurlPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_issueurlFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issueurlPayload>
          }
          findFirst: {
            args: Prisma.inducks_issueurlFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issueurlPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_issueurlFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issueurlPayload>
          }
          findMany: {
            args: Prisma.inducks_issueurlFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issueurlPayload>[]
          }
          create: {
            args: Prisma.inducks_issueurlCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issueurlPayload>
          }
          createMany: {
            args: Prisma.inducks_issueurlCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_issueurlDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issueurlPayload>
          }
          update: {
            args: Prisma.inducks_issueurlUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issueurlPayload>
          }
          deleteMany: {
            args: Prisma.inducks_issueurlDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_issueurlUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_issueurlUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_issueurlPayload>
          }
          aggregate: {
            args: Prisma.Inducks_issueurlAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_issueurl>
          }
          groupBy: {
            args: Prisma.inducks_issueurlGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_issueurlGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_issueurlCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_issueurlCountAggregateOutputType> | number
          }
        }
      }
      inducks_language: {
        payload: Prisma.$inducks_languagePayload<ExtArgs>
        fields: Prisma.inducks_languageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_languageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_languagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_languageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_languagePayload>
          }
          findFirst: {
            args: Prisma.inducks_languageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_languagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_languageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_languagePayload>
          }
          findMany: {
            args: Prisma.inducks_languageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_languagePayload>[]
          }
          create: {
            args: Prisma.inducks_languageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_languagePayload>
          }
          createMany: {
            args: Prisma.inducks_languageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_languageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_languagePayload>
          }
          update: {
            args: Prisma.inducks_languageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_languagePayload>
          }
          deleteMany: {
            args: Prisma.inducks_languageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_languageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_languageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_languagePayload>
          }
          aggregate: {
            args: Prisma.Inducks_languageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_language>
          }
          groupBy: {
            args: Prisma.inducks_languageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_languageGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_languageCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_languageCountAggregateOutputType> | number
          }
        }
      }
      inducks_languagename: {
        payload: Prisma.$inducks_languagenamePayload<ExtArgs>
        fields: Prisma.inducks_languagenameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_languagenameFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_languagenamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_languagenameFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_languagenamePayload>
          }
          findFirst: {
            args: Prisma.inducks_languagenameFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_languagenamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_languagenameFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_languagenamePayload>
          }
          findMany: {
            args: Prisma.inducks_languagenameFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_languagenamePayload>[]
          }
          create: {
            args: Prisma.inducks_languagenameCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_languagenamePayload>
          }
          createMany: {
            args: Prisma.inducks_languagenameCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_languagenameDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_languagenamePayload>
          }
          update: {
            args: Prisma.inducks_languagenameUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_languagenamePayload>
          }
          deleteMany: {
            args: Prisma.inducks_languagenameDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_languagenameUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_languagenameUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_languagenamePayload>
          }
          aggregate: {
            args: Prisma.Inducks_languagenameAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_languagename>
          }
          groupBy: {
            args: Prisma.inducks_languagenameGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_languagenameGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_languagenameCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_languagenameCountAggregateOutputType> | number
          }
        }
      }
      inducks_log: {
        payload: Prisma.$inducks_logPayload<ExtArgs>
        fields: Prisma.inducks_logFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_logFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_logPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_logFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_logPayload>
          }
          findFirst: {
            args: Prisma.inducks_logFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_logPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_logFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_logPayload>
          }
          findMany: {
            args: Prisma.inducks_logFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_logPayload>[]
          }
          create: {
            args: Prisma.inducks_logCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_logPayload>
          }
          createMany: {
            args: Prisma.inducks_logCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_logDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_logPayload>
          }
          update: {
            args: Prisma.inducks_logUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_logPayload>
          }
          deleteMany: {
            args: Prisma.inducks_logDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_logUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_logUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_logPayload>
          }
          aggregate: {
            args: Prisma.Inducks_logAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_log>
          }
          groupBy: {
            args: Prisma.inducks_logGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_logGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_logCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_logCountAggregateOutputType> | number
          }
        }
      }
      inducks_logdata: {
        payload: Prisma.$inducks_logdataPayload<ExtArgs>
        fields: Prisma.inducks_logdataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_logdataFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_logdataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_logdataFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_logdataPayload>
          }
          findFirst: {
            args: Prisma.inducks_logdataFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_logdataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_logdataFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_logdataPayload>
          }
          findMany: {
            args: Prisma.inducks_logdataFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_logdataPayload>[]
          }
          create: {
            args: Prisma.inducks_logdataCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_logdataPayload>
          }
          createMany: {
            args: Prisma.inducks_logdataCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_logdataDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_logdataPayload>
          }
          update: {
            args: Prisma.inducks_logdataUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_logdataPayload>
          }
          deleteMany: {
            args: Prisma.inducks_logdataDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_logdataUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_logdataUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_logdataPayload>
          }
          aggregate: {
            args: Prisma.Inducks_logdataAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_logdata>
          }
          groupBy: {
            args: Prisma.inducks_logdataGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_logdataGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_logdataCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_logdataCountAggregateOutputType> | number
          }
        }
      }
      inducks_logocharacter: {
        payload: Prisma.$inducks_logocharacterPayload<ExtArgs>
        fields: Prisma.inducks_logocharacterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_logocharacterFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_logocharacterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_logocharacterFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_logocharacterPayload>
          }
          findFirst: {
            args: Prisma.inducks_logocharacterFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_logocharacterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_logocharacterFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_logocharacterPayload>
          }
          findMany: {
            args: Prisma.inducks_logocharacterFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_logocharacterPayload>[]
          }
          create: {
            args: Prisma.inducks_logocharacterCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_logocharacterPayload>
          }
          createMany: {
            args: Prisma.inducks_logocharacterCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_logocharacterDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_logocharacterPayload>
          }
          update: {
            args: Prisma.inducks_logocharacterUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_logocharacterPayload>
          }
          deleteMany: {
            args: Prisma.inducks_logocharacterDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_logocharacterUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_logocharacterUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_logocharacterPayload>
          }
          aggregate: {
            args: Prisma.Inducks_logocharacterAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_logocharacter>
          }
          groupBy: {
            args: Prisma.inducks_logocharacterGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_logocharacterGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_logocharacterCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_logocharacterCountAggregateOutputType> | number
          }
        }
      }
      inducks_movie: {
        payload: Prisma.$inducks_moviePayload<ExtArgs>
        fields: Prisma.inducks_movieFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_movieFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_moviePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_movieFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_moviePayload>
          }
          findFirst: {
            args: Prisma.inducks_movieFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_moviePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_movieFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_moviePayload>
          }
          findMany: {
            args: Prisma.inducks_movieFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_moviePayload>[]
          }
          create: {
            args: Prisma.inducks_movieCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_moviePayload>
          }
          createMany: {
            args: Prisma.inducks_movieCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_movieDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_moviePayload>
          }
          update: {
            args: Prisma.inducks_movieUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_moviePayload>
          }
          deleteMany: {
            args: Prisma.inducks_movieDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_movieUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_movieUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_moviePayload>
          }
          aggregate: {
            args: Prisma.Inducks_movieAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_movie>
          }
          groupBy: {
            args: Prisma.inducks_movieGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_movieGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_movieCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_movieCountAggregateOutputType> | number
          }
        }
      }
      inducks_moviecharacter: {
        payload: Prisma.$inducks_moviecharacterPayload<ExtArgs>
        fields: Prisma.inducks_moviecharacterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_moviecharacterFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_moviecharacterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_moviecharacterFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_moviecharacterPayload>
          }
          findFirst: {
            args: Prisma.inducks_moviecharacterFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_moviecharacterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_moviecharacterFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_moviecharacterPayload>
          }
          findMany: {
            args: Prisma.inducks_moviecharacterFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_moviecharacterPayload>[]
          }
          create: {
            args: Prisma.inducks_moviecharacterCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_moviecharacterPayload>
          }
          createMany: {
            args: Prisma.inducks_moviecharacterCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_moviecharacterDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_moviecharacterPayload>
          }
          update: {
            args: Prisma.inducks_moviecharacterUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_moviecharacterPayload>
          }
          deleteMany: {
            args: Prisma.inducks_moviecharacterDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_moviecharacterUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_moviecharacterUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_moviecharacterPayload>
          }
          aggregate: {
            args: Prisma.Inducks_moviecharacterAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_moviecharacter>
          }
          groupBy: {
            args: Prisma.inducks_moviecharacterGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_moviecharacterGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_moviecharacterCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_moviecharacterCountAggregateOutputType> | number
          }
        }
      }
      inducks_moviejob: {
        payload: Prisma.$inducks_moviejobPayload<ExtArgs>
        fields: Prisma.inducks_moviejobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_moviejobFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_moviejobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_moviejobFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_moviejobPayload>
          }
          findFirst: {
            args: Prisma.inducks_moviejobFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_moviejobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_moviejobFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_moviejobPayload>
          }
          findMany: {
            args: Prisma.inducks_moviejobFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_moviejobPayload>[]
          }
          create: {
            args: Prisma.inducks_moviejobCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_moviejobPayload>
          }
          createMany: {
            args: Prisma.inducks_moviejobCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_moviejobDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_moviejobPayload>
          }
          update: {
            args: Prisma.inducks_moviejobUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_moviejobPayload>
          }
          deleteMany: {
            args: Prisma.inducks_moviejobDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_moviejobUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_moviejobUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_moviejobPayload>
          }
          aggregate: {
            args: Prisma.Inducks_moviejobAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_moviejob>
          }
          groupBy: {
            args: Prisma.inducks_moviejobGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_moviejobGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_moviejobCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_moviejobCountAggregateOutputType> | number
          }
        }
      }
      inducks_moviereference: {
        payload: Prisma.$inducks_moviereferencePayload<ExtArgs>
        fields: Prisma.inducks_moviereferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_moviereferenceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_moviereferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_moviereferenceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_moviereferencePayload>
          }
          findFirst: {
            args: Prisma.inducks_moviereferenceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_moviereferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_moviereferenceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_moviereferencePayload>
          }
          findMany: {
            args: Prisma.inducks_moviereferenceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_moviereferencePayload>[]
          }
          create: {
            args: Prisma.inducks_moviereferenceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_moviereferencePayload>
          }
          createMany: {
            args: Prisma.inducks_moviereferenceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_moviereferenceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_moviereferencePayload>
          }
          update: {
            args: Prisma.inducks_moviereferenceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_moviereferencePayload>
          }
          deleteMany: {
            args: Prisma.inducks_moviereferenceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_moviereferenceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_moviereferenceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_moviereferencePayload>
          }
          aggregate: {
            args: Prisma.Inducks_moviereferenceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_moviereference>
          }
          groupBy: {
            args: Prisma.inducks_moviereferenceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_moviereferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_moviereferenceCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_moviereferenceCountAggregateOutputType> | number
          }
        }
      }
      inducks_person: {
        payload: Prisma.$inducks_personPayload<ExtArgs>
        fields: Prisma.inducks_personFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_personFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_personPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_personFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_personPayload>
          }
          findFirst: {
            args: Prisma.inducks_personFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_personPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_personFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_personPayload>
          }
          findMany: {
            args: Prisma.inducks_personFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_personPayload>[]
          }
          create: {
            args: Prisma.inducks_personCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_personPayload>
          }
          createMany: {
            args: Prisma.inducks_personCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_personDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_personPayload>
          }
          update: {
            args: Prisma.inducks_personUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_personPayload>
          }
          deleteMany: {
            args: Prisma.inducks_personDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_personUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_personUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_personPayload>
          }
          aggregate: {
            args: Prisma.Inducks_personAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_person>
          }
          groupBy: {
            args: Prisma.inducks_personGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_personGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_personCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_personCountAggregateOutputType> | number
          }
        }
      }
      inducks_personurl: {
        payload: Prisma.$inducks_personurlPayload<ExtArgs>
        fields: Prisma.inducks_personurlFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_personurlFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_personurlPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_personurlFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_personurlPayload>
          }
          findFirst: {
            args: Prisma.inducks_personurlFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_personurlPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_personurlFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_personurlPayload>
          }
          findMany: {
            args: Prisma.inducks_personurlFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_personurlPayload>[]
          }
          create: {
            args: Prisma.inducks_personurlCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_personurlPayload>
          }
          createMany: {
            args: Prisma.inducks_personurlCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_personurlDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_personurlPayload>
          }
          update: {
            args: Prisma.inducks_personurlUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_personurlPayload>
          }
          deleteMany: {
            args: Prisma.inducks_personurlDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_personurlUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_personurlUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_personurlPayload>
          }
          aggregate: {
            args: Prisma.Inducks_personurlAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_personurl>
          }
          groupBy: {
            args: Prisma.inducks_personurlGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_personurlGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_personurlCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_personurlCountAggregateOutputType> | number
          }
        }
      }
      inducks_publication: {
        payload: Prisma.$inducks_publicationPayload<ExtArgs>
        fields: Prisma.inducks_publicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_publicationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_publicationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publicationPayload>
          }
          findFirst: {
            args: Prisma.inducks_publicationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_publicationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publicationPayload>
          }
          findMany: {
            args: Prisma.inducks_publicationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publicationPayload>[]
          }
          create: {
            args: Prisma.inducks_publicationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publicationPayload>
          }
          createMany: {
            args: Prisma.inducks_publicationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_publicationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publicationPayload>
          }
          update: {
            args: Prisma.inducks_publicationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publicationPayload>
          }
          deleteMany: {
            args: Prisma.inducks_publicationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_publicationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_publicationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publicationPayload>
          }
          aggregate: {
            args: Prisma.Inducks_publicationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_publication>
          }
          groupBy: {
            args: Prisma.inducks_publicationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_publicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_publicationCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_publicationCountAggregateOutputType> | number
          }
        }
      }
      inducks_publicationcategory: {
        payload: Prisma.$inducks_publicationcategoryPayload<ExtArgs>
        fields: Prisma.inducks_publicationcategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_publicationcategoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publicationcategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_publicationcategoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publicationcategoryPayload>
          }
          findFirst: {
            args: Prisma.inducks_publicationcategoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publicationcategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_publicationcategoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publicationcategoryPayload>
          }
          findMany: {
            args: Prisma.inducks_publicationcategoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publicationcategoryPayload>[]
          }
          create: {
            args: Prisma.inducks_publicationcategoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publicationcategoryPayload>
          }
          createMany: {
            args: Prisma.inducks_publicationcategoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_publicationcategoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publicationcategoryPayload>
          }
          update: {
            args: Prisma.inducks_publicationcategoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publicationcategoryPayload>
          }
          deleteMany: {
            args: Prisma.inducks_publicationcategoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_publicationcategoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_publicationcategoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publicationcategoryPayload>
          }
          aggregate: {
            args: Prisma.Inducks_publicationcategoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_publicationcategory>
          }
          groupBy: {
            args: Prisma.inducks_publicationcategoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_publicationcategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_publicationcategoryCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_publicationcategoryCountAggregateOutputType> | number
          }
        }
      }
      inducks_publicationname: {
        payload: Prisma.$inducks_publicationnamePayload<ExtArgs>
        fields: Prisma.inducks_publicationnameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_publicationnameFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publicationnamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_publicationnameFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publicationnamePayload>
          }
          findFirst: {
            args: Prisma.inducks_publicationnameFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publicationnamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_publicationnameFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publicationnamePayload>
          }
          findMany: {
            args: Prisma.inducks_publicationnameFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publicationnamePayload>[]
          }
          create: {
            args: Prisma.inducks_publicationnameCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publicationnamePayload>
          }
          createMany: {
            args: Prisma.inducks_publicationnameCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_publicationnameDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publicationnamePayload>
          }
          update: {
            args: Prisma.inducks_publicationnameUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publicationnamePayload>
          }
          deleteMany: {
            args: Prisma.inducks_publicationnameDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_publicationnameUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_publicationnameUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publicationnamePayload>
          }
          aggregate: {
            args: Prisma.Inducks_publicationnameAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_publicationname>
          }
          groupBy: {
            args: Prisma.inducks_publicationnameGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_publicationnameGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_publicationnameCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_publicationnameCountAggregateOutputType> | number
          }
        }
      }
      inducks_publicationurl: {
        payload: Prisma.$inducks_publicationurlPayload<ExtArgs>
        fields: Prisma.inducks_publicationurlFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_publicationurlFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publicationurlPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_publicationurlFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publicationurlPayload>
          }
          findFirst: {
            args: Prisma.inducks_publicationurlFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publicationurlPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_publicationurlFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publicationurlPayload>
          }
          findMany: {
            args: Prisma.inducks_publicationurlFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publicationurlPayload>[]
          }
          create: {
            args: Prisma.inducks_publicationurlCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publicationurlPayload>
          }
          createMany: {
            args: Prisma.inducks_publicationurlCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_publicationurlDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publicationurlPayload>
          }
          update: {
            args: Prisma.inducks_publicationurlUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publicationurlPayload>
          }
          deleteMany: {
            args: Prisma.inducks_publicationurlDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_publicationurlUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_publicationurlUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publicationurlPayload>
          }
          aggregate: {
            args: Prisma.Inducks_publicationurlAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_publicationurl>
          }
          groupBy: {
            args: Prisma.inducks_publicationurlGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_publicationurlGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_publicationurlCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_publicationurlCountAggregateOutputType> | number
          }
        }
      }
      inducks_publisher: {
        payload: Prisma.$inducks_publisherPayload<ExtArgs>
        fields: Prisma.inducks_publisherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_publisherFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publisherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_publisherFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publisherPayload>
          }
          findFirst: {
            args: Prisma.inducks_publisherFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publisherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_publisherFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publisherPayload>
          }
          findMany: {
            args: Prisma.inducks_publisherFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publisherPayload>[]
          }
          create: {
            args: Prisma.inducks_publisherCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publisherPayload>
          }
          createMany: {
            args: Prisma.inducks_publisherCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_publisherDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publisherPayload>
          }
          update: {
            args: Prisma.inducks_publisherUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publisherPayload>
          }
          deleteMany: {
            args: Prisma.inducks_publisherDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_publisherUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_publisherUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publisherPayload>
          }
          aggregate: {
            args: Prisma.Inducks_publisherAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_publisher>
          }
          groupBy: {
            args: Prisma.inducks_publisherGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_publisherGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_publisherCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_publisherCountAggregateOutputType> | number
          }
        }
      }
      inducks_publishingjob: {
        payload: Prisma.$inducks_publishingjobPayload<ExtArgs>
        fields: Prisma.inducks_publishingjobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_publishingjobFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publishingjobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_publishingjobFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publishingjobPayload>
          }
          findFirst: {
            args: Prisma.inducks_publishingjobFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publishingjobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_publishingjobFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publishingjobPayload>
          }
          findMany: {
            args: Prisma.inducks_publishingjobFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publishingjobPayload>[]
          }
          create: {
            args: Prisma.inducks_publishingjobCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publishingjobPayload>
          }
          createMany: {
            args: Prisma.inducks_publishingjobCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_publishingjobDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publishingjobPayload>
          }
          update: {
            args: Prisma.inducks_publishingjobUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publishingjobPayload>
          }
          deleteMany: {
            args: Prisma.inducks_publishingjobDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_publishingjobUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_publishingjobUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_publishingjobPayload>
          }
          aggregate: {
            args: Prisma.Inducks_publishingjobAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_publishingjob>
          }
          groupBy: {
            args: Prisma.inducks_publishingjobGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_publishingjobGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_publishingjobCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_publishingjobCountAggregateOutputType> | number
          }
        }
      }
      inducks_referencereason: {
        payload: Prisma.$inducks_referencereasonPayload<ExtArgs>
        fields: Prisma.inducks_referencereasonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_referencereasonFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_referencereasonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_referencereasonFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_referencereasonPayload>
          }
          findFirst: {
            args: Prisma.inducks_referencereasonFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_referencereasonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_referencereasonFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_referencereasonPayload>
          }
          findMany: {
            args: Prisma.inducks_referencereasonFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_referencereasonPayload>[]
          }
          create: {
            args: Prisma.inducks_referencereasonCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_referencereasonPayload>
          }
          createMany: {
            args: Prisma.inducks_referencereasonCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_referencereasonDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_referencereasonPayload>
          }
          update: {
            args: Prisma.inducks_referencereasonUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_referencereasonPayload>
          }
          deleteMany: {
            args: Prisma.inducks_referencereasonDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_referencereasonUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_referencereasonUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_referencereasonPayload>
          }
          aggregate: {
            args: Prisma.Inducks_referencereasonAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_referencereason>
          }
          groupBy: {
            args: Prisma.inducks_referencereasonGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_referencereasonGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_referencereasonCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_referencereasonCountAggregateOutputType> | number
          }
        }
      }
      inducks_referencereasonname: {
        payload: Prisma.$inducks_referencereasonnamePayload<ExtArgs>
        fields: Prisma.inducks_referencereasonnameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_referencereasonnameFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_referencereasonnamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_referencereasonnameFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_referencereasonnamePayload>
          }
          findFirst: {
            args: Prisma.inducks_referencereasonnameFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_referencereasonnamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_referencereasonnameFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_referencereasonnamePayload>
          }
          findMany: {
            args: Prisma.inducks_referencereasonnameFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_referencereasonnamePayload>[]
          }
          create: {
            args: Prisma.inducks_referencereasonnameCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_referencereasonnamePayload>
          }
          createMany: {
            args: Prisma.inducks_referencereasonnameCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_referencereasonnameDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_referencereasonnamePayload>
          }
          update: {
            args: Prisma.inducks_referencereasonnameUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_referencereasonnamePayload>
          }
          deleteMany: {
            args: Prisma.inducks_referencereasonnameDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_referencereasonnameUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_referencereasonnameUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_referencereasonnamePayload>
          }
          aggregate: {
            args: Prisma.Inducks_referencereasonnameAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_referencereasonname>
          }
          groupBy: {
            args: Prisma.inducks_referencereasonnameGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_referencereasonnameGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_referencereasonnameCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_referencereasonnameCountAggregateOutputType> | number
          }
        }
      }
      inducks_site: {
        payload: Prisma.$inducks_sitePayload<ExtArgs>
        fields: Prisma.inducks_siteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_siteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_sitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_siteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_sitePayload>
          }
          findFirst: {
            args: Prisma.inducks_siteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_sitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_siteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_sitePayload>
          }
          findMany: {
            args: Prisma.inducks_siteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_sitePayload>[]
          }
          create: {
            args: Prisma.inducks_siteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_sitePayload>
          }
          createMany: {
            args: Prisma.inducks_siteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_siteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_sitePayload>
          }
          update: {
            args: Prisma.inducks_siteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_sitePayload>
          }
          deleteMany: {
            args: Prisma.inducks_siteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_siteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_siteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_sitePayload>
          }
          aggregate: {
            args: Prisma.Inducks_siteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_site>
          }
          groupBy: {
            args: Prisma.inducks_siteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_siteGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_siteCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_siteCountAggregateOutputType> | number
          }
        }
      }
      inducks_statcharactercharacter: {
        payload: Prisma.$inducks_statcharactercharacterPayload<ExtArgs>
        fields: Prisma.inducks_statcharactercharacterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_statcharactercharacterFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statcharactercharacterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_statcharactercharacterFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statcharactercharacterPayload>
          }
          findFirst: {
            args: Prisma.inducks_statcharactercharacterFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statcharactercharacterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_statcharactercharacterFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statcharactercharacterPayload>
          }
          findMany: {
            args: Prisma.inducks_statcharactercharacterFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statcharactercharacterPayload>[]
          }
          create: {
            args: Prisma.inducks_statcharactercharacterCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statcharactercharacterPayload>
          }
          createMany: {
            args: Prisma.inducks_statcharactercharacterCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_statcharactercharacterDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statcharactercharacterPayload>
          }
          update: {
            args: Prisma.inducks_statcharactercharacterUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statcharactercharacterPayload>
          }
          deleteMany: {
            args: Prisma.inducks_statcharactercharacterDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_statcharactercharacterUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_statcharactercharacterUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statcharactercharacterPayload>
          }
          aggregate: {
            args: Prisma.Inducks_statcharactercharacterAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_statcharactercharacter>
          }
          groupBy: {
            args: Prisma.inducks_statcharactercharacterGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_statcharactercharacterGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_statcharactercharacterCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_statcharactercharacterCountAggregateOutputType> | number
          }
        }
      }
      inducks_statcharactercountry: {
        payload: Prisma.$inducks_statcharactercountryPayload<ExtArgs>
        fields: Prisma.inducks_statcharactercountryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_statcharactercountryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statcharactercountryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_statcharactercountryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statcharactercountryPayload>
          }
          findFirst: {
            args: Prisma.inducks_statcharactercountryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statcharactercountryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_statcharactercountryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statcharactercountryPayload>
          }
          findMany: {
            args: Prisma.inducks_statcharactercountryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statcharactercountryPayload>[]
          }
          create: {
            args: Prisma.inducks_statcharactercountryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statcharactercountryPayload>
          }
          createMany: {
            args: Prisma.inducks_statcharactercountryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_statcharactercountryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statcharactercountryPayload>
          }
          update: {
            args: Prisma.inducks_statcharactercountryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statcharactercountryPayload>
          }
          deleteMany: {
            args: Prisma.inducks_statcharactercountryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_statcharactercountryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_statcharactercountryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statcharactercountryPayload>
          }
          aggregate: {
            args: Prisma.Inducks_statcharactercountryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_statcharactercountry>
          }
          groupBy: {
            args: Prisma.inducks_statcharactercountryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_statcharactercountryGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_statcharactercountryCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_statcharactercountryCountAggregateOutputType> | number
          }
        }
      }
      inducks_statcharacterstory: {
        payload: Prisma.$inducks_statcharacterstoryPayload<ExtArgs>
        fields: Prisma.inducks_statcharacterstoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_statcharacterstoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statcharacterstoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_statcharacterstoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statcharacterstoryPayload>
          }
          findFirst: {
            args: Prisma.inducks_statcharacterstoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statcharacterstoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_statcharacterstoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statcharacterstoryPayload>
          }
          findMany: {
            args: Prisma.inducks_statcharacterstoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statcharacterstoryPayload>[]
          }
          create: {
            args: Prisma.inducks_statcharacterstoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statcharacterstoryPayload>
          }
          createMany: {
            args: Prisma.inducks_statcharacterstoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_statcharacterstoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statcharacterstoryPayload>
          }
          update: {
            args: Prisma.inducks_statcharacterstoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statcharacterstoryPayload>
          }
          deleteMany: {
            args: Prisma.inducks_statcharacterstoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_statcharacterstoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_statcharacterstoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statcharacterstoryPayload>
          }
          aggregate: {
            args: Prisma.Inducks_statcharacterstoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_statcharacterstory>
          }
          groupBy: {
            args: Prisma.inducks_statcharacterstoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_statcharacterstoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_statcharacterstoryCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_statcharacterstoryCountAggregateOutputType> | number
          }
        }
      }
      inducks_statpersoncharacter: {
        payload: Prisma.$inducks_statpersoncharacterPayload<ExtArgs>
        fields: Prisma.inducks_statpersoncharacterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_statpersoncharacterFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statpersoncharacterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_statpersoncharacterFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statpersoncharacterPayload>
          }
          findFirst: {
            args: Prisma.inducks_statpersoncharacterFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statpersoncharacterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_statpersoncharacterFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statpersoncharacterPayload>
          }
          findMany: {
            args: Prisma.inducks_statpersoncharacterFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statpersoncharacterPayload>[]
          }
          create: {
            args: Prisma.inducks_statpersoncharacterCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statpersoncharacterPayload>
          }
          createMany: {
            args: Prisma.inducks_statpersoncharacterCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_statpersoncharacterDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statpersoncharacterPayload>
          }
          update: {
            args: Prisma.inducks_statpersoncharacterUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statpersoncharacterPayload>
          }
          deleteMany: {
            args: Prisma.inducks_statpersoncharacterDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_statpersoncharacterUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_statpersoncharacterUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statpersoncharacterPayload>
          }
          aggregate: {
            args: Prisma.Inducks_statpersoncharacterAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_statpersoncharacter>
          }
          groupBy: {
            args: Prisma.inducks_statpersoncharacterGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_statpersoncharacterGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_statpersoncharacterCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_statpersoncharacterCountAggregateOutputType> | number
          }
        }
      }
      inducks_statpersoncountry: {
        payload: Prisma.$inducks_statpersoncountryPayload<ExtArgs>
        fields: Prisma.inducks_statpersoncountryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_statpersoncountryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statpersoncountryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_statpersoncountryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statpersoncountryPayload>
          }
          findFirst: {
            args: Prisma.inducks_statpersoncountryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statpersoncountryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_statpersoncountryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statpersoncountryPayload>
          }
          findMany: {
            args: Prisma.inducks_statpersoncountryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statpersoncountryPayload>[]
          }
          create: {
            args: Prisma.inducks_statpersoncountryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statpersoncountryPayload>
          }
          createMany: {
            args: Prisma.inducks_statpersoncountryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_statpersoncountryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statpersoncountryPayload>
          }
          update: {
            args: Prisma.inducks_statpersoncountryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statpersoncountryPayload>
          }
          deleteMany: {
            args: Prisma.inducks_statpersoncountryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_statpersoncountryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_statpersoncountryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statpersoncountryPayload>
          }
          aggregate: {
            args: Prisma.Inducks_statpersoncountryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_statpersoncountry>
          }
          groupBy: {
            args: Prisma.inducks_statpersoncountryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_statpersoncountryGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_statpersoncountryCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_statpersoncountryCountAggregateOutputType> | number
          }
        }
      }
      inducks_statpersonperson: {
        payload: Prisma.$inducks_statpersonpersonPayload<ExtArgs>
        fields: Prisma.inducks_statpersonpersonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_statpersonpersonFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statpersonpersonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_statpersonpersonFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statpersonpersonPayload>
          }
          findFirst: {
            args: Prisma.inducks_statpersonpersonFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statpersonpersonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_statpersonpersonFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statpersonpersonPayload>
          }
          findMany: {
            args: Prisma.inducks_statpersonpersonFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statpersonpersonPayload>[]
          }
          create: {
            args: Prisma.inducks_statpersonpersonCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statpersonpersonPayload>
          }
          createMany: {
            args: Prisma.inducks_statpersonpersonCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_statpersonpersonDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statpersonpersonPayload>
          }
          update: {
            args: Prisma.inducks_statpersonpersonUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statpersonpersonPayload>
          }
          deleteMany: {
            args: Prisma.inducks_statpersonpersonDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_statpersonpersonUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_statpersonpersonUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statpersonpersonPayload>
          }
          aggregate: {
            args: Prisma.Inducks_statpersonpersonAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_statpersonperson>
          }
          groupBy: {
            args: Prisma.inducks_statpersonpersonGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_statpersonpersonGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_statpersonpersonCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_statpersonpersonCountAggregateOutputType> | number
          }
        }
      }
      inducks_statpersonstory: {
        payload: Prisma.$inducks_statpersonstoryPayload<ExtArgs>
        fields: Prisma.inducks_statpersonstoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_statpersonstoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statpersonstoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_statpersonstoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statpersonstoryPayload>
          }
          findFirst: {
            args: Prisma.inducks_statpersonstoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statpersonstoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_statpersonstoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statpersonstoryPayload>
          }
          findMany: {
            args: Prisma.inducks_statpersonstoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statpersonstoryPayload>[]
          }
          create: {
            args: Prisma.inducks_statpersonstoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statpersonstoryPayload>
          }
          createMany: {
            args: Prisma.inducks_statpersonstoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_statpersonstoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statpersonstoryPayload>
          }
          update: {
            args: Prisma.inducks_statpersonstoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statpersonstoryPayload>
          }
          deleteMany: {
            args: Prisma.inducks_statpersonstoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_statpersonstoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_statpersonstoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_statpersonstoryPayload>
          }
          aggregate: {
            args: Prisma.Inducks_statpersonstoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_statpersonstory>
          }
          groupBy: {
            args: Prisma.inducks_statpersonstoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_statpersonstoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_statpersonstoryCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_statpersonstoryCountAggregateOutputType> | number
          }
        }
      }
      inducks_story: {
        payload: Prisma.$inducks_storyPayload<ExtArgs>
        fields: Prisma.inducks_storyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_storyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_storyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyPayload>
          }
          findFirst: {
            args: Prisma.inducks_storyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_storyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyPayload>
          }
          findMany: {
            args: Prisma.inducks_storyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyPayload>[]
          }
          create: {
            args: Prisma.inducks_storyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyPayload>
          }
          createMany: {
            args: Prisma.inducks_storyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_storyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyPayload>
          }
          update: {
            args: Prisma.inducks_storyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyPayload>
          }
          deleteMany: {
            args: Prisma.inducks_storyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_storyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_storyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyPayload>
          }
          aggregate: {
            args: Prisma.Inducks_storyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_story>
          }
          groupBy: {
            args: Prisma.inducks_storyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_storyGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_storyCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_storyCountAggregateOutputType> | number
          }
        }
      }
      inducks_storycodes: {
        payload: Prisma.$inducks_storycodesPayload<ExtArgs>
        fields: Prisma.inducks_storycodesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_storycodesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storycodesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_storycodesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storycodesPayload>
          }
          findFirst: {
            args: Prisma.inducks_storycodesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storycodesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_storycodesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storycodesPayload>
          }
          findMany: {
            args: Prisma.inducks_storycodesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storycodesPayload>[]
          }
          create: {
            args: Prisma.inducks_storycodesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storycodesPayload>
          }
          createMany: {
            args: Prisma.inducks_storycodesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_storycodesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storycodesPayload>
          }
          update: {
            args: Prisma.inducks_storycodesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storycodesPayload>
          }
          deleteMany: {
            args: Prisma.inducks_storycodesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_storycodesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_storycodesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storycodesPayload>
          }
          aggregate: {
            args: Prisma.Inducks_storycodesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_storycodes>
          }
          groupBy: {
            args: Prisma.inducks_storycodesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_storycodesGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_storycodesCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_storycodesCountAggregateOutputType> | number
          }
        }
      }
      inducks_storydescription: {
        payload: Prisma.$inducks_storydescriptionPayload<ExtArgs>
        fields: Prisma.inducks_storydescriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_storydescriptionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storydescriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_storydescriptionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storydescriptionPayload>
          }
          findFirst: {
            args: Prisma.inducks_storydescriptionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storydescriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_storydescriptionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storydescriptionPayload>
          }
          findMany: {
            args: Prisma.inducks_storydescriptionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storydescriptionPayload>[]
          }
          create: {
            args: Prisma.inducks_storydescriptionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storydescriptionPayload>
          }
          createMany: {
            args: Prisma.inducks_storydescriptionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_storydescriptionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storydescriptionPayload>
          }
          update: {
            args: Prisma.inducks_storydescriptionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storydescriptionPayload>
          }
          deleteMany: {
            args: Prisma.inducks_storydescriptionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_storydescriptionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_storydescriptionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storydescriptionPayload>
          }
          aggregate: {
            args: Prisma.Inducks_storydescriptionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_storydescription>
          }
          groupBy: {
            args: Prisma.inducks_storydescriptionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_storydescriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_storydescriptionCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_storydescriptionCountAggregateOutputType> | number
          }
        }
      }
      inducks_storyheader: {
        payload: Prisma.$inducks_storyheaderPayload<ExtArgs>
        fields: Prisma.inducks_storyheaderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_storyheaderFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyheaderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_storyheaderFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyheaderPayload>
          }
          findFirst: {
            args: Prisma.inducks_storyheaderFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyheaderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_storyheaderFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyheaderPayload>
          }
          findMany: {
            args: Prisma.inducks_storyheaderFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyheaderPayload>[]
          }
          create: {
            args: Prisma.inducks_storyheaderCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyheaderPayload>
          }
          createMany: {
            args: Prisma.inducks_storyheaderCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_storyheaderDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyheaderPayload>
          }
          update: {
            args: Prisma.inducks_storyheaderUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyheaderPayload>
          }
          deleteMany: {
            args: Prisma.inducks_storyheaderDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_storyheaderUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_storyheaderUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyheaderPayload>
          }
          aggregate: {
            args: Prisma.Inducks_storyheaderAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_storyheader>
          }
          groupBy: {
            args: Prisma.inducks_storyheaderGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_storyheaderGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_storyheaderCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_storyheaderCountAggregateOutputType> | number
          }
        }
      }
      inducks_storyjob: {
        payload: Prisma.$inducks_storyjobPayload<ExtArgs>
        fields: Prisma.inducks_storyjobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_storyjobFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyjobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_storyjobFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyjobPayload>
          }
          findFirst: {
            args: Prisma.inducks_storyjobFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyjobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_storyjobFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyjobPayload>
          }
          findMany: {
            args: Prisma.inducks_storyjobFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyjobPayload>[]
          }
          create: {
            args: Prisma.inducks_storyjobCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyjobPayload>
          }
          createMany: {
            args: Prisma.inducks_storyjobCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_storyjobDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyjobPayload>
          }
          update: {
            args: Prisma.inducks_storyjobUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyjobPayload>
          }
          deleteMany: {
            args: Prisma.inducks_storyjobDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_storyjobUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_storyjobUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyjobPayload>
          }
          aggregate: {
            args: Prisma.Inducks_storyjobAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_storyjob>
          }
          groupBy: {
            args: Prisma.inducks_storyjobGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_storyjobGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_storyjobCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_storyjobCountAggregateOutputType> | number
          }
        }
      }
      inducks_storyreference: {
        payload: Prisma.$inducks_storyreferencePayload<ExtArgs>
        fields: Prisma.inducks_storyreferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_storyreferenceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_storyreferenceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyreferencePayload>
          }
          findFirst: {
            args: Prisma.inducks_storyreferenceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_storyreferenceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyreferencePayload>
          }
          findMany: {
            args: Prisma.inducks_storyreferenceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyreferencePayload>[]
          }
          create: {
            args: Prisma.inducks_storyreferenceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyreferencePayload>
          }
          createMany: {
            args: Prisma.inducks_storyreferenceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_storyreferenceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyreferencePayload>
          }
          update: {
            args: Prisma.inducks_storyreferenceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyreferencePayload>
          }
          deleteMany: {
            args: Prisma.inducks_storyreferenceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_storyreferenceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_storyreferenceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyreferencePayload>
          }
          aggregate: {
            args: Prisma.Inducks_storyreferenceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_storyreference>
          }
          groupBy: {
            args: Prisma.inducks_storyreferenceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_storyreferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_storyreferenceCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_storyreferenceCountAggregateOutputType> | number
          }
        }
      }
      inducks_storysubseries: {
        payload: Prisma.$inducks_storysubseriesPayload<ExtArgs>
        fields: Prisma.inducks_storysubseriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_storysubseriesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storysubseriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_storysubseriesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storysubseriesPayload>
          }
          findFirst: {
            args: Prisma.inducks_storysubseriesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storysubseriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_storysubseriesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storysubseriesPayload>
          }
          findMany: {
            args: Prisma.inducks_storysubseriesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storysubseriesPayload>[]
          }
          create: {
            args: Prisma.inducks_storysubseriesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storysubseriesPayload>
          }
          createMany: {
            args: Prisma.inducks_storysubseriesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_storysubseriesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storysubseriesPayload>
          }
          update: {
            args: Prisma.inducks_storysubseriesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storysubseriesPayload>
          }
          deleteMany: {
            args: Prisma.inducks_storysubseriesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_storysubseriesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_storysubseriesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storysubseriesPayload>
          }
          aggregate: {
            args: Prisma.Inducks_storysubseriesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_storysubseries>
          }
          groupBy: {
            args: Prisma.inducks_storysubseriesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_storysubseriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_storysubseriesCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_storysubseriesCountAggregateOutputType> | number
          }
        }
      }
      inducks_storyurl: {
        payload: Prisma.$inducks_storyurlPayload<ExtArgs>
        fields: Prisma.inducks_storyurlFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_storyurlFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyurlPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_storyurlFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyurlPayload>
          }
          findFirst: {
            args: Prisma.inducks_storyurlFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyurlPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_storyurlFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyurlPayload>
          }
          findMany: {
            args: Prisma.inducks_storyurlFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyurlPayload>[]
          }
          create: {
            args: Prisma.inducks_storyurlCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyurlPayload>
          }
          createMany: {
            args: Prisma.inducks_storyurlCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_storyurlDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyurlPayload>
          }
          update: {
            args: Prisma.inducks_storyurlUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyurlPayload>
          }
          deleteMany: {
            args: Prisma.inducks_storyurlDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_storyurlUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_storyurlUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyurlPayload>
          }
          aggregate: {
            args: Prisma.Inducks_storyurlAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_storyurl>
          }
          groupBy: {
            args: Prisma.inducks_storyurlGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_storyurlGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_storyurlCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_storyurlCountAggregateOutputType> | number
          }
        }
      }
      inducks_storyversion: {
        payload: Prisma.$inducks_storyversionPayload<ExtArgs>
        fields: Prisma.inducks_storyversionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_storyversionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyversionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_storyversionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyversionPayload>
          }
          findFirst: {
            args: Prisma.inducks_storyversionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyversionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_storyversionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyversionPayload>
          }
          findMany: {
            args: Prisma.inducks_storyversionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyversionPayload>[]
          }
          create: {
            args: Prisma.inducks_storyversionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyversionPayload>
          }
          createMany: {
            args: Prisma.inducks_storyversionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_storyversionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyversionPayload>
          }
          update: {
            args: Prisma.inducks_storyversionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyversionPayload>
          }
          deleteMany: {
            args: Prisma.inducks_storyversionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_storyversionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_storyversionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyversionPayload>
          }
          aggregate: {
            args: Prisma.Inducks_storyversionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_storyversion>
          }
          groupBy: {
            args: Prisma.inducks_storyversionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_storyversionGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_storyversionCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_storyversionCountAggregateOutputType> | number
          }
        }
      }
      inducks_storyversion_nofulltext: {
        payload: Prisma.$inducks_storyversion_nofulltextPayload<ExtArgs>
        fields: Prisma.inducks_storyversion_nofulltextFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_storyversion_nofulltextFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyversion_nofulltextPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_storyversion_nofulltextFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyversion_nofulltextPayload>
          }
          findFirst: {
            args: Prisma.inducks_storyversion_nofulltextFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyversion_nofulltextPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_storyversion_nofulltextFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyversion_nofulltextPayload>
          }
          findMany: {
            args: Prisma.inducks_storyversion_nofulltextFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyversion_nofulltextPayload>[]
          }
          create: {
            args: Prisma.inducks_storyversion_nofulltextCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyversion_nofulltextPayload>
          }
          createMany: {
            args: Prisma.inducks_storyversion_nofulltextCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_storyversion_nofulltextDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyversion_nofulltextPayload>
          }
          update: {
            args: Prisma.inducks_storyversion_nofulltextUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyversion_nofulltextPayload>
          }
          deleteMany: {
            args: Prisma.inducks_storyversion_nofulltextDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_storyversion_nofulltextUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_storyversion_nofulltextUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_storyversion_nofulltextPayload>
          }
          aggregate: {
            args: Prisma.Inducks_storyversion_nofulltextAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_storyversion_nofulltext>
          }
          groupBy: {
            args: Prisma.inducks_storyversion_nofulltextGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_storyversion_nofulltextGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_storyversion_nofulltextCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_storyversion_nofulltextCountAggregateOutputType> | number
          }
        }
      }
      inducks_studio: {
        payload: Prisma.$inducks_studioPayload<ExtArgs>
        fields: Prisma.inducks_studioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_studioFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_studioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_studioFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_studioPayload>
          }
          findFirst: {
            args: Prisma.inducks_studioFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_studioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_studioFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_studioPayload>
          }
          findMany: {
            args: Prisma.inducks_studioFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_studioPayload>[]
          }
          create: {
            args: Prisma.inducks_studioCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_studioPayload>
          }
          createMany: {
            args: Prisma.inducks_studioCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_studioDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_studioPayload>
          }
          update: {
            args: Prisma.inducks_studioUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_studioPayload>
          }
          deleteMany: {
            args: Prisma.inducks_studioDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_studioUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_studioUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_studioPayload>
          }
          aggregate: {
            args: Prisma.Inducks_studioAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_studio>
          }
          groupBy: {
            args: Prisma.inducks_studioGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_studioGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_studioCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_studioCountAggregateOutputType> | number
          }
        }
      }
      inducks_studiowork: {
        payload: Prisma.$inducks_studioworkPayload<ExtArgs>
        fields: Prisma.inducks_studioworkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_studioworkFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_studioworkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_studioworkFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_studioworkPayload>
          }
          findFirst: {
            args: Prisma.inducks_studioworkFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_studioworkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_studioworkFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_studioworkPayload>
          }
          findMany: {
            args: Prisma.inducks_studioworkFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_studioworkPayload>[]
          }
          create: {
            args: Prisma.inducks_studioworkCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_studioworkPayload>
          }
          createMany: {
            args: Prisma.inducks_studioworkCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_studioworkDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_studioworkPayload>
          }
          update: {
            args: Prisma.inducks_studioworkUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_studioworkPayload>
          }
          deleteMany: {
            args: Prisma.inducks_studioworkDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_studioworkUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_studioworkUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_studioworkPayload>
          }
          aggregate: {
            args: Prisma.Inducks_studioworkAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_studiowork>
          }
          groupBy: {
            args: Prisma.inducks_studioworkGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_studioworkGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_studioworkCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_studioworkCountAggregateOutputType> | number
          }
        }
      }
      inducks_subseries: {
        payload: Prisma.$inducks_subseriesPayload<ExtArgs>
        fields: Prisma.inducks_subseriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_subseriesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_subseriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_subseriesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_subseriesPayload>
          }
          findFirst: {
            args: Prisma.inducks_subseriesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_subseriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_subseriesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_subseriesPayload>
          }
          findMany: {
            args: Prisma.inducks_subseriesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_subseriesPayload>[]
          }
          create: {
            args: Prisma.inducks_subseriesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_subseriesPayload>
          }
          createMany: {
            args: Prisma.inducks_subseriesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_subseriesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_subseriesPayload>
          }
          update: {
            args: Prisma.inducks_subseriesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_subseriesPayload>
          }
          deleteMany: {
            args: Prisma.inducks_subseriesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_subseriesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_subseriesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_subseriesPayload>
          }
          aggregate: {
            args: Prisma.Inducks_subseriesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_subseries>
          }
          groupBy: {
            args: Prisma.inducks_subseriesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_subseriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_subseriesCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_subseriesCountAggregateOutputType> | number
          }
        }
      }
      inducks_subseriesname: {
        payload: Prisma.$inducks_subseriesnamePayload<ExtArgs>
        fields: Prisma.inducks_subseriesnameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_subseriesnameFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_subseriesnamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_subseriesnameFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_subseriesnamePayload>
          }
          findFirst: {
            args: Prisma.inducks_subseriesnameFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_subseriesnamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_subseriesnameFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_subseriesnamePayload>
          }
          findMany: {
            args: Prisma.inducks_subseriesnameFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_subseriesnamePayload>[]
          }
          create: {
            args: Prisma.inducks_subseriesnameCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_subseriesnamePayload>
          }
          createMany: {
            args: Prisma.inducks_subseriesnameCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_subseriesnameDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_subseriesnamePayload>
          }
          update: {
            args: Prisma.inducks_subseriesnameUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_subseriesnamePayload>
          }
          deleteMany: {
            args: Prisma.inducks_subseriesnameDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_subseriesnameUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_subseriesnameUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_subseriesnamePayload>
          }
          aggregate: {
            args: Prisma.Inducks_subseriesnameAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_subseriesname>
          }
          groupBy: {
            args: Prisma.inducks_subseriesnameGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_subseriesnameGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_subseriesnameCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_subseriesnameCountAggregateOutputType> | number
          }
        }
      }
      inducks_substory: {
        payload: Prisma.$inducks_substoryPayload<ExtArgs>
        fields: Prisma.inducks_substoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_substoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_substoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_substoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_substoryPayload>
          }
          findFirst: {
            args: Prisma.inducks_substoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_substoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_substoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_substoryPayload>
          }
          findMany: {
            args: Prisma.inducks_substoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_substoryPayload>[]
          }
          create: {
            args: Prisma.inducks_substoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_substoryPayload>
          }
          createMany: {
            args: Prisma.inducks_substoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_substoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_substoryPayload>
          }
          update: {
            args: Prisma.inducks_substoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_substoryPayload>
          }
          deleteMany: {
            args: Prisma.inducks_substoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_substoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_substoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_substoryPayload>
          }
          aggregate: {
            args: Prisma.Inducks_substoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_substory>
          }
          groupBy: {
            args: Prisma.inducks_substoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_substoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_substoryCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_substoryCountAggregateOutputType> | number
          }
        }
      }
      inducks_team: {
        payload: Prisma.$inducks_teamPayload<ExtArgs>
        fields: Prisma.inducks_teamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_teamFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_teamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_teamFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_teamPayload>
          }
          findFirst: {
            args: Prisma.inducks_teamFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_teamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_teamFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_teamPayload>
          }
          findMany: {
            args: Prisma.inducks_teamFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_teamPayload>[]
          }
          create: {
            args: Prisma.inducks_teamCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_teamPayload>
          }
          createMany: {
            args: Prisma.inducks_teamCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_teamDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_teamPayload>
          }
          update: {
            args: Prisma.inducks_teamUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_teamPayload>
          }
          deleteMany: {
            args: Prisma.inducks_teamDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_teamUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_teamUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_teamPayload>
          }
          aggregate: {
            args: Prisma.Inducks_teamAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_team>
          }
          groupBy: {
            args: Prisma.inducks_teamGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_teamGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_teamCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_teamCountAggregateOutputType> | number
          }
        }
      }
      inducks_teammember: {
        payload: Prisma.$inducks_teammemberPayload<ExtArgs>
        fields: Prisma.inducks_teammemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_teammemberFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_teammemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_teammemberFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_teammemberPayload>
          }
          findFirst: {
            args: Prisma.inducks_teammemberFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_teammemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_teammemberFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_teammemberPayload>
          }
          findMany: {
            args: Prisma.inducks_teammemberFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_teammemberPayload>[]
          }
          create: {
            args: Prisma.inducks_teammemberCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_teammemberPayload>
          }
          createMany: {
            args: Prisma.inducks_teammemberCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_teammemberDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_teammemberPayload>
          }
          update: {
            args: Prisma.inducks_teammemberUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_teammemberPayload>
          }
          deleteMany: {
            args: Prisma.inducks_teammemberDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_teammemberUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_teammemberUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_teammemberPayload>
          }
          aggregate: {
            args: Prisma.Inducks_teammemberAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_teammember>
          }
          groupBy: {
            args: Prisma.inducks_teammemberGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_teammemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_teammemberCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_teammemberCountAggregateOutputType> | number
          }
        }
      }
      inducks_ucrelation: {
        payload: Prisma.$inducks_ucrelationPayload<ExtArgs>
        fields: Prisma.inducks_ucrelationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_ucrelationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_ucrelationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_ucrelationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_ucrelationPayload>
          }
          findFirst: {
            args: Prisma.inducks_ucrelationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_ucrelationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_ucrelationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_ucrelationPayload>
          }
          findMany: {
            args: Prisma.inducks_ucrelationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_ucrelationPayload>[]
          }
          create: {
            args: Prisma.inducks_ucrelationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_ucrelationPayload>
          }
          createMany: {
            args: Prisma.inducks_ucrelationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_ucrelationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_ucrelationPayload>
          }
          update: {
            args: Prisma.inducks_ucrelationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_ucrelationPayload>
          }
          deleteMany: {
            args: Prisma.inducks_ucrelationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_ucrelationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_ucrelationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_ucrelationPayload>
          }
          aggregate: {
            args: Prisma.Inducks_ucrelationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_ucrelation>
          }
          groupBy: {
            args: Prisma.inducks_ucrelationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_ucrelationGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_ucrelationCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_ucrelationCountAggregateOutputType> | number
          }
        }
      }
      inducks_universe: {
        payload: Prisma.$inducks_universePayload<ExtArgs>
        fields: Prisma.inducks_universeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_universeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_universePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_universeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_universePayload>
          }
          findFirst: {
            args: Prisma.inducks_universeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_universePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_universeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_universePayload>
          }
          findMany: {
            args: Prisma.inducks_universeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_universePayload>[]
          }
          create: {
            args: Prisma.inducks_universeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_universePayload>
          }
          createMany: {
            args: Prisma.inducks_universeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_universeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_universePayload>
          }
          update: {
            args: Prisma.inducks_universeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_universePayload>
          }
          deleteMany: {
            args: Prisma.inducks_universeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_universeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_universeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_universePayload>
          }
          aggregate: {
            args: Prisma.Inducks_universeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_universe>
          }
          groupBy: {
            args: Prisma.inducks_universeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_universeGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_universeCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_universeCountAggregateOutputType> | number
          }
        }
      }
      inducks_universename: {
        payload: Prisma.$inducks_universenamePayload<ExtArgs>
        fields: Prisma.inducks_universenameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inducks_universenameFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_universenamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inducks_universenameFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_universenamePayload>
          }
          findFirst: {
            args: Prisma.inducks_universenameFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_universenamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inducks_universenameFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_universenamePayload>
          }
          findMany: {
            args: Prisma.inducks_universenameFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_universenamePayload>[]
          }
          create: {
            args: Prisma.inducks_universenameCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_universenamePayload>
          }
          createMany: {
            args: Prisma.inducks_universenameCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.inducks_universenameDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_universenamePayload>
          }
          update: {
            args: Prisma.inducks_universenameUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_universenamePayload>
          }
          deleteMany: {
            args: Prisma.inducks_universenameDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.inducks_universenameUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.inducks_universenameUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$inducks_universenamePayload>
          }
          aggregate: {
            args: Prisma.Inducks_universenameAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInducks_universename>
          }
          groupBy: {
            args: Prisma.inducks_universenameGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_universenameGroupByOutputType>[]
          }
          count: {
            args: Prisma.inducks_universenameCountArgs<ExtArgs>,
            result: $Utils.Optional<Inducks_universenameCountAggregateOutputType> | number
          }
        }
      }
      numeros_cpt: {
        payload: Prisma.$numeros_cptPayload<ExtArgs>
        fields: Prisma.numeros_cptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.numeros_cptFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$numeros_cptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.numeros_cptFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$numeros_cptPayload>
          }
          findFirst: {
            args: Prisma.numeros_cptFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$numeros_cptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.numeros_cptFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$numeros_cptPayload>
          }
          findMany: {
            args: Prisma.numeros_cptFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$numeros_cptPayload>[]
          }
          create: {
            args: Prisma.numeros_cptCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$numeros_cptPayload>
          }
          createMany: {
            args: Prisma.numeros_cptCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.numeros_cptDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$numeros_cptPayload>
          }
          update: {
            args: Prisma.numeros_cptUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$numeros_cptPayload>
          }
          deleteMany: {
            args: Prisma.numeros_cptDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.numeros_cptUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.numeros_cptUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$numeros_cptPayload>
          }
          aggregate: {
            args: Prisma.Numeros_cptAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNumeros_cpt>
          }
          groupBy: {
            args: Prisma.numeros_cptGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Numeros_cptGroupByOutputType>[]
          }
          count: {
            args: Prisma.numeros_cptCountArgs<ExtArgs>,
            result: $Utils.Optional<Numeros_cptCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model datasets_entryurls
   */

  export type AggregateDatasets_entryurls = {
    _count: Datasets_entryurlsCountAggregateOutputType | null
    _avg: Datasets_entryurlsAvgAggregateOutputType | null
    _sum: Datasets_entryurlsSumAggregateOutputType | null
    _min: Datasets_entryurlsMinAggregateOutputType | null
    _max: Datasets_entryurlsMaxAggregateOutputType | null
  }

  export type Datasets_entryurlsAvgAggregateOutputType = {
    id: number | null
    dataset_id: number | null
  }

  export type Datasets_entryurlsSumAggregateOutputType = {
    id: number | null
    dataset_id: number | null
  }

  export type Datasets_entryurlsMinAggregateOutputType = {
    id: number | null
    dataset_id: number | null
    sitecode_url: string | null
  }

  export type Datasets_entryurlsMaxAggregateOutputType = {
    id: number | null
    dataset_id: number | null
    sitecode_url: string | null
  }

  export type Datasets_entryurlsCountAggregateOutputType = {
    id: number
    dataset_id: number
    sitecode_url: number
    _all: number
  }


  export type Datasets_entryurlsAvgAggregateInputType = {
    id?: true
    dataset_id?: true
  }

  export type Datasets_entryurlsSumAggregateInputType = {
    id?: true
    dataset_id?: true
  }

  export type Datasets_entryurlsMinAggregateInputType = {
    id?: true
    dataset_id?: true
    sitecode_url?: true
  }

  export type Datasets_entryurlsMaxAggregateInputType = {
    id?: true
    dataset_id?: true
    sitecode_url?: true
  }

  export type Datasets_entryurlsCountAggregateInputType = {
    id?: true
    dataset_id?: true
    sitecode_url?: true
    _all?: true
  }

  export type Datasets_entryurlsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which datasets_entryurls to aggregate.
     */
    where?: datasets_entryurlsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of datasets_entryurls to fetch.
     */
    orderBy?: datasets_entryurlsOrderByWithRelationInput | datasets_entryurlsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: datasets_entryurlsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` datasets_entryurls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` datasets_entryurls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned datasets_entryurls
    **/
    _count?: true | Datasets_entryurlsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Datasets_entryurlsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Datasets_entryurlsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Datasets_entryurlsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Datasets_entryurlsMaxAggregateInputType
  }

  export type GetDatasets_entryurlsAggregateType<T extends Datasets_entryurlsAggregateArgs> = {
        [P in keyof T & keyof AggregateDatasets_entryurls]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDatasets_entryurls[P]>
      : GetScalarType<T[P], AggregateDatasets_entryurls[P]>
  }




  export type datasets_entryurlsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: datasets_entryurlsWhereInput
    orderBy?: datasets_entryurlsOrderByWithAggregationInput | datasets_entryurlsOrderByWithAggregationInput[]
    by: Datasets_entryurlsScalarFieldEnum[] | Datasets_entryurlsScalarFieldEnum
    having?: datasets_entryurlsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Datasets_entryurlsCountAggregateInputType | true
    _avg?: Datasets_entryurlsAvgAggregateInputType
    _sum?: Datasets_entryurlsSumAggregateInputType
    _min?: Datasets_entryurlsMinAggregateInputType
    _max?: Datasets_entryurlsMaxAggregateInputType
  }

  export type Datasets_entryurlsGroupByOutputType = {
    id: number
    dataset_id: number
    sitecode_url: string
    _count: Datasets_entryurlsCountAggregateOutputType | null
    _avg: Datasets_entryurlsAvgAggregateOutputType | null
    _sum: Datasets_entryurlsSumAggregateOutputType | null
    _min: Datasets_entryurlsMinAggregateOutputType | null
    _max: Datasets_entryurlsMaxAggregateOutputType | null
  }

  type GetDatasets_entryurlsGroupByPayload<T extends datasets_entryurlsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Datasets_entryurlsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Datasets_entryurlsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Datasets_entryurlsGroupByOutputType[P]>
            : GetScalarType<T[P], Datasets_entryurlsGroupByOutputType[P]>
        }
      >
    >


  export type datasets_entryurlsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dataset_id?: boolean
    sitecode_url?: boolean
  }, ExtArgs["result"]["datasets_entryurls"]>

  export type datasets_entryurlsSelectScalar = {
    id?: boolean
    dataset_id?: boolean
    sitecode_url?: boolean
  }


  export type $datasets_entryurlsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "datasets_entryurls"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: number
      dataset_id: number
      sitecode_url: string
    }, ExtArgs["result"]["datasets_entryurls"]>
    composites: {}
  }


  type datasets_entryurlsGetPayload<S extends boolean | null | undefined | datasets_entryurlsDefaultArgs> = $Result.GetResult<Prisma.$datasets_entryurlsPayload, S>

  type datasets_entryurlsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<datasets_entryurlsFindManyArgs, 'select' | 'include'> & {
      select?: Datasets_entryurlsCountAggregateInputType | true
    }

  export interface datasets_entryurlsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['datasets_entryurls'], meta: { name: 'datasets_entryurls' } }
    /**
     * Find zero or one Datasets_entryurls that matches the filter.
     * @param {datasets_entryurlsFindUniqueArgs} args - Arguments to find a Datasets_entryurls
     * @example
     * // Get one Datasets_entryurls
     * const datasets_entryurls = await prisma.datasets_entryurls.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends datasets_entryurlsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, datasets_entryurlsFindUniqueArgs<ExtArgs>>
    ): Prisma__datasets_entryurlsClient<$Result.GetResult<Prisma.$datasets_entryurlsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Datasets_entryurls that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {datasets_entryurlsFindUniqueOrThrowArgs} args - Arguments to find a Datasets_entryurls
     * @example
     * // Get one Datasets_entryurls
     * const datasets_entryurls = await prisma.datasets_entryurls.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends datasets_entryurlsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, datasets_entryurlsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__datasets_entryurlsClient<$Result.GetResult<Prisma.$datasets_entryurlsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Datasets_entryurls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datasets_entryurlsFindFirstArgs} args - Arguments to find a Datasets_entryurls
     * @example
     * // Get one Datasets_entryurls
     * const datasets_entryurls = await prisma.datasets_entryurls.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends datasets_entryurlsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, datasets_entryurlsFindFirstArgs<ExtArgs>>
    ): Prisma__datasets_entryurlsClient<$Result.GetResult<Prisma.$datasets_entryurlsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Datasets_entryurls that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datasets_entryurlsFindFirstOrThrowArgs} args - Arguments to find a Datasets_entryurls
     * @example
     * // Get one Datasets_entryurls
     * const datasets_entryurls = await prisma.datasets_entryurls.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends datasets_entryurlsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, datasets_entryurlsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__datasets_entryurlsClient<$Result.GetResult<Prisma.$datasets_entryurlsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Datasets_entryurls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datasets_entryurlsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Datasets_entryurls
     * const datasets_entryurls = await prisma.datasets_entryurls.findMany()
     * 
     * // Get first 10 Datasets_entryurls
     * const datasets_entryurls = await prisma.datasets_entryurls.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const datasets_entryurlsWithIdOnly = await prisma.datasets_entryurls.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends datasets_entryurlsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, datasets_entryurlsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$datasets_entryurlsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Datasets_entryurls.
     * @param {datasets_entryurlsCreateArgs} args - Arguments to create a Datasets_entryurls.
     * @example
     * // Create one Datasets_entryurls
     * const Datasets_entryurls = await prisma.datasets_entryurls.create({
     *   data: {
     *     // ... data to create a Datasets_entryurls
     *   }
     * })
     * 
    **/
    create<T extends datasets_entryurlsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, datasets_entryurlsCreateArgs<ExtArgs>>
    ): Prisma__datasets_entryurlsClient<$Result.GetResult<Prisma.$datasets_entryurlsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Datasets_entryurls.
     *     @param {datasets_entryurlsCreateManyArgs} args - Arguments to create many Datasets_entryurls.
     *     @example
     *     // Create many Datasets_entryurls
     *     const datasets_entryurls = await prisma.datasets_entryurls.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends datasets_entryurlsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, datasets_entryurlsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Datasets_entryurls.
     * @param {datasets_entryurlsDeleteArgs} args - Arguments to delete one Datasets_entryurls.
     * @example
     * // Delete one Datasets_entryurls
     * const Datasets_entryurls = await prisma.datasets_entryurls.delete({
     *   where: {
     *     // ... filter to delete one Datasets_entryurls
     *   }
     * })
     * 
    **/
    delete<T extends datasets_entryurlsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, datasets_entryurlsDeleteArgs<ExtArgs>>
    ): Prisma__datasets_entryurlsClient<$Result.GetResult<Prisma.$datasets_entryurlsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Datasets_entryurls.
     * @param {datasets_entryurlsUpdateArgs} args - Arguments to update one Datasets_entryurls.
     * @example
     * // Update one Datasets_entryurls
     * const datasets_entryurls = await prisma.datasets_entryurls.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends datasets_entryurlsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, datasets_entryurlsUpdateArgs<ExtArgs>>
    ): Prisma__datasets_entryurlsClient<$Result.GetResult<Prisma.$datasets_entryurlsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Datasets_entryurls.
     * @param {datasets_entryurlsDeleteManyArgs} args - Arguments to filter Datasets_entryurls to delete.
     * @example
     * // Delete a few Datasets_entryurls
     * const { count } = await prisma.datasets_entryurls.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends datasets_entryurlsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, datasets_entryurlsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Datasets_entryurls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datasets_entryurlsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Datasets_entryurls
     * const datasets_entryurls = await prisma.datasets_entryurls.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends datasets_entryurlsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, datasets_entryurlsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Datasets_entryurls.
     * @param {datasets_entryurlsUpsertArgs} args - Arguments to update or create a Datasets_entryurls.
     * @example
     * // Update or create a Datasets_entryurls
     * const datasets_entryurls = await prisma.datasets_entryurls.upsert({
     *   create: {
     *     // ... data to create a Datasets_entryurls
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Datasets_entryurls we want to update
     *   }
     * })
    **/
    upsert<T extends datasets_entryurlsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, datasets_entryurlsUpsertArgs<ExtArgs>>
    ): Prisma__datasets_entryurlsClient<$Result.GetResult<Prisma.$datasets_entryurlsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Datasets_entryurls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datasets_entryurlsCountArgs} args - Arguments to filter Datasets_entryurls to count.
     * @example
     * // Count the number of Datasets_entryurls
     * const count = await prisma.datasets_entryurls.count({
     *   where: {
     *     // ... the filter for the Datasets_entryurls we want to count
     *   }
     * })
    **/
    count<T extends datasets_entryurlsCountArgs>(
      args?: Subset<T, datasets_entryurlsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Datasets_entryurlsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Datasets_entryurls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Datasets_entryurlsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Datasets_entryurlsAggregateArgs>(args: Subset<T, Datasets_entryurlsAggregateArgs>): Prisma.PrismaPromise<GetDatasets_entryurlsAggregateType<T>>

    /**
     * Group by Datasets_entryurls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datasets_entryurlsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends datasets_entryurlsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: datasets_entryurlsGroupByArgs['orderBy'] }
        : { orderBy?: datasets_entryurlsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, datasets_entryurlsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDatasets_entryurlsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the datasets_entryurls model
   */
  readonly fields: datasets_entryurlsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for datasets_entryurls.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__datasets_entryurlsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the datasets_entryurls model
   */ 
  interface datasets_entryurlsFieldRefs {
    readonly id: FieldRef<"datasets_entryurls", 'Int'>
    readonly dataset_id: FieldRef<"datasets_entryurls", 'Int'>
    readonly sitecode_url: FieldRef<"datasets_entryurls", 'String'>
  }
    

  // Custom InputTypes

  /**
   * datasets_entryurls findUnique
   */
  export type datasets_entryurlsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datasets_entryurls
     */
    select?: datasets_entryurlsSelect<ExtArgs> | null
    /**
     * Filter, which datasets_entryurls to fetch.
     */
    where: datasets_entryurlsWhereUniqueInput
  }


  /**
   * datasets_entryurls findUniqueOrThrow
   */
  export type datasets_entryurlsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datasets_entryurls
     */
    select?: datasets_entryurlsSelect<ExtArgs> | null
    /**
     * Filter, which datasets_entryurls to fetch.
     */
    where: datasets_entryurlsWhereUniqueInput
  }


  /**
   * datasets_entryurls findFirst
   */
  export type datasets_entryurlsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datasets_entryurls
     */
    select?: datasets_entryurlsSelect<ExtArgs> | null
    /**
     * Filter, which datasets_entryurls to fetch.
     */
    where?: datasets_entryurlsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of datasets_entryurls to fetch.
     */
    orderBy?: datasets_entryurlsOrderByWithRelationInput | datasets_entryurlsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for datasets_entryurls.
     */
    cursor?: datasets_entryurlsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` datasets_entryurls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` datasets_entryurls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of datasets_entryurls.
     */
    distinct?: Datasets_entryurlsScalarFieldEnum | Datasets_entryurlsScalarFieldEnum[]
  }


  /**
   * datasets_entryurls findFirstOrThrow
   */
  export type datasets_entryurlsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datasets_entryurls
     */
    select?: datasets_entryurlsSelect<ExtArgs> | null
    /**
     * Filter, which datasets_entryurls to fetch.
     */
    where?: datasets_entryurlsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of datasets_entryurls to fetch.
     */
    orderBy?: datasets_entryurlsOrderByWithRelationInput | datasets_entryurlsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for datasets_entryurls.
     */
    cursor?: datasets_entryurlsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` datasets_entryurls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` datasets_entryurls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of datasets_entryurls.
     */
    distinct?: Datasets_entryurlsScalarFieldEnum | Datasets_entryurlsScalarFieldEnum[]
  }


  /**
   * datasets_entryurls findMany
   */
  export type datasets_entryurlsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datasets_entryurls
     */
    select?: datasets_entryurlsSelect<ExtArgs> | null
    /**
     * Filter, which datasets_entryurls to fetch.
     */
    where?: datasets_entryurlsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of datasets_entryurls to fetch.
     */
    orderBy?: datasets_entryurlsOrderByWithRelationInput | datasets_entryurlsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing datasets_entryurls.
     */
    cursor?: datasets_entryurlsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` datasets_entryurls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` datasets_entryurls.
     */
    skip?: number
    distinct?: Datasets_entryurlsScalarFieldEnum | Datasets_entryurlsScalarFieldEnum[]
  }


  /**
   * datasets_entryurls create
   */
  export type datasets_entryurlsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datasets_entryurls
     */
    select?: datasets_entryurlsSelect<ExtArgs> | null
    /**
     * The data needed to create a datasets_entryurls.
     */
    data: XOR<datasets_entryurlsCreateInput, datasets_entryurlsUncheckedCreateInput>
  }


  /**
   * datasets_entryurls createMany
   */
  export type datasets_entryurlsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many datasets_entryurls.
     */
    data: datasets_entryurlsCreateManyInput | datasets_entryurlsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * datasets_entryurls update
   */
  export type datasets_entryurlsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datasets_entryurls
     */
    select?: datasets_entryurlsSelect<ExtArgs> | null
    /**
     * The data needed to update a datasets_entryurls.
     */
    data: XOR<datasets_entryurlsUpdateInput, datasets_entryurlsUncheckedUpdateInput>
    /**
     * Choose, which datasets_entryurls to update.
     */
    where: datasets_entryurlsWhereUniqueInput
  }


  /**
   * datasets_entryurls updateMany
   */
  export type datasets_entryurlsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update datasets_entryurls.
     */
    data: XOR<datasets_entryurlsUpdateManyMutationInput, datasets_entryurlsUncheckedUpdateManyInput>
    /**
     * Filter which datasets_entryurls to update
     */
    where?: datasets_entryurlsWhereInput
  }


  /**
   * datasets_entryurls upsert
   */
  export type datasets_entryurlsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datasets_entryurls
     */
    select?: datasets_entryurlsSelect<ExtArgs> | null
    /**
     * The filter to search for the datasets_entryurls to update in case it exists.
     */
    where: datasets_entryurlsWhereUniqueInput
    /**
     * In case the datasets_entryurls found by the `where` argument doesn't exist, create a new datasets_entryurls with this data.
     */
    create: XOR<datasets_entryurlsCreateInput, datasets_entryurlsUncheckedCreateInput>
    /**
     * In case the datasets_entryurls was found with the provided `where` argument, update it with this data.
     */
    update: XOR<datasets_entryurlsUpdateInput, datasets_entryurlsUncheckedUpdateInput>
  }


  /**
   * datasets_entryurls delete
   */
  export type datasets_entryurlsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datasets_entryurls
     */
    select?: datasets_entryurlsSelect<ExtArgs> | null
    /**
     * Filter which datasets_entryurls to delete.
     */
    where: datasets_entryurlsWhereUniqueInput
  }


  /**
   * datasets_entryurls deleteMany
   */
  export type datasets_entryurlsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which datasets_entryurls to delete
     */
    where?: datasets_entryurlsWhereInput
  }


  /**
   * datasets_entryurls without action
   */
  export type datasets_entryurlsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datasets_entryurls
     */
    select?: datasets_entryurlsSelect<ExtArgs> | null
  }



  /**
   * Model inducks_appearance
   */

  export type AggregateInducks_appearance = {
    _count: Inducks_appearanceCountAggregateOutputType | null
    _avg: Inducks_appearanceAvgAggregateOutputType | null
    _sum: Inducks_appearanceSumAggregateOutputType | null
    _min: Inducks_appearanceMinAggregateOutputType | null
    _max: Inducks_appearanceMaxAggregateOutputType | null
  }

  export type Inducks_appearanceAvgAggregateOutputType = {
    number: number | null
  }

  export type Inducks_appearanceSumAggregateOutputType = {
    number: number | null
  }

  export type Inducks_appearanceMinAggregateOutputType = {
    storyversioncode: string | null
    charactercode: string | null
    number: number | null
    appearancecomment: string | null
    doubt: $Enums.inducks_appearance_doubt | null
  }

  export type Inducks_appearanceMaxAggregateOutputType = {
    storyversioncode: string | null
    charactercode: string | null
    number: number | null
    appearancecomment: string | null
    doubt: $Enums.inducks_appearance_doubt | null
  }

  export type Inducks_appearanceCountAggregateOutputType = {
    storyversioncode: number
    charactercode: number
    number: number
    appearancecomment: number
    doubt: number
    _all: number
  }


  export type Inducks_appearanceAvgAggregateInputType = {
    number?: true
  }

  export type Inducks_appearanceSumAggregateInputType = {
    number?: true
  }

  export type Inducks_appearanceMinAggregateInputType = {
    storyversioncode?: true
    charactercode?: true
    number?: true
    appearancecomment?: true
    doubt?: true
  }

  export type Inducks_appearanceMaxAggregateInputType = {
    storyversioncode?: true
    charactercode?: true
    number?: true
    appearancecomment?: true
    doubt?: true
  }

  export type Inducks_appearanceCountAggregateInputType = {
    storyversioncode?: true
    charactercode?: true
    number?: true
    appearancecomment?: true
    doubt?: true
    _all?: true
  }

  export type Inducks_appearanceAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_appearance to aggregate.
     */
    where?: inducks_appearanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_appearances to fetch.
     */
    orderBy?: inducks_appearanceOrderByWithRelationInput | inducks_appearanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_appearanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_appearances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_appearances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_appearances
    **/
    _count?: true | Inducks_appearanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Inducks_appearanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Inducks_appearanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_appearanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_appearanceMaxAggregateInputType
  }

  export type GetInducks_appearanceAggregateType<T extends Inducks_appearanceAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_appearance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_appearance[P]>
      : GetScalarType<T[P], AggregateInducks_appearance[P]>
  }




  export type inducks_appearanceGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_appearanceWhereInput
    orderBy?: inducks_appearanceOrderByWithAggregationInput | inducks_appearanceOrderByWithAggregationInput[]
    by: Inducks_appearanceScalarFieldEnum[] | Inducks_appearanceScalarFieldEnum
    having?: inducks_appearanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_appearanceCountAggregateInputType | true
    _avg?: Inducks_appearanceAvgAggregateInputType
    _sum?: Inducks_appearanceSumAggregateInputType
    _min?: Inducks_appearanceMinAggregateInputType
    _max?: Inducks_appearanceMaxAggregateInputType
  }

  export type Inducks_appearanceGroupByOutputType = {
    storyversioncode: string
    charactercode: string
    number: number | null
    appearancecomment: string | null
    doubt: $Enums.inducks_appearance_doubt | null
    _count: Inducks_appearanceCountAggregateOutputType | null
    _avg: Inducks_appearanceAvgAggregateOutputType | null
    _sum: Inducks_appearanceSumAggregateOutputType | null
    _min: Inducks_appearanceMinAggregateOutputType | null
    _max: Inducks_appearanceMaxAggregateOutputType | null
  }

  type GetInducks_appearanceGroupByPayload<T extends inducks_appearanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_appearanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_appearanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_appearanceGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_appearanceGroupByOutputType[P]>
        }
      >
    >


  export type inducks_appearanceSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    storyversioncode?: boolean
    charactercode?: boolean
    number?: boolean
    appearancecomment?: boolean
    doubt?: boolean
  }, ExtArgs["result"]["inducks_appearance"]>

  export type inducks_appearanceSelectScalar = {
    storyversioncode?: boolean
    charactercode?: boolean
    number?: boolean
    appearancecomment?: boolean
    doubt?: boolean
  }


  export type $inducks_appearancePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_appearance"
    objects: {}
    scalars: $Extensions.GetResult<{
      storyversioncode: string
      charactercode: string
      number: number | null
      appearancecomment: string | null
      doubt: $Enums.inducks_appearance_doubt | null
    }, ExtArgs["result"]["inducks_appearance"]>
    composites: {}
  }


  type inducks_appearanceGetPayload<S extends boolean | null | undefined | inducks_appearanceDefaultArgs> = $Result.GetResult<Prisma.$inducks_appearancePayload, S>

  type inducks_appearanceCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_appearanceFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_appearanceCountAggregateInputType | true
    }

  export interface inducks_appearanceDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_appearance'], meta: { name: 'inducks_appearance' } }
    /**
     * Find zero or one Inducks_appearance that matches the filter.
     * @param {inducks_appearanceFindUniqueArgs} args - Arguments to find a Inducks_appearance
     * @example
     * // Get one Inducks_appearance
     * const inducks_appearance = await prisma.inducks_appearance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_appearanceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_appearanceFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_appearanceClient<$Result.GetResult<Prisma.$inducks_appearancePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_appearance that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_appearanceFindUniqueOrThrowArgs} args - Arguments to find a Inducks_appearance
     * @example
     * // Get one Inducks_appearance
     * const inducks_appearance = await prisma.inducks_appearance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_appearanceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_appearanceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_appearanceClient<$Result.GetResult<Prisma.$inducks_appearancePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_appearance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_appearanceFindFirstArgs} args - Arguments to find a Inducks_appearance
     * @example
     * // Get one Inducks_appearance
     * const inducks_appearance = await prisma.inducks_appearance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_appearanceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_appearanceFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_appearanceClient<$Result.GetResult<Prisma.$inducks_appearancePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_appearance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_appearanceFindFirstOrThrowArgs} args - Arguments to find a Inducks_appearance
     * @example
     * // Get one Inducks_appearance
     * const inducks_appearance = await prisma.inducks_appearance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_appearanceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_appearanceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_appearanceClient<$Result.GetResult<Prisma.$inducks_appearancePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_appearances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_appearanceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_appearances
     * const inducks_appearances = await prisma.inducks_appearance.findMany()
     * 
     * // Get first 10 Inducks_appearances
     * const inducks_appearances = await prisma.inducks_appearance.findMany({ take: 10 })
     * 
     * // Only select the `storyversioncode`
     * const inducks_appearanceWithStoryversioncodeOnly = await prisma.inducks_appearance.findMany({ select: { storyversioncode: true } })
     * 
    **/
    findMany<T extends inducks_appearanceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_appearanceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_appearancePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_appearance.
     * @param {inducks_appearanceCreateArgs} args - Arguments to create a Inducks_appearance.
     * @example
     * // Create one Inducks_appearance
     * const Inducks_appearance = await prisma.inducks_appearance.create({
     *   data: {
     *     // ... data to create a Inducks_appearance
     *   }
     * })
     * 
    **/
    create<T extends inducks_appearanceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_appearanceCreateArgs<ExtArgs>>
    ): Prisma__inducks_appearanceClient<$Result.GetResult<Prisma.$inducks_appearancePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_appearances.
     *     @param {inducks_appearanceCreateManyArgs} args - Arguments to create many Inducks_appearances.
     *     @example
     *     // Create many Inducks_appearances
     *     const inducks_appearance = await prisma.inducks_appearance.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_appearanceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_appearanceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_appearance.
     * @param {inducks_appearanceDeleteArgs} args - Arguments to delete one Inducks_appearance.
     * @example
     * // Delete one Inducks_appearance
     * const Inducks_appearance = await prisma.inducks_appearance.delete({
     *   where: {
     *     // ... filter to delete one Inducks_appearance
     *   }
     * })
     * 
    **/
    delete<T extends inducks_appearanceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_appearanceDeleteArgs<ExtArgs>>
    ): Prisma__inducks_appearanceClient<$Result.GetResult<Prisma.$inducks_appearancePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_appearance.
     * @param {inducks_appearanceUpdateArgs} args - Arguments to update one Inducks_appearance.
     * @example
     * // Update one Inducks_appearance
     * const inducks_appearance = await prisma.inducks_appearance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_appearanceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_appearanceUpdateArgs<ExtArgs>>
    ): Prisma__inducks_appearanceClient<$Result.GetResult<Prisma.$inducks_appearancePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_appearances.
     * @param {inducks_appearanceDeleteManyArgs} args - Arguments to filter Inducks_appearances to delete.
     * @example
     * // Delete a few Inducks_appearances
     * const { count } = await prisma.inducks_appearance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_appearanceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_appearanceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_appearances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_appearanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_appearances
     * const inducks_appearance = await prisma.inducks_appearance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_appearanceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_appearanceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_appearance.
     * @param {inducks_appearanceUpsertArgs} args - Arguments to update or create a Inducks_appearance.
     * @example
     * // Update or create a Inducks_appearance
     * const inducks_appearance = await prisma.inducks_appearance.upsert({
     *   create: {
     *     // ... data to create a Inducks_appearance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_appearance we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_appearanceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_appearanceUpsertArgs<ExtArgs>>
    ): Prisma__inducks_appearanceClient<$Result.GetResult<Prisma.$inducks_appearancePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_appearances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_appearanceCountArgs} args - Arguments to filter Inducks_appearances to count.
     * @example
     * // Count the number of Inducks_appearances
     * const count = await prisma.inducks_appearance.count({
     *   where: {
     *     // ... the filter for the Inducks_appearances we want to count
     *   }
     * })
    **/
    count<T extends inducks_appearanceCountArgs>(
      args?: Subset<T, inducks_appearanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_appearanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_appearance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_appearanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_appearanceAggregateArgs>(args: Subset<T, Inducks_appearanceAggregateArgs>): Prisma.PrismaPromise<GetInducks_appearanceAggregateType<T>>

    /**
     * Group by Inducks_appearance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_appearanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_appearanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_appearanceGroupByArgs['orderBy'] }
        : { orderBy?: inducks_appearanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_appearanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_appearanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_appearance model
   */
  readonly fields: inducks_appearanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_appearance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_appearanceClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_appearance model
   */ 
  interface inducks_appearanceFieldRefs {
    readonly storyversioncode: FieldRef<"inducks_appearance", 'String'>
    readonly charactercode: FieldRef<"inducks_appearance", 'String'>
    readonly number: FieldRef<"inducks_appearance", 'Int'>
    readonly appearancecomment: FieldRef<"inducks_appearance", 'String'>
    readonly doubt: FieldRef<"inducks_appearance", 'inducks_appearance_doubt'>
  }
    

  // Custom InputTypes

  /**
   * inducks_appearance findUnique
   */
  export type inducks_appearanceFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_appearance
     */
    select?: inducks_appearanceSelect<ExtArgs> | null
    /**
     * Filter, which inducks_appearance to fetch.
     */
    where: inducks_appearanceWhereUniqueInput
  }


  /**
   * inducks_appearance findUniqueOrThrow
   */
  export type inducks_appearanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_appearance
     */
    select?: inducks_appearanceSelect<ExtArgs> | null
    /**
     * Filter, which inducks_appearance to fetch.
     */
    where: inducks_appearanceWhereUniqueInput
  }


  /**
   * inducks_appearance findFirst
   */
  export type inducks_appearanceFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_appearance
     */
    select?: inducks_appearanceSelect<ExtArgs> | null
    /**
     * Filter, which inducks_appearance to fetch.
     */
    where?: inducks_appearanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_appearances to fetch.
     */
    orderBy?: inducks_appearanceOrderByWithRelationInput | inducks_appearanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_appearances.
     */
    cursor?: inducks_appearanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_appearances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_appearances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_appearances.
     */
    distinct?: Inducks_appearanceScalarFieldEnum | Inducks_appearanceScalarFieldEnum[]
  }


  /**
   * inducks_appearance findFirstOrThrow
   */
  export type inducks_appearanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_appearance
     */
    select?: inducks_appearanceSelect<ExtArgs> | null
    /**
     * Filter, which inducks_appearance to fetch.
     */
    where?: inducks_appearanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_appearances to fetch.
     */
    orderBy?: inducks_appearanceOrderByWithRelationInput | inducks_appearanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_appearances.
     */
    cursor?: inducks_appearanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_appearances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_appearances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_appearances.
     */
    distinct?: Inducks_appearanceScalarFieldEnum | Inducks_appearanceScalarFieldEnum[]
  }


  /**
   * inducks_appearance findMany
   */
  export type inducks_appearanceFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_appearance
     */
    select?: inducks_appearanceSelect<ExtArgs> | null
    /**
     * Filter, which inducks_appearances to fetch.
     */
    where?: inducks_appearanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_appearances to fetch.
     */
    orderBy?: inducks_appearanceOrderByWithRelationInput | inducks_appearanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_appearances.
     */
    cursor?: inducks_appearanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_appearances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_appearances.
     */
    skip?: number
    distinct?: Inducks_appearanceScalarFieldEnum | Inducks_appearanceScalarFieldEnum[]
  }


  /**
   * inducks_appearance create
   */
  export type inducks_appearanceCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_appearance
     */
    select?: inducks_appearanceSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_appearance.
     */
    data: XOR<inducks_appearanceCreateInput, inducks_appearanceUncheckedCreateInput>
  }


  /**
   * inducks_appearance createMany
   */
  export type inducks_appearanceCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_appearances.
     */
    data: inducks_appearanceCreateManyInput | inducks_appearanceCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_appearance update
   */
  export type inducks_appearanceUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_appearance
     */
    select?: inducks_appearanceSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_appearance.
     */
    data: XOR<inducks_appearanceUpdateInput, inducks_appearanceUncheckedUpdateInput>
    /**
     * Choose, which inducks_appearance to update.
     */
    where: inducks_appearanceWhereUniqueInput
  }


  /**
   * inducks_appearance updateMany
   */
  export type inducks_appearanceUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_appearances.
     */
    data: XOR<inducks_appearanceUpdateManyMutationInput, inducks_appearanceUncheckedUpdateManyInput>
    /**
     * Filter which inducks_appearances to update
     */
    where?: inducks_appearanceWhereInput
  }


  /**
   * inducks_appearance upsert
   */
  export type inducks_appearanceUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_appearance
     */
    select?: inducks_appearanceSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_appearance to update in case it exists.
     */
    where: inducks_appearanceWhereUniqueInput
    /**
     * In case the inducks_appearance found by the `where` argument doesn't exist, create a new inducks_appearance with this data.
     */
    create: XOR<inducks_appearanceCreateInput, inducks_appearanceUncheckedCreateInput>
    /**
     * In case the inducks_appearance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_appearanceUpdateInput, inducks_appearanceUncheckedUpdateInput>
  }


  /**
   * inducks_appearance delete
   */
  export type inducks_appearanceDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_appearance
     */
    select?: inducks_appearanceSelect<ExtArgs> | null
    /**
     * Filter which inducks_appearance to delete.
     */
    where: inducks_appearanceWhereUniqueInput
  }


  /**
   * inducks_appearance deleteMany
   */
  export type inducks_appearanceDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_appearances to delete
     */
    where?: inducks_appearanceWhereInput
  }


  /**
   * inducks_appearance without action
   */
  export type inducks_appearanceDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_appearance
     */
    select?: inducks_appearanceSelect<ExtArgs> | null
  }



  /**
   * Model inducks_character
   */

  export type AggregateInducks_character = {
    _count: Inducks_characterCountAggregateOutputType | null
    _min: Inducks_characterMinAggregateOutputType | null
    _max: Inducks_characterMaxAggregateOutputType | null
  }

  export type Inducks_characterMinAggregateOutputType = {
    charactercode: string | null
    charactername: string | null
    official: $Enums.inducks_character_official | null
    onetime: $Enums.inducks_character_onetime | null
    heroonly: $Enums.inducks_character_heroonly | null
    charactercomment: string | null
  }

  export type Inducks_characterMaxAggregateOutputType = {
    charactercode: string | null
    charactername: string | null
    official: $Enums.inducks_character_official | null
    onetime: $Enums.inducks_character_onetime | null
    heroonly: $Enums.inducks_character_heroonly | null
    charactercomment: string | null
  }

  export type Inducks_characterCountAggregateOutputType = {
    charactercode: number
    charactername: number
    official: number
    onetime: number
    heroonly: number
    charactercomment: number
    _all: number
  }


  export type Inducks_characterMinAggregateInputType = {
    charactercode?: true
    charactername?: true
    official?: true
    onetime?: true
    heroonly?: true
    charactercomment?: true
  }

  export type Inducks_characterMaxAggregateInputType = {
    charactercode?: true
    charactername?: true
    official?: true
    onetime?: true
    heroonly?: true
    charactercomment?: true
  }

  export type Inducks_characterCountAggregateInputType = {
    charactercode?: true
    charactername?: true
    official?: true
    onetime?: true
    heroonly?: true
    charactercomment?: true
    _all?: true
  }

  export type Inducks_characterAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_character to aggregate.
     */
    where?: inducks_characterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_characters to fetch.
     */
    orderBy?: inducks_characterOrderByWithRelationInput | inducks_characterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_characterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_characters
    **/
    _count?: true | Inducks_characterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_characterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_characterMaxAggregateInputType
  }

  export type GetInducks_characterAggregateType<T extends Inducks_characterAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_character]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_character[P]>
      : GetScalarType<T[P], AggregateInducks_character[P]>
  }




  export type inducks_characterGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_characterWhereInput
    orderBy?: inducks_characterOrderByWithAggregationInput | inducks_characterOrderByWithAggregationInput[]
    by: Inducks_characterScalarFieldEnum[] | Inducks_characterScalarFieldEnum
    having?: inducks_characterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_characterCountAggregateInputType | true
    _min?: Inducks_characterMinAggregateInputType
    _max?: Inducks_characterMaxAggregateInputType
  }

  export type Inducks_characterGroupByOutputType = {
    charactercode: string
    charactername: string | null
    official: $Enums.inducks_character_official | null
    onetime: $Enums.inducks_character_onetime | null
    heroonly: $Enums.inducks_character_heroonly | null
    charactercomment: string | null
    _count: Inducks_characterCountAggregateOutputType | null
    _min: Inducks_characterMinAggregateOutputType | null
    _max: Inducks_characterMaxAggregateOutputType | null
  }

  type GetInducks_characterGroupByPayload<T extends inducks_characterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_characterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_characterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_characterGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_characterGroupByOutputType[P]>
        }
      >
    >


  export type inducks_characterSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    charactercode?: boolean
    charactername?: boolean
    official?: boolean
    onetime?: boolean
    heroonly?: boolean
    charactercomment?: boolean
  }, ExtArgs["result"]["inducks_character"]>

  export type inducks_characterSelectScalar = {
    charactercode?: boolean
    charactername?: boolean
    official?: boolean
    onetime?: boolean
    heroonly?: boolean
    charactercomment?: boolean
  }


  export type $inducks_characterPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_character"
    objects: {}
    scalars: $Extensions.GetResult<{
      charactercode: string
      charactername: string | null
      official: $Enums.inducks_character_official | null
      onetime: $Enums.inducks_character_onetime | null
      heroonly: $Enums.inducks_character_heroonly | null
      charactercomment: string | null
    }, ExtArgs["result"]["inducks_character"]>
    composites: {}
  }


  type inducks_characterGetPayload<S extends boolean | null | undefined | inducks_characterDefaultArgs> = $Result.GetResult<Prisma.$inducks_characterPayload, S>

  type inducks_characterCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_characterFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_characterCountAggregateInputType | true
    }

  export interface inducks_characterDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_character'], meta: { name: 'inducks_character' } }
    /**
     * Find zero or one Inducks_character that matches the filter.
     * @param {inducks_characterFindUniqueArgs} args - Arguments to find a Inducks_character
     * @example
     * // Get one Inducks_character
     * const inducks_character = await prisma.inducks_character.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_characterFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_characterFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_characterClient<$Result.GetResult<Prisma.$inducks_characterPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_character that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_characterFindUniqueOrThrowArgs} args - Arguments to find a Inducks_character
     * @example
     * // Get one Inducks_character
     * const inducks_character = await prisma.inducks_character.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_characterFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_characterFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_characterClient<$Result.GetResult<Prisma.$inducks_characterPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_character that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_characterFindFirstArgs} args - Arguments to find a Inducks_character
     * @example
     * // Get one Inducks_character
     * const inducks_character = await prisma.inducks_character.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_characterFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_characterFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_characterClient<$Result.GetResult<Prisma.$inducks_characterPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_character that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_characterFindFirstOrThrowArgs} args - Arguments to find a Inducks_character
     * @example
     * // Get one Inducks_character
     * const inducks_character = await prisma.inducks_character.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_characterFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_characterFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_characterClient<$Result.GetResult<Prisma.$inducks_characterPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_characters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_characterFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_characters
     * const inducks_characters = await prisma.inducks_character.findMany()
     * 
     * // Get first 10 Inducks_characters
     * const inducks_characters = await prisma.inducks_character.findMany({ take: 10 })
     * 
     * // Only select the `charactercode`
     * const inducks_characterWithCharactercodeOnly = await prisma.inducks_character.findMany({ select: { charactercode: true } })
     * 
    **/
    findMany<T extends inducks_characterFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_characterFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_characterPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_character.
     * @param {inducks_characterCreateArgs} args - Arguments to create a Inducks_character.
     * @example
     * // Create one Inducks_character
     * const Inducks_character = await prisma.inducks_character.create({
     *   data: {
     *     // ... data to create a Inducks_character
     *   }
     * })
     * 
    **/
    create<T extends inducks_characterCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_characterCreateArgs<ExtArgs>>
    ): Prisma__inducks_characterClient<$Result.GetResult<Prisma.$inducks_characterPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_characters.
     *     @param {inducks_characterCreateManyArgs} args - Arguments to create many Inducks_characters.
     *     @example
     *     // Create many Inducks_characters
     *     const inducks_character = await prisma.inducks_character.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_characterCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_characterCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_character.
     * @param {inducks_characterDeleteArgs} args - Arguments to delete one Inducks_character.
     * @example
     * // Delete one Inducks_character
     * const Inducks_character = await prisma.inducks_character.delete({
     *   where: {
     *     // ... filter to delete one Inducks_character
     *   }
     * })
     * 
    **/
    delete<T extends inducks_characterDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_characterDeleteArgs<ExtArgs>>
    ): Prisma__inducks_characterClient<$Result.GetResult<Prisma.$inducks_characterPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_character.
     * @param {inducks_characterUpdateArgs} args - Arguments to update one Inducks_character.
     * @example
     * // Update one Inducks_character
     * const inducks_character = await prisma.inducks_character.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_characterUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_characterUpdateArgs<ExtArgs>>
    ): Prisma__inducks_characterClient<$Result.GetResult<Prisma.$inducks_characterPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_characters.
     * @param {inducks_characterDeleteManyArgs} args - Arguments to filter Inducks_characters to delete.
     * @example
     * // Delete a few Inducks_characters
     * const { count } = await prisma.inducks_character.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_characterDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_characterDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_characterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_characters
     * const inducks_character = await prisma.inducks_character.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_characterUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_characterUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_character.
     * @param {inducks_characterUpsertArgs} args - Arguments to update or create a Inducks_character.
     * @example
     * // Update or create a Inducks_character
     * const inducks_character = await prisma.inducks_character.upsert({
     *   create: {
     *     // ... data to create a Inducks_character
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_character we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_characterUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_characterUpsertArgs<ExtArgs>>
    ): Prisma__inducks_characterClient<$Result.GetResult<Prisma.$inducks_characterPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_characterCountArgs} args - Arguments to filter Inducks_characters to count.
     * @example
     * // Count the number of Inducks_characters
     * const count = await prisma.inducks_character.count({
     *   where: {
     *     // ... the filter for the Inducks_characters we want to count
     *   }
     * })
    **/
    count<T extends inducks_characterCountArgs>(
      args?: Subset<T, inducks_characterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_characterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_character.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_characterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_characterAggregateArgs>(args: Subset<T, Inducks_characterAggregateArgs>): Prisma.PrismaPromise<GetInducks_characterAggregateType<T>>

    /**
     * Group by Inducks_character.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_characterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_characterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_characterGroupByArgs['orderBy'] }
        : { orderBy?: inducks_characterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_characterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_characterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_character model
   */
  readonly fields: inducks_characterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_character.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_characterClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_character model
   */ 
  interface inducks_characterFieldRefs {
    readonly charactercode: FieldRef<"inducks_character", 'String'>
    readonly charactername: FieldRef<"inducks_character", 'String'>
    readonly official: FieldRef<"inducks_character", 'inducks_character_official'>
    readonly onetime: FieldRef<"inducks_character", 'inducks_character_onetime'>
    readonly heroonly: FieldRef<"inducks_character", 'inducks_character_heroonly'>
    readonly charactercomment: FieldRef<"inducks_character", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_character findUnique
   */
  export type inducks_characterFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_character
     */
    select?: inducks_characterSelect<ExtArgs> | null
    /**
     * Filter, which inducks_character to fetch.
     */
    where: inducks_characterWhereUniqueInput
  }


  /**
   * inducks_character findUniqueOrThrow
   */
  export type inducks_characterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_character
     */
    select?: inducks_characterSelect<ExtArgs> | null
    /**
     * Filter, which inducks_character to fetch.
     */
    where: inducks_characterWhereUniqueInput
  }


  /**
   * inducks_character findFirst
   */
  export type inducks_characterFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_character
     */
    select?: inducks_characterSelect<ExtArgs> | null
    /**
     * Filter, which inducks_character to fetch.
     */
    where?: inducks_characterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_characters to fetch.
     */
    orderBy?: inducks_characterOrderByWithRelationInput | inducks_characterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_characters.
     */
    cursor?: inducks_characterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_characters.
     */
    distinct?: Inducks_characterScalarFieldEnum | Inducks_characterScalarFieldEnum[]
  }


  /**
   * inducks_character findFirstOrThrow
   */
  export type inducks_characterFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_character
     */
    select?: inducks_characterSelect<ExtArgs> | null
    /**
     * Filter, which inducks_character to fetch.
     */
    where?: inducks_characterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_characters to fetch.
     */
    orderBy?: inducks_characterOrderByWithRelationInput | inducks_characterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_characters.
     */
    cursor?: inducks_characterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_characters.
     */
    distinct?: Inducks_characterScalarFieldEnum | Inducks_characterScalarFieldEnum[]
  }


  /**
   * inducks_character findMany
   */
  export type inducks_characterFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_character
     */
    select?: inducks_characterSelect<ExtArgs> | null
    /**
     * Filter, which inducks_characters to fetch.
     */
    where?: inducks_characterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_characters to fetch.
     */
    orderBy?: inducks_characterOrderByWithRelationInput | inducks_characterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_characters.
     */
    cursor?: inducks_characterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_characters.
     */
    skip?: number
    distinct?: Inducks_characterScalarFieldEnum | Inducks_characterScalarFieldEnum[]
  }


  /**
   * inducks_character create
   */
  export type inducks_characterCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_character
     */
    select?: inducks_characterSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_character.
     */
    data: XOR<inducks_characterCreateInput, inducks_characterUncheckedCreateInput>
  }


  /**
   * inducks_character createMany
   */
  export type inducks_characterCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_characters.
     */
    data: inducks_characterCreateManyInput | inducks_characterCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_character update
   */
  export type inducks_characterUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_character
     */
    select?: inducks_characterSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_character.
     */
    data: XOR<inducks_characterUpdateInput, inducks_characterUncheckedUpdateInput>
    /**
     * Choose, which inducks_character to update.
     */
    where: inducks_characterWhereUniqueInput
  }


  /**
   * inducks_character updateMany
   */
  export type inducks_characterUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_characters.
     */
    data: XOR<inducks_characterUpdateManyMutationInput, inducks_characterUncheckedUpdateManyInput>
    /**
     * Filter which inducks_characters to update
     */
    where?: inducks_characterWhereInput
  }


  /**
   * inducks_character upsert
   */
  export type inducks_characterUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_character
     */
    select?: inducks_characterSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_character to update in case it exists.
     */
    where: inducks_characterWhereUniqueInput
    /**
     * In case the inducks_character found by the `where` argument doesn't exist, create a new inducks_character with this data.
     */
    create: XOR<inducks_characterCreateInput, inducks_characterUncheckedCreateInput>
    /**
     * In case the inducks_character was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_characterUpdateInput, inducks_characterUncheckedUpdateInput>
  }


  /**
   * inducks_character delete
   */
  export type inducks_characterDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_character
     */
    select?: inducks_characterSelect<ExtArgs> | null
    /**
     * Filter which inducks_character to delete.
     */
    where: inducks_characterWhereUniqueInput
  }


  /**
   * inducks_character deleteMany
   */
  export type inducks_characterDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_characters to delete
     */
    where?: inducks_characterWhereInput
  }


  /**
   * inducks_character without action
   */
  export type inducks_characterDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_character
     */
    select?: inducks_characterSelect<ExtArgs> | null
  }



  /**
   * Model inducks_characteralias
   */

  export type AggregateInducks_characteralias = {
    _count: Inducks_characteraliasCountAggregateOutputType | null
    _min: Inducks_characteraliasMinAggregateOutputType | null
    _max: Inducks_characteraliasMaxAggregateOutputType | null
  }

  export type Inducks_characteraliasMinAggregateOutputType = {
    charactercode: string | null
    charactername: string | null
  }

  export type Inducks_characteraliasMaxAggregateOutputType = {
    charactercode: string | null
    charactername: string | null
  }

  export type Inducks_characteraliasCountAggregateOutputType = {
    charactercode: number
    charactername: number
    _all: number
  }


  export type Inducks_characteraliasMinAggregateInputType = {
    charactercode?: true
    charactername?: true
  }

  export type Inducks_characteraliasMaxAggregateInputType = {
    charactercode?: true
    charactername?: true
  }

  export type Inducks_characteraliasCountAggregateInputType = {
    charactercode?: true
    charactername?: true
    _all?: true
  }

  export type Inducks_characteraliasAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_characteralias to aggregate.
     */
    where?: inducks_characteraliasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_characteraliases to fetch.
     */
    orderBy?: inducks_characteraliasOrderByWithRelationInput | inducks_characteraliasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_characteraliasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_characteraliases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_characteraliases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_characteraliases
    **/
    _count?: true | Inducks_characteraliasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_characteraliasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_characteraliasMaxAggregateInputType
  }

  export type GetInducks_characteraliasAggregateType<T extends Inducks_characteraliasAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_characteralias]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_characteralias[P]>
      : GetScalarType<T[P], AggregateInducks_characteralias[P]>
  }




  export type inducks_characteraliasGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_characteraliasWhereInput
    orderBy?: inducks_characteraliasOrderByWithAggregationInput | inducks_characteraliasOrderByWithAggregationInput[]
    by: Inducks_characteraliasScalarFieldEnum[] | Inducks_characteraliasScalarFieldEnum
    having?: inducks_characteraliasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_characteraliasCountAggregateInputType | true
    _min?: Inducks_characteraliasMinAggregateInputType
    _max?: Inducks_characteraliasMaxAggregateInputType
  }

  export type Inducks_characteraliasGroupByOutputType = {
    charactercode: string | null
    charactername: string
    _count: Inducks_characteraliasCountAggregateOutputType | null
    _min: Inducks_characteraliasMinAggregateOutputType | null
    _max: Inducks_characteraliasMaxAggregateOutputType | null
  }

  type GetInducks_characteraliasGroupByPayload<T extends inducks_characteraliasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_characteraliasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_characteraliasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_characteraliasGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_characteraliasGroupByOutputType[P]>
        }
      >
    >


  export type inducks_characteraliasSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    charactercode?: boolean
    charactername?: boolean
  }, ExtArgs["result"]["inducks_characteralias"]>

  export type inducks_characteraliasSelectScalar = {
    charactercode?: boolean
    charactername?: boolean
  }


  export type $inducks_characteraliasPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_characteralias"
    objects: {}
    scalars: $Extensions.GetResult<{
      charactercode: string | null
      charactername: string
    }, ExtArgs["result"]["inducks_characteralias"]>
    composites: {}
  }


  type inducks_characteraliasGetPayload<S extends boolean | null | undefined | inducks_characteraliasDefaultArgs> = $Result.GetResult<Prisma.$inducks_characteraliasPayload, S>

  type inducks_characteraliasCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_characteraliasFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_characteraliasCountAggregateInputType | true
    }

  export interface inducks_characteraliasDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_characteralias'], meta: { name: 'inducks_characteralias' } }
    /**
     * Find zero or one Inducks_characteralias that matches the filter.
     * @param {inducks_characteraliasFindUniqueArgs} args - Arguments to find a Inducks_characteralias
     * @example
     * // Get one Inducks_characteralias
     * const inducks_characteralias = await prisma.inducks_characteralias.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_characteraliasFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_characteraliasFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_characteraliasClient<$Result.GetResult<Prisma.$inducks_characteraliasPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_characteralias that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_characteraliasFindUniqueOrThrowArgs} args - Arguments to find a Inducks_characteralias
     * @example
     * // Get one Inducks_characteralias
     * const inducks_characteralias = await prisma.inducks_characteralias.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_characteraliasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_characteraliasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_characteraliasClient<$Result.GetResult<Prisma.$inducks_characteraliasPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_characteralias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_characteraliasFindFirstArgs} args - Arguments to find a Inducks_characteralias
     * @example
     * // Get one Inducks_characteralias
     * const inducks_characteralias = await prisma.inducks_characteralias.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_characteraliasFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_characteraliasFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_characteraliasClient<$Result.GetResult<Prisma.$inducks_characteraliasPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_characteralias that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_characteraliasFindFirstOrThrowArgs} args - Arguments to find a Inducks_characteralias
     * @example
     * // Get one Inducks_characteralias
     * const inducks_characteralias = await prisma.inducks_characteralias.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_characteraliasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_characteraliasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_characteraliasClient<$Result.GetResult<Prisma.$inducks_characteraliasPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_characteraliases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_characteraliasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_characteraliases
     * const inducks_characteraliases = await prisma.inducks_characteralias.findMany()
     * 
     * // Get first 10 Inducks_characteraliases
     * const inducks_characteraliases = await prisma.inducks_characteralias.findMany({ take: 10 })
     * 
     * // Only select the `charactercode`
     * const inducks_characteraliasWithCharactercodeOnly = await prisma.inducks_characteralias.findMany({ select: { charactercode: true } })
     * 
    **/
    findMany<T extends inducks_characteraliasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_characteraliasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_characteraliasPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_characteralias.
     * @param {inducks_characteraliasCreateArgs} args - Arguments to create a Inducks_characteralias.
     * @example
     * // Create one Inducks_characteralias
     * const Inducks_characteralias = await prisma.inducks_characteralias.create({
     *   data: {
     *     // ... data to create a Inducks_characteralias
     *   }
     * })
     * 
    **/
    create<T extends inducks_characteraliasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_characteraliasCreateArgs<ExtArgs>>
    ): Prisma__inducks_characteraliasClient<$Result.GetResult<Prisma.$inducks_characteraliasPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_characteraliases.
     *     @param {inducks_characteraliasCreateManyArgs} args - Arguments to create many Inducks_characteraliases.
     *     @example
     *     // Create many Inducks_characteraliases
     *     const inducks_characteralias = await prisma.inducks_characteralias.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_characteraliasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_characteraliasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_characteralias.
     * @param {inducks_characteraliasDeleteArgs} args - Arguments to delete one Inducks_characteralias.
     * @example
     * // Delete one Inducks_characteralias
     * const Inducks_characteralias = await prisma.inducks_characteralias.delete({
     *   where: {
     *     // ... filter to delete one Inducks_characteralias
     *   }
     * })
     * 
    **/
    delete<T extends inducks_characteraliasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_characteraliasDeleteArgs<ExtArgs>>
    ): Prisma__inducks_characteraliasClient<$Result.GetResult<Prisma.$inducks_characteraliasPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_characteralias.
     * @param {inducks_characteraliasUpdateArgs} args - Arguments to update one Inducks_characteralias.
     * @example
     * // Update one Inducks_characteralias
     * const inducks_characteralias = await prisma.inducks_characteralias.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_characteraliasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_characteraliasUpdateArgs<ExtArgs>>
    ): Prisma__inducks_characteraliasClient<$Result.GetResult<Prisma.$inducks_characteraliasPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_characteraliases.
     * @param {inducks_characteraliasDeleteManyArgs} args - Arguments to filter Inducks_characteraliases to delete.
     * @example
     * // Delete a few Inducks_characteraliases
     * const { count } = await prisma.inducks_characteralias.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_characteraliasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_characteraliasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_characteraliases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_characteraliasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_characteraliases
     * const inducks_characteralias = await prisma.inducks_characteralias.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_characteraliasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_characteraliasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_characteralias.
     * @param {inducks_characteraliasUpsertArgs} args - Arguments to update or create a Inducks_characteralias.
     * @example
     * // Update or create a Inducks_characteralias
     * const inducks_characteralias = await prisma.inducks_characteralias.upsert({
     *   create: {
     *     // ... data to create a Inducks_characteralias
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_characteralias we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_characteraliasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_characteraliasUpsertArgs<ExtArgs>>
    ): Prisma__inducks_characteraliasClient<$Result.GetResult<Prisma.$inducks_characteraliasPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_characteraliases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_characteraliasCountArgs} args - Arguments to filter Inducks_characteraliases to count.
     * @example
     * // Count the number of Inducks_characteraliases
     * const count = await prisma.inducks_characteralias.count({
     *   where: {
     *     // ... the filter for the Inducks_characteraliases we want to count
     *   }
     * })
    **/
    count<T extends inducks_characteraliasCountArgs>(
      args?: Subset<T, inducks_characteraliasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_characteraliasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_characteralias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_characteraliasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_characteraliasAggregateArgs>(args: Subset<T, Inducks_characteraliasAggregateArgs>): Prisma.PrismaPromise<GetInducks_characteraliasAggregateType<T>>

    /**
     * Group by Inducks_characteralias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_characteraliasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_characteraliasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_characteraliasGroupByArgs['orderBy'] }
        : { orderBy?: inducks_characteraliasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_characteraliasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_characteraliasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_characteralias model
   */
  readonly fields: inducks_characteraliasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_characteralias.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_characteraliasClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_characteralias model
   */ 
  interface inducks_characteraliasFieldRefs {
    readonly charactercode: FieldRef<"inducks_characteralias", 'String'>
    readonly charactername: FieldRef<"inducks_characteralias", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_characteralias findUnique
   */
  export type inducks_characteraliasFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characteralias
     */
    select?: inducks_characteraliasSelect<ExtArgs> | null
    /**
     * Filter, which inducks_characteralias to fetch.
     */
    where: inducks_characteraliasWhereUniqueInput
  }


  /**
   * inducks_characteralias findUniqueOrThrow
   */
  export type inducks_characteraliasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characteralias
     */
    select?: inducks_characteraliasSelect<ExtArgs> | null
    /**
     * Filter, which inducks_characteralias to fetch.
     */
    where: inducks_characteraliasWhereUniqueInput
  }


  /**
   * inducks_characteralias findFirst
   */
  export type inducks_characteraliasFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characteralias
     */
    select?: inducks_characteraliasSelect<ExtArgs> | null
    /**
     * Filter, which inducks_characteralias to fetch.
     */
    where?: inducks_characteraliasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_characteraliases to fetch.
     */
    orderBy?: inducks_characteraliasOrderByWithRelationInput | inducks_characteraliasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_characteraliases.
     */
    cursor?: inducks_characteraliasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_characteraliases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_characteraliases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_characteraliases.
     */
    distinct?: Inducks_characteraliasScalarFieldEnum | Inducks_characteraliasScalarFieldEnum[]
  }


  /**
   * inducks_characteralias findFirstOrThrow
   */
  export type inducks_characteraliasFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characteralias
     */
    select?: inducks_characteraliasSelect<ExtArgs> | null
    /**
     * Filter, which inducks_characteralias to fetch.
     */
    where?: inducks_characteraliasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_characteraliases to fetch.
     */
    orderBy?: inducks_characteraliasOrderByWithRelationInput | inducks_characteraliasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_characteraliases.
     */
    cursor?: inducks_characteraliasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_characteraliases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_characteraliases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_characteraliases.
     */
    distinct?: Inducks_characteraliasScalarFieldEnum | Inducks_characteraliasScalarFieldEnum[]
  }


  /**
   * inducks_characteralias findMany
   */
  export type inducks_characteraliasFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characteralias
     */
    select?: inducks_characteraliasSelect<ExtArgs> | null
    /**
     * Filter, which inducks_characteraliases to fetch.
     */
    where?: inducks_characteraliasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_characteraliases to fetch.
     */
    orderBy?: inducks_characteraliasOrderByWithRelationInput | inducks_characteraliasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_characteraliases.
     */
    cursor?: inducks_characteraliasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_characteraliases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_characteraliases.
     */
    skip?: number
    distinct?: Inducks_characteraliasScalarFieldEnum | Inducks_characteraliasScalarFieldEnum[]
  }


  /**
   * inducks_characteralias create
   */
  export type inducks_characteraliasCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characteralias
     */
    select?: inducks_characteraliasSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_characteralias.
     */
    data: XOR<inducks_characteraliasCreateInput, inducks_characteraliasUncheckedCreateInput>
  }


  /**
   * inducks_characteralias createMany
   */
  export type inducks_characteraliasCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_characteraliases.
     */
    data: inducks_characteraliasCreateManyInput | inducks_characteraliasCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_characteralias update
   */
  export type inducks_characteraliasUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characteralias
     */
    select?: inducks_characteraliasSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_characteralias.
     */
    data: XOR<inducks_characteraliasUpdateInput, inducks_characteraliasUncheckedUpdateInput>
    /**
     * Choose, which inducks_characteralias to update.
     */
    where: inducks_characteraliasWhereUniqueInput
  }


  /**
   * inducks_characteralias updateMany
   */
  export type inducks_characteraliasUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_characteraliases.
     */
    data: XOR<inducks_characteraliasUpdateManyMutationInput, inducks_characteraliasUncheckedUpdateManyInput>
    /**
     * Filter which inducks_characteraliases to update
     */
    where?: inducks_characteraliasWhereInput
  }


  /**
   * inducks_characteralias upsert
   */
  export type inducks_characteraliasUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characteralias
     */
    select?: inducks_characteraliasSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_characteralias to update in case it exists.
     */
    where: inducks_characteraliasWhereUniqueInput
    /**
     * In case the inducks_characteralias found by the `where` argument doesn't exist, create a new inducks_characteralias with this data.
     */
    create: XOR<inducks_characteraliasCreateInput, inducks_characteraliasUncheckedCreateInput>
    /**
     * In case the inducks_characteralias was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_characteraliasUpdateInput, inducks_characteraliasUncheckedUpdateInput>
  }


  /**
   * inducks_characteralias delete
   */
  export type inducks_characteraliasDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characteralias
     */
    select?: inducks_characteraliasSelect<ExtArgs> | null
    /**
     * Filter which inducks_characteralias to delete.
     */
    where: inducks_characteraliasWhereUniqueInput
  }


  /**
   * inducks_characteralias deleteMany
   */
  export type inducks_characteraliasDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_characteraliases to delete
     */
    where?: inducks_characteraliasWhereInput
  }


  /**
   * inducks_characteralias without action
   */
  export type inducks_characteraliasDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characteralias
     */
    select?: inducks_characteraliasSelect<ExtArgs> | null
  }



  /**
   * Model inducks_characterdetail
   */

  export type AggregateInducks_characterdetail = {
    _count: Inducks_characterdetailCountAggregateOutputType | null
    _avg: Inducks_characterdetailAvgAggregateOutputType | null
    _sum: Inducks_characterdetailSumAggregateOutputType | null
    _min: Inducks_characterdetailMinAggregateOutputType | null
    _max: Inducks_characterdetailMaxAggregateOutputType | null
  }

  export type Inducks_characterdetailAvgAggregateOutputType = {
    number: number | null
  }

  export type Inducks_characterdetailSumAggregateOutputType = {
    number: number | null
  }

  export type Inducks_characterdetailMinAggregateOutputType = {
    charactername: string | null
    charactercode: string | null
    number: number | null
  }

  export type Inducks_characterdetailMaxAggregateOutputType = {
    charactername: string | null
    charactercode: string | null
    number: number | null
  }

  export type Inducks_characterdetailCountAggregateOutputType = {
    charactername: number
    charactercode: number
    number: number
    _all: number
  }


  export type Inducks_characterdetailAvgAggregateInputType = {
    number?: true
  }

  export type Inducks_characterdetailSumAggregateInputType = {
    number?: true
  }

  export type Inducks_characterdetailMinAggregateInputType = {
    charactername?: true
    charactercode?: true
    number?: true
  }

  export type Inducks_characterdetailMaxAggregateInputType = {
    charactername?: true
    charactercode?: true
    number?: true
  }

  export type Inducks_characterdetailCountAggregateInputType = {
    charactername?: true
    charactercode?: true
    number?: true
    _all?: true
  }

  export type Inducks_characterdetailAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_characterdetail to aggregate.
     */
    where?: inducks_characterdetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_characterdetails to fetch.
     */
    orderBy?: inducks_characterdetailOrderByWithRelationInput | inducks_characterdetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_characterdetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_characterdetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_characterdetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_characterdetails
    **/
    _count?: true | Inducks_characterdetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Inducks_characterdetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Inducks_characterdetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_characterdetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_characterdetailMaxAggregateInputType
  }

  export type GetInducks_characterdetailAggregateType<T extends Inducks_characterdetailAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_characterdetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_characterdetail[P]>
      : GetScalarType<T[P], AggregateInducks_characterdetail[P]>
  }




  export type inducks_characterdetailGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_characterdetailWhereInput
    orderBy?: inducks_characterdetailOrderByWithAggregationInput | inducks_characterdetailOrderByWithAggregationInput[]
    by: Inducks_characterdetailScalarFieldEnum[] | Inducks_characterdetailScalarFieldEnum
    having?: inducks_characterdetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_characterdetailCountAggregateInputType | true
    _avg?: Inducks_characterdetailAvgAggregateInputType
    _sum?: Inducks_characterdetailSumAggregateInputType
    _min?: Inducks_characterdetailMinAggregateInputType
    _max?: Inducks_characterdetailMaxAggregateInputType
  }

  export type Inducks_characterdetailGroupByOutputType = {
    charactername: string | null
    charactercode: string
    number: number | null
    _count: Inducks_characterdetailCountAggregateOutputType | null
    _avg: Inducks_characterdetailAvgAggregateOutputType | null
    _sum: Inducks_characterdetailSumAggregateOutputType | null
    _min: Inducks_characterdetailMinAggregateOutputType | null
    _max: Inducks_characterdetailMaxAggregateOutputType | null
  }

  type GetInducks_characterdetailGroupByPayload<T extends inducks_characterdetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_characterdetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_characterdetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_characterdetailGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_characterdetailGroupByOutputType[P]>
        }
      >
    >


  export type inducks_characterdetailSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    charactername?: boolean
    charactercode?: boolean
    number?: boolean
  }, ExtArgs["result"]["inducks_characterdetail"]>

  export type inducks_characterdetailSelectScalar = {
    charactername?: boolean
    charactercode?: boolean
    number?: boolean
  }


  export type $inducks_characterdetailPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_characterdetail"
    objects: {}
    scalars: $Extensions.GetResult<{
      charactername: string | null
      charactercode: string
      number: number | null
    }, ExtArgs["result"]["inducks_characterdetail"]>
    composites: {}
  }


  type inducks_characterdetailGetPayload<S extends boolean | null | undefined | inducks_characterdetailDefaultArgs> = $Result.GetResult<Prisma.$inducks_characterdetailPayload, S>

  type inducks_characterdetailCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_characterdetailFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_characterdetailCountAggregateInputType | true
    }

  export interface inducks_characterdetailDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_characterdetail'], meta: { name: 'inducks_characterdetail' } }
    /**
     * Find zero or one Inducks_characterdetail that matches the filter.
     * @param {inducks_characterdetailFindUniqueArgs} args - Arguments to find a Inducks_characterdetail
     * @example
     * // Get one Inducks_characterdetail
     * const inducks_characterdetail = await prisma.inducks_characterdetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_characterdetailFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_characterdetailFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_characterdetailClient<$Result.GetResult<Prisma.$inducks_characterdetailPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_characterdetail that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_characterdetailFindUniqueOrThrowArgs} args - Arguments to find a Inducks_characterdetail
     * @example
     * // Get one Inducks_characterdetail
     * const inducks_characterdetail = await prisma.inducks_characterdetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_characterdetailFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_characterdetailFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_characterdetailClient<$Result.GetResult<Prisma.$inducks_characterdetailPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_characterdetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_characterdetailFindFirstArgs} args - Arguments to find a Inducks_characterdetail
     * @example
     * // Get one Inducks_characterdetail
     * const inducks_characterdetail = await prisma.inducks_characterdetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_characterdetailFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_characterdetailFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_characterdetailClient<$Result.GetResult<Prisma.$inducks_characterdetailPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_characterdetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_characterdetailFindFirstOrThrowArgs} args - Arguments to find a Inducks_characterdetail
     * @example
     * // Get one Inducks_characterdetail
     * const inducks_characterdetail = await prisma.inducks_characterdetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_characterdetailFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_characterdetailFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_characterdetailClient<$Result.GetResult<Prisma.$inducks_characterdetailPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_characterdetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_characterdetailFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_characterdetails
     * const inducks_characterdetails = await prisma.inducks_characterdetail.findMany()
     * 
     * // Get first 10 Inducks_characterdetails
     * const inducks_characterdetails = await prisma.inducks_characterdetail.findMany({ take: 10 })
     * 
     * // Only select the `charactername`
     * const inducks_characterdetailWithCharacternameOnly = await prisma.inducks_characterdetail.findMany({ select: { charactername: true } })
     * 
    **/
    findMany<T extends inducks_characterdetailFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_characterdetailFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_characterdetailPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_characterdetail.
     * @param {inducks_characterdetailCreateArgs} args - Arguments to create a Inducks_characterdetail.
     * @example
     * // Create one Inducks_characterdetail
     * const Inducks_characterdetail = await prisma.inducks_characterdetail.create({
     *   data: {
     *     // ... data to create a Inducks_characterdetail
     *   }
     * })
     * 
    **/
    create<T extends inducks_characterdetailCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_characterdetailCreateArgs<ExtArgs>>
    ): Prisma__inducks_characterdetailClient<$Result.GetResult<Prisma.$inducks_characterdetailPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_characterdetails.
     *     @param {inducks_characterdetailCreateManyArgs} args - Arguments to create many Inducks_characterdetails.
     *     @example
     *     // Create many Inducks_characterdetails
     *     const inducks_characterdetail = await prisma.inducks_characterdetail.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_characterdetailCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_characterdetailCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_characterdetail.
     * @param {inducks_characterdetailDeleteArgs} args - Arguments to delete one Inducks_characterdetail.
     * @example
     * // Delete one Inducks_characterdetail
     * const Inducks_characterdetail = await prisma.inducks_characterdetail.delete({
     *   where: {
     *     // ... filter to delete one Inducks_characterdetail
     *   }
     * })
     * 
    **/
    delete<T extends inducks_characterdetailDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_characterdetailDeleteArgs<ExtArgs>>
    ): Prisma__inducks_characterdetailClient<$Result.GetResult<Prisma.$inducks_characterdetailPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_characterdetail.
     * @param {inducks_characterdetailUpdateArgs} args - Arguments to update one Inducks_characterdetail.
     * @example
     * // Update one Inducks_characterdetail
     * const inducks_characterdetail = await prisma.inducks_characterdetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_characterdetailUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_characterdetailUpdateArgs<ExtArgs>>
    ): Prisma__inducks_characterdetailClient<$Result.GetResult<Prisma.$inducks_characterdetailPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_characterdetails.
     * @param {inducks_characterdetailDeleteManyArgs} args - Arguments to filter Inducks_characterdetails to delete.
     * @example
     * // Delete a few Inducks_characterdetails
     * const { count } = await prisma.inducks_characterdetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_characterdetailDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_characterdetailDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_characterdetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_characterdetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_characterdetails
     * const inducks_characterdetail = await prisma.inducks_characterdetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_characterdetailUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_characterdetailUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_characterdetail.
     * @param {inducks_characterdetailUpsertArgs} args - Arguments to update or create a Inducks_characterdetail.
     * @example
     * // Update or create a Inducks_characterdetail
     * const inducks_characterdetail = await prisma.inducks_characterdetail.upsert({
     *   create: {
     *     // ... data to create a Inducks_characterdetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_characterdetail we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_characterdetailUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_characterdetailUpsertArgs<ExtArgs>>
    ): Prisma__inducks_characterdetailClient<$Result.GetResult<Prisma.$inducks_characterdetailPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_characterdetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_characterdetailCountArgs} args - Arguments to filter Inducks_characterdetails to count.
     * @example
     * // Count the number of Inducks_characterdetails
     * const count = await prisma.inducks_characterdetail.count({
     *   where: {
     *     // ... the filter for the Inducks_characterdetails we want to count
     *   }
     * })
    **/
    count<T extends inducks_characterdetailCountArgs>(
      args?: Subset<T, inducks_characterdetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_characterdetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_characterdetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_characterdetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_characterdetailAggregateArgs>(args: Subset<T, Inducks_characterdetailAggregateArgs>): Prisma.PrismaPromise<GetInducks_characterdetailAggregateType<T>>

    /**
     * Group by Inducks_characterdetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_characterdetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_characterdetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_characterdetailGroupByArgs['orderBy'] }
        : { orderBy?: inducks_characterdetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_characterdetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_characterdetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_characterdetail model
   */
  readonly fields: inducks_characterdetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_characterdetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_characterdetailClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_characterdetail model
   */ 
  interface inducks_characterdetailFieldRefs {
    readonly charactername: FieldRef<"inducks_characterdetail", 'String'>
    readonly charactercode: FieldRef<"inducks_characterdetail", 'String'>
    readonly number: FieldRef<"inducks_characterdetail", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * inducks_characterdetail findUnique
   */
  export type inducks_characterdetailFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characterdetail
     */
    select?: inducks_characterdetailSelect<ExtArgs> | null
    /**
     * Filter, which inducks_characterdetail to fetch.
     */
    where: inducks_characterdetailWhereUniqueInput
  }


  /**
   * inducks_characterdetail findUniqueOrThrow
   */
  export type inducks_characterdetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characterdetail
     */
    select?: inducks_characterdetailSelect<ExtArgs> | null
    /**
     * Filter, which inducks_characterdetail to fetch.
     */
    where: inducks_characterdetailWhereUniqueInput
  }


  /**
   * inducks_characterdetail findFirst
   */
  export type inducks_characterdetailFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characterdetail
     */
    select?: inducks_characterdetailSelect<ExtArgs> | null
    /**
     * Filter, which inducks_characterdetail to fetch.
     */
    where?: inducks_characterdetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_characterdetails to fetch.
     */
    orderBy?: inducks_characterdetailOrderByWithRelationInput | inducks_characterdetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_characterdetails.
     */
    cursor?: inducks_characterdetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_characterdetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_characterdetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_characterdetails.
     */
    distinct?: Inducks_characterdetailScalarFieldEnum | Inducks_characterdetailScalarFieldEnum[]
  }


  /**
   * inducks_characterdetail findFirstOrThrow
   */
  export type inducks_characterdetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characterdetail
     */
    select?: inducks_characterdetailSelect<ExtArgs> | null
    /**
     * Filter, which inducks_characterdetail to fetch.
     */
    where?: inducks_characterdetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_characterdetails to fetch.
     */
    orderBy?: inducks_characterdetailOrderByWithRelationInput | inducks_characterdetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_characterdetails.
     */
    cursor?: inducks_characterdetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_characterdetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_characterdetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_characterdetails.
     */
    distinct?: Inducks_characterdetailScalarFieldEnum | Inducks_characterdetailScalarFieldEnum[]
  }


  /**
   * inducks_characterdetail findMany
   */
  export type inducks_characterdetailFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characterdetail
     */
    select?: inducks_characterdetailSelect<ExtArgs> | null
    /**
     * Filter, which inducks_characterdetails to fetch.
     */
    where?: inducks_characterdetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_characterdetails to fetch.
     */
    orderBy?: inducks_characterdetailOrderByWithRelationInput | inducks_characterdetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_characterdetails.
     */
    cursor?: inducks_characterdetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_characterdetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_characterdetails.
     */
    skip?: number
    distinct?: Inducks_characterdetailScalarFieldEnum | Inducks_characterdetailScalarFieldEnum[]
  }


  /**
   * inducks_characterdetail create
   */
  export type inducks_characterdetailCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characterdetail
     */
    select?: inducks_characterdetailSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_characterdetail.
     */
    data: XOR<inducks_characterdetailCreateInput, inducks_characterdetailUncheckedCreateInput>
  }


  /**
   * inducks_characterdetail createMany
   */
  export type inducks_characterdetailCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_characterdetails.
     */
    data: inducks_characterdetailCreateManyInput | inducks_characterdetailCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_characterdetail update
   */
  export type inducks_characterdetailUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characterdetail
     */
    select?: inducks_characterdetailSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_characterdetail.
     */
    data: XOR<inducks_characterdetailUpdateInput, inducks_characterdetailUncheckedUpdateInput>
    /**
     * Choose, which inducks_characterdetail to update.
     */
    where: inducks_characterdetailWhereUniqueInput
  }


  /**
   * inducks_characterdetail updateMany
   */
  export type inducks_characterdetailUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_characterdetails.
     */
    data: XOR<inducks_characterdetailUpdateManyMutationInput, inducks_characterdetailUncheckedUpdateManyInput>
    /**
     * Filter which inducks_characterdetails to update
     */
    where?: inducks_characterdetailWhereInput
  }


  /**
   * inducks_characterdetail upsert
   */
  export type inducks_characterdetailUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characterdetail
     */
    select?: inducks_characterdetailSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_characterdetail to update in case it exists.
     */
    where: inducks_characterdetailWhereUniqueInput
    /**
     * In case the inducks_characterdetail found by the `where` argument doesn't exist, create a new inducks_characterdetail with this data.
     */
    create: XOR<inducks_characterdetailCreateInput, inducks_characterdetailUncheckedCreateInput>
    /**
     * In case the inducks_characterdetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_characterdetailUpdateInput, inducks_characterdetailUncheckedUpdateInput>
  }


  /**
   * inducks_characterdetail delete
   */
  export type inducks_characterdetailDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characterdetail
     */
    select?: inducks_characterdetailSelect<ExtArgs> | null
    /**
     * Filter which inducks_characterdetail to delete.
     */
    where: inducks_characterdetailWhereUniqueInput
  }


  /**
   * inducks_characterdetail deleteMany
   */
  export type inducks_characterdetailDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_characterdetails to delete
     */
    where?: inducks_characterdetailWhereInput
  }


  /**
   * inducks_characterdetail without action
   */
  export type inducks_characterdetailDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characterdetail
     */
    select?: inducks_characterdetailSelect<ExtArgs> | null
  }



  /**
   * Model inducks_charactername
   */

  export type AggregateInducks_charactername = {
    _count: Inducks_characternameCountAggregateOutputType | null
    _min: Inducks_characternameMinAggregateOutputType | null
    _max: Inducks_characternameMaxAggregateOutputType | null
  }

  export type Inducks_characternameMinAggregateOutputType = {
    charactercode: string | null
    languagecode: string | null
    charactername: string | null
    preferred: $Enums.inducks_charactername_preferred | null
    characternamecomment: string | null
  }

  export type Inducks_characternameMaxAggregateOutputType = {
    charactercode: string | null
    languagecode: string | null
    charactername: string | null
    preferred: $Enums.inducks_charactername_preferred | null
    characternamecomment: string | null
  }

  export type Inducks_characternameCountAggregateOutputType = {
    charactercode: number
    languagecode: number
    charactername: number
    preferred: number
    characternamecomment: number
    _all: number
  }


  export type Inducks_characternameMinAggregateInputType = {
    charactercode?: true
    languagecode?: true
    charactername?: true
    preferred?: true
    characternamecomment?: true
  }

  export type Inducks_characternameMaxAggregateInputType = {
    charactercode?: true
    languagecode?: true
    charactername?: true
    preferred?: true
    characternamecomment?: true
  }

  export type Inducks_characternameCountAggregateInputType = {
    charactercode?: true
    languagecode?: true
    charactername?: true
    preferred?: true
    characternamecomment?: true
    _all?: true
  }

  export type Inducks_characternameAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_charactername to aggregate.
     */
    where?: inducks_characternameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_characternames to fetch.
     */
    orderBy?: inducks_characternameOrderByWithRelationInput | inducks_characternameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_characternameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_characternames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_characternames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_characternames
    **/
    _count?: true | Inducks_characternameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_characternameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_characternameMaxAggregateInputType
  }

  export type GetInducks_characternameAggregateType<T extends Inducks_characternameAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_charactername]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_charactername[P]>
      : GetScalarType<T[P], AggregateInducks_charactername[P]>
  }




  export type inducks_characternameGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_characternameWhereInput
    orderBy?: inducks_characternameOrderByWithAggregationInput | inducks_characternameOrderByWithAggregationInput[]
    by: Inducks_characternameScalarFieldEnum[] | Inducks_characternameScalarFieldEnum
    having?: inducks_characternameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_characternameCountAggregateInputType | true
    _min?: Inducks_characternameMinAggregateInputType
    _max?: Inducks_characternameMaxAggregateInputType
  }

  export type Inducks_characternameGroupByOutputType = {
    charactercode: string
    languagecode: string
    charactername: string
    preferred: $Enums.inducks_charactername_preferred | null
    characternamecomment: string | null
    _count: Inducks_characternameCountAggregateOutputType | null
    _min: Inducks_characternameMinAggregateOutputType | null
    _max: Inducks_characternameMaxAggregateOutputType | null
  }

  type GetInducks_characternameGroupByPayload<T extends inducks_characternameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_characternameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_characternameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_characternameGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_characternameGroupByOutputType[P]>
        }
      >
    >


  export type inducks_characternameSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    charactercode?: boolean
    languagecode?: boolean
    charactername?: boolean
    preferred?: boolean
    characternamecomment?: boolean
  }, ExtArgs["result"]["inducks_charactername"]>

  export type inducks_characternameSelectScalar = {
    charactercode?: boolean
    languagecode?: boolean
    charactername?: boolean
    preferred?: boolean
    characternamecomment?: boolean
  }


  export type $inducks_characternamePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_charactername"
    objects: {}
    scalars: $Extensions.GetResult<{
      charactercode: string
      languagecode: string
      charactername: string
      preferred: $Enums.inducks_charactername_preferred | null
      characternamecomment: string | null
    }, ExtArgs["result"]["inducks_charactername"]>
    composites: {}
  }


  type inducks_characternameGetPayload<S extends boolean | null | undefined | inducks_characternameDefaultArgs> = $Result.GetResult<Prisma.$inducks_characternamePayload, S>

  type inducks_characternameCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_characternameFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_characternameCountAggregateInputType | true
    }

  export interface inducks_characternameDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_charactername'], meta: { name: 'inducks_charactername' } }
    /**
     * Find zero or one Inducks_charactername that matches the filter.
     * @param {inducks_characternameFindUniqueArgs} args - Arguments to find a Inducks_charactername
     * @example
     * // Get one Inducks_charactername
     * const inducks_charactername = await prisma.inducks_charactername.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_characternameFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_characternameFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_characternameClient<$Result.GetResult<Prisma.$inducks_characternamePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_charactername that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_characternameFindUniqueOrThrowArgs} args - Arguments to find a Inducks_charactername
     * @example
     * // Get one Inducks_charactername
     * const inducks_charactername = await prisma.inducks_charactername.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_characternameFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_characternameFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_characternameClient<$Result.GetResult<Prisma.$inducks_characternamePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_charactername that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_characternameFindFirstArgs} args - Arguments to find a Inducks_charactername
     * @example
     * // Get one Inducks_charactername
     * const inducks_charactername = await prisma.inducks_charactername.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_characternameFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_characternameFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_characternameClient<$Result.GetResult<Prisma.$inducks_characternamePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_charactername that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_characternameFindFirstOrThrowArgs} args - Arguments to find a Inducks_charactername
     * @example
     * // Get one Inducks_charactername
     * const inducks_charactername = await prisma.inducks_charactername.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_characternameFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_characternameFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_characternameClient<$Result.GetResult<Prisma.$inducks_characternamePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_characternames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_characternameFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_characternames
     * const inducks_characternames = await prisma.inducks_charactername.findMany()
     * 
     * // Get first 10 Inducks_characternames
     * const inducks_characternames = await prisma.inducks_charactername.findMany({ take: 10 })
     * 
     * // Only select the `charactercode`
     * const inducks_characternameWithCharactercodeOnly = await prisma.inducks_charactername.findMany({ select: { charactercode: true } })
     * 
    **/
    findMany<T extends inducks_characternameFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_characternameFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_characternamePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_charactername.
     * @param {inducks_characternameCreateArgs} args - Arguments to create a Inducks_charactername.
     * @example
     * // Create one Inducks_charactername
     * const Inducks_charactername = await prisma.inducks_charactername.create({
     *   data: {
     *     // ... data to create a Inducks_charactername
     *   }
     * })
     * 
    **/
    create<T extends inducks_characternameCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_characternameCreateArgs<ExtArgs>>
    ): Prisma__inducks_characternameClient<$Result.GetResult<Prisma.$inducks_characternamePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_characternames.
     *     @param {inducks_characternameCreateManyArgs} args - Arguments to create many Inducks_characternames.
     *     @example
     *     // Create many Inducks_characternames
     *     const inducks_charactername = await prisma.inducks_charactername.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_characternameCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_characternameCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_charactername.
     * @param {inducks_characternameDeleteArgs} args - Arguments to delete one Inducks_charactername.
     * @example
     * // Delete one Inducks_charactername
     * const Inducks_charactername = await prisma.inducks_charactername.delete({
     *   where: {
     *     // ... filter to delete one Inducks_charactername
     *   }
     * })
     * 
    **/
    delete<T extends inducks_characternameDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_characternameDeleteArgs<ExtArgs>>
    ): Prisma__inducks_characternameClient<$Result.GetResult<Prisma.$inducks_characternamePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_charactername.
     * @param {inducks_characternameUpdateArgs} args - Arguments to update one Inducks_charactername.
     * @example
     * // Update one Inducks_charactername
     * const inducks_charactername = await prisma.inducks_charactername.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_characternameUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_characternameUpdateArgs<ExtArgs>>
    ): Prisma__inducks_characternameClient<$Result.GetResult<Prisma.$inducks_characternamePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_characternames.
     * @param {inducks_characternameDeleteManyArgs} args - Arguments to filter Inducks_characternames to delete.
     * @example
     * // Delete a few Inducks_characternames
     * const { count } = await prisma.inducks_charactername.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_characternameDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_characternameDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_characternames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_characternameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_characternames
     * const inducks_charactername = await prisma.inducks_charactername.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_characternameUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_characternameUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_charactername.
     * @param {inducks_characternameUpsertArgs} args - Arguments to update or create a Inducks_charactername.
     * @example
     * // Update or create a Inducks_charactername
     * const inducks_charactername = await prisma.inducks_charactername.upsert({
     *   create: {
     *     // ... data to create a Inducks_charactername
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_charactername we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_characternameUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_characternameUpsertArgs<ExtArgs>>
    ): Prisma__inducks_characternameClient<$Result.GetResult<Prisma.$inducks_characternamePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_characternames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_characternameCountArgs} args - Arguments to filter Inducks_characternames to count.
     * @example
     * // Count the number of Inducks_characternames
     * const count = await prisma.inducks_charactername.count({
     *   where: {
     *     // ... the filter for the Inducks_characternames we want to count
     *   }
     * })
    **/
    count<T extends inducks_characternameCountArgs>(
      args?: Subset<T, inducks_characternameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_characternameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_charactername.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_characternameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_characternameAggregateArgs>(args: Subset<T, Inducks_characternameAggregateArgs>): Prisma.PrismaPromise<GetInducks_characternameAggregateType<T>>

    /**
     * Group by Inducks_charactername.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_characternameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_characternameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_characternameGroupByArgs['orderBy'] }
        : { orderBy?: inducks_characternameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_characternameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_characternameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_charactername model
   */
  readonly fields: inducks_characternameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_charactername.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_characternameClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_charactername model
   */ 
  interface inducks_characternameFieldRefs {
    readonly charactercode: FieldRef<"inducks_charactername", 'String'>
    readonly languagecode: FieldRef<"inducks_charactername", 'String'>
    readonly charactername: FieldRef<"inducks_charactername", 'String'>
    readonly preferred: FieldRef<"inducks_charactername", 'inducks_charactername_preferred'>
    readonly characternamecomment: FieldRef<"inducks_charactername", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_charactername findUnique
   */
  export type inducks_characternameFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_charactername
     */
    select?: inducks_characternameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_charactername to fetch.
     */
    where: inducks_characternameWhereUniqueInput
  }


  /**
   * inducks_charactername findUniqueOrThrow
   */
  export type inducks_characternameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_charactername
     */
    select?: inducks_characternameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_charactername to fetch.
     */
    where: inducks_characternameWhereUniqueInput
  }


  /**
   * inducks_charactername findFirst
   */
  export type inducks_characternameFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_charactername
     */
    select?: inducks_characternameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_charactername to fetch.
     */
    where?: inducks_characternameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_characternames to fetch.
     */
    orderBy?: inducks_characternameOrderByWithRelationInput | inducks_characternameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_characternames.
     */
    cursor?: inducks_characternameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_characternames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_characternames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_characternames.
     */
    distinct?: Inducks_characternameScalarFieldEnum | Inducks_characternameScalarFieldEnum[]
  }


  /**
   * inducks_charactername findFirstOrThrow
   */
  export type inducks_characternameFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_charactername
     */
    select?: inducks_characternameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_charactername to fetch.
     */
    where?: inducks_characternameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_characternames to fetch.
     */
    orderBy?: inducks_characternameOrderByWithRelationInput | inducks_characternameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_characternames.
     */
    cursor?: inducks_characternameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_characternames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_characternames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_characternames.
     */
    distinct?: Inducks_characternameScalarFieldEnum | Inducks_characternameScalarFieldEnum[]
  }


  /**
   * inducks_charactername findMany
   */
  export type inducks_characternameFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_charactername
     */
    select?: inducks_characternameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_characternames to fetch.
     */
    where?: inducks_characternameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_characternames to fetch.
     */
    orderBy?: inducks_characternameOrderByWithRelationInput | inducks_characternameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_characternames.
     */
    cursor?: inducks_characternameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_characternames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_characternames.
     */
    skip?: number
    distinct?: Inducks_characternameScalarFieldEnum | Inducks_characternameScalarFieldEnum[]
  }


  /**
   * inducks_charactername create
   */
  export type inducks_characternameCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_charactername
     */
    select?: inducks_characternameSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_charactername.
     */
    data: XOR<inducks_characternameCreateInput, inducks_characternameUncheckedCreateInput>
  }


  /**
   * inducks_charactername createMany
   */
  export type inducks_characternameCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_characternames.
     */
    data: inducks_characternameCreateManyInput | inducks_characternameCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_charactername update
   */
  export type inducks_characternameUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_charactername
     */
    select?: inducks_characternameSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_charactername.
     */
    data: XOR<inducks_characternameUpdateInput, inducks_characternameUncheckedUpdateInput>
    /**
     * Choose, which inducks_charactername to update.
     */
    where: inducks_characternameWhereUniqueInput
  }


  /**
   * inducks_charactername updateMany
   */
  export type inducks_characternameUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_characternames.
     */
    data: XOR<inducks_characternameUpdateManyMutationInput, inducks_characternameUncheckedUpdateManyInput>
    /**
     * Filter which inducks_characternames to update
     */
    where?: inducks_characternameWhereInput
  }


  /**
   * inducks_charactername upsert
   */
  export type inducks_characternameUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_charactername
     */
    select?: inducks_characternameSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_charactername to update in case it exists.
     */
    where: inducks_characternameWhereUniqueInput
    /**
     * In case the inducks_charactername found by the `where` argument doesn't exist, create a new inducks_charactername with this data.
     */
    create: XOR<inducks_characternameCreateInput, inducks_characternameUncheckedCreateInput>
    /**
     * In case the inducks_charactername was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_characternameUpdateInput, inducks_characternameUncheckedUpdateInput>
  }


  /**
   * inducks_charactername delete
   */
  export type inducks_characternameDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_charactername
     */
    select?: inducks_characternameSelect<ExtArgs> | null
    /**
     * Filter which inducks_charactername to delete.
     */
    where: inducks_characternameWhereUniqueInput
  }


  /**
   * inducks_charactername deleteMany
   */
  export type inducks_characternameDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_characternames to delete
     */
    where?: inducks_characternameWhereInput
  }


  /**
   * inducks_charactername without action
   */
  export type inducks_characternameDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_charactername
     */
    select?: inducks_characternameSelect<ExtArgs> | null
  }



  /**
   * Model inducks_characterreference
   */

  export type AggregateInducks_characterreference = {
    _count: Inducks_characterreferenceCountAggregateOutputType | null
    _min: Inducks_characterreferenceMinAggregateOutputType | null
    _max: Inducks_characterreferenceMaxAggregateOutputType | null
  }

  export type Inducks_characterreferenceMinAggregateOutputType = {
    fromcharactercode: string | null
    tocharactercode: string | null
    isgroupofcharacters: $Enums.inducks_characterreference_isgroupofcharacters | null
  }

  export type Inducks_characterreferenceMaxAggregateOutputType = {
    fromcharactercode: string | null
    tocharactercode: string | null
    isgroupofcharacters: $Enums.inducks_characterreference_isgroupofcharacters | null
  }

  export type Inducks_characterreferenceCountAggregateOutputType = {
    fromcharactercode: number
    tocharactercode: number
    isgroupofcharacters: number
    _all: number
  }


  export type Inducks_characterreferenceMinAggregateInputType = {
    fromcharactercode?: true
    tocharactercode?: true
    isgroupofcharacters?: true
  }

  export type Inducks_characterreferenceMaxAggregateInputType = {
    fromcharactercode?: true
    tocharactercode?: true
    isgroupofcharacters?: true
  }

  export type Inducks_characterreferenceCountAggregateInputType = {
    fromcharactercode?: true
    tocharactercode?: true
    isgroupofcharacters?: true
    _all?: true
  }

  export type Inducks_characterreferenceAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_characterreference to aggregate.
     */
    where?: inducks_characterreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_characterreferences to fetch.
     */
    orderBy?: inducks_characterreferenceOrderByWithRelationInput | inducks_characterreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_characterreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_characterreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_characterreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_characterreferences
    **/
    _count?: true | Inducks_characterreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_characterreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_characterreferenceMaxAggregateInputType
  }

  export type GetInducks_characterreferenceAggregateType<T extends Inducks_characterreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_characterreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_characterreference[P]>
      : GetScalarType<T[P], AggregateInducks_characterreference[P]>
  }




  export type inducks_characterreferenceGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_characterreferenceWhereInput
    orderBy?: inducks_characterreferenceOrderByWithAggregationInput | inducks_characterreferenceOrderByWithAggregationInput[]
    by: Inducks_characterreferenceScalarFieldEnum[] | Inducks_characterreferenceScalarFieldEnum
    having?: inducks_characterreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_characterreferenceCountAggregateInputType | true
    _min?: Inducks_characterreferenceMinAggregateInputType
    _max?: Inducks_characterreferenceMaxAggregateInputType
  }

  export type Inducks_characterreferenceGroupByOutputType = {
    fromcharactercode: string
    tocharactercode: string
    isgroupofcharacters: $Enums.inducks_characterreference_isgroupofcharacters | null
    _count: Inducks_characterreferenceCountAggregateOutputType | null
    _min: Inducks_characterreferenceMinAggregateOutputType | null
    _max: Inducks_characterreferenceMaxAggregateOutputType | null
  }

  type GetInducks_characterreferenceGroupByPayload<T extends inducks_characterreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_characterreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_characterreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_characterreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_characterreferenceGroupByOutputType[P]>
        }
      >
    >


  export type inducks_characterreferenceSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    fromcharactercode?: boolean
    tocharactercode?: boolean
    isgroupofcharacters?: boolean
  }, ExtArgs["result"]["inducks_characterreference"]>

  export type inducks_characterreferenceSelectScalar = {
    fromcharactercode?: boolean
    tocharactercode?: boolean
    isgroupofcharacters?: boolean
  }


  export type $inducks_characterreferencePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_characterreference"
    objects: {}
    scalars: $Extensions.GetResult<{
      fromcharactercode: string
      tocharactercode: string
      isgroupofcharacters: $Enums.inducks_characterreference_isgroupofcharacters | null
    }, ExtArgs["result"]["inducks_characterreference"]>
    composites: {}
  }


  type inducks_characterreferenceGetPayload<S extends boolean | null | undefined | inducks_characterreferenceDefaultArgs> = $Result.GetResult<Prisma.$inducks_characterreferencePayload, S>

  type inducks_characterreferenceCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_characterreferenceFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_characterreferenceCountAggregateInputType | true
    }

  export interface inducks_characterreferenceDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_characterreference'], meta: { name: 'inducks_characterreference' } }
    /**
     * Find zero or one Inducks_characterreference that matches the filter.
     * @param {inducks_characterreferenceFindUniqueArgs} args - Arguments to find a Inducks_characterreference
     * @example
     * // Get one Inducks_characterreference
     * const inducks_characterreference = await prisma.inducks_characterreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_characterreferenceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_characterreferenceFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_characterreferenceClient<$Result.GetResult<Prisma.$inducks_characterreferencePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_characterreference that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_characterreferenceFindUniqueOrThrowArgs} args - Arguments to find a Inducks_characterreference
     * @example
     * // Get one Inducks_characterreference
     * const inducks_characterreference = await prisma.inducks_characterreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_characterreferenceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_characterreferenceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_characterreferenceClient<$Result.GetResult<Prisma.$inducks_characterreferencePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_characterreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_characterreferenceFindFirstArgs} args - Arguments to find a Inducks_characterreference
     * @example
     * // Get one Inducks_characterreference
     * const inducks_characterreference = await prisma.inducks_characterreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_characterreferenceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_characterreferenceFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_characterreferenceClient<$Result.GetResult<Prisma.$inducks_characterreferencePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_characterreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_characterreferenceFindFirstOrThrowArgs} args - Arguments to find a Inducks_characterreference
     * @example
     * // Get one Inducks_characterreference
     * const inducks_characterreference = await prisma.inducks_characterreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_characterreferenceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_characterreferenceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_characterreferenceClient<$Result.GetResult<Prisma.$inducks_characterreferencePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_characterreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_characterreferenceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_characterreferences
     * const inducks_characterreferences = await prisma.inducks_characterreference.findMany()
     * 
     * // Get first 10 Inducks_characterreferences
     * const inducks_characterreferences = await prisma.inducks_characterreference.findMany({ take: 10 })
     * 
     * // Only select the `fromcharactercode`
     * const inducks_characterreferenceWithFromcharactercodeOnly = await prisma.inducks_characterreference.findMany({ select: { fromcharactercode: true } })
     * 
    **/
    findMany<T extends inducks_characterreferenceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_characterreferenceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_characterreferencePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_characterreference.
     * @param {inducks_characterreferenceCreateArgs} args - Arguments to create a Inducks_characterreference.
     * @example
     * // Create one Inducks_characterreference
     * const Inducks_characterreference = await prisma.inducks_characterreference.create({
     *   data: {
     *     // ... data to create a Inducks_characterreference
     *   }
     * })
     * 
    **/
    create<T extends inducks_characterreferenceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_characterreferenceCreateArgs<ExtArgs>>
    ): Prisma__inducks_characterreferenceClient<$Result.GetResult<Prisma.$inducks_characterreferencePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_characterreferences.
     *     @param {inducks_characterreferenceCreateManyArgs} args - Arguments to create many Inducks_characterreferences.
     *     @example
     *     // Create many Inducks_characterreferences
     *     const inducks_characterreference = await prisma.inducks_characterreference.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_characterreferenceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_characterreferenceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_characterreference.
     * @param {inducks_characterreferenceDeleteArgs} args - Arguments to delete one Inducks_characterreference.
     * @example
     * // Delete one Inducks_characterreference
     * const Inducks_characterreference = await prisma.inducks_characterreference.delete({
     *   where: {
     *     // ... filter to delete one Inducks_characterreference
     *   }
     * })
     * 
    **/
    delete<T extends inducks_characterreferenceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_characterreferenceDeleteArgs<ExtArgs>>
    ): Prisma__inducks_characterreferenceClient<$Result.GetResult<Prisma.$inducks_characterreferencePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_characterreference.
     * @param {inducks_characterreferenceUpdateArgs} args - Arguments to update one Inducks_characterreference.
     * @example
     * // Update one Inducks_characterreference
     * const inducks_characterreference = await prisma.inducks_characterreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_characterreferenceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_characterreferenceUpdateArgs<ExtArgs>>
    ): Prisma__inducks_characterreferenceClient<$Result.GetResult<Prisma.$inducks_characterreferencePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_characterreferences.
     * @param {inducks_characterreferenceDeleteManyArgs} args - Arguments to filter Inducks_characterreferences to delete.
     * @example
     * // Delete a few Inducks_characterreferences
     * const { count } = await prisma.inducks_characterreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_characterreferenceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_characterreferenceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_characterreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_characterreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_characterreferences
     * const inducks_characterreference = await prisma.inducks_characterreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_characterreferenceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_characterreferenceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_characterreference.
     * @param {inducks_characterreferenceUpsertArgs} args - Arguments to update or create a Inducks_characterreference.
     * @example
     * // Update or create a Inducks_characterreference
     * const inducks_characterreference = await prisma.inducks_characterreference.upsert({
     *   create: {
     *     // ... data to create a Inducks_characterreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_characterreference we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_characterreferenceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_characterreferenceUpsertArgs<ExtArgs>>
    ): Prisma__inducks_characterreferenceClient<$Result.GetResult<Prisma.$inducks_characterreferencePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_characterreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_characterreferenceCountArgs} args - Arguments to filter Inducks_characterreferences to count.
     * @example
     * // Count the number of Inducks_characterreferences
     * const count = await prisma.inducks_characterreference.count({
     *   where: {
     *     // ... the filter for the Inducks_characterreferences we want to count
     *   }
     * })
    **/
    count<T extends inducks_characterreferenceCountArgs>(
      args?: Subset<T, inducks_characterreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_characterreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_characterreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_characterreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_characterreferenceAggregateArgs>(args: Subset<T, Inducks_characterreferenceAggregateArgs>): Prisma.PrismaPromise<GetInducks_characterreferenceAggregateType<T>>

    /**
     * Group by Inducks_characterreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_characterreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_characterreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_characterreferenceGroupByArgs['orderBy'] }
        : { orderBy?: inducks_characterreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_characterreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_characterreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_characterreference model
   */
  readonly fields: inducks_characterreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_characterreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_characterreferenceClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_characterreference model
   */ 
  interface inducks_characterreferenceFieldRefs {
    readonly fromcharactercode: FieldRef<"inducks_characterreference", 'String'>
    readonly tocharactercode: FieldRef<"inducks_characterreference", 'String'>
    readonly isgroupofcharacters: FieldRef<"inducks_characterreference", 'inducks_characterreference_isgroupofcharacters'>
  }
    

  // Custom InputTypes

  /**
   * inducks_characterreference findUnique
   */
  export type inducks_characterreferenceFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characterreference
     */
    select?: inducks_characterreferenceSelect<ExtArgs> | null
    /**
     * Filter, which inducks_characterreference to fetch.
     */
    where: inducks_characterreferenceWhereUniqueInput
  }


  /**
   * inducks_characterreference findUniqueOrThrow
   */
  export type inducks_characterreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characterreference
     */
    select?: inducks_characterreferenceSelect<ExtArgs> | null
    /**
     * Filter, which inducks_characterreference to fetch.
     */
    where: inducks_characterreferenceWhereUniqueInput
  }


  /**
   * inducks_characterreference findFirst
   */
  export type inducks_characterreferenceFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characterreference
     */
    select?: inducks_characterreferenceSelect<ExtArgs> | null
    /**
     * Filter, which inducks_characterreference to fetch.
     */
    where?: inducks_characterreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_characterreferences to fetch.
     */
    orderBy?: inducks_characterreferenceOrderByWithRelationInput | inducks_characterreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_characterreferences.
     */
    cursor?: inducks_characterreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_characterreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_characterreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_characterreferences.
     */
    distinct?: Inducks_characterreferenceScalarFieldEnum | Inducks_characterreferenceScalarFieldEnum[]
  }


  /**
   * inducks_characterreference findFirstOrThrow
   */
  export type inducks_characterreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characterreference
     */
    select?: inducks_characterreferenceSelect<ExtArgs> | null
    /**
     * Filter, which inducks_characterreference to fetch.
     */
    where?: inducks_characterreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_characterreferences to fetch.
     */
    orderBy?: inducks_characterreferenceOrderByWithRelationInput | inducks_characterreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_characterreferences.
     */
    cursor?: inducks_characterreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_characterreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_characterreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_characterreferences.
     */
    distinct?: Inducks_characterreferenceScalarFieldEnum | Inducks_characterreferenceScalarFieldEnum[]
  }


  /**
   * inducks_characterreference findMany
   */
  export type inducks_characterreferenceFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characterreference
     */
    select?: inducks_characterreferenceSelect<ExtArgs> | null
    /**
     * Filter, which inducks_characterreferences to fetch.
     */
    where?: inducks_characterreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_characterreferences to fetch.
     */
    orderBy?: inducks_characterreferenceOrderByWithRelationInput | inducks_characterreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_characterreferences.
     */
    cursor?: inducks_characterreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_characterreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_characterreferences.
     */
    skip?: number
    distinct?: Inducks_characterreferenceScalarFieldEnum | Inducks_characterreferenceScalarFieldEnum[]
  }


  /**
   * inducks_characterreference create
   */
  export type inducks_characterreferenceCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characterreference
     */
    select?: inducks_characterreferenceSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_characterreference.
     */
    data: XOR<inducks_characterreferenceCreateInput, inducks_characterreferenceUncheckedCreateInput>
  }


  /**
   * inducks_characterreference createMany
   */
  export type inducks_characterreferenceCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_characterreferences.
     */
    data: inducks_characterreferenceCreateManyInput | inducks_characterreferenceCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_characterreference update
   */
  export type inducks_characterreferenceUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characterreference
     */
    select?: inducks_characterreferenceSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_characterreference.
     */
    data: XOR<inducks_characterreferenceUpdateInput, inducks_characterreferenceUncheckedUpdateInput>
    /**
     * Choose, which inducks_characterreference to update.
     */
    where: inducks_characterreferenceWhereUniqueInput
  }


  /**
   * inducks_characterreference updateMany
   */
  export type inducks_characterreferenceUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_characterreferences.
     */
    data: XOR<inducks_characterreferenceUpdateManyMutationInput, inducks_characterreferenceUncheckedUpdateManyInput>
    /**
     * Filter which inducks_characterreferences to update
     */
    where?: inducks_characterreferenceWhereInput
  }


  /**
   * inducks_characterreference upsert
   */
  export type inducks_characterreferenceUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characterreference
     */
    select?: inducks_characterreferenceSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_characterreference to update in case it exists.
     */
    where: inducks_characterreferenceWhereUniqueInput
    /**
     * In case the inducks_characterreference found by the `where` argument doesn't exist, create a new inducks_characterreference with this data.
     */
    create: XOR<inducks_characterreferenceCreateInput, inducks_characterreferenceUncheckedCreateInput>
    /**
     * In case the inducks_characterreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_characterreferenceUpdateInput, inducks_characterreferenceUncheckedUpdateInput>
  }


  /**
   * inducks_characterreference delete
   */
  export type inducks_characterreferenceDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characterreference
     */
    select?: inducks_characterreferenceSelect<ExtArgs> | null
    /**
     * Filter which inducks_characterreference to delete.
     */
    where: inducks_characterreferenceWhereUniqueInput
  }


  /**
   * inducks_characterreference deleteMany
   */
  export type inducks_characterreferenceDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_characterreferences to delete
     */
    where?: inducks_characterreferenceWhereInput
  }


  /**
   * inducks_characterreference without action
   */
  export type inducks_characterreferenceDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characterreference
     */
    select?: inducks_characterreferenceSelect<ExtArgs> | null
  }



  /**
   * Model inducks_characterurl
   */

  export type AggregateInducks_characterurl = {
    _count: Inducks_characterurlCountAggregateOutputType | null
    _min: Inducks_characterurlMinAggregateOutputType | null
    _max: Inducks_characterurlMaxAggregateOutputType | null
  }

  export type Inducks_characterurlMinAggregateOutputType = {
    charactercode: string | null
    sitecode: string | null
    url: string | null
  }

  export type Inducks_characterurlMaxAggregateOutputType = {
    charactercode: string | null
    sitecode: string | null
    url: string | null
  }

  export type Inducks_characterurlCountAggregateOutputType = {
    charactercode: number
    sitecode: number
    url: number
    _all: number
  }


  export type Inducks_characterurlMinAggregateInputType = {
    charactercode?: true
    sitecode?: true
    url?: true
  }

  export type Inducks_characterurlMaxAggregateInputType = {
    charactercode?: true
    sitecode?: true
    url?: true
  }

  export type Inducks_characterurlCountAggregateInputType = {
    charactercode?: true
    sitecode?: true
    url?: true
    _all?: true
  }

  export type Inducks_characterurlAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_characterurl to aggregate.
     */
    where?: inducks_characterurlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_characterurls to fetch.
     */
    orderBy?: inducks_characterurlOrderByWithRelationInput | inducks_characterurlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_characterurlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_characterurls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_characterurls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_characterurls
    **/
    _count?: true | Inducks_characterurlCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_characterurlMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_characterurlMaxAggregateInputType
  }

  export type GetInducks_characterurlAggregateType<T extends Inducks_characterurlAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_characterurl]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_characterurl[P]>
      : GetScalarType<T[P], AggregateInducks_characterurl[P]>
  }




  export type inducks_characterurlGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_characterurlWhereInput
    orderBy?: inducks_characterurlOrderByWithAggregationInput | inducks_characterurlOrderByWithAggregationInput[]
    by: Inducks_characterurlScalarFieldEnum[] | Inducks_characterurlScalarFieldEnum
    having?: inducks_characterurlScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_characterurlCountAggregateInputType | true
    _min?: Inducks_characterurlMinAggregateInputType
    _max?: Inducks_characterurlMaxAggregateInputType
  }

  export type Inducks_characterurlGroupByOutputType = {
    charactercode: string
    sitecode: string
    url: string | null
    _count: Inducks_characterurlCountAggregateOutputType | null
    _min: Inducks_characterurlMinAggregateOutputType | null
    _max: Inducks_characterurlMaxAggregateOutputType | null
  }

  type GetInducks_characterurlGroupByPayload<T extends inducks_characterurlGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_characterurlGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_characterurlGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_characterurlGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_characterurlGroupByOutputType[P]>
        }
      >
    >


  export type inducks_characterurlSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    charactercode?: boolean
    sitecode?: boolean
    url?: boolean
  }, ExtArgs["result"]["inducks_characterurl"]>

  export type inducks_characterurlSelectScalar = {
    charactercode?: boolean
    sitecode?: boolean
    url?: boolean
  }


  export type $inducks_characterurlPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_characterurl"
    objects: {}
    scalars: $Extensions.GetResult<{
      charactercode: string
      sitecode: string
      url: string | null
    }, ExtArgs["result"]["inducks_characterurl"]>
    composites: {}
  }


  type inducks_characterurlGetPayload<S extends boolean | null | undefined | inducks_characterurlDefaultArgs> = $Result.GetResult<Prisma.$inducks_characterurlPayload, S>

  type inducks_characterurlCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_characterurlFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_characterurlCountAggregateInputType | true
    }

  export interface inducks_characterurlDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_characterurl'], meta: { name: 'inducks_characterurl' } }
    /**
     * Find zero or one Inducks_characterurl that matches the filter.
     * @param {inducks_characterurlFindUniqueArgs} args - Arguments to find a Inducks_characterurl
     * @example
     * // Get one Inducks_characterurl
     * const inducks_characterurl = await prisma.inducks_characterurl.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_characterurlFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_characterurlFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_characterurlClient<$Result.GetResult<Prisma.$inducks_characterurlPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_characterurl that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_characterurlFindUniqueOrThrowArgs} args - Arguments to find a Inducks_characterurl
     * @example
     * // Get one Inducks_characterurl
     * const inducks_characterurl = await prisma.inducks_characterurl.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_characterurlFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_characterurlFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_characterurlClient<$Result.GetResult<Prisma.$inducks_characterurlPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_characterurl that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_characterurlFindFirstArgs} args - Arguments to find a Inducks_characterurl
     * @example
     * // Get one Inducks_characterurl
     * const inducks_characterurl = await prisma.inducks_characterurl.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_characterurlFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_characterurlFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_characterurlClient<$Result.GetResult<Prisma.$inducks_characterurlPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_characterurl that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_characterurlFindFirstOrThrowArgs} args - Arguments to find a Inducks_characterurl
     * @example
     * // Get one Inducks_characterurl
     * const inducks_characterurl = await prisma.inducks_characterurl.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_characterurlFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_characterurlFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_characterurlClient<$Result.GetResult<Prisma.$inducks_characterurlPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_characterurls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_characterurlFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_characterurls
     * const inducks_characterurls = await prisma.inducks_characterurl.findMany()
     * 
     * // Get first 10 Inducks_characterurls
     * const inducks_characterurls = await prisma.inducks_characterurl.findMany({ take: 10 })
     * 
     * // Only select the `charactercode`
     * const inducks_characterurlWithCharactercodeOnly = await prisma.inducks_characterurl.findMany({ select: { charactercode: true } })
     * 
    **/
    findMany<T extends inducks_characterurlFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_characterurlFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_characterurlPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_characterurl.
     * @param {inducks_characterurlCreateArgs} args - Arguments to create a Inducks_characterurl.
     * @example
     * // Create one Inducks_characterurl
     * const Inducks_characterurl = await prisma.inducks_characterurl.create({
     *   data: {
     *     // ... data to create a Inducks_characterurl
     *   }
     * })
     * 
    **/
    create<T extends inducks_characterurlCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_characterurlCreateArgs<ExtArgs>>
    ): Prisma__inducks_characterurlClient<$Result.GetResult<Prisma.$inducks_characterurlPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_characterurls.
     *     @param {inducks_characterurlCreateManyArgs} args - Arguments to create many Inducks_characterurls.
     *     @example
     *     // Create many Inducks_characterurls
     *     const inducks_characterurl = await prisma.inducks_characterurl.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_characterurlCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_characterurlCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_characterurl.
     * @param {inducks_characterurlDeleteArgs} args - Arguments to delete one Inducks_characterurl.
     * @example
     * // Delete one Inducks_characterurl
     * const Inducks_characterurl = await prisma.inducks_characterurl.delete({
     *   where: {
     *     // ... filter to delete one Inducks_characterurl
     *   }
     * })
     * 
    **/
    delete<T extends inducks_characterurlDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_characterurlDeleteArgs<ExtArgs>>
    ): Prisma__inducks_characterurlClient<$Result.GetResult<Prisma.$inducks_characterurlPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_characterurl.
     * @param {inducks_characterurlUpdateArgs} args - Arguments to update one Inducks_characterurl.
     * @example
     * // Update one Inducks_characterurl
     * const inducks_characterurl = await prisma.inducks_characterurl.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_characterurlUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_characterurlUpdateArgs<ExtArgs>>
    ): Prisma__inducks_characterurlClient<$Result.GetResult<Prisma.$inducks_characterurlPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_characterurls.
     * @param {inducks_characterurlDeleteManyArgs} args - Arguments to filter Inducks_characterurls to delete.
     * @example
     * // Delete a few Inducks_characterurls
     * const { count } = await prisma.inducks_characterurl.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_characterurlDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_characterurlDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_characterurls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_characterurlUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_characterurls
     * const inducks_characterurl = await prisma.inducks_characterurl.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_characterurlUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_characterurlUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_characterurl.
     * @param {inducks_characterurlUpsertArgs} args - Arguments to update or create a Inducks_characterurl.
     * @example
     * // Update or create a Inducks_characterurl
     * const inducks_characterurl = await prisma.inducks_characterurl.upsert({
     *   create: {
     *     // ... data to create a Inducks_characterurl
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_characterurl we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_characterurlUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_characterurlUpsertArgs<ExtArgs>>
    ): Prisma__inducks_characterurlClient<$Result.GetResult<Prisma.$inducks_characterurlPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_characterurls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_characterurlCountArgs} args - Arguments to filter Inducks_characterurls to count.
     * @example
     * // Count the number of Inducks_characterurls
     * const count = await prisma.inducks_characterurl.count({
     *   where: {
     *     // ... the filter for the Inducks_characterurls we want to count
     *   }
     * })
    **/
    count<T extends inducks_characterurlCountArgs>(
      args?: Subset<T, inducks_characterurlCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_characterurlCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_characterurl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_characterurlAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_characterurlAggregateArgs>(args: Subset<T, Inducks_characterurlAggregateArgs>): Prisma.PrismaPromise<GetInducks_characterurlAggregateType<T>>

    /**
     * Group by Inducks_characterurl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_characterurlGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_characterurlGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_characterurlGroupByArgs['orderBy'] }
        : { orderBy?: inducks_characterurlGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_characterurlGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_characterurlGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_characterurl model
   */
  readonly fields: inducks_characterurlFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_characterurl.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_characterurlClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_characterurl model
   */ 
  interface inducks_characterurlFieldRefs {
    readonly charactercode: FieldRef<"inducks_characterurl", 'String'>
    readonly sitecode: FieldRef<"inducks_characterurl", 'String'>
    readonly url: FieldRef<"inducks_characterurl", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_characterurl findUnique
   */
  export type inducks_characterurlFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characterurl
     */
    select?: inducks_characterurlSelect<ExtArgs> | null
    /**
     * Filter, which inducks_characterurl to fetch.
     */
    where: inducks_characterurlWhereUniqueInput
  }


  /**
   * inducks_characterurl findUniqueOrThrow
   */
  export type inducks_characterurlFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characterurl
     */
    select?: inducks_characterurlSelect<ExtArgs> | null
    /**
     * Filter, which inducks_characterurl to fetch.
     */
    where: inducks_characterurlWhereUniqueInput
  }


  /**
   * inducks_characterurl findFirst
   */
  export type inducks_characterurlFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characterurl
     */
    select?: inducks_characterurlSelect<ExtArgs> | null
    /**
     * Filter, which inducks_characterurl to fetch.
     */
    where?: inducks_characterurlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_characterurls to fetch.
     */
    orderBy?: inducks_characterurlOrderByWithRelationInput | inducks_characterurlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_characterurls.
     */
    cursor?: inducks_characterurlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_characterurls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_characterurls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_characterurls.
     */
    distinct?: Inducks_characterurlScalarFieldEnum | Inducks_characterurlScalarFieldEnum[]
  }


  /**
   * inducks_characterurl findFirstOrThrow
   */
  export type inducks_characterurlFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characterurl
     */
    select?: inducks_characterurlSelect<ExtArgs> | null
    /**
     * Filter, which inducks_characterurl to fetch.
     */
    where?: inducks_characterurlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_characterurls to fetch.
     */
    orderBy?: inducks_characterurlOrderByWithRelationInput | inducks_characterurlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_characterurls.
     */
    cursor?: inducks_characterurlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_characterurls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_characterurls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_characterurls.
     */
    distinct?: Inducks_characterurlScalarFieldEnum | Inducks_characterurlScalarFieldEnum[]
  }


  /**
   * inducks_characterurl findMany
   */
  export type inducks_characterurlFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characterurl
     */
    select?: inducks_characterurlSelect<ExtArgs> | null
    /**
     * Filter, which inducks_characterurls to fetch.
     */
    where?: inducks_characterurlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_characterurls to fetch.
     */
    orderBy?: inducks_characterurlOrderByWithRelationInput | inducks_characterurlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_characterurls.
     */
    cursor?: inducks_characterurlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_characterurls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_characterurls.
     */
    skip?: number
    distinct?: Inducks_characterurlScalarFieldEnum | Inducks_characterurlScalarFieldEnum[]
  }


  /**
   * inducks_characterurl create
   */
  export type inducks_characterurlCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characterurl
     */
    select?: inducks_characterurlSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_characterurl.
     */
    data: XOR<inducks_characterurlCreateInput, inducks_characterurlUncheckedCreateInput>
  }


  /**
   * inducks_characterurl createMany
   */
  export type inducks_characterurlCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_characterurls.
     */
    data: inducks_characterurlCreateManyInput | inducks_characterurlCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_characterurl update
   */
  export type inducks_characterurlUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characterurl
     */
    select?: inducks_characterurlSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_characterurl.
     */
    data: XOR<inducks_characterurlUpdateInput, inducks_characterurlUncheckedUpdateInput>
    /**
     * Choose, which inducks_characterurl to update.
     */
    where: inducks_characterurlWhereUniqueInput
  }


  /**
   * inducks_characterurl updateMany
   */
  export type inducks_characterurlUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_characterurls.
     */
    data: XOR<inducks_characterurlUpdateManyMutationInput, inducks_characterurlUncheckedUpdateManyInput>
    /**
     * Filter which inducks_characterurls to update
     */
    where?: inducks_characterurlWhereInput
  }


  /**
   * inducks_characterurl upsert
   */
  export type inducks_characterurlUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characterurl
     */
    select?: inducks_characterurlSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_characterurl to update in case it exists.
     */
    where: inducks_characterurlWhereUniqueInput
    /**
     * In case the inducks_characterurl found by the `where` argument doesn't exist, create a new inducks_characterurl with this data.
     */
    create: XOR<inducks_characterurlCreateInput, inducks_characterurlUncheckedCreateInput>
    /**
     * In case the inducks_characterurl was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_characterurlUpdateInput, inducks_characterurlUncheckedUpdateInput>
  }


  /**
   * inducks_characterurl delete
   */
  export type inducks_characterurlDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characterurl
     */
    select?: inducks_characterurlSelect<ExtArgs> | null
    /**
     * Filter which inducks_characterurl to delete.
     */
    where: inducks_characterurlWhereUniqueInput
  }


  /**
   * inducks_characterurl deleteMany
   */
  export type inducks_characterurlDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_characterurls to delete
     */
    where?: inducks_characterurlWhereInput
  }


  /**
   * inducks_characterurl without action
   */
  export type inducks_characterurlDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_characterurl
     */
    select?: inducks_characterurlSelect<ExtArgs> | null
  }



  /**
   * Model inducks_country
   */

  export type AggregateInducks_country = {
    _count: Inducks_countryCountAggregateOutputType | null
    _min: Inducks_countryMinAggregateOutputType | null
    _max: Inducks_countryMaxAggregateOutputType | null
  }

  export type Inducks_countryMinAggregateOutputType = {
    countrycode: string | null
    countryname: string | null
    defaultlanguage: string | null
    defaultmaintenanceteam: string | null
  }

  export type Inducks_countryMaxAggregateOutputType = {
    countrycode: string | null
    countryname: string | null
    defaultlanguage: string | null
    defaultmaintenanceteam: string | null
  }

  export type Inducks_countryCountAggregateOutputType = {
    countrycode: number
    countryname: number
    defaultlanguage: number
    defaultmaintenanceteam: number
    _all: number
  }


  export type Inducks_countryMinAggregateInputType = {
    countrycode?: true
    countryname?: true
    defaultlanguage?: true
    defaultmaintenanceteam?: true
  }

  export type Inducks_countryMaxAggregateInputType = {
    countrycode?: true
    countryname?: true
    defaultlanguage?: true
    defaultmaintenanceteam?: true
  }

  export type Inducks_countryCountAggregateInputType = {
    countrycode?: true
    countryname?: true
    defaultlanguage?: true
    defaultmaintenanceteam?: true
    _all?: true
  }

  export type Inducks_countryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_country to aggregate.
     */
    where?: inducks_countryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_countries to fetch.
     */
    orderBy?: inducks_countryOrderByWithRelationInput | inducks_countryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_countryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_countries
    **/
    _count?: true | Inducks_countryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_countryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_countryMaxAggregateInputType
  }

  export type GetInducks_countryAggregateType<T extends Inducks_countryAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_country]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_country[P]>
      : GetScalarType<T[P], AggregateInducks_country[P]>
  }




  export type inducks_countryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_countryWhereInput
    orderBy?: inducks_countryOrderByWithAggregationInput | inducks_countryOrderByWithAggregationInput[]
    by: Inducks_countryScalarFieldEnum[] | Inducks_countryScalarFieldEnum
    having?: inducks_countryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_countryCountAggregateInputType | true
    _min?: Inducks_countryMinAggregateInputType
    _max?: Inducks_countryMaxAggregateInputType
  }

  export type Inducks_countryGroupByOutputType = {
    countrycode: string
    countryname: string | null
    defaultlanguage: string | null
    defaultmaintenanceteam: string | null
    _count: Inducks_countryCountAggregateOutputType | null
    _min: Inducks_countryMinAggregateOutputType | null
    _max: Inducks_countryMaxAggregateOutputType | null
  }

  type GetInducks_countryGroupByPayload<T extends inducks_countryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_countryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_countryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_countryGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_countryGroupByOutputType[P]>
        }
      >
    >


  export type inducks_countrySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    countrycode?: boolean
    countryname?: boolean
    defaultlanguage?: boolean
    defaultmaintenanceteam?: boolean
  }, ExtArgs["result"]["inducks_country"]>

  export type inducks_countrySelectScalar = {
    countrycode?: boolean
    countryname?: boolean
    defaultlanguage?: boolean
    defaultmaintenanceteam?: boolean
  }


  export type $inducks_countryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_country"
    objects: {}
    scalars: $Extensions.GetResult<{
      countrycode: string
      countryname: string | null
      defaultlanguage: string | null
      defaultmaintenanceteam: string | null
    }, ExtArgs["result"]["inducks_country"]>
    composites: {}
  }


  type inducks_countryGetPayload<S extends boolean | null | undefined | inducks_countryDefaultArgs> = $Result.GetResult<Prisma.$inducks_countryPayload, S>

  type inducks_countryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_countryFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_countryCountAggregateInputType | true
    }

  export interface inducks_countryDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_country'], meta: { name: 'inducks_country' } }
    /**
     * Find zero or one Inducks_country that matches the filter.
     * @param {inducks_countryFindUniqueArgs} args - Arguments to find a Inducks_country
     * @example
     * // Get one Inducks_country
     * const inducks_country = await prisma.inducks_country.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_countryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_countryFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_countryClient<$Result.GetResult<Prisma.$inducks_countryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_country that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_countryFindUniqueOrThrowArgs} args - Arguments to find a Inducks_country
     * @example
     * // Get one Inducks_country
     * const inducks_country = await prisma.inducks_country.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_countryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_countryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_countryClient<$Result.GetResult<Prisma.$inducks_countryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_country that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_countryFindFirstArgs} args - Arguments to find a Inducks_country
     * @example
     * // Get one Inducks_country
     * const inducks_country = await prisma.inducks_country.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_countryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_countryFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_countryClient<$Result.GetResult<Prisma.$inducks_countryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_country that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_countryFindFirstOrThrowArgs} args - Arguments to find a Inducks_country
     * @example
     * // Get one Inducks_country
     * const inducks_country = await prisma.inducks_country.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_countryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_countryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_countryClient<$Result.GetResult<Prisma.$inducks_countryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_countryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_countries
     * const inducks_countries = await prisma.inducks_country.findMany()
     * 
     * // Get first 10 Inducks_countries
     * const inducks_countries = await prisma.inducks_country.findMany({ take: 10 })
     * 
     * // Only select the `countrycode`
     * const inducks_countryWithCountrycodeOnly = await prisma.inducks_country.findMany({ select: { countrycode: true } })
     * 
    **/
    findMany<T extends inducks_countryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_countryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_countryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_country.
     * @param {inducks_countryCreateArgs} args - Arguments to create a Inducks_country.
     * @example
     * // Create one Inducks_country
     * const Inducks_country = await prisma.inducks_country.create({
     *   data: {
     *     // ... data to create a Inducks_country
     *   }
     * })
     * 
    **/
    create<T extends inducks_countryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_countryCreateArgs<ExtArgs>>
    ): Prisma__inducks_countryClient<$Result.GetResult<Prisma.$inducks_countryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_countries.
     *     @param {inducks_countryCreateManyArgs} args - Arguments to create many Inducks_countries.
     *     @example
     *     // Create many Inducks_countries
     *     const inducks_country = await prisma.inducks_country.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_countryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_countryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_country.
     * @param {inducks_countryDeleteArgs} args - Arguments to delete one Inducks_country.
     * @example
     * // Delete one Inducks_country
     * const Inducks_country = await prisma.inducks_country.delete({
     *   where: {
     *     // ... filter to delete one Inducks_country
     *   }
     * })
     * 
    **/
    delete<T extends inducks_countryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_countryDeleteArgs<ExtArgs>>
    ): Prisma__inducks_countryClient<$Result.GetResult<Prisma.$inducks_countryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_country.
     * @param {inducks_countryUpdateArgs} args - Arguments to update one Inducks_country.
     * @example
     * // Update one Inducks_country
     * const inducks_country = await prisma.inducks_country.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_countryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_countryUpdateArgs<ExtArgs>>
    ): Prisma__inducks_countryClient<$Result.GetResult<Prisma.$inducks_countryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_countries.
     * @param {inducks_countryDeleteManyArgs} args - Arguments to filter Inducks_countries to delete.
     * @example
     * // Delete a few Inducks_countries
     * const { count } = await prisma.inducks_country.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_countryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_countryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_countryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_countries
     * const inducks_country = await prisma.inducks_country.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_countryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_countryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_country.
     * @param {inducks_countryUpsertArgs} args - Arguments to update or create a Inducks_country.
     * @example
     * // Update or create a Inducks_country
     * const inducks_country = await prisma.inducks_country.upsert({
     *   create: {
     *     // ... data to create a Inducks_country
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_country we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_countryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_countryUpsertArgs<ExtArgs>>
    ): Prisma__inducks_countryClient<$Result.GetResult<Prisma.$inducks_countryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_countryCountArgs} args - Arguments to filter Inducks_countries to count.
     * @example
     * // Count the number of Inducks_countries
     * const count = await prisma.inducks_country.count({
     *   where: {
     *     // ... the filter for the Inducks_countries we want to count
     *   }
     * })
    **/
    count<T extends inducks_countryCountArgs>(
      args?: Subset<T, inducks_countryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_countryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_countryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_countryAggregateArgs>(args: Subset<T, Inducks_countryAggregateArgs>): Prisma.PrismaPromise<GetInducks_countryAggregateType<T>>

    /**
     * Group by Inducks_country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_countryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_countryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_countryGroupByArgs['orderBy'] }
        : { orderBy?: inducks_countryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_countryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_countryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_country model
   */
  readonly fields: inducks_countryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_country.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_countryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_country model
   */ 
  interface inducks_countryFieldRefs {
    readonly countrycode: FieldRef<"inducks_country", 'String'>
    readonly countryname: FieldRef<"inducks_country", 'String'>
    readonly defaultlanguage: FieldRef<"inducks_country", 'String'>
    readonly defaultmaintenanceteam: FieldRef<"inducks_country", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_country findUnique
   */
  export type inducks_countryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_country
     */
    select?: inducks_countrySelect<ExtArgs> | null
    /**
     * Filter, which inducks_country to fetch.
     */
    where: inducks_countryWhereUniqueInput
  }


  /**
   * inducks_country findUniqueOrThrow
   */
  export type inducks_countryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_country
     */
    select?: inducks_countrySelect<ExtArgs> | null
    /**
     * Filter, which inducks_country to fetch.
     */
    where: inducks_countryWhereUniqueInput
  }


  /**
   * inducks_country findFirst
   */
  export type inducks_countryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_country
     */
    select?: inducks_countrySelect<ExtArgs> | null
    /**
     * Filter, which inducks_country to fetch.
     */
    where?: inducks_countryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_countries to fetch.
     */
    orderBy?: inducks_countryOrderByWithRelationInput | inducks_countryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_countries.
     */
    cursor?: inducks_countryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_countries.
     */
    distinct?: Inducks_countryScalarFieldEnum | Inducks_countryScalarFieldEnum[]
  }


  /**
   * inducks_country findFirstOrThrow
   */
  export type inducks_countryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_country
     */
    select?: inducks_countrySelect<ExtArgs> | null
    /**
     * Filter, which inducks_country to fetch.
     */
    where?: inducks_countryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_countries to fetch.
     */
    orderBy?: inducks_countryOrderByWithRelationInput | inducks_countryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_countries.
     */
    cursor?: inducks_countryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_countries.
     */
    distinct?: Inducks_countryScalarFieldEnum | Inducks_countryScalarFieldEnum[]
  }


  /**
   * inducks_country findMany
   */
  export type inducks_countryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_country
     */
    select?: inducks_countrySelect<ExtArgs> | null
    /**
     * Filter, which inducks_countries to fetch.
     */
    where?: inducks_countryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_countries to fetch.
     */
    orderBy?: inducks_countryOrderByWithRelationInput | inducks_countryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_countries.
     */
    cursor?: inducks_countryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_countries.
     */
    skip?: number
    distinct?: Inducks_countryScalarFieldEnum | Inducks_countryScalarFieldEnum[]
  }


  /**
   * inducks_country create
   */
  export type inducks_countryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_country
     */
    select?: inducks_countrySelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_country.
     */
    data: XOR<inducks_countryCreateInput, inducks_countryUncheckedCreateInput>
  }


  /**
   * inducks_country createMany
   */
  export type inducks_countryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_countries.
     */
    data: inducks_countryCreateManyInput | inducks_countryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_country update
   */
  export type inducks_countryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_country
     */
    select?: inducks_countrySelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_country.
     */
    data: XOR<inducks_countryUpdateInput, inducks_countryUncheckedUpdateInput>
    /**
     * Choose, which inducks_country to update.
     */
    where: inducks_countryWhereUniqueInput
  }


  /**
   * inducks_country updateMany
   */
  export type inducks_countryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_countries.
     */
    data: XOR<inducks_countryUpdateManyMutationInput, inducks_countryUncheckedUpdateManyInput>
    /**
     * Filter which inducks_countries to update
     */
    where?: inducks_countryWhereInput
  }


  /**
   * inducks_country upsert
   */
  export type inducks_countryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_country
     */
    select?: inducks_countrySelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_country to update in case it exists.
     */
    where: inducks_countryWhereUniqueInput
    /**
     * In case the inducks_country found by the `where` argument doesn't exist, create a new inducks_country with this data.
     */
    create: XOR<inducks_countryCreateInput, inducks_countryUncheckedCreateInput>
    /**
     * In case the inducks_country was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_countryUpdateInput, inducks_countryUncheckedUpdateInput>
  }


  /**
   * inducks_country delete
   */
  export type inducks_countryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_country
     */
    select?: inducks_countrySelect<ExtArgs> | null
    /**
     * Filter which inducks_country to delete.
     */
    where: inducks_countryWhereUniqueInput
  }


  /**
   * inducks_country deleteMany
   */
  export type inducks_countryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_countries to delete
     */
    where?: inducks_countryWhereInput
  }


  /**
   * inducks_country without action
   */
  export type inducks_countryDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_country
     */
    select?: inducks_countrySelect<ExtArgs> | null
  }



  /**
   * Model inducks_countryname
   */

  export type AggregateInducks_countryname = {
    _count: Inducks_countrynameCountAggregateOutputType | null
    _min: Inducks_countrynameMinAggregateOutputType | null
    _max: Inducks_countrynameMaxAggregateOutputType | null
  }

  export type Inducks_countrynameMinAggregateOutputType = {
    countrycode: string | null
    languagecode: string | null
    countryname: string | null
  }

  export type Inducks_countrynameMaxAggregateOutputType = {
    countrycode: string | null
    languagecode: string | null
    countryname: string | null
  }

  export type Inducks_countrynameCountAggregateOutputType = {
    countrycode: number
    languagecode: number
    countryname: number
    _all: number
  }


  export type Inducks_countrynameMinAggregateInputType = {
    countrycode?: true
    languagecode?: true
    countryname?: true
  }

  export type Inducks_countrynameMaxAggregateInputType = {
    countrycode?: true
    languagecode?: true
    countryname?: true
  }

  export type Inducks_countrynameCountAggregateInputType = {
    countrycode?: true
    languagecode?: true
    countryname?: true
    _all?: true
  }

  export type Inducks_countrynameAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_countryname to aggregate.
     */
    where?: inducks_countrynameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_countrynames to fetch.
     */
    orderBy?: inducks_countrynameOrderByWithRelationInput | inducks_countrynameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_countrynameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_countrynames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_countrynames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_countrynames
    **/
    _count?: true | Inducks_countrynameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_countrynameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_countrynameMaxAggregateInputType
  }

  export type GetInducks_countrynameAggregateType<T extends Inducks_countrynameAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_countryname]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_countryname[P]>
      : GetScalarType<T[P], AggregateInducks_countryname[P]>
  }




  export type inducks_countrynameGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_countrynameWhereInput
    orderBy?: inducks_countrynameOrderByWithAggregationInput | inducks_countrynameOrderByWithAggregationInput[]
    by: Inducks_countrynameScalarFieldEnum[] | Inducks_countrynameScalarFieldEnum
    having?: inducks_countrynameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_countrynameCountAggregateInputType | true
    _min?: Inducks_countrynameMinAggregateInputType
    _max?: Inducks_countrynameMaxAggregateInputType
  }

  export type Inducks_countrynameGroupByOutputType = {
    countrycode: string
    languagecode: string
    countryname: string | null
    _count: Inducks_countrynameCountAggregateOutputType | null
    _min: Inducks_countrynameMinAggregateOutputType | null
    _max: Inducks_countrynameMaxAggregateOutputType | null
  }

  type GetInducks_countrynameGroupByPayload<T extends inducks_countrynameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_countrynameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_countrynameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_countrynameGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_countrynameGroupByOutputType[P]>
        }
      >
    >


  export type inducks_countrynameSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    countrycode?: boolean
    languagecode?: boolean
    countryname?: boolean
  }, ExtArgs["result"]["inducks_countryname"]>

  export type inducks_countrynameSelectScalar = {
    countrycode?: boolean
    languagecode?: boolean
    countryname?: boolean
  }


  export type $inducks_countrynamePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_countryname"
    objects: {}
    scalars: $Extensions.GetResult<{
      countrycode: string
      languagecode: string
      countryname: string | null
    }, ExtArgs["result"]["inducks_countryname"]>
    composites: {}
  }


  type inducks_countrynameGetPayload<S extends boolean | null | undefined | inducks_countrynameDefaultArgs> = $Result.GetResult<Prisma.$inducks_countrynamePayload, S>

  type inducks_countrynameCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_countrynameFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_countrynameCountAggregateInputType | true
    }

  export interface inducks_countrynameDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_countryname'], meta: { name: 'inducks_countryname' } }
    /**
     * Find zero or one Inducks_countryname that matches the filter.
     * @param {inducks_countrynameFindUniqueArgs} args - Arguments to find a Inducks_countryname
     * @example
     * // Get one Inducks_countryname
     * const inducks_countryname = await prisma.inducks_countryname.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_countrynameFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_countrynameFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_countrynameClient<$Result.GetResult<Prisma.$inducks_countrynamePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_countryname that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_countrynameFindUniqueOrThrowArgs} args - Arguments to find a Inducks_countryname
     * @example
     * // Get one Inducks_countryname
     * const inducks_countryname = await prisma.inducks_countryname.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_countrynameFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_countrynameFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_countrynameClient<$Result.GetResult<Prisma.$inducks_countrynamePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_countryname that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_countrynameFindFirstArgs} args - Arguments to find a Inducks_countryname
     * @example
     * // Get one Inducks_countryname
     * const inducks_countryname = await prisma.inducks_countryname.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_countrynameFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_countrynameFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_countrynameClient<$Result.GetResult<Prisma.$inducks_countrynamePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_countryname that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_countrynameFindFirstOrThrowArgs} args - Arguments to find a Inducks_countryname
     * @example
     * // Get one Inducks_countryname
     * const inducks_countryname = await prisma.inducks_countryname.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_countrynameFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_countrynameFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_countrynameClient<$Result.GetResult<Prisma.$inducks_countrynamePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_countrynames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_countrynameFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_countrynames
     * const inducks_countrynames = await prisma.inducks_countryname.findMany()
     * 
     * // Get first 10 Inducks_countrynames
     * const inducks_countrynames = await prisma.inducks_countryname.findMany({ take: 10 })
     * 
     * // Only select the `countrycode`
     * const inducks_countrynameWithCountrycodeOnly = await prisma.inducks_countryname.findMany({ select: { countrycode: true } })
     * 
    **/
    findMany<T extends inducks_countrynameFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_countrynameFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_countrynamePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_countryname.
     * @param {inducks_countrynameCreateArgs} args - Arguments to create a Inducks_countryname.
     * @example
     * // Create one Inducks_countryname
     * const Inducks_countryname = await prisma.inducks_countryname.create({
     *   data: {
     *     // ... data to create a Inducks_countryname
     *   }
     * })
     * 
    **/
    create<T extends inducks_countrynameCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_countrynameCreateArgs<ExtArgs>>
    ): Prisma__inducks_countrynameClient<$Result.GetResult<Prisma.$inducks_countrynamePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_countrynames.
     *     @param {inducks_countrynameCreateManyArgs} args - Arguments to create many Inducks_countrynames.
     *     @example
     *     // Create many Inducks_countrynames
     *     const inducks_countryname = await prisma.inducks_countryname.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_countrynameCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_countrynameCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_countryname.
     * @param {inducks_countrynameDeleteArgs} args - Arguments to delete one Inducks_countryname.
     * @example
     * // Delete one Inducks_countryname
     * const Inducks_countryname = await prisma.inducks_countryname.delete({
     *   where: {
     *     // ... filter to delete one Inducks_countryname
     *   }
     * })
     * 
    **/
    delete<T extends inducks_countrynameDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_countrynameDeleteArgs<ExtArgs>>
    ): Prisma__inducks_countrynameClient<$Result.GetResult<Prisma.$inducks_countrynamePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_countryname.
     * @param {inducks_countrynameUpdateArgs} args - Arguments to update one Inducks_countryname.
     * @example
     * // Update one Inducks_countryname
     * const inducks_countryname = await prisma.inducks_countryname.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_countrynameUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_countrynameUpdateArgs<ExtArgs>>
    ): Prisma__inducks_countrynameClient<$Result.GetResult<Prisma.$inducks_countrynamePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_countrynames.
     * @param {inducks_countrynameDeleteManyArgs} args - Arguments to filter Inducks_countrynames to delete.
     * @example
     * // Delete a few Inducks_countrynames
     * const { count } = await prisma.inducks_countryname.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_countrynameDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_countrynameDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_countrynames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_countrynameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_countrynames
     * const inducks_countryname = await prisma.inducks_countryname.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_countrynameUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_countrynameUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_countryname.
     * @param {inducks_countrynameUpsertArgs} args - Arguments to update or create a Inducks_countryname.
     * @example
     * // Update or create a Inducks_countryname
     * const inducks_countryname = await prisma.inducks_countryname.upsert({
     *   create: {
     *     // ... data to create a Inducks_countryname
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_countryname we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_countrynameUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_countrynameUpsertArgs<ExtArgs>>
    ): Prisma__inducks_countrynameClient<$Result.GetResult<Prisma.$inducks_countrynamePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_countrynames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_countrynameCountArgs} args - Arguments to filter Inducks_countrynames to count.
     * @example
     * // Count the number of Inducks_countrynames
     * const count = await prisma.inducks_countryname.count({
     *   where: {
     *     // ... the filter for the Inducks_countrynames we want to count
     *   }
     * })
    **/
    count<T extends inducks_countrynameCountArgs>(
      args?: Subset<T, inducks_countrynameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_countrynameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_countryname.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_countrynameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_countrynameAggregateArgs>(args: Subset<T, Inducks_countrynameAggregateArgs>): Prisma.PrismaPromise<GetInducks_countrynameAggregateType<T>>

    /**
     * Group by Inducks_countryname.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_countrynameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_countrynameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_countrynameGroupByArgs['orderBy'] }
        : { orderBy?: inducks_countrynameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_countrynameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_countrynameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_countryname model
   */
  readonly fields: inducks_countrynameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_countryname.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_countrynameClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_countryname model
   */ 
  interface inducks_countrynameFieldRefs {
    readonly countrycode: FieldRef<"inducks_countryname", 'String'>
    readonly languagecode: FieldRef<"inducks_countryname", 'String'>
    readonly countryname: FieldRef<"inducks_countryname", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_countryname findUnique
   */
  export type inducks_countrynameFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_countryname
     */
    select?: inducks_countrynameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_countryname to fetch.
     */
    where: inducks_countrynameWhereUniqueInput
  }


  /**
   * inducks_countryname findUniqueOrThrow
   */
  export type inducks_countrynameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_countryname
     */
    select?: inducks_countrynameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_countryname to fetch.
     */
    where: inducks_countrynameWhereUniqueInput
  }


  /**
   * inducks_countryname findFirst
   */
  export type inducks_countrynameFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_countryname
     */
    select?: inducks_countrynameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_countryname to fetch.
     */
    where?: inducks_countrynameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_countrynames to fetch.
     */
    orderBy?: inducks_countrynameOrderByWithRelationInput | inducks_countrynameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_countrynames.
     */
    cursor?: inducks_countrynameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_countrynames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_countrynames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_countrynames.
     */
    distinct?: Inducks_countrynameScalarFieldEnum | Inducks_countrynameScalarFieldEnum[]
  }


  /**
   * inducks_countryname findFirstOrThrow
   */
  export type inducks_countrynameFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_countryname
     */
    select?: inducks_countrynameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_countryname to fetch.
     */
    where?: inducks_countrynameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_countrynames to fetch.
     */
    orderBy?: inducks_countrynameOrderByWithRelationInput | inducks_countrynameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_countrynames.
     */
    cursor?: inducks_countrynameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_countrynames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_countrynames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_countrynames.
     */
    distinct?: Inducks_countrynameScalarFieldEnum | Inducks_countrynameScalarFieldEnum[]
  }


  /**
   * inducks_countryname findMany
   */
  export type inducks_countrynameFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_countryname
     */
    select?: inducks_countrynameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_countrynames to fetch.
     */
    where?: inducks_countrynameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_countrynames to fetch.
     */
    orderBy?: inducks_countrynameOrderByWithRelationInput | inducks_countrynameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_countrynames.
     */
    cursor?: inducks_countrynameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_countrynames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_countrynames.
     */
    skip?: number
    distinct?: Inducks_countrynameScalarFieldEnum | Inducks_countrynameScalarFieldEnum[]
  }


  /**
   * inducks_countryname create
   */
  export type inducks_countrynameCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_countryname
     */
    select?: inducks_countrynameSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_countryname.
     */
    data: XOR<inducks_countrynameCreateInput, inducks_countrynameUncheckedCreateInput>
  }


  /**
   * inducks_countryname createMany
   */
  export type inducks_countrynameCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_countrynames.
     */
    data: inducks_countrynameCreateManyInput | inducks_countrynameCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_countryname update
   */
  export type inducks_countrynameUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_countryname
     */
    select?: inducks_countrynameSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_countryname.
     */
    data: XOR<inducks_countrynameUpdateInput, inducks_countrynameUncheckedUpdateInput>
    /**
     * Choose, which inducks_countryname to update.
     */
    where: inducks_countrynameWhereUniqueInput
  }


  /**
   * inducks_countryname updateMany
   */
  export type inducks_countrynameUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_countrynames.
     */
    data: XOR<inducks_countrynameUpdateManyMutationInput, inducks_countrynameUncheckedUpdateManyInput>
    /**
     * Filter which inducks_countrynames to update
     */
    where?: inducks_countrynameWhereInput
  }


  /**
   * inducks_countryname upsert
   */
  export type inducks_countrynameUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_countryname
     */
    select?: inducks_countrynameSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_countryname to update in case it exists.
     */
    where: inducks_countrynameWhereUniqueInput
    /**
     * In case the inducks_countryname found by the `where` argument doesn't exist, create a new inducks_countryname with this data.
     */
    create: XOR<inducks_countrynameCreateInput, inducks_countrynameUncheckedCreateInput>
    /**
     * In case the inducks_countryname was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_countrynameUpdateInput, inducks_countrynameUncheckedUpdateInput>
  }


  /**
   * inducks_countryname delete
   */
  export type inducks_countrynameDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_countryname
     */
    select?: inducks_countrynameSelect<ExtArgs> | null
    /**
     * Filter which inducks_countryname to delete.
     */
    where: inducks_countrynameWhereUniqueInput
  }


  /**
   * inducks_countryname deleteMany
   */
  export type inducks_countrynameDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_countrynames to delete
     */
    where?: inducks_countrynameWhereInput
  }


  /**
   * inducks_countryname without action
   */
  export type inducks_countrynameDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_countryname
     */
    select?: inducks_countrynameSelect<ExtArgs> | null
  }



  /**
   * Model inducks_currency
   */

  export type AggregateInducks_currency = {
    _count: Inducks_currencyCountAggregateOutputType | null
    _min: Inducks_currencyMinAggregateOutputType | null
    _max: Inducks_currencyMaxAggregateOutputType | null
  }

  export type Inducks_currencyMinAggregateOutputType = {
    currencycode: string | null
    currencyname: string | null
  }

  export type Inducks_currencyMaxAggregateOutputType = {
    currencycode: string | null
    currencyname: string | null
  }

  export type Inducks_currencyCountAggregateOutputType = {
    currencycode: number
    currencyname: number
    _all: number
  }


  export type Inducks_currencyMinAggregateInputType = {
    currencycode?: true
    currencyname?: true
  }

  export type Inducks_currencyMaxAggregateInputType = {
    currencycode?: true
    currencyname?: true
  }

  export type Inducks_currencyCountAggregateInputType = {
    currencycode?: true
    currencyname?: true
    _all?: true
  }

  export type Inducks_currencyAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_currency to aggregate.
     */
    where?: inducks_currencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_currencies to fetch.
     */
    orderBy?: inducks_currencyOrderByWithRelationInput | inducks_currencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_currencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_currencies
    **/
    _count?: true | Inducks_currencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_currencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_currencyMaxAggregateInputType
  }

  export type GetInducks_currencyAggregateType<T extends Inducks_currencyAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_currency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_currency[P]>
      : GetScalarType<T[P], AggregateInducks_currency[P]>
  }




  export type inducks_currencyGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_currencyWhereInput
    orderBy?: inducks_currencyOrderByWithAggregationInput | inducks_currencyOrderByWithAggregationInput[]
    by: Inducks_currencyScalarFieldEnum[] | Inducks_currencyScalarFieldEnum
    having?: inducks_currencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_currencyCountAggregateInputType | true
    _min?: Inducks_currencyMinAggregateInputType
    _max?: Inducks_currencyMaxAggregateInputType
  }

  export type Inducks_currencyGroupByOutputType = {
    currencycode: string
    currencyname: string | null
    _count: Inducks_currencyCountAggregateOutputType | null
    _min: Inducks_currencyMinAggregateOutputType | null
    _max: Inducks_currencyMaxAggregateOutputType | null
  }

  type GetInducks_currencyGroupByPayload<T extends inducks_currencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_currencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_currencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_currencyGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_currencyGroupByOutputType[P]>
        }
      >
    >


  export type inducks_currencySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    currencycode?: boolean
    currencyname?: boolean
  }, ExtArgs["result"]["inducks_currency"]>

  export type inducks_currencySelectScalar = {
    currencycode?: boolean
    currencyname?: boolean
  }


  export type $inducks_currencyPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_currency"
    objects: {}
    scalars: $Extensions.GetResult<{
      currencycode: string
      currencyname: string | null
    }, ExtArgs["result"]["inducks_currency"]>
    composites: {}
  }


  type inducks_currencyGetPayload<S extends boolean | null | undefined | inducks_currencyDefaultArgs> = $Result.GetResult<Prisma.$inducks_currencyPayload, S>

  type inducks_currencyCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_currencyFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_currencyCountAggregateInputType | true
    }

  export interface inducks_currencyDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_currency'], meta: { name: 'inducks_currency' } }
    /**
     * Find zero or one Inducks_currency that matches the filter.
     * @param {inducks_currencyFindUniqueArgs} args - Arguments to find a Inducks_currency
     * @example
     * // Get one Inducks_currency
     * const inducks_currency = await prisma.inducks_currency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_currencyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_currencyFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_currencyClient<$Result.GetResult<Prisma.$inducks_currencyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_currency that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_currencyFindUniqueOrThrowArgs} args - Arguments to find a Inducks_currency
     * @example
     * // Get one Inducks_currency
     * const inducks_currency = await prisma.inducks_currency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_currencyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_currencyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_currencyClient<$Result.GetResult<Prisma.$inducks_currencyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_currency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_currencyFindFirstArgs} args - Arguments to find a Inducks_currency
     * @example
     * // Get one Inducks_currency
     * const inducks_currency = await prisma.inducks_currency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_currencyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_currencyFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_currencyClient<$Result.GetResult<Prisma.$inducks_currencyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_currency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_currencyFindFirstOrThrowArgs} args - Arguments to find a Inducks_currency
     * @example
     * // Get one Inducks_currency
     * const inducks_currency = await prisma.inducks_currency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_currencyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_currencyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_currencyClient<$Result.GetResult<Prisma.$inducks_currencyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_currencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_currencyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_currencies
     * const inducks_currencies = await prisma.inducks_currency.findMany()
     * 
     * // Get first 10 Inducks_currencies
     * const inducks_currencies = await prisma.inducks_currency.findMany({ take: 10 })
     * 
     * // Only select the `currencycode`
     * const inducks_currencyWithCurrencycodeOnly = await prisma.inducks_currency.findMany({ select: { currencycode: true } })
     * 
    **/
    findMany<T extends inducks_currencyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_currencyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_currencyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_currency.
     * @param {inducks_currencyCreateArgs} args - Arguments to create a Inducks_currency.
     * @example
     * // Create one Inducks_currency
     * const Inducks_currency = await prisma.inducks_currency.create({
     *   data: {
     *     // ... data to create a Inducks_currency
     *   }
     * })
     * 
    **/
    create<T extends inducks_currencyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_currencyCreateArgs<ExtArgs>>
    ): Prisma__inducks_currencyClient<$Result.GetResult<Prisma.$inducks_currencyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_currencies.
     *     @param {inducks_currencyCreateManyArgs} args - Arguments to create many Inducks_currencies.
     *     @example
     *     // Create many Inducks_currencies
     *     const inducks_currency = await prisma.inducks_currency.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_currencyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_currencyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_currency.
     * @param {inducks_currencyDeleteArgs} args - Arguments to delete one Inducks_currency.
     * @example
     * // Delete one Inducks_currency
     * const Inducks_currency = await prisma.inducks_currency.delete({
     *   where: {
     *     // ... filter to delete one Inducks_currency
     *   }
     * })
     * 
    **/
    delete<T extends inducks_currencyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_currencyDeleteArgs<ExtArgs>>
    ): Prisma__inducks_currencyClient<$Result.GetResult<Prisma.$inducks_currencyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_currency.
     * @param {inducks_currencyUpdateArgs} args - Arguments to update one Inducks_currency.
     * @example
     * // Update one Inducks_currency
     * const inducks_currency = await prisma.inducks_currency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_currencyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_currencyUpdateArgs<ExtArgs>>
    ): Prisma__inducks_currencyClient<$Result.GetResult<Prisma.$inducks_currencyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_currencies.
     * @param {inducks_currencyDeleteManyArgs} args - Arguments to filter Inducks_currencies to delete.
     * @example
     * // Delete a few Inducks_currencies
     * const { count } = await prisma.inducks_currency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_currencyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_currencyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_currencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_currencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_currencies
     * const inducks_currency = await prisma.inducks_currency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_currencyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_currencyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_currency.
     * @param {inducks_currencyUpsertArgs} args - Arguments to update or create a Inducks_currency.
     * @example
     * // Update or create a Inducks_currency
     * const inducks_currency = await prisma.inducks_currency.upsert({
     *   create: {
     *     // ... data to create a Inducks_currency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_currency we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_currencyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_currencyUpsertArgs<ExtArgs>>
    ): Prisma__inducks_currencyClient<$Result.GetResult<Prisma.$inducks_currencyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_currencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_currencyCountArgs} args - Arguments to filter Inducks_currencies to count.
     * @example
     * // Count the number of Inducks_currencies
     * const count = await prisma.inducks_currency.count({
     *   where: {
     *     // ... the filter for the Inducks_currencies we want to count
     *   }
     * })
    **/
    count<T extends inducks_currencyCountArgs>(
      args?: Subset<T, inducks_currencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_currencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_currency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_currencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_currencyAggregateArgs>(args: Subset<T, Inducks_currencyAggregateArgs>): Prisma.PrismaPromise<GetInducks_currencyAggregateType<T>>

    /**
     * Group by Inducks_currency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_currencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_currencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_currencyGroupByArgs['orderBy'] }
        : { orderBy?: inducks_currencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_currencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_currencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_currency model
   */
  readonly fields: inducks_currencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_currency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_currencyClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_currency model
   */ 
  interface inducks_currencyFieldRefs {
    readonly currencycode: FieldRef<"inducks_currency", 'String'>
    readonly currencyname: FieldRef<"inducks_currency", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_currency findUnique
   */
  export type inducks_currencyFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_currency
     */
    select?: inducks_currencySelect<ExtArgs> | null
    /**
     * Filter, which inducks_currency to fetch.
     */
    where: inducks_currencyWhereUniqueInput
  }


  /**
   * inducks_currency findUniqueOrThrow
   */
  export type inducks_currencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_currency
     */
    select?: inducks_currencySelect<ExtArgs> | null
    /**
     * Filter, which inducks_currency to fetch.
     */
    where: inducks_currencyWhereUniqueInput
  }


  /**
   * inducks_currency findFirst
   */
  export type inducks_currencyFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_currency
     */
    select?: inducks_currencySelect<ExtArgs> | null
    /**
     * Filter, which inducks_currency to fetch.
     */
    where?: inducks_currencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_currencies to fetch.
     */
    orderBy?: inducks_currencyOrderByWithRelationInput | inducks_currencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_currencies.
     */
    cursor?: inducks_currencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_currencies.
     */
    distinct?: Inducks_currencyScalarFieldEnum | Inducks_currencyScalarFieldEnum[]
  }


  /**
   * inducks_currency findFirstOrThrow
   */
  export type inducks_currencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_currency
     */
    select?: inducks_currencySelect<ExtArgs> | null
    /**
     * Filter, which inducks_currency to fetch.
     */
    where?: inducks_currencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_currencies to fetch.
     */
    orderBy?: inducks_currencyOrderByWithRelationInput | inducks_currencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_currencies.
     */
    cursor?: inducks_currencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_currencies.
     */
    distinct?: Inducks_currencyScalarFieldEnum | Inducks_currencyScalarFieldEnum[]
  }


  /**
   * inducks_currency findMany
   */
  export type inducks_currencyFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_currency
     */
    select?: inducks_currencySelect<ExtArgs> | null
    /**
     * Filter, which inducks_currencies to fetch.
     */
    where?: inducks_currencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_currencies to fetch.
     */
    orderBy?: inducks_currencyOrderByWithRelationInput | inducks_currencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_currencies.
     */
    cursor?: inducks_currencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_currencies.
     */
    skip?: number
    distinct?: Inducks_currencyScalarFieldEnum | Inducks_currencyScalarFieldEnum[]
  }


  /**
   * inducks_currency create
   */
  export type inducks_currencyCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_currency
     */
    select?: inducks_currencySelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_currency.
     */
    data: XOR<inducks_currencyCreateInput, inducks_currencyUncheckedCreateInput>
  }


  /**
   * inducks_currency createMany
   */
  export type inducks_currencyCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_currencies.
     */
    data: inducks_currencyCreateManyInput | inducks_currencyCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_currency update
   */
  export type inducks_currencyUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_currency
     */
    select?: inducks_currencySelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_currency.
     */
    data: XOR<inducks_currencyUpdateInput, inducks_currencyUncheckedUpdateInput>
    /**
     * Choose, which inducks_currency to update.
     */
    where: inducks_currencyWhereUniqueInput
  }


  /**
   * inducks_currency updateMany
   */
  export type inducks_currencyUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_currencies.
     */
    data: XOR<inducks_currencyUpdateManyMutationInput, inducks_currencyUncheckedUpdateManyInput>
    /**
     * Filter which inducks_currencies to update
     */
    where?: inducks_currencyWhereInput
  }


  /**
   * inducks_currency upsert
   */
  export type inducks_currencyUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_currency
     */
    select?: inducks_currencySelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_currency to update in case it exists.
     */
    where: inducks_currencyWhereUniqueInput
    /**
     * In case the inducks_currency found by the `where` argument doesn't exist, create a new inducks_currency with this data.
     */
    create: XOR<inducks_currencyCreateInput, inducks_currencyUncheckedCreateInput>
    /**
     * In case the inducks_currency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_currencyUpdateInput, inducks_currencyUncheckedUpdateInput>
  }


  /**
   * inducks_currency delete
   */
  export type inducks_currencyDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_currency
     */
    select?: inducks_currencySelect<ExtArgs> | null
    /**
     * Filter which inducks_currency to delete.
     */
    where: inducks_currencyWhereUniqueInput
  }


  /**
   * inducks_currency deleteMany
   */
  export type inducks_currencyDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_currencies to delete
     */
    where?: inducks_currencyWhereInput
  }


  /**
   * inducks_currency without action
   */
  export type inducks_currencyDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_currency
     */
    select?: inducks_currencySelect<ExtArgs> | null
  }



  /**
   * Model inducks_currencyname
   */

  export type AggregateInducks_currencyname = {
    _count: Inducks_currencynameCountAggregateOutputType | null
    _min: Inducks_currencynameMinAggregateOutputType | null
    _max: Inducks_currencynameMaxAggregateOutputType | null
  }

  export type Inducks_currencynameMinAggregateOutputType = {
    currencycode: string | null
    languagecode: string | null
    shortcurrencyname: string | null
    longcurrencyname: string | null
  }

  export type Inducks_currencynameMaxAggregateOutputType = {
    currencycode: string | null
    languagecode: string | null
    shortcurrencyname: string | null
    longcurrencyname: string | null
  }

  export type Inducks_currencynameCountAggregateOutputType = {
    currencycode: number
    languagecode: number
    shortcurrencyname: number
    longcurrencyname: number
    _all: number
  }


  export type Inducks_currencynameMinAggregateInputType = {
    currencycode?: true
    languagecode?: true
    shortcurrencyname?: true
    longcurrencyname?: true
  }

  export type Inducks_currencynameMaxAggregateInputType = {
    currencycode?: true
    languagecode?: true
    shortcurrencyname?: true
    longcurrencyname?: true
  }

  export type Inducks_currencynameCountAggregateInputType = {
    currencycode?: true
    languagecode?: true
    shortcurrencyname?: true
    longcurrencyname?: true
    _all?: true
  }

  export type Inducks_currencynameAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_currencyname to aggregate.
     */
    where?: inducks_currencynameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_currencynames to fetch.
     */
    orderBy?: inducks_currencynameOrderByWithRelationInput | inducks_currencynameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_currencynameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_currencynames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_currencynames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_currencynames
    **/
    _count?: true | Inducks_currencynameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_currencynameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_currencynameMaxAggregateInputType
  }

  export type GetInducks_currencynameAggregateType<T extends Inducks_currencynameAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_currencyname]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_currencyname[P]>
      : GetScalarType<T[P], AggregateInducks_currencyname[P]>
  }




  export type inducks_currencynameGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_currencynameWhereInput
    orderBy?: inducks_currencynameOrderByWithAggregationInput | inducks_currencynameOrderByWithAggregationInput[]
    by: Inducks_currencynameScalarFieldEnum[] | Inducks_currencynameScalarFieldEnum
    having?: inducks_currencynameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_currencynameCountAggregateInputType | true
    _min?: Inducks_currencynameMinAggregateInputType
    _max?: Inducks_currencynameMaxAggregateInputType
  }

  export type Inducks_currencynameGroupByOutputType = {
    currencycode: string
    languagecode: string
    shortcurrencyname: string | null
    longcurrencyname: string | null
    _count: Inducks_currencynameCountAggregateOutputType | null
    _min: Inducks_currencynameMinAggregateOutputType | null
    _max: Inducks_currencynameMaxAggregateOutputType | null
  }

  type GetInducks_currencynameGroupByPayload<T extends inducks_currencynameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_currencynameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_currencynameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_currencynameGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_currencynameGroupByOutputType[P]>
        }
      >
    >


  export type inducks_currencynameSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    currencycode?: boolean
    languagecode?: boolean
    shortcurrencyname?: boolean
    longcurrencyname?: boolean
  }, ExtArgs["result"]["inducks_currencyname"]>

  export type inducks_currencynameSelectScalar = {
    currencycode?: boolean
    languagecode?: boolean
    shortcurrencyname?: boolean
    longcurrencyname?: boolean
  }


  export type $inducks_currencynamePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_currencyname"
    objects: {}
    scalars: $Extensions.GetResult<{
      currencycode: string
      languagecode: string
      shortcurrencyname: string | null
      longcurrencyname: string | null
    }, ExtArgs["result"]["inducks_currencyname"]>
    composites: {}
  }


  type inducks_currencynameGetPayload<S extends boolean | null | undefined | inducks_currencynameDefaultArgs> = $Result.GetResult<Prisma.$inducks_currencynamePayload, S>

  type inducks_currencynameCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_currencynameFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_currencynameCountAggregateInputType | true
    }

  export interface inducks_currencynameDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_currencyname'], meta: { name: 'inducks_currencyname' } }
    /**
     * Find zero or one Inducks_currencyname that matches the filter.
     * @param {inducks_currencynameFindUniqueArgs} args - Arguments to find a Inducks_currencyname
     * @example
     * // Get one Inducks_currencyname
     * const inducks_currencyname = await prisma.inducks_currencyname.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_currencynameFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_currencynameFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_currencynameClient<$Result.GetResult<Prisma.$inducks_currencynamePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_currencyname that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_currencynameFindUniqueOrThrowArgs} args - Arguments to find a Inducks_currencyname
     * @example
     * // Get one Inducks_currencyname
     * const inducks_currencyname = await prisma.inducks_currencyname.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_currencynameFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_currencynameFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_currencynameClient<$Result.GetResult<Prisma.$inducks_currencynamePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_currencyname that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_currencynameFindFirstArgs} args - Arguments to find a Inducks_currencyname
     * @example
     * // Get one Inducks_currencyname
     * const inducks_currencyname = await prisma.inducks_currencyname.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_currencynameFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_currencynameFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_currencynameClient<$Result.GetResult<Prisma.$inducks_currencynamePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_currencyname that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_currencynameFindFirstOrThrowArgs} args - Arguments to find a Inducks_currencyname
     * @example
     * // Get one Inducks_currencyname
     * const inducks_currencyname = await prisma.inducks_currencyname.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_currencynameFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_currencynameFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_currencynameClient<$Result.GetResult<Prisma.$inducks_currencynamePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_currencynames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_currencynameFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_currencynames
     * const inducks_currencynames = await prisma.inducks_currencyname.findMany()
     * 
     * // Get first 10 Inducks_currencynames
     * const inducks_currencynames = await prisma.inducks_currencyname.findMany({ take: 10 })
     * 
     * // Only select the `currencycode`
     * const inducks_currencynameWithCurrencycodeOnly = await prisma.inducks_currencyname.findMany({ select: { currencycode: true } })
     * 
    **/
    findMany<T extends inducks_currencynameFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_currencynameFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_currencynamePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_currencyname.
     * @param {inducks_currencynameCreateArgs} args - Arguments to create a Inducks_currencyname.
     * @example
     * // Create one Inducks_currencyname
     * const Inducks_currencyname = await prisma.inducks_currencyname.create({
     *   data: {
     *     // ... data to create a Inducks_currencyname
     *   }
     * })
     * 
    **/
    create<T extends inducks_currencynameCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_currencynameCreateArgs<ExtArgs>>
    ): Prisma__inducks_currencynameClient<$Result.GetResult<Prisma.$inducks_currencynamePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_currencynames.
     *     @param {inducks_currencynameCreateManyArgs} args - Arguments to create many Inducks_currencynames.
     *     @example
     *     // Create many Inducks_currencynames
     *     const inducks_currencyname = await prisma.inducks_currencyname.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_currencynameCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_currencynameCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_currencyname.
     * @param {inducks_currencynameDeleteArgs} args - Arguments to delete one Inducks_currencyname.
     * @example
     * // Delete one Inducks_currencyname
     * const Inducks_currencyname = await prisma.inducks_currencyname.delete({
     *   where: {
     *     // ... filter to delete one Inducks_currencyname
     *   }
     * })
     * 
    **/
    delete<T extends inducks_currencynameDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_currencynameDeleteArgs<ExtArgs>>
    ): Prisma__inducks_currencynameClient<$Result.GetResult<Prisma.$inducks_currencynamePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_currencyname.
     * @param {inducks_currencynameUpdateArgs} args - Arguments to update one Inducks_currencyname.
     * @example
     * // Update one Inducks_currencyname
     * const inducks_currencyname = await prisma.inducks_currencyname.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_currencynameUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_currencynameUpdateArgs<ExtArgs>>
    ): Prisma__inducks_currencynameClient<$Result.GetResult<Prisma.$inducks_currencynamePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_currencynames.
     * @param {inducks_currencynameDeleteManyArgs} args - Arguments to filter Inducks_currencynames to delete.
     * @example
     * // Delete a few Inducks_currencynames
     * const { count } = await prisma.inducks_currencyname.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_currencynameDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_currencynameDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_currencynames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_currencynameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_currencynames
     * const inducks_currencyname = await prisma.inducks_currencyname.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_currencynameUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_currencynameUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_currencyname.
     * @param {inducks_currencynameUpsertArgs} args - Arguments to update or create a Inducks_currencyname.
     * @example
     * // Update or create a Inducks_currencyname
     * const inducks_currencyname = await prisma.inducks_currencyname.upsert({
     *   create: {
     *     // ... data to create a Inducks_currencyname
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_currencyname we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_currencynameUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_currencynameUpsertArgs<ExtArgs>>
    ): Prisma__inducks_currencynameClient<$Result.GetResult<Prisma.$inducks_currencynamePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_currencynames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_currencynameCountArgs} args - Arguments to filter Inducks_currencynames to count.
     * @example
     * // Count the number of Inducks_currencynames
     * const count = await prisma.inducks_currencyname.count({
     *   where: {
     *     // ... the filter for the Inducks_currencynames we want to count
     *   }
     * })
    **/
    count<T extends inducks_currencynameCountArgs>(
      args?: Subset<T, inducks_currencynameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_currencynameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_currencyname.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_currencynameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_currencynameAggregateArgs>(args: Subset<T, Inducks_currencynameAggregateArgs>): Prisma.PrismaPromise<GetInducks_currencynameAggregateType<T>>

    /**
     * Group by Inducks_currencyname.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_currencynameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_currencynameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_currencynameGroupByArgs['orderBy'] }
        : { orderBy?: inducks_currencynameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_currencynameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_currencynameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_currencyname model
   */
  readonly fields: inducks_currencynameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_currencyname.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_currencynameClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_currencyname model
   */ 
  interface inducks_currencynameFieldRefs {
    readonly currencycode: FieldRef<"inducks_currencyname", 'String'>
    readonly languagecode: FieldRef<"inducks_currencyname", 'String'>
    readonly shortcurrencyname: FieldRef<"inducks_currencyname", 'String'>
    readonly longcurrencyname: FieldRef<"inducks_currencyname", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_currencyname findUnique
   */
  export type inducks_currencynameFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_currencyname
     */
    select?: inducks_currencynameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_currencyname to fetch.
     */
    where: inducks_currencynameWhereUniqueInput
  }


  /**
   * inducks_currencyname findUniqueOrThrow
   */
  export type inducks_currencynameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_currencyname
     */
    select?: inducks_currencynameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_currencyname to fetch.
     */
    where: inducks_currencynameWhereUniqueInput
  }


  /**
   * inducks_currencyname findFirst
   */
  export type inducks_currencynameFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_currencyname
     */
    select?: inducks_currencynameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_currencyname to fetch.
     */
    where?: inducks_currencynameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_currencynames to fetch.
     */
    orderBy?: inducks_currencynameOrderByWithRelationInput | inducks_currencynameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_currencynames.
     */
    cursor?: inducks_currencynameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_currencynames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_currencynames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_currencynames.
     */
    distinct?: Inducks_currencynameScalarFieldEnum | Inducks_currencynameScalarFieldEnum[]
  }


  /**
   * inducks_currencyname findFirstOrThrow
   */
  export type inducks_currencynameFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_currencyname
     */
    select?: inducks_currencynameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_currencyname to fetch.
     */
    where?: inducks_currencynameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_currencynames to fetch.
     */
    orderBy?: inducks_currencynameOrderByWithRelationInput | inducks_currencynameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_currencynames.
     */
    cursor?: inducks_currencynameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_currencynames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_currencynames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_currencynames.
     */
    distinct?: Inducks_currencynameScalarFieldEnum | Inducks_currencynameScalarFieldEnum[]
  }


  /**
   * inducks_currencyname findMany
   */
  export type inducks_currencynameFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_currencyname
     */
    select?: inducks_currencynameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_currencynames to fetch.
     */
    where?: inducks_currencynameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_currencynames to fetch.
     */
    orderBy?: inducks_currencynameOrderByWithRelationInput | inducks_currencynameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_currencynames.
     */
    cursor?: inducks_currencynameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_currencynames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_currencynames.
     */
    skip?: number
    distinct?: Inducks_currencynameScalarFieldEnum | Inducks_currencynameScalarFieldEnum[]
  }


  /**
   * inducks_currencyname create
   */
  export type inducks_currencynameCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_currencyname
     */
    select?: inducks_currencynameSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_currencyname.
     */
    data: XOR<inducks_currencynameCreateInput, inducks_currencynameUncheckedCreateInput>
  }


  /**
   * inducks_currencyname createMany
   */
  export type inducks_currencynameCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_currencynames.
     */
    data: inducks_currencynameCreateManyInput | inducks_currencynameCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_currencyname update
   */
  export type inducks_currencynameUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_currencyname
     */
    select?: inducks_currencynameSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_currencyname.
     */
    data: XOR<inducks_currencynameUpdateInput, inducks_currencynameUncheckedUpdateInput>
    /**
     * Choose, which inducks_currencyname to update.
     */
    where: inducks_currencynameWhereUniqueInput
  }


  /**
   * inducks_currencyname updateMany
   */
  export type inducks_currencynameUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_currencynames.
     */
    data: XOR<inducks_currencynameUpdateManyMutationInput, inducks_currencynameUncheckedUpdateManyInput>
    /**
     * Filter which inducks_currencynames to update
     */
    where?: inducks_currencynameWhereInput
  }


  /**
   * inducks_currencyname upsert
   */
  export type inducks_currencynameUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_currencyname
     */
    select?: inducks_currencynameSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_currencyname to update in case it exists.
     */
    where: inducks_currencynameWhereUniqueInput
    /**
     * In case the inducks_currencyname found by the `where` argument doesn't exist, create a new inducks_currencyname with this data.
     */
    create: XOR<inducks_currencynameCreateInput, inducks_currencynameUncheckedCreateInput>
    /**
     * In case the inducks_currencyname was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_currencynameUpdateInput, inducks_currencynameUncheckedUpdateInput>
  }


  /**
   * inducks_currencyname delete
   */
  export type inducks_currencynameDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_currencyname
     */
    select?: inducks_currencynameSelect<ExtArgs> | null
    /**
     * Filter which inducks_currencyname to delete.
     */
    where: inducks_currencynameWhereUniqueInput
  }


  /**
   * inducks_currencyname deleteMany
   */
  export type inducks_currencynameDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_currencynames to delete
     */
    where?: inducks_currencynameWhereInput
  }


  /**
   * inducks_currencyname without action
   */
  export type inducks_currencynameDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_currencyname
     */
    select?: inducks_currencynameSelect<ExtArgs> | null
  }



  /**
   * Model inducks_entry
   */

  export type AggregateInducks_entry = {
    _count: Inducks_entryCountAggregateOutputType | null
    _min: Inducks_entryMinAggregateOutputType | null
    _max: Inducks_entryMaxAggregateOutputType | null
  }

  export type Inducks_entryMinAggregateOutputType = {
    entrycode: string | null
    issuecode: string | null
    storyversioncode: string | null
    languagecode: string | null
    includedinentrycode: string | null
    position: string | null
    printedcode: string | null
    guessedcode: string | null
    title: string | null
    reallytitle: $Enums.inducks_entry_reallytitle | null
    printedhero: string | null
    changes: string | null
    cut: string | null
    minorchanges: string | null
    missingpanels: string | null
    mirrored: $Enums.inducks_entry_mirrored | null
    sideways: $Enums.inducks_entry_sideways | null
    startdate: string | null
    enddate: string | null
    identificationuncertain: $Enums.inducks_entry_identificationuncertain | null
    alsoreprint: string | null
    part: string | null
    entrycomment: string | null
    error: $Enums.inducks_entry_error | null
  }

  export type Inducks_entryMaxAggregateOutputType = {
    entrycode: string | null
    issuecode: string | null
    storyversioncode: string | null
    languagecode: string | null
    includedinentrycode: string | null
    position: string | null
    printedcode: string | null
    guessedcode: string | null
    title: string | null
    reallytitle: $Enums.inducks_entry_reallytitle | null
    printedhero: string | null
    changes: string | null
    cut: string | null
    minorchanges: string | null
    missingpanels: string | null
    mirrored: $Enums.inducks_entry_mirrored | null
    sideways: $Enums.inducks_entry_sideways | null
    startdate: string | null
    enddate: string | null
    identificationuncertain: $Enums.inducks_entry_identificationuncertain | null
    alsoreprint: string | null
    part: string | null
    entrycomment: string | null
    error: $Enums.inducks_entry_error | null
  }

  export type Inducks_entryCountAggregateOutputType = {
    entrycode: number
    issuecode: number
    storyversioncode: number
    languagecode: number
    includedinentrycode: number
    position: number
    printedcode: number
    guessedcode: number
    title: number
    reallytitle: number
    printedhero: number
    changes: number
    cut: number
    minorchanges: number
    missingpanels: number
    mirrored: number
    sideways: number
    startdate: number
    enddate: number
    identificationuncertain: number
    alsoreprint: number
    part: number
    entrycomment: number
    error: number
    _all: number
  }


  export type Inducks_entryMinAggregateInputType = {
    entrycode?: true
    issuecode?: true
    storyversioncode?: true
    languagecode?: true
    includedinentrycode?: true
    position?: true
    printedcode?: true
    guessedcode?: true
    title?: true
    reallytitle?: true
    printedhero?: true
    changes?: true
    cut?: true
    minorchanges?: true
    missingpanels?: true
    mirrored?: true
    sideways?: true
    startdate?: true
    enddate?: true
    identificationuncertain?: true
    alsoreprint?: true
    part?: true
    entrycomment?: true
    error?: true
  }

  export type Inducks_entryMaxAggregateInputType = {
    entrycode?: true
    issuecode?: true
    storyversioncode?: true
    languagecode?: true
    includedinentrycode?: true
    position?: true
    printedcode?: true
    guessedcode?: true
    title?: true
    reallytitle?: true
    printedhero?: true
    changes?: true
    cut?: true
    minorchanges?: true
    missingpanels?: true
    mirrored?: true
    sideways?: true
    startdate?: true
    enddate?: true
    identificationuncertain?: true
    alsoreprint?: true
    part?: true
    entrycomment?: true
    error?: true
  }

  export type Inducks_entryCountAggregateInputType = {
    entrycode?: true
    issuecode?: true
    storyversioncode?: true
    languagecode?: true
    includedinentrycode?: true
    position?: true
    printedcode?: true
    guessedcode?: true
    title?: true
    reallytitle?: true
    printedhero?: true
    changes?: true
    cut?: true
    minorchanges?: true
    missingpanels?: true
    mirrored?: true
    sideways?: true
    startdate?: true
    enddate?: true
    identificationuncertain?: true
    alsoreprint?: true
    part?: true
    entrycomment?: true
    error?: true
    _all?: true
  }

  export type Inducks_entryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_entry to aggregate.
     */
    where?: inducks_entryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_entries to fetch.
     */
    orderBy?: inducks_entryOrderByWithRelationInput | inducks_entryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_entryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_entries
    **/
    _count?: true | Inducks_entryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_entryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_entryMaxAggregateInputType
  }

  export type GetInducks_entryAggregateType<T extends Inducks_entryAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_entry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_entry[P]>
      : GetScalarType<T[P], AggregateInducks_entry[P]>
  }




  export type inducks_entryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_entryWhereInput
    orderBy?: inducks_entryOrderByWithAggregationInput | inducks_entryOrderByWithAggregationInput[]
    by: Inducks_entryScalarFieldEnum[] | Inducks_entryScalarFieldEnum
    having?: inducks_entryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_entryCountAggregateInputType | true
    _min?: Inducks_entryMinAggregateInputType
    _max?: Inducks_entryMaxAggregateInputType
  }

  export type Inducks_entryGroupByOutputType = {
    entrycode: string
    issuecode: string | null
    storyversioncode: string | null
    languagecode: string | null
    includedinentrycode: string | null
    position: string | null
    printedcode: string | null
    guessedcode: string | null
    title: string | null
    reallytitle: $Enums.inducks_entry_reallytitle | null
    printedhero: string | null
    changes: string | null
    cut: string | null
    minorchanges: string | null
    missingpanels: string | null
    mirrored: $Enums.inducks_entry_mirrored | null
    sideways: $Enums.inducks_entry_sideways | null
    startdate: string | null
    enddate: string | null
    identificationuncertain: $Enums.inducks_entry_identificationuncertain | null
    alsoreprint: string | null
    part: string | null
    entrycomment: string | null
    error: $Enums.inducks_entry_error | null
    _count: Inducks_entryCountAggregateOutputType | null
    _min: Inducks_entryMinAggregateOutputType | null
    _max: Inducks_entryMaxAggregateOutputType | null
  }

  type GetInducks_entryGroupByPayload<T extends inducks_entryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_entryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_entryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_entryGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_entryGroupByOutputType[P]>
        }
      >
    >


  export type inducks_entrySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    entrycode?: boolean
    issuecode?: boolean
    storyversioncode?: boolean
    languagecode?: boolean
    includedinentrycode?: boolean
    position?: boolean
    printedcode?: boolean
    guessedcode?: boolean
    title?: boolean
    reallytitle?: boolean
    printedhero?: boolean
    changes?: boolean
    cut?: boolean
    minorchanges?: boolean
    missingpanels?: boolean
    mirrored?: boolean
    sideways?: boolean
    startdate?: boolean
    enddate?: boolean
    identificationuncertain?: boolean
    alsoreprint?: boolean
    part?: boolean
    entrycomment?: boolean
    error?: boolean
  }, ExtArgs["result"]["inducks_entry"]>

  export type inducks_entrySelectScalar = {
    entrycode?: boolean
    issuecode?: boolean
    storyversioncode?: boolean
    languagecode?: boolean
    includedinentrycode?: boolean
    position?: boolean
    printedcode?: boolean
    guessedcode?: boolean
    title?: boolean
    reallytitle?: boolean
    printedhero?: boolean
    changes?: boolean
    cut?: boolean
    minorchanges?: boolean
    missingpanels?: boolean
    mirrored?: boolean
    sideways?: boolean
    startdate?: boolean
    enddate?: boolean
    identificationuncertain?: boolean
    alsoreprint?: boolean
    part?: boolean
    entrycomment?: boolean
    error?: boolean
  }


  export type $inducks_entryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_entry"
    objects: {}
    scalars: $Extensions.GetResult<{
      entrycode: string
      issuecode: string | null
      storyversioncode: string | null
      languagecode: string | null
      includedinentrycode: string | null
      position: string | null
      printedcode: string | null
      guessedcode: string | null
      title: string | null
      reallytitle: $Enums.inducks_entry_reallytitle | null
      printedhero: string | null
      changes: string | null
      cut: string | null
      minorchanges: string | null
      missingpanels: string | null
      mirrored: $Enums.inducks_entry_mirrored | null
      sideways: $Enums.inducks_entry_sideways | null
      startdate: string | null
      enddate: string | null
      identificationuncertain: $Enums.inducks_entry_identificationuncertain | null
      alsoreprint: string | null
      part: string | null
      entrycomment: string | null
      error: $Enums.inducks_entry_error | null
    }, ExtArgs["result"]["inducks_entry"]>
    composites: {}
  }


  type inducks_entryGetPayload<S extends boolean | null | undefined | inducks_entryDefaultArgs> = $Result.GetResult<Prisma.$inducks_entryPayload, S>

  type inducks_entryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_entryFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_entryCountAggregateInputType | true
    }

  export interface inducks_entryDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_entry'], meta: { name: 'inducks_entry' } }
    /**
     * Find zero or one Inducks_entry that matches the filter.
     * @param {inducks_entryFindUniqueArgs} args - Arguments to find a Inducks_entry
     * @example
     * // Get one Inducks_entry
     * const inducks_entry = await prisma.inducks_entry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_entryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_entryFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_entryClient<$Result.GetResult<Prisma.$inducks_entryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_entry that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_entryFindUniqueOrThrowArgs} args - Arguments to find a Inducks_entry
     * @example
     * // Get one Inducks_entry
     * const inducks_entry = await prisma.inducks_entry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_entryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_entryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_entryClient<$Result.GetResult<Prisma.$inducks_entryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_entry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_entryFindFirstArgs} args - Arguments to find a Inducks_entry
     * @example
     * // Get one Inducks_entry
     * const inducks_entry = await prisma.inducks_entry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_entryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_entryFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_entryClient<$Result.GetResult<Prisma.$inducks_entryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_entry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_entryFindFirstOrThrowArgs} args - Arguments to find a Inducks_entry
     * @example
     * // Get one Inducks_entry
     * const inducks_entry = await prisma.inducks_entry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_entryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_entryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_entryClient<$Result.GetResult<Prisma.$inducks_entryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_entries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_entryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_entries
     * const inducks_entries = await prisma.inducks_entry.findMany()
     * 
     * // Get first 10 Inducks_entries
     * const inducks_entries = await prisma.inducks_entry.findMany({ take: 10 })
     * 
     * // Only select the `entrycode`
     * const inducks_entryWithEntrycodeOnly = await prisma.inducks_entry.findMany({ select: { entrycode: true } })
     * 
    **/
    findMany<T extends inducks_entryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_entryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_entryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_entry.
     * @param {inducks_entryCreateArgs} args - Arguments to create a Inducks_entry.
     * @example
     * // Create one Inducks_entry
     * const Inducks_entry = await prisma.inducks_entry.create({
     *   data: {
     *     // ... data to create a Inducks_entry
     *   }
     * })
     * 
    **/
    create<T extends inducks_entryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_entryCreateArgs<ExtArgs>>
    ): Prisma__inducks_entryClient<$Result.GetResult<Prisma.$inducks_entryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_entries.
     *     @param {inducks_entryCreateManyArgs} args - Arguments to create many Inducks_entries.
     *     @example
     *     // Create many Inducks_entries
     *     const inducks_entry = await prisma.inducks_entry.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_entryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_entryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_entry.
     * @param {inducks_entryDeleteArgs} args - Arguments to delete one Inducks_entry.
     * @example
     * // Delete one Inducks_entry
     * const Inducks_entry = await prisma.inducks_entry.delete({
     *   where: {
     *     // ... filter to delete one Inducks_entry
     *   }
     * })
     * 
    **/
    delete<T extends inducks_entryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_entryDeleteArgs<ExtArgs>>
    ): Prisma__inducks_entryClient<$Result.GetResult<Prisma.$inducks_entryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_entry.
     * @param {inducks_entryUpdateArgs} args - Arguments to update one Inducks_entry.
     * @example
     * // Update one Inducks_entry
     * const inducks_entry = await prisma.inducks_entry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_entryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_entryUpdateArgs<ExtArgs>>
    ): Prisma__inducks_entryClient<$Result.GetResult<Prisma.$inducks_entryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_entries.
     * @param {inducks_entryDeleteManyArgs} args - Arguments to filter Inducks_entries to delete.
     * @example
     * // Delete a few Inducks_entries
     * const { count } = await prisma.inducks_entry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_entryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_entryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_entryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_entries
     * const inducks_entry = await prisma.inducks_entry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_entryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_entryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_entry.
     * @param {inducks_entryUpsertArgs} args - Arguments to update or create a Inducks_entry.
     * @example
     * // Update or create a Inducks_entry
     * const inducks_entry = await prisma.inducks_entry.upsert({
     *   create: {
     *     // ... data to create a Inducks_entry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_entry we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_entryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_entryUpsertArgs<ExtArgs>>
    ): Prisma__inducks_entryClient<$Result.GetResult<Prisma.$inducks_entryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_entryCountArgs} args - Arguments to filter Inducks_entries to count.
     * @example
     * // Count the number of Inducks_entries
     * const count = await prisma.inducks_entry.count({
     *   where: {
     *     // ... the filter for the Inducks_entries we want to count
     *   }
     * })
    **/
    count<T extends inducks_entryCountArgs>(
      args?: Subset<T, inducks_entryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_entryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_entry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_entryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_entryAggregateArgs>(args: Subset<T, Inducks_entryAggregateArgs>): Prisma.PrismaPromise<GetInducks_entryAggregateType<T>>

    /**
     * Group by Inducks_entry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_entryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_entryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_entryGroupByArgs['orderBy'] }
        : { orderBy?: inducks_entryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_entryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_entryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_entry model
   */
  readonly fields: inducks_entryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_entry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_entryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_entry model
   */ 
  interface inducks_entryFieldRefs {
    readonly entrycode: FieldRef<"inducks_entry", 'String'>
    readonly issuecode: FieldRef<"inducks_entry", 'String'>
    readonly storyversioncode: FieldRef<"inducks_entry", 'String'>
    readonly languagecode: FieldRef<"inducks_entry", 'String'>
    readonly includedinentrycode: FieldRef<"inducks_entry", 'String'>
    readonly position: FieldRef<"inducks_entry", 'String'>
    readonly printedcode: FieldRef<"inducks_entry", 'String'>
    readonly guessedcode: FieldRef<"inducks_entry", 'String'>
    readonly title: FieldRef<"inducks_entry", 'String'>
    readonly reallytitle: FieldRef<"inducks_entry", 'inducks_entry_reallytitle'>
    readonly printedhero: FieldRef<"inducks_entry", 'String'>
    readonly changes: FieldRef<"inducks_entry", 'String'>
    readonly cut: FieldRef<"inducks_entry", 'String'>
    readonly minorchanges: FieldRef<"inducks_entry", 'String'>
    readonly missingpanels: FieldRef<"inducks_entry", 'String'>
    readonly mirrored: FieldRef<"inducks_entry", 'inducks_entry_mirrored'>
    readonly sideways: FieldRef<"inducks_entry", 'inducks_entry_sideways'>
    readonly startdate: FieldRef<"inducks_entry", 'String'>
    readonly enddate: FieldRef<"inducks_entry", 'String'>
    readonly identificationuncertain: FieldRef<"inducks_entry", 'inducks_entry_identificationuncertain'>
    readonly alsoreprint: FieldRef<"inducks_entry", 'String'>
    readonly part: FieldRef<"inducks_entry", 'String'>
    readonly entrycomment: FieldRef<"inducks_entry", 'String'>
    readonly error: FieldRef<"inducks_entry", 'inducks_entry_error'>
  }
    

  // Custom InputTypes

  /**
   * inducks_entry findUnique
   */
  export type inducks_entryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entry
     */
    select?: inducks_entrySelect<ExtArgs> | null
    /**
     * Filter, which inducks_entry to fetch.
     */
    where: inducks_entryWhereUniqueInput
  }


  /**
   * inducks_entry findUniqueOrThrow
   */
  export type inducks_entryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entry
     */
    select?: inducks_entrySelect<ExtArgs> | null
    /**
     * Filter, which inducks_entry to fetch.
     */
    where: inducks_entryWhereUniqueInput
  }


  /**
   * inducks_entry findFirst
   */
  export type inducks_entryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entry
     */
    select?: inducks_entrySelect<ExtArgs> | null
    /**
     * Filter, which inducks_entry to fetch.
     */
    where?: inducks_entryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_entries to fetch.
     */
    orderBy?: inducks_entryOrderByWithRelationInput | inducks_entryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_entries.
     */
    cursor?: inducks_entryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_entries.
     */
    distinct?: Inducks_entryScalarFieldEnum | Inducks_entryScalarFieldEnum[]
  }


  /**
   * inducks_entry findFirstOrThrow
   */
  export type inducks_entryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entry
     */
    select?: inducks_entrySelect<ExtArgs> | null
    /**
     * Filter, which inducks_entry to fetch.
     */
    where?: inducks_entryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_entries to fetch.
     */
    orderBy?: inducks_entryOrderByWithRelationInput | inducks_entryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_entries.
     */
    cursor?: inducks_entryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_entries.
     */
    distinct?: Inducks_entryScalarFieldEnum | Inducks_entryScalarFieldEnum[]
  }


  /**
   * inducks_entry findMany
   */
  export type inducks_entryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entry
     */
    select?: inducks_entrySelect<ExtArgs> | null
    /**
     * Filter, which inducks_entries to fetch.
     */
    where?: inducks_entryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_entries to fetch.
     */
    orderBy?: inducks_entryOrderByWithRelationInput | inducks_entryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_entries.
     */
    cursor?: inducks_entryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_entries.
     */
    skip?: number
    distinct?: Inducks_entryScalarFieldEnum | Inducks_entryScalarFieldEnum[]
  }


  /**
   * inducks_entry create
   */
  export type inducks_entryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entry
     */
    select?: inducks_entrySelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_entry.
     */
    data: XOR<inducks_entryCreateInput, inducks_entryUncheckedCreateInput>
  }


  /**
   * inducks_entry createMany
   */
  export type inducks_entryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_entries.
     */
    data: inducks_entryCreateManyInput | inducks_entryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_entry update
   */
  export type inducks_entryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entry
     */
    select?: inducks_entrySelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_entry.
     */
    data: XOR<inducks_entryUpdateInput, inducks_entryUncheckedUpdateInput>
    /**
     * Choose, which inducks_entry to update.
     */
    where: inducks_entryWhereUniqueInput
  }


  /**
   * inducks_entry updateMany
   */
  export type inducks_entryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_entries.
     */
    data: XOR<inducks_entryUpdateManyMutationInput, inducks_entryUncheckedUpdateManyInput>
    /**
     * Filter which inducks_entries to update
     */
    where?: inducks_entryWhereInput
  }


  /**
   * inducks_entry upsert
   */
  export type inducks_entryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entry
     */
    select?: inducks_entrySelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_entry to update in case it exists.
     */
    where: inducks_entryWhereUniqueInput
    /**
     * In case the inducks_entry found by the `where` argument doesn't exist, create a new inducks_entry with this data.
     */
    create: XOR<inducks_entryCreateInput, inducks_entryUncheckedCreateInput>
    /**
     * In case the inducks_entry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_entryUpdateInput, inducks_entryUncheckedUpdateInput>
  }


  /**
   * inducks_entry delete
   */
  export type inducks_entryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entry
     */
    select?: inducks_entrySelect<ExtArgs> | null
    /**
     * Filter which inducks_entry to delete.
     */
    where: inducks_entryWhereUniqueInput
  }


  /**
   * inducks_entry deleteMany
   */
  export type inducks_entryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_entries to delete
     */
    where?: inducks_entryWhereInput
  }


  /**
   * inducks_entry without action
   */
  export type inducks_entryDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entry
     */
    select?: inducks_entrySelect<ExtArgs> | null
  }



  /**
   * Model inducks_entry_nofulltext
   */

  export type AggregateInducks_entry_nofulltext = {
    _count: Inducks_entry_nofulltextCountAggregateOutputType | null
    _min: Inducks_entry_nofulltextMinAggregateOutputType | null
    _max: Inducks_entry_nofulltextMaxAggregateOutputType | null
  }

  export type Inducks_entry_nofulltextMinAggregateOutputType = {
    entrycode: string | null
    issuecode: string | null
    storyversioncode: string | null
    languagecode: string | null
    includedinentrycode: string | null
    position: string | null
    printedcode: string | null
    guessedcode: string | null
    title: string | null
    reallytitle: $Enums.inducks_entry_nofulltext_reallytitle | null
    printedhero: string | null
    changes: string | null
    cut: string | null
    minorchanges: string | null
    missingpanels: string | null
    mirrored: $Enums.inducks_entry_nofulltext_mirrored | null
    sideways: $Enums.inducks_entry_nofulltext_sideways | null
    startdate: string | null
    enddate: string | null
    identificationuncertain: $Enums.inducks_entry_nofulltext_identificationuncertain | null
    alsoreprint: string | null
    part: string | null
    entrycomment: string | null
    error: $Enums.inducks_entry_nofulltext_error | null
  }

  export type Inducks_entry_nofulltextMaxAggregateOutputType = {
    entrycode: string | null
    issuecode: string | null
    storyversioncode: string | null
    languagecode: string | null
    includedinentrycode: string | null
    position: string | null
    printedcode: string | null
    guessedcode: string | null
    title: string | null
    reallytitle: $Enums.inducks_entry_nofulltext_reallytitle | null
    printedhero: string | null
    changes: string | null
    cut: string | null
    minorchanges: string | null
    missingpanels: string | null
    mirrored: $Enums.inducks_entry_nofulltext_mirrored | null
    sideways: $Enums.inducks_entry_nofulltext_sideways | null
    startdate: string | null
    enddate: string | null
    identificationuncertain: $Enums.inducks_entry_nofulltext_identificationuncertain | null
    alsoreprint: string | null
    part: string | null
    entrycomment: string | null
    error: $Enums.inducks_entry_nofulltext_error | null
  }

  export type Inducks_entry_nofulltextCountAggregateOutputType = {
    entrycode: number
    issuecode: number
    storyversioncode: number
    languagecode: number
    includedinentrycode: number
    position: number
    printedcode: number
    guessedcode: number
    title: number
    reallytitle: number
    printedhero: number
    changes: number
    cut: number
    minorchanges: number
    missingpanels: number
    mirrored: number
    sideways: number
    startdate: number
    enddate: number
    identificationuncertain: number
    alsoreprint: number
    part: number
    entrycomment: number
    error: number
    _all: number
  }


  export type Inducks_entry_nofulltextMinAggregateInputType = {
    entrycode?: true
    issuecode?: true
    storyversioncode?: true
    languagecode?: true
    includedinentrycode?: true
    position?: true
    printedcode?: true
    guessedcode?: true
    title?: true
    reallytitle?: true
    printedhero?: true
    changes?: true
    cut?: true
    minorchanges?: true
    missingpanels?: true
    mirrored?: true
    sideways?: true
    startdate?: true
    enddate?: true
    identificationuncertain?: true
    alsoreprint?: true
    part?: true
    entrycomment?: true
    error?: true
  }

  export type Inducks_entry_nofulltextMaxAggregateInputType = {
    entrycode?: true
    issuecode?: true
    storyversioncode?: true
    languagecode?: true
    includedinentrycode?: true
    position?: true
    printedcode?: true
    guessedcode?: true
    title?: true
    reallytitle?: true
    printedhero?: true
    changes?: true
    cut?: true
    minorchanges?: true
    missingpanels?: true
    mirrored?: true
    sideways?: true
    startdate?: true
    enddate?: true
    identificationuncertain?: true
    alsoreprint?: true
    part?: true
    entrycomment?: true
    error?: true
  }

  export type Inducks_entry_nofulltextCountAggregateInputType = {
    entrycode?: true
    issuecode?: true
    storyversioncode?: true
    languagecode?: true
    includedinentrycode?: true
    position?: true
    printedcode?: true
    guessedcode?: true
    title?: true
    reallytitle?: true
    printedhero?: true
    changes?: true
    cut?: true
    minorchanges?: true
    missingpanels?: true
    mirrored?: true
    sideways?: true
    startdate?: true
    enddate?: true
    identificationuncertain?: true
    alsoreprint?: true
    part?: true
    entrycomment?: true
    error?: true
    _all?: true
  }

  export type Inducks_entry_nofulltextAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_entry_nofulltext to aggregate.
     */
    where?: inducks_entry_nofulltextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_entry_nofulltexts to fetch.
     */
    orderBy?: inducks_entry_nofulltextOrderByWithRelationInput | inducks_entry_nofulltextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_entry_nofulltextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_entry_nofulltexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_entry_nofulltexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_entry_nofulltexts
    **/
    _count?: true | Inducks_entry_nofulltextCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_entry_nofulltextMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_entry_nofulltextMaxAggregateInputType
  }

  export type GetInducks_entry_nofulltextAggregateType<T extends Inducks_entry_nofulltextAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_entry_nofulltext]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_entry_nofulltext[P]>
      : GetScalarType<T[P], AggregateInducks_entry_nofulltext[P]>
  }




  export type inducks_entry_nofulltextGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_entry_nofulltextWhereInput
    orderBy?: inducks_entry_nofulltextOrderByWithAggregationInput | inducks_entry_nofulltextOrderByWithAggregationInput[]
    by: Inducks_entry_nofulltextScalarFieldEnum[] | Inducks_entry_nofulltextScalarFieldEnum
    having?: inducks_entry_nofulltextScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_entry_nofulltextCountAggregateInputType | true
    _min?: Inducks_entry_nofulltextMinAggregateInputType
    _max?: Inducks_entry_nofulltextMaxAggregateInputType
  }

  export type Inducks_entry_nofulltextGroupByOutputType = {
    entrycode: string
    issuecode: string | null
    storyversioncode: string | null
    languagecode: string | null
    includedinentrycode: string | null
    position: string | null
    printedcode: string | null
    guessedcode: string | null
    title: string | null
    reallytitle: $Enums.inducks_entry_nofulltext_reallytitle | null
    printedhero: string | null
    changes: string | null
    cut: string | null
    minorchanges: string | null
    missingpanels: string | null
    mirrored: $Enums.inducks_entry_nofulltext_mirrored | null
    sideways: $Enums.inducks_entry_nofulltext_sideways | null
    startdate: string | null
    enddate: string | null
    identificationuncertain: $Enums.inducks_entry_nofulltext_identificationuncertain | null
    alsoreprint: string | null
    part: string | null
    entrycomment: string | null
    error: $Enums.inducks_entry_nofulltext_error | null
    _count: Inducks_entry_nofulltextCountAggregateOutputType | null
    _min: Inducks_entry_nofulltextMinAggregateOutputType | null
    _max: Inducks_entry_nofulltextMaxAggregateOutputType | null
  }

  type GetInducks_entry_nofulltextGroupByPayload<T extends inducks_entry_nofulltextGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_entry_nofulltextGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_entry_nofulltextGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_entry_nofulltextGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_entry_nofulltextGroupByOutputType[P]>
        }
      >
    >


  export type inducks_entry_nofulltextSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    entrycode?: boolean
    issuecode?: boolean
    storyversioncode?: boolean
    languagecode?: boolean
    includedinentrycode?: boolean
    position?: boolean
    printedcode?: boolean
    guessedcode?: boolean
    title?: boolean
    reallytitle?: boolean
    printedhero?: boolean
    changes?: boolean
    cut?: boolean
    minorchanges?: boolean
    missingpanels?: boolean
    mirrored?: boolean
    sideways?: boolean
    startdate?: boolean
    enddate?: boolean
    identificationuncertain?: boolean
    alsoreprint?: boolean
    part?: boolean
    entrycomment?: boolean
    error?: boolean
  }, ExtArgs["result"]["inducks_entry_nofulltext"]>

  export type inducks_entry_nofulltextSelectScalar = {
    entrycode?: boolean
    issuecode?: boolean
    storyversioncode?: boolean
    languagecode?: boolean
    includedinentrycode?: boolean
    position?: boolean
    printedcode?: boolean
    guessedcode?: boolean
    title?: boolean
    reallytitle?: boolean
    printedhero?: boolean
    changes?: boolean
    cut?: boolean
    minorchanges?: boolean
    missingpanels?: boolean
    mirrored?: boolean
    sideways?: boolean
    startdate?: boolean
    enddate?: boolean
    identificationuncertain?: boolean
    alsoreprint?: boolean
    part?: boolean
    entrycomment?: boolean
    error?: boolean
  }


  export type $inducks_entry_nofulltextPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_entry_nofulltext"
    objects: {}
    scalars: $Extensions.GetResult<{
      entrycode: string
      issuecode: string | null
      storyversioncode: string | null
      languagecode: string | null
      includedinentrycode: string | null
      position: string | null
      printedcode: string | null
      guessedcode: string | null
      title: string | null
      reallytitle: $Enums.inducks_entry_nofulltext_reallytitle | null
      printedhero: string | null
      changes: string | null
      cut: string | null
      minorchanges: string | null
      missingpanels: string | null
      mirrored: $Enums.inducks_entry_nofulltext_mirrored | null
      sideways: $Enums.inducks_entry_nofulltext_sideways | null
      startdate: string | null
      enddate: string | null
      identificationuncertain: $Enums.inducks_entry_nofulltext_identificationuncertain | null
      alsoreprint: string | null
      part: string | null
      entrycomment: string | null
      error: $Enums.inducks_entry_nofulltext_error | null
    }, ExtArgs["result"]["inducks_entry_nofulltext"]>
    composites: {}
  }


  type inducks_entry_nofulltextGetPayload<S extends boolean | null | undefined | inducks_entry_nofulltextDefaultArgs> = $Result.GetResult<Prisma.$inducks_entry_nofulltextPayload, S>

  type inducks_entry_nofulltextCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_entry_nofulltextFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_entry_nofulltextCountAggregateInputType | true
    }

  export interface inducks_entry_nofulltextDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_entry_nofulltext'], meta: { name: 'inducks_entry_nofulltext' } }
    /**
     * Find zero or one Inducks_entry_nofulltext that matches the filter.
     * @param {inducks_entry_nofulltextFindUniqueArgs} args - Arguments to find a Inducks_entry_nofulltext
     * @example
     * // Get one Inducks_entry_nofulltext
     * const inducks_entry_nofulltext = await prisma.inducks_entry_nofulltext.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_entry_nofulltextFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_entry_nofulltextFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_entry_nofulltextClient<$Result.GetResult<Prisma.$inducks_entry_nofulltextPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_entry_nofulltext that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_entry_nofulltextFindUniqueOrThrowArgs} args - Arguments to find a Inducks_entry_nofulltext
     * @example
     * // Get one Inducks_entry_nofulltext
     * const inducks_entry_nofulltext = await prisma.inducks_entry_nofulltext.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_entry_nofulltextFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_entry_nofulltextFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_entry_nofulltextClient<$Result.GetResult<Prisma.$inducks_entry_nofulltextPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_entry_nofulltext that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_entry_nofulltextFindFirstArgs} args - Arguments to find a Inducks_entry_nofulltext
     * @example
     * // Get one Inducks_entry_nofulltext
     * const inducks_entry_nofulltext = await prisma.inducks_entry_nofulltext.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_entry_nofulltextFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_entry_nofulltextFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_entry_nofulltextClient<$Result.GetResult<Prisma.$inducks_entry_nofulltextPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_entry_nofulltext that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_entry_nofulltextFindFirstOrThrowArgs} args - Arguments to find a Inducks_entry_nofulltext
     * @example
     * // Get one Inducks_entry_nofulltext
     * const inducks_entry_nofulltext = await prisma.inducks_entry_nofulltext.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_entry_nofulltextFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_entry_nofulltextFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_entry_nofulltextClient<$Result.GetResult<Prisma.$inducks_entry_nofulltextPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_entry_nofulltexts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_entry_nofulltextFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_entry_nofulltexts
     * const inducks_entry_nofulltexts = await prisma.inducks_entry_nofulltext.findMany()
     * 
     * // Get first 10 Inducks_entry_nofulltexts
     * const inducks_entry_nofulltexts = await prisma.inducks_entry_nofulltext.findMany({ take: 10 })
     * 
     * // Only select the `entrycode`
     * const inducks_entry_nofulltextWithEntrycodeOnly = await prisma.inducks_entry_nofulltext.findMany({ select: { entrycode: true } })
     * 
    **/
    findMany<T extends inducks_entry_nofulltextFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_entry_nofulltextFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_entry_nofulltextPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_entry_nofulltext.
     * @param {inducks_entry_nofulltextCreateArgs} args - Arguments to create a Inducks_entry_nofulltext.
     * @example
     * // Create one Inducks_entry_nofulltext
     * const Inducks_entry_nofulltext = await prisma.inducks_entry_nofulltext.create({
     *   data: {
     *     // ... data to create a Inducks_entry_nofulltext
     *   }
     * })
     * 
    **/
    create<T extends inducks_entry_nofulltextCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_entry_nofulltextCreateArgs<ExtArgs>>
    ): Prisma__inducks_entry_nofulltextClient<$Result.GetResult<Prisma.$inducks_entry_nofulltextPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_entry_nofulltexts.
     *     @param {inducks_entry_nofulltextCreateManyArgs} args - Arguments to create many Inducks_entry_nofulltexts.
     *     @example
     *     // Create many Inducks_entry_nofulltexts
     *     const inducks_entry_nofulltext = await prisma.inducks_entry_nofulltext.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_entry_nofulltextCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_entry_nofulltextCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_entry_nofulltext.
     * @param {inducks_entry_nofulltextDeleteArgs} args - Arguments to delete one Inducks_entry_nofulltext.
     * @example
     * // Delete one Inducks_entry_nofulltext
     * const Inducks_entry_nofulltext = await prisma.inducks_entry_nofulltext.delete({
     *   where: {
     *     // ... filter to delete one Inducks_entry_nofulltext
     *   }
     * })
     * 
    **/
    delete<T extends inducks_entry_nofulltextDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_entry_nofulltextDeleteArgs<ExtArgs>>
    ): Prisma__inducks_entry_nofulltextClient<$Result.GetResult<Prisma.$inducks_entry_nofulltextPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_entry_nofulltext.
     * @param {inducks_entry_nofulltextUpdateArgs} args - Arguments to update one Inducks_entry_nofulltext.
     * @example
     * // Update one Inducks_entry_nofulltext
     * const inducks_entry_nofulltext = await prisma.inducks_entry_nofulltext.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_entry_nofulltextUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_entry_nofulltextUpdateArgs<ExtArgs>>
    ): Prisma__inducks_entry_nofulltextClient<$Result.GetResult<Prisma.$inducks_entry_nofulltextPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_entry_nofulltexts.
     * @param {inducks_entry_nofulltextDeleteManyArgs} args - Arguments to filter Inducks_entry_nofulltexts to delete.
     * @example
     * // Delete a few Inducks_entry_nofulltexts
     * const { count } = await prisma.inducks_entry_nofulltext.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_entry_nofulltextDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_entry_nofulltextDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_entry_nofulltexts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_entry_nofulltextUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_entry_nofulltexts
     * const inducks_entry_nofulltext = await prisma.inducks_entry_nofulltext.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_entry_nofulltextUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_entry_nofulltextUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_entry_nofulltext.
     * @param {inducks_entry_nofulltextUpsertArgs} args - Arguments to update or create a Inducks_entry_nofulltext.
     * @example
     * // Update or create a Inducks_entry_nofulltext
     * const inducks_entry_nofulltext = await prisma.inducks_entry_nofulltext.upsert({
     *   create: {
     *     // ... data to create a Inducks_entry_nofulltext
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_entry_nofulltext we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_entry_nofulltextUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_entry_nofulltextUpsertArgs<ExtArgs>>
    ): Prisma__inducks_entry_nofulltextClient<$Result.GetResult<Prisma.$inducks_entry_nofulltextPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_entry_nofulltexts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_entry_nofulltextCountArgs} args - Arguments to filter Inducks_entry_nofulltexts to count.
     * @example
     * // Count the number of Inducks_entry_nofulltexts
     * const count = await prisma.inducks_entry_nofulltext.count({
     *   where: {
     *     // ... the filter for the Inducks_entry_nofulltexts we want to count
     *   }
     * })
    **/
    count<T extends inducks_entry_nofulltextCountArgs>(
      args?: Subset<T, inducks_entry_nofulltextCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_entry_nofulltextCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_entry_nofulltext.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_entry_nofulltextAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_entry_nofulltextAggregateArgs>(args: Subset<T, Inducks_entry_nofulltextAggregateArgs>): Prisma.PrismaPromise<GetInducks_entry_nofulltextAggregateType<T>>

    /**
     * Group by Inducks_entry_nofulltext.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_entry_nofulltextGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_entry_nofulltextGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_entry_nofulltextGroupByArgs['orderBy'] }
        : { orderBy?: inducks_entry_nofulltextGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_entry_nofulltextGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_entry_nofulltextGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_entry_nofulltext model
   */
  readonly fields: inducks_entry_nofulltextFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_entry_nofulltext.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_entry_nofulltextClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_entry_nofulltext model
   */ 
  interface inducks_entry_nofulltextFieldRefs {
    readonly entrycode: FieldRef<"inducks_entry_nofulltext", 'String'>
    readonly issuecode: FieldRef<"inducks_entry_nofulltext", 'String'>
    readonly storyversioncode: FieldRef<"inducks_entry_nofulltext", 'String'>
    readonly languagecode: FieldRef<"inducks_entry_nofulltext", 'String'>
    readonly includedinentrycode: FieldRef<"inducks_entry_nofulltext", 'String'>
    readonly position: FieldRef<"inducks_entry_nofulltext", 'String'>
    readonly printedcode: FieldRef<"inducks_entry_nofulltext", 'String'>
    readonly guessedcode: FieldRef<"inducks_entry_nofulltext", 'String'>
    readonly title: FieldRef<"inducks_entry_nofulltext", 'String'>
    readonly reallytitle: FieldRef<"inducks_entry_nofulltext", 'inducks_entry_nofulltext_reallytitle'>
    readonly printedhero: FieldRef<"inducks_entry_nofulltext", 'String'>
    readonly changes: FieldRef<"inducks_entry_nofulltext", 'String'>
    readonly cut: FieldRef<"inducks_entry_nofulltext", 'String'>
    readonly minorchanges: FieldRef<"inducks_entry_nofulltext", 'String'>
    readonly missingpanels: FieldRef<"inducks_entry_nofulltext", 'String'>
    readonly mirrored: FieldRef<"inducks_entry_nofulltext", 'inducks_entry_nofulltext_mirrored'>
    readonly sideways: FieldRef<"inducks_entry_nofulltext", 'inducks_entry_nofulltext_sideways'>
    readonly startdate: FieldRef<"inducks_entry_nofulltext", 'String'>
    readonly enddate: FieldRef<"inducks_entry_nofulltext", 'String'>
    readonly identificationuncertain: FieldRef<"inducks_entry_nofulltext", 'inducks_entry_nofulltext_identificationuncertain'>
    readonly alsoreprint: FieldRef<"inducks_entry_nofulltext", 'String'>
    readonly part: FieldRef<"inducks_entry_nofulltext", 'String'>
    readonly entrycomment: FieldRef<"inducks_entry_nofulltext", 'String'>
    readonly error: FieldRef<"inducks_entry_nofulltext", 'inducks_entry_nofulltext_error'>
  }
    

  // Custom InputTypes

  /**
   * inducks_entry_nofulltext findUnique
   */
  export type inducks_entry_nofulltextFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entry_nofulltext
     */
    select?: inducks_entry_nofulltextSelect<ExtArgs> | null
    /**
     * Filter, which inducks_entry_nofulltext to fetch.
     */
    where: inducks_entry_nofulltextWhereUniqueInput
  }


  /**
   * inducks_entry_nofulltext findUniqueOrThrow
   */
  export type inducks_entry_nofulltextFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entry_nofulltext
     */
    select?: inducks_entry_nofulltextSelect<ExtArgs> | null
    /**
     * Filter, which inducks_entry_nofulltext to fetch.
     */
    where: inducks_entry_nofulltextWhereUniqueInput
  }


  /**
   * inducks_entry_nofulltext findFirst
   */
  export type inducks_entry_nofulltextFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entry_nofulltext
     */
    select?: inducks_entry_nofulltextSelect<ExtArgs> | null
    /**
     * Filter, which inducks_entry_nofulltext to fetch.
     */
    where?: inducks_entry_nofulltextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_entry_nofulltexts to fetch.
     */
    orderBy?: inducks_entry_nofulltextOrderByWithRelationInput | inducks_entry_nofulltextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_entry_nofulltexts.
     */
    cursor?: inducks_entry_nofulltextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_entry_nofulltexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_entry_nofulltexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_entry_nofulltexts.
     */
    distinct?: Inducks_entry_nofulltextScalarFieldEnum | Inducks_entry_nofulltextScalarFieldEnum[]
  }


  /**
   * inducks_entry_nofulltext findFirstOrThrow
   */
  export type inducks_entry_nofulltextFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entry_nofulltext
     */
    select?: inducks_entry_nofulltextSelect<ExtArgs> | null
    /**
     * Filter, which inducks_entry_nofulltext to fetch.
     */
    where?: inducks_entry_nofulltextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_entry_nofulltexts to fetch.
     */
    orderBy?: inducks_entry_nofulltextOrderByWithRelationInput | inducks_entry_nofulltextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_entry_nofulltexts.
     */
    cursor?: inducks_entry_nofulltextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_entry_nofulltexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_entry_nofulltexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_entry_nofulltexts.
     */
    distinct?: Inducks_entry_nofulltextScalarFieldEnum | Inducks_entry_nofulltextScalarFieldEnum[]
  }


  /**
   * inducks_entry_nofulltext findMany
   */
  export type inducks_entry_nofulltextFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entry_nofulltext
     */
    select?: inducks_entry_nofulltextSelect<ExtArgs> | null
    /**
     * Filter, which inducks_entry_nofulltexts to fetch.
     */
    where?: inducks_entry_nofulltextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_entry_nofulltexts to fetch.
     */
    orderBy?: inducks_entry_nofulltextOrderByWithRelationInput | inducks_entry_nofulltextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_entry_nofulltexts.
     */
    cursor?: inducks_entry_nofulltextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_entry_nofulltexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_entry_nofulltexts.
     */
    skip?: number
    distinct?: Inducks_entry_nofulltextScalarFieldEnum | Inducks_entry_nofulltextScalarFieldEnum[]
  }


  /**
   * inducks_entry_nofulltext create
   */
  export type inducks_entry_nofulltextCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entry_nofulltext
     */
    select?: inducks_entry_nofulltextSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_entry_nofulltext.
     */
    data: XOR<inducks_entry_nofulltextCreateInput, inducks_entry_nofulltextUncheckedCreateInput>
  }


  /**
   * inducks_entry_nofulltext createMany
   */
  export type inducks_entry_nofulltextCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_entry_nofulltexts.
     */
    data: inducks_entry_nofulltextCreateManyInput | inducks_entry_nofulltextCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_entry_nofulltext update
   */
  export type inducks_entry_nofulltextUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entry_nofulltext
     */
    select?: inducks_entry_nofulltextSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_entry_nofulltext.
     */
    data: XOR<inducks_entry_nofulltextUpdateInput, inducks_entry_nofulltextUncheckedUpdateInput>
    /**
     * Choose, which inducks_entry_nofulltext to update.
     */
    where: inducks_entry_nofulltextWhereUniqueInput
  }


  /**
   * inducks_entry_nofulltext updateMany
   */
  export type inducks_entry_nofulltextUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_entry_nofulltexts.
     */
    data: XOR<inducks_entry_nofulltextUpdateManyMutationInput, inducks_entry_nofulltextUncheckedUpdateManyInput>
    /**
     * Filter which inducks_entry_nofulltexts to update
     */
    where?: inducks_entry_nofulltextWhereInput
  }


  /**
   * inducks_entry_nofulltext upsert
   */
  export type inducks_entry_nofulltextUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entry_nofulltext
     */
    select?: inducks_entry_nofulltextSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_entry_nofulltext to update in case it exists.
     */
    where: inducks_entry_nofulltextWhereUniqueInput
    /**
     * In case the inducks_entry_nofulltext found by the `where` argument doesn't exist, create a new inducks_entry_nofulltext with this data.
     */
    create: XOR<inducks_entry_nofulltextCreateInput, inducks_entry_nofulltextUncheckedCreateInput>
    /**
     * In case the inducks_entry_nofulltext was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_entry_nofulltextUpdateInput, inducks_entry_nofulltextUncheckedUpdateInput>
  }


  /**
   * inducks_entry_nofulltext delete
   */
  export type inducks_entry_nofulltextDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entry_nofulltext
     */
    select?: inducks_entry_nofulltextSelect<ExtArgs> | null
    /**
     * Filter which inducks_entry_nofulltext to delete.
     */
    where: inducks_entry_nofulltextWhereUniqueInput
  }


  /**
   * inducks_entry_nofulltext deleteMany
   */
  export type inducks_entry_nofulltextDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_entry_nofulltexts to delete
     */
    where?: inducks_entry_nofulltextWhereInput
  }


  /**
   * inducks_entry_nofulltext without action
   */
  export type inducks_entry_nofulltextDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entry_nofulltext
     */
    select?: inducks_entry_nofulltextSelect<ExtArgs> | null
  }



  /**
   * Model inducks_entrycharactername
   */

  export type AggregateInducks_entrycharactername = {
    _count: Inducks_entrycharacternameCountAggregateOutputType | null
    _min: Inducks_entrycharacternameMinAggregateOutputType | null
    _max: Inducks_entrycharacternameMaxAggregateOutputType | null
  }

  export type Inducks_entrycharacternameMinAggregateOutputType = {
    entrycode: string | null
    charactercode: string | null
    charactername: string | null
  }

  export type Inducks_entrycharacternameMaxAggregateOutputType = {
    entrycode: string | null
    charactercode: string | null
    charactername: string | null
  }

  export type Inducks_entrycharacternameCountAggregateOutputType = {
    entrycode: number
    charactercode: number
    charactername: number
    _all: number
  }


  export type Inducks_entrycharacternameMinAggregateInputType = {
    entrycode?: true
    charactercode?: true
    charactername?: true
  }

  export type Inducks_entrycharacternameMaxAggregateInputType = {
    entrycode?: true
    charactercode?: true
    charactername?: true
  }

  export type Inducks_entrycharacternameCountAggregateInputType = {
    entrycode?: true
    charactercode?: true
    charactername?: true
    _all?: true
  }

  export type Inducks_entrycharacternameAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_entrycharactername to aggregate.
     */
    where?: inducks_entrycharacternameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_entrycharacternames to fetch.
     */
    orderBy?: inducks_entrycharacternameOrderByWithRelationInput | inducks_entrycharacternameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_entrycharacternameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_entrycharacternames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_entrycharacternames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_entrycharacternames
    **/
    _count?: true | Inducks_entrycharacternameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_entrycharacternameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_entrycharacternameMaxAggregateInputType
  }

  export type GetInducks_entrycharacternameAggregateType<T extends Inducks_entrycharacternameAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_entrycharactername]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_entrycharactername[P]>
      : GetScalarType<T[P], AggregateInducks_entrycharactername[P]>
  }




  export type inducks_entrycharacternameGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_entrycharacternameWhereInput
    orderBy?: inducks_entrycharacternameOrderByWithAggregationInput | inducks_entrycharacternameOrderByWithAggregationInput[]
    by: Inducks_entrycharacternameScalarFieldEnum[] | Inducks_entrycharacternameScalarFieldEnum
    having?: inducks_entrycharacternameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_entrycharacternameCountAggregateInputType | true
    _min?: Inducks_entrycharacternameMinAggregateInputType
    _max?: Inducks_entrycharacternameMaxAggregateInputType
  }

  export type Inducks_entrycharacternameGroupByOutputType = {
    entrycode: string
    charactercode: string
    charactername: string | null
    _count: Inducks_entrycharacternameCountAggregateOutputType | null
    _min: Inducks_entrycharacternameMinAggregateOutputType | null
    _max: Inducks_entrycharacternameMaxAggregateOutputType | null
  }

  type GetInducks_entrycharacternameGroupByPayload<T extends inducks_entrycharacternameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_entrycharacternameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_entrycharacternameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_entrycharacternameGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_entrycharacternameGroupByOutputType[P]>
        }
      >
    >


  export type inducks_entrycharacternameSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    entrycode?: boolean
    charactercode?: boolean
    charactername?: boolean
  }, ExtArgs["result"]["inducks_entrycharactername"]>

  export type inducks_entrycharacternameSelectScalar = {
    entrycode?: boolean
    charactercode?: boolean
    charactername?: boolean
  }


  export type $inducks_entrycharacternamePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_entrycharactername"
    objects: {}
    scalars: $Extensions.GetResult<{
      entrycode: string
      charactercode: string
      charactername: string | null
    }, ExtArgs["result"]["inducks_entrycharactername"]>
    composites: {}
  }


  type inducks_entrycharacternameGetPayload<S extends boolean | null | undefined | inducks_entrycharacternameDefaultArgs> = $Result.GetResult<Prisma.$inducks_entrycharacternamePayload, S>

  type inducks_entrycharacternameCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_entrycharacternameFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_entrycharacternameCountAggregateInputType | true
    }

  export interface inducks_entrycharacternameDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_entrycharactername'], meta: { name: 'inducks_entrycharactername' } }
    /**
     * Find zero or one Inducks_entrycharactername that matches the filter.
     * @param {inducks_entrycharacternameFindUniqueArgs} args - Arguments to find a Inducks_entrycharactername
     * @example
     * // Get one Inducks_entrycharactername
     * const inducks_entrycharactername = await prisma.inducks_entrycharactername.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_entrycharacternameFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_entrycharacternameFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_entrycharacternameClient<$Result.GetResult<Prisma.$inducks_entrycharacternamePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_entrycharactername that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_entrycharacternameFindUniqueOrThrowArgs} args - Arguments to find a Inducks_entrycharactername
     * @example
     * // Get one Inducks_entrycharactername
     * const inducks_entrycharactername = await prisma.inducks_entrycharactername.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_entrycharacternameFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_entrycharacternameFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_entrycharacternameClient<$Result.GetResult<Prisma.$inducks_entrycharacternamePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_entrycharactername that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_entrycharacternameFindFirstArgs} args - Arguments to find a Inducks_entrycharactername
     * @example
     * // Get one Inducks_entrycharactername
     * const inducks_entrycharactername = await prisma.inducks_entrycharactername.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_entrycharacternameFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_entrycharacternameFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_entrycharacternameClient<$Result.GetResult<Prisma.$inducks_entrycharacternamePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_entrycharactername that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_entrycharacternameFindFirstOrThrowArgs} args - Arguments to find a Inducks_entrycharactername
     * @example
     * // Get one Inducks_entrycharactername
     * const inducks_entrycharactername = await prisma.inducks_entrycharactername.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_entrycharacternameFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_entrycharacternameFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_entrycharacternameClient<$Result.GetResult<Prisma.$inducks_entrycharacternamePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_entrycharacternames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_entrycharacternameFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_entrycharacternames
     * const inducks_entrycharacternames = await prisma.inducks_entrycharactername.findMany()
     * 
     * // Get first 10 Inducks_entrycharacternames
     * const inducks_entrycharacternames = await prisma.inducks_entrycharactername.findMany({ take: 10 })
     * 
     * // Only select the `entrycode`
     * const inducks_entrycharacternameWithEntrycodeOnly = await prisma.inducks_entrycharactername.findMany({ select: { entrycode: true } })
     * 
    **/
    findMany<T extends inducks_entrycharacternameFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_entrycharacternameFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_entrycharacternamePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_entrycharactername.
     * @param {inducks_entrycharacternameCreateArgs} args - Arguments to create a Inducks_entrycharactername.
     * @example
     * // Create one Inducks_entrycharactername
     * const Inducks_entrycharactername = await prisma.inducks_entrycharactername.create({
     *   data: {
     *     // ... data to create a Inducks_entrycharactername
     *   }
     * })
     * 
    **/
    create<T extends inducks_entrycharacternameCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_entrycharacternameCreateArgs<ExtArgs>>
    ): Prisma__inducks_entrycharacternameClient<$Result.GetResult<Prisma.$inducks_entrycharacternamePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_entrycharacternames.
     *     @param {inducks_entrycharacternameCreateManyArgs} args - Arguments to create many Inducks_entrycharacternames.
     *     @example
     *     // Create many Inducks_entrycharacternames
     *     const inducks_entrycharactername = await prisma.inducks_entrycharactername.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_entrycharacternameCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_entrycharacternameCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_entrycharactername.
     * @param {inducks_entrycharacternameDeleteArgs} args - Arguments to delete one Inducks_entrycharactername.
     * @example
     * // Delete one Inducks_entrycharactername
     * const Inducks_entrycharactername = await prisma.inducks_entrycharactername.delete({
     *   where: {
     *     // ... filter to delete one Inducks_entrycharactername
     *   }
     * })
     * 
    **/
    delete<T extends inducks_entrycharacternameDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_entrycharacternameDeleteArgs<ExtArgs>>
    ): Prisma__inducks_entrycharacternameClient<$Result.GetResult<Prisma.$inducks_entrycharacternamePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_entrycharactername.
     * @param {inducks_entrycharacternameUpdateArgs} args - Arguments to update one Inducks_entrycharactername.
     * @example
     * // Update one Inducks_entrycharactername
     * const inducks_entrycharactername = await prisma.inducks_entrycharactername.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_entrycharacternameUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_entrycharacternameUpdateArgs<ExtArgs>>
    ): Prisma__inducks_entrycharacternameClient<$Result.GetResult<Prisma.$inducks_entrycharacternamePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_entrycharacternames.
     * @param {inducks_entrycharacternameDeleteManyArgs} args - Arguments to filter Inducks_entrycharacternames to delete.
     * @example
     * // Delete a few Inducks_entrycharacternames
     * const { count } = await prisma.inducks_entrycharactername.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_entrycharacternameDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_entrycharacternameDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_entrycharacternames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_entrycharacternameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_entrycharacternames
     * const inducks_entrycharactername = await prisma.inducks_entrycharactername.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_entrycharacternameUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_entrycharacternameUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_entrycharactername.
     * @param {inducks_entrycharacternameUpsertArgs} args - Arguments to update or create a Inducks_entrycharactername.
     * @example
     * // Update or create a Inducks_entrycharactername
     * const inducks_entrycharactername = await prisma.inducks_entrycharactername.upsert({
     *   create: {
     *     // ... data to create a Inducks_entrycharactername
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_entrycharactername we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_entrycharacternameUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_entrycharacternameUpsertArgs<ExtArgs>>
    ): Prisma__inducks_entrycharacternameClient<$Result.GetResult<Prisma.$inducks_entrycharacternamePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_entrycharacternames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_entrycharacternameCountArgs} args - Arguments to filter Inducks_entrycharacternames to count.
     * @example
     * // Count the number of Inducks_entrycharacternames
     * const count = await prisma.inducks_entrycharactername.count({
     *   where: {
     *     // ... the filter for the Inducks_entrycharacternames we want to count
     *   }
     * })
    **/
    count<T extends inducks_entrycharacternameCountArgs>(
      args?: Subset<T, inducks_entrycharacternameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_entrycharacternameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_entrycharactername.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_entrycharacternameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_entrycharacternameAggregateArgs>(args: Subset<T, Inducks_entrycharacternameAggregateArgs>): Prisma.PrismaPromise<GetInducks_entrycharacternameAggregateType<T>>

    /**
     * Group by Inducks_entrycharactername.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_entrycharacternameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_entrycharacternameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_entrycharacternameGroupByArgs['orderBy'] }
        : { orderBy?: inducks_entrycharacternameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_entrycharacternameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_entrycharacternameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_entrycharactername model
   */
  readonly fields: inducks_entrycharacternameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_entrycharactername.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_entrycharacternameClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_entrycharactername model
   */ 
  interface inducks_entrycharacternameFieldRefs {
    readonly entrycode: FieldRef<"inducks_entrycharactername", 'String'>
    readonly charactercode: FieldRef<"inducks_entrycharactername", 'String'>
    readonly charactername: FieldRef<"inducks_entrycharactername", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_entrycharactername findUnique
   */
  export type inducks_entrycharacternameFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entrycharactername
     */
    select?: inducks_entrycharacternameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_entrycharactername to fetch.
     */
    where: inducks_entrycharacternameWhereUniqueInput
  }


  /**
   * inducks_entrycharactername findUniqueOrThrow
   */
  export type inducks_entrycharacternameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entrycharactername
     */
    select?: inducks_entrycharacternameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_entrycharactername to fetch.
     */
    where: inducks_entrycharacternameWhereUniqueInput
  }


  /**
   * inducks_entrycharactername findFirst
   */
  export type inducks_entrycharacternameFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entrycharactername
     */
    select?: inducks_entrycharacternameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_entrycharactername to fetch.
     */
    where?: inducks_entrycharacternameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_entrycharacternames to fetch.
     */
    orderBy?: inducks_entrycharacternameOrderByWithRelationInput | inducks_entrycharacternameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_entrycharacternames.
     */
    cursor?: inducks_entrycharacternameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_entrycharacternames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_entrycharacternames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_entrycharacternames.
     */
    distinct?: Inducks_entrycharacternameScalarFieldEnum | Inducks_entrycharacternameScalarFieldEnum[]
  }


  /**
   * inducks_entrycharactername findFirstOrThrow
   */
  export type inducks_entrycharacternameFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entrycharactername
     */
    select?: inducks_entrycharacternameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_entrycharactername to fetch.
     */
    where?: inducks_entrycharacternameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_entrycharacternames to fetch.
     */
    orderBy?: inducks_entrycharacternameOrderByWithRelationInput | inducks_entrycharacternameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_entrycharacternames.
     */
    cursor?: inducks_entrycharacternameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_entrycharacternames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_entrycharacternames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_entrycharacternames.
     */
    distinct?: Inducks_entrycharacternameScalarFieldEnum | Inducks_entrycharacternameScalarFieldEnum[]
  }


  /**
   * inducks_entrycharactername findMany
   */
  export type inducks_entrycharacternameFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entrycharactername
     */
    select?: inducks_entrycharacternameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_entrycharacternames to fetch.
     */
    where?: inducks_entrycharacternameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_entrycharacternames to fetch.
     */
    orderBy?: inducks_entrycharacternameOrderByWithRelationInput | inducks_entrycharacternameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_entrycharacternames.
     */
    cursor?: inducks_entrycharacternameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_entrycharacternames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_entrycharacternames.
     */
    skip?: number
    distinct?: Inducks_entrycharacternameScalarFieldEnum | Inducks_entrycharacternameScalarFieldEnum[]
  }


  /**
   * inducks_entrycharactername create
   */
  export type inducks_entrycharacternameCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entrycharactername
     */
    select?: inducks_entrycharacternameSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_entrycharactername.
     */
    data: XOR<inducks_entrycharacternameCreateInput, inducks_entrycharacternameUncheckedCreateInput>
  }


  /**
   * inducks_entrycharactername createMany
   */
  export type inducks_entrycharacternameCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_entrycharacternames.
     */
    data: inducks_entrycharacternameCreateManyInput | inducks_entrycharacternameCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_entrycharactername update
   */
  export type inducks_entrycharacternameUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entrycharactername
     */
    select?: inducks_entrycharacternameSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_entrycharactername.
     */
    data: XOR<inducks_entrycharacternameUpdateInput, inducks_entrycharacternameUncheckedUpdateInput>
    /**
     * Choose, which inducks_entrycharactername to update.
     */
    where: inducks_entrycharacternameWhereUniqueInput
  }


  /**
   * inducks_entrycharactername updateMany
   */
  export type inducks_entrycharacternameUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_entrycharacternames.
     */
    data: XOR<inducks_entrycharacternameUpdateManyMutationInput, inducks_entrycharacternameUncheckedUpdateManyInput>
    /**
     * Filter which inducks_entrycharacternames to update
     */
    where?: inducks_entrycharacternameWhereInput
  }


  /**
   * inducks_entrycharactername upsert
   */
  export type inducks_entrycharacternameUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entrycharactername
     */
    select?: inducks_entrycharacternameSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_entrycharactername to update in case it exists.
     */
    where: inducks_entrycharacternameWhereUniqueInput
    /**
     * In case the inducks_entrycharactername found by the `where` argument doesn't exist, create a new inducks_entrycharactername with this data.
     */
    create: XOR<inducks_entrycharacternameCreateInput, inducks_entrycharacternameUncheckedCreateInput>
    /**
     * In case the inducks_entrycharactername was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_entrycharacternameUpdateInput, inducks_entrycharacternameUncheckedUpdateInput>
  }


  /**
   * inducks_entrycharactername delete
   */
  export type inducks_entrycharacternameDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entrycharactername
     */
    select?: inducks_entrycharacternameSelect<ExtArgs> | null
    /**
     * Filter which inducks_entrycharactername to delete.
     */
    where: inducks_entrycharacternameWhereUniqueInput
  }


  /**
   * inducks_entrycharactername deleteMany
   */
  export type inducks_entrycharacternameDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_entrycharacternames to delete
     */
    where?: inducks_entrycharacternameWhereInput
  }


  /**
   * inducks_entrycharactername without action
   */
  export type inducks_entrycharacternameDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entrycharactername
     */
    select?: inducks_entrycharacternameSelect<ExtArgs> | null
  }



  /**
   * Model inducks_entryjob
   */

  export type AggregateInducks_entryjob = {
    _count: Inducks_entryjobCountAggregateOutputType | null
    _min: Inducks_entryjobMinAggregateOutputType | null
    _max: Inducks_entryjobMaxAggregateOutputType | null
  }

  export type Inducks_entryjobMinAggregateOutputType = {
    entrycode: string | null
    personcode: string | null
    transletcol: string | null
    entryjobcomment: string | null
    doubt: $Enums.inducks_entryjob_doubt | null
  }

  export type Inducks_entryjobMaxAggregateOutputType = {
    entrycode: string | null
    personcode: string | null
    transletcol: string | null
    entryjobcomment: string | null
    doubt: $Enums.inducks_entryjob_doubt | null
  }

  export type Inducks_entryjobCountAggregateOutputType = {
    entrycode: number
    personcode: number
    transletcol: number
    entryjobcomment: number
    doubt: number
    _all: number
  }


  export type Inducks_entryjobMinAggregateInputType = {
    entrycode?: true
    personcode?: true
    transletcol?: true
    entryjobcomment?: true
    doubt?: true
  }

  export type Inducks_entryjobMaxAggregateInputType = {
    entrycode?: true
    personcode?: true
    transletcol?: true
    entryjobcomment?: true
    doubt?: true
  }

  export type Inducks_entryjobCountAggregateInputType = {
    entrycode?: true
    personcode?: true
    transletcol?: true
    entryjobcomment?: true
    doubt?: true
    _all?: true
  }

  export type Inducks_entryjobAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_entryjob to aggregate.
     */
    where?: inducks_entryjobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_entryjobs to fetch.
     */
    orderBy?: inducks_entryjobOrderByWithRelationInput | inducks_entryjobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_entryjobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_entryjobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_entryjobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_entryjobs
    **/
    _count?: true | Inducks_entryjobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_entryjobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_entryjobMaxAggregateInputType
  }

  export type GetInducks_entryjobAggregateType<T extends Inducks_entryjobAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_entryjob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_entryjob[P]>
      : GetScalarType<T[P], AggregateInducks_entryjob[P]>
  }




  export type inducks_entryjobGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_entryjobWhereInput
    orderBy?: inducks_entryjobOrderByWithAggregationInput | inducks_entryjobOrderByWithAggregationInput[]
    by: Inducks_entryjobScalarFieldEnum[] | Inducks_entryjobScalarFieldEnum
    having?: inducks_entryjobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_entryjobCountAggregateInputType | true
    _min?: Inducks_entryjobMinAggregateInputType
    _max?: Inducks_entryjobMaxAggregateInputType
  }

  export type Inducks_entryjobGroupByOutputType = {
    entrycode: string
    personcode: string
    transletcol: string
    entryjobcomment: string | null
    doubt: $Enums.inducks_entryjob_doubt | null
    _count: Inducks_entryjobCountAggregateOutputType | null
    _min: Inducks_entryjobMinAggregateOutputType | null
    _max: Inducks_entryjobMaxAggregateOutputType | null
  }

  type GetInducks_entryjobGroupByPayload<T extends inducks_entryjobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_entryjobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_entryjobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_entryjobGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_entryjobGroupByOutputType[P]>
        }
      >
    >


  export type inducks_entryjobSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    entrycode?: boolean
    personcode?: boolean
    transletcol?: boolean
    entryjobcomment?: boolean
    doubt?: boolean
  }, ExtArgs["result"]["inducks_entryjob"]>

  export type inducks_entryjobSelectScalar = {
    entrycode?: boolean
    personcode?: boolean
    transletcol?: boolean
    entryjobcomment?: boolean
    doubt?: boolean
  }


  export type $inducks_entryjobPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_entryjob"
    objects: {}
    scalars: $Extensions.GetResult<{
      entrycode: string
      personcode: string
      transletcol: string
      entryjobcomment: string | null
      doubt: $Enums.inducks_entryjob_doubt | null
    }, ExtArgs["result"]["inducks_entryjob"]>
    composites: {}
  }


  type inducks_entryjobGetPayload<S extends boolean | null | undefined | inducks_entryjobDefaultArgs> = $Result.GetResult<Prisma.$inducks_entryjobPayload, S>

  type inducks_entryjobCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_entryjobFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_entryjobCountAggregateInputType | true
    }

  export interface inducks_entryjobDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_entryjob'], meta: { name: 'inducks_entryjob' } }
    /**
     * Find zero or one Inducks_entryjob that matches the filter.
     * @param {inducks_entryjobFindUniqueArgs} args - Arguments to find a Inducks_entryjob
     * @example
     * // Get one Inducks_entryjob
     * const inducks_entryjob = await prisma.inducks_entryjob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_entryjobFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_entryjobFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_entryjobClient<$Result.GetResult<Prisma.$inducks_entryjobPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_entryjob that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_entryjobFindUniqueOrThrowArgs} args - Arguments to find a Inducks_entryjob
     * @example
     * // Get one Inducks_entryjob
     * const inducks_entryjob = await prisma.inducks_entryjob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_entryjobFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_entryjobFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_entryjobClient<$Result.GetResult<Prisma.$inducks_entryjobPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_entryjob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_entryjobFindFirstArgs} args - Arguments to find a Inducks_entryjob
     * @example
     * // Get one Inducks_entryjob
     * const inducks_entryjob = await prisma.inducks_entryjob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_entryjobFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_entryjobFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_entryjobClient<$Result.GetResult<Prisma.$inducks_entryjobPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_entryjob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_entryjobFindFirstOrThrowArgs} args - Arguments to find a Inducks_entryjob
     * @example
     * // Get one Inducks_entryjob
     * const inducks_entryjob = await prisma.inducks_entryjob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_entryjobFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_entryjobFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_entryjobClient<$Result.GetResult<Prisma.$inducks_entryjobPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_entryjobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_entryjobFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_entryjobs
     * const inducks_entryjobs = await prisma.inducks_entryjob.findMany()
     * 
     * // Get first 10 Inducks_entryjobs
     * const inducks_entryjobs = await prisma.inducks_entryjob.findMany({ take: 10 })
     * 
     * // Only select the `entrycode`
     * const inducks_entryjobWithEntrycodeOnly = await prisma.inducks_entryjob.findMany({ select: { entrycode: true } })
     * 
    **/
    findMany<T extends inducks_entryjobFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_entryjobFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_entryjobPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_entryjob.
     * @param {inducks_entryjobCreateArgs} args - Arguments to create a Inducks_entryjob.
     * @example
     * // Create one Inducks_entryjob
     * const Inducks_entryjob = await prisma.inducks_entryjob.create({
     *   data: {
     *     // ... data to create a Inducks_entryjob
     *   }
     * })
     * 
    **/
    create<T extends inducks_entryjobCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_entryjobCreateArgs<ExtArgs>>
    ): Prisma__inducks_entryjobClient<$Result.GetResult<Prisma.$inducks_entryjobPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_entryjobs.
     *     @param {inducks_entryjobCreateManyArgs} args - Arguments to create many Inducks_entryjobs.
     *     @example
     *     // Create many Inducks_entryjobs
     *     const inducks_entryjob = await prisma.inducks_entryjob.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_entryjobCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_entryjobCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_entryjob.
     * @param {inducks_entryjobDeleteArgs} args - Arguments to delete one Inducks_entryjob.
     * @example
     * // Delete one Inducks_entryjob
     * const Inducks_entryjob = await prisma.inducks_entryjob.delete({
     *   where: {
     *     // ... filter to delete one Inducks_entryjob
     *   }
     * })
     * 
    **/
    delete<T extends inducks_entryjobDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_entryjobDeleteArgs<ExtArgs>>
    ): Prisma__inducks_entryjobClient<$Result.GetResult<Prisma.$inducks_entryjobPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_entryjob.
     * @param {inducks_entryjobUpdateArgs} args - Arguments to update one Inducks_entryjob.
     * @example
     * // Update one Inducks_entryjob
     * const inducks_entryjob = await prisma.inducks_entryjob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_entryjobUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_entryjobUpdateArgs<ExtArgs>>
    ): Prisma__inducks_entryjobClient<$Result.GetResult<Prisma.$inducks_entryjobPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_entryjobs.
     * @param {inducks_entryjobDeleteManyArgs} args - Arguments to filter Inducks_entryjobs to delete.
     * @example
     * // Delete a few Inducks_entryjobs
     * const { count } = await prisma.inducks_entryjob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_entryjobDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_entryjobDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_entryjobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_entryjobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_entryjobs
     * const inducks_entryjob = await prisma.inducks_entryjob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_entryjobUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_entryjobUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_entryjob.
     * @param {inducks_entryjobUpsertArgs} args - Arguments to update or create a Inducks_entryjob.
     * @example
     * // Update or create a Inducks_entryjob
     * const inducks_entryjob = await prisma.inducks_entryjob.upsert({
     *   create: {
     *     // ... data to create a Inducks_entryjob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_entryjob we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_entryjobUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_entryjobUpsertArgs<ExtArgs>>
    ): Prisma__inducks_entryjobClient<$Result.GetResult<Prisma.$inducks_entryjobPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_entryjobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_entryjobCountArgs} args - Arguments to filter Inducks_entryjobs to count.
     * @example
     * // Count the number of Inducks_entryjobs
     * const count = await prisma.inducks_entryjob.count({
     *   where: {
     *     // ... the filter for the Inducks_entryjobs we want to count
     *   }
     * })
    **/
    count<T extends inducks_entryjobCountArgs>(
      args?: Subset<T, inducks_entryjobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_entryjobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_entryjob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_entryjobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_entryjobAggregateArgs>(args: Subset<T, Inducks_entryjobAggregateArgs>): Prisma.PrismaPromise<GetInducks_entryjobAggregateType<T>>

    /**
     * Group by Inducks_entryjob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_entryjobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_entryjobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_entryjobGroupByArgs['orderBy'] }
        : { orderBy?: inducks_entryjobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_entryjobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_entryjobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_entryjob model
   */
  readonly fields: inducks_entryjobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_entryjob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_entryjobClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_entryjob model
   */ 
  interface inducks_entryjobFieldRefs {
    readonly entrycode: FieldRef<"inducks_entryjob", 'String'>
    readonly personcode: FieldRef<"inducks_entryjob", 'String'>
    readonly transletcol: FieldRef<"inducks_entryjob", 'String'>
    readonly entryjobcomment: FieldRef<"inducks_entryjob", 'String'>
    readonly doubt: FieldRef<"inducks_entryjob", 'inducks_entryjob_doubt'>
  }
    

  // Custom InputTypes

  /**
   * inducks_entryjob findUnique
   */
  export type inducks_entryjobFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entryjob
     */
    select?: inducks_entryjobSelect<ExtArgs> | null
    /**
     * Filter, which inducks_entryjob to fetch.
     */
    where: inducks_entryjobWhereUniqueInput
  }


  /**
   * inducks_entryjob findUniqueOrThrow
   */
  export type inducks_entryjobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entryjob
     */
    select?: inducks_entryjobSelect<ExtArgs> | null
    /**
     * Filter, which inducks_entryjob to fetch.
     */
    where: inducks_entryjobWhereUniqueInput
  }


  /**
   * inducks_entryjob findFirst
   */
  export type inducks_entryjobFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entryjob
     */
    select?: inducks_entryjobSelect<ExtArgs> | null
    /**
     * Filter, which inducks_entryjob to fetch.
     */
    where?: inducks_entryjobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_entryjobs to fetch.
     */
    orderBy?: inducks_entryjobOrderByWithRelationInput | inducks_entryjobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_entryjobs.
     */
    cursor?: inducks_entryjobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_entryjobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_entryjobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_entryjobs.
     */
    distinct?: Inducks_entryjobScalarFieldEnum | Inducks_entryjobScalarFieldEnum[]
  }


  /**
   * inducks_entryjob findFirstOrThrow
   */
  export type inducks_entryjobFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entryjob
     */
    select?: inducks_entryjobSelect<ExtArgs> | null
    /**
     * Filter, which inducks_entryjob to fetch.
     */
    where?: inducks_entryjobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_entryjobs to fetch.
     */
    orderBy?: inducks_entryjobOrderByWithRelationInput | inducks_entryjobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_entryjobs.
     */
    cursor?: inducks_entryjobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_entryjobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_entryjobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_entryjobs.
     */
    distinct?: Inducks_entryjobScalarFieldEnum | Inducks_entryjobScalarFieldEnum[]
  }


  /**
   * inducks_entryjob findMany
   */
  export type inducks_entryjobFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entryjob
     */
    select?: inducks_entryjobSelect<ExtArgs> | null
    /**
     * Filter, which inducks_entryjobs to fetch.
     */
    where?: inducks_entryjobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_entryjobs to fetch.
     */
    orderBy?: inducks_entryjobOrderByWithRelationInput | inducks_entryjobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_entryjobs.
     */
    cursor?: inducks_entryjobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_entryjobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_entryjobs.
     */
    skip?: number
    distinct?: Inducks_entryjobScalarFieldEnum | Inducks_entryjobScalarFieldEnum[]
  }


  /**
   * inducks_entryjob create
   */
  export type inducks_entryjobCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entryjob
     */
    select?: inducks_entryjobSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_entryjob.
     */
    data: XOR<inducks_entryjobCreateInput, inducks_entryjobUncheckedCreateInput>
  }


  /**
   * inducks_entryjob createMany
   */
  export type inducks_entryjobCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_entryjobs.
     */
    data: inducks_entryjobCreateManyInput | inducks_entryjobCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_entryjob update
   */
  export type inducks_entryjobUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entryjob
     */
    select?: inducks_entryjobSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_entryjob.
     */
    data: XOR<inducks_entryjobUpdateInput, inducks_entryjobUncheckedUpdateInput>
    /**
     * Choose, which inducks_entryjob to update.
     */
    where: inducks_entryjobWhereUniqueInput
  }


  /**
   * inducks_entryjob updateMany
   */
  export type inducks_entryjobUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_entryjobs.
     */
    data: XOR<inducks_entryjobUpdateManyMutationInput, inducks_entryjobUncheckedUpdateManyInput>
    /**
     * Filter which inducks_entryjobs to update
     */
    where?: inducks_entryjobWhereInput
  }


  /**
   * inducks_entryjob upsert
   */
  export type inducks_entryjobUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entryjob
     */
    select?: inducks_entryjobSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_entryjob to update in case it exists.
     */
    where: inducks_entryjobWhereUniqueInput
    /**
     * In case the inducks_entryjob found by the `where` argument doesn't exist, create a new inducks_entryjob with this data.
     */
    create: XOR<inducks_entryjobCreateInput, inducks_entryjobUncheckedCreateInput>
    /**
     * In case the inducks_entryjob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_entryjobUpdateInput, inducks_entryjobUncheckedUpdateInput>
  }


  /**
   * inducks_entryjob delete
   */
  export type inducks_entryjobDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entryjob
     */
    select?: inducks_entryjobSelect<ExtArgs> | null
    /**
     * Filter which inducks_entryjob to delete.
     */
    where: inducks_entryjobWhereUniqueInput
  }


  /**
   * inducks_entryjob deleteMany
   */
  export type inducks_entryjobDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_entryjobs to delete
     */
    where?: inducks_entryjobWhereInput
  }


  /**
   * inducks_entryjob without action
   */
  export type inducks_entryjobDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entryjob
     */
    select?: inducks_entryjobSelect<ExtArgs> | null
  }



  /**
   * Model inducks_entryurl
   */

  export type AggregateInducks_entryurl = {
    _count: Inducks_entryurlCountAggregateOutputType | null
    _avg: Inducks_entryurlAvgAggregateOutputType | null
    _sum: Inducks_entryurlSumAggregateOutputType | null
    _min: Inducks_entryurlMinAggregateOutputType | null
    _max: Inducks_entryurlMaxAggregateOutputType | null
  }

  export type Inducks_entryurlAvgAggregateOutputType = {
    pagenumber: number | null
    id: number | null
  }

  export type Inducks_entryurlSumAggregateOutputType = {
    pagenumber: number | null
    id: number | null
  }

  export type Inducks_entryurlMinAggregateOutputType = {
    entrycode: string | null
    sitecode: string | null
    pagenumber: number | null
    url: string | null
    storycode: string | null
    public: $Enums.inducks_entryurl_public | null
    id: number | null
  }

  export type Inducks_entryurlMaxAggregateOutputType = {
    entrycode: string | null
    sitecode: string | null
    pagenumber: number | null
    url: string | null
    storycode: string | null
    public: $Enums.inducks_entryurl_public | null
    id: number | null
  }

  export type Inducks_entryurlCountAggregateOutputType = {
    entrycode: number
    sitecode: number
    pagenumber: number
    url: number
    storycode: number
    public: number
    id: number
    _all: number
  }


  export type Inducks_entryurlAvgAggregateInputType = {
    pagenumber?: true
    id?: true
  }

  export type Inducks_entryurlSumAggregateInputType = {
    pagenumber?: true
    id?: true
  }

  export type Inducks_entryurlMinAggregateInputType = {
    entrycode?: true
    sitecode?: true
    pagenumber?: true
    url?: true
    storycode?: true
    public?: true
    id?: true
  }

  export type Inducks_entryurlMaxAggregateInputType = {
    entrycode?: true
    sitecode?: true
    pagenumber?: true
    url?: true
    storycode?: true
    public?: true
    id?: true
  }

  export type Inducks_entryurlCountAggregateInputType = {
    entrycode?: true
    sitecode?: true
    pagenumber?: true
    url?: true
    storycode?: true
    public?: true
    id?: true
    _all?: true
  }

  export type Inducks_entryurlAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_entryurl to aggregate.
     */
    where?: inducks_entryurlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_entryurls to fetch.
     */
    orderBy?: inducks_entryurlOrderByWithRelationInput | inducks_entryurlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_entryurlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_entryurls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_entryurls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_entryurls
    **/
    _count?: true | Inducks_entryurlCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Inducks_entryurlAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Inducks_entryurlSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_entryurlMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_entryurlMaxAggregateInputType
  }

  export type GetInducks_entryurlAggregateType<T extends Inducks_entryurlAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_entryurl]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_entryurl[P]>
      : GetScalarType<T[P], AggregateInducks_entryurl[P]>
  }




  export type inducks_entryurlGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_entryurlWhereInput
    orderBy?: inducks_entryurlOrderByWithAggregationInput | inducks_entryurlOrderByWithAggregationInput[]
    by: Inducks_entryurlScalarFieldEnum[] | Inducks_entryurlScalarFieldEnum
    having?: inducks_entryurlScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_entryurlCountAggregateInputType | true
    _avg?: Inducks_entryurlAvgAggregateInputType
    _sum?: Inducks_entryurlSumAggregateInputType
    _min?: Inducks_entryurlMinAggregateInputType
    _max?: Inducks_entryurlMaxAggregateInputType
  }

  export type Inducks_entryurlGroupByOutputType = {
    entrycode: string | null
    sitecode: string | null
    pagenumber: number | null
    url: string | null
    storycode: string | null
    public: $Enums.inducks_entryurl_public | null
    id: number
    _count: Inducks_entryurlCountAggregateOutputType | null
    _avg: Inducks_entryurlAvgAggregateOutputType | null
    _sum: Inducks_entryurlSumAggregateOutputType | null
    _min: Inducks_entryurlMinAggregateOutputType | null
    _max: Inducks_entryurlMaxAggregateOutputType | null
  }

  type GetInducks_entryurlGroupByPayload<T extends inducks_entryurlGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_entryurlGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_entryurlGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_entryurlGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_entryurlGroupByOutputType[P]>
        }
      >
    >


  export type inducks_entryurlSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    entrycode?: boolean
    sitecode?: boolean
    pagenumber?: boolean
    url?: boolean
    storycode?: boolean
    public?: boolean
    id?: boolean
  }, ExtArgs["result"]["inducks_entryurl"]>

  export type inducks_entryurlSelectScalar = {
    entrycode?: boolean
    sitecode?: boolean
    pagenumber?: boolean
    url?: boolean
    storycode?: boolean
    public?: boolean
    id?: boolean
  }


  export type $inducks_entryurlPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_entryurl"
    objects: {}
    scalars: $Extensions.GetResult<{
      entrycode: string | null
      sitecode: string | null
      pagenumber: number | null
      url: string | null
      storycode: string | null
      public: $Enums.inducks_entryurl_public | null
      id: number
    }, ExtArgs["result"]["inducks_entryurl"]>
    composites: {}
  }


  type inducks_entryurlGetPayload<S extends boolean | null | undefined | inducks_entryurlDefaultArgs> = $Result.GetResult<Prisma.$inducks_entryurlPayload, S>

  type inducks_entryurlCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_entryurlFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_entryurlCountAggregateInputType | true
    }

  export interface inducks_entryurlDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_entryurl'], meta: { name: 'inducks_entryurl' } }
    /**
     * Find zero or one Inducks_entryurl that matches the filter.
     * @param {inducks_entryurlFindUniqueArgs} args - Arguments to find a Inducks_entryurl
     * @example
     * // Get one Inducks_entryurl
     * const inducks_entryurl = await prisma.inducks_entryurl.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_entryurlFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_entryurlFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_entryurlClient<$Result.GetResult<Prisma.$inducks_entryurlPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_entryurl that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_entryurlFindUniqueOrThrowArgs} args - Arguments to find a Inducks_entryurl
     * @example
     * // Get one Inducks_entryurl
     * const inducks_entryurl = await prisma.inducks_entryurl.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_entryurlFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_entryurlFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_entryurlClient<$Result.GetResult<Prisma.$inducks_entryurlPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_entryurl that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_entryurlFindFirstArgs} args - Arguments to find a Inducks_entryurl
     * @example
     * // Get one Inducks_entryurl
     * const inducks_entryurl = await prisma.inducks_entryurl.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_entryurlFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_entryurlFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_entryurlClient<$Result.GetResult<Prisma.$inducks_entryurlPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_entryurl that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_entryurlFindFirstOrThrowArgs} args - Arguments to find a Inducks_entryurl
     * @example
     * // Get one Inducks_entryurl
     * const inducks_entryurl = await prisma.inducks_entryurl.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_entryurlFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_entryurlFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_entryurlClient<$Result.GetResult<Prisma.$inducks_entryurlPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_entryurls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_entryurlFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_entryurls
     * const inducks_entryurls = await prisma.inducks_entryurl.findMany()
     * 
     * // Get first 10 Inducks_entryurls
     * const inducks_entryurls = await prisma.inducks_entryurl.findMany({ take: 10 })
     * 
     * // Only select the `entrycode`
     * const inducks_entryurlWithEntrycodeOnly = await prisma.inducks_entryurl.findMany({ select: { entrycode: true } })
     * 
    **/
    findMany<T extends inducks_entryurlFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_entryurlFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_entryurlPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_entryurl.
     * @param {inducks_entryurlCreateArgs} args - Arguments to create a Inducks_entryurl.
     * @example
     * // Create one Inducks_entryurl
     * const Inducks_entryurl = await prisma.inducks_entryurl.create({
     *   data: {
     *     // ... data to create a Inducks_entryurl
     *   }
     * })
     * 
    **/
    create<T extends inducks_entryurlCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_entryurlCreateArgs<ExtArgs>>
    ): Prisma__inducks_entryurlClient<$Result.GetResult<Prisma.$inducks_entryurlPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_entryurls.
     *     @param {inducks_entryurlCreateManyArgs} args - Arguments to create many Inducks_entryurls.
     *     @example
     *     // Create many Inducks_entryurls
     *     const inducks_entryurl = await prisma.inducks_entryurl.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_entryurlCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_entryurlCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_entryurl.
     * @param {inducks_entryurlDeleteArgs} args - Arguments to delete one Inducks_entryurl.
     * @example
     * // Delete one Inducks_entryurl
     * const Inducks_entryurl = await prisma.inducks_entryurl.delete({
     *   where: {
     *     // ... filter to delete one Inducks_entryurl
     *   }
     * })
     * 
    **/
    delete<T extends inducks_entryurlDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_entryurlDeleteArgs<ExtArgs>>
    ): Prisma__inducks_entryurlClient<$Result.GetResult<Prisma.$inducks_entryurlPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_entryurl.
     * @param {inducks_entryurlUpdateArgs} args - Arguments to update one Inducks_entryurl.
     * @example
     * // Update one Inducks_entryurl
     * const inducks_entryurl = await prisma.inducks_entryurl.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_entryurlUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_entryurlUpdateArgs<ExtArgs>>
    ): Prisma__inducks_entryurlClient<$Result.GetResult<Prisma.$inducks_entryurlPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_entryurls.
     * @param {inducks_entryurlDeleteManyArgs} args - Arguments to filter Inducks_entryurls to delete.
     * @example
     * // Delete a few Inducks_entryurls
     * const { count } = await prisma.inducks_entryurl.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_entryurlDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_entryurlDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_entryurls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_entryurlUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_entryurls
     * const inducks_entryurl = await prisma.inducks_entryurl.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_entryurlUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_entryurlUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_entryurl.
     * @param {inducks_entryurlUpsertArgs} args - Arguments to update or create a Inducks_entryurl.
     * @example
     * // Update or create a Inducks_entryurl
     * const inducks_entryurl = await prisma.inducks_entryurl.upsert({
     *   create: {
     *     // ... data to create a Inducks_entryurl
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_entryurl we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_entryurlUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_entryurlUpsertArgs<ExtArgs>>
    ): Prisma__inducks_entryurlClient<$Result.GetResult<Prisma.$inducks_entryurlPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_entryurls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_entryurlCountArgs} args - Arguments to filter Inducks_entryurls to count.
     * @example
     * // Count the number of Inducks_entryurls
     * const count = await prisma.inducks_entryurl.count({
     *   where: {
     *     // ... the filter for the Inducks_entryurls we want to count
     *   }
     * })
    **/
    count<T extends inducks_entryurlCountArgs>(
      args?: Subset<T, inducks_entryurlCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_entryurlCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_entryurl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_entryurlAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_entryurlAggregateArgs>(args: Subset<T, Inducks_entryurlAggregateArgs>): Prisma.PrismaPromise<GetInducks_entryurlAggregateType<T>>

    /**
     * Group by Inducks_entryurl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_entryurlGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_entryurlGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_entryurlGroupByArgs['orderBy'] }
        : { orderBy?: inducks_entryurlGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_entryurlGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_entryurlGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_entryurl model
   */
  readonly fields: inducks_entryurlFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_entryurl.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_entryurlClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_entryurl model
   */ 
  interface inducks_entryurlFieldRefs {
    readonly entrycode: FieldRef<"inducks_entryurl", 'String'>
    readonly sitecode: FieldRef<"inducks_entryurl", 'String'>
    readonly pagenumber: FieldRef<"inducks_entryurl", 'Int'>
    readonly url: FieldRef<"inducks_entryurl", 'String'>
    readonly storycode: FieldRef<"inducks_entryurl", 'String'>
    readonly public: FieldRef<"inducks_entryurl", 'inducks_entryurl_public'>
    readonly id: FieldRef<"inducks_entryurl", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * inducks_entryurl findUnique
   */
  export type inducks_entryurlFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entryurl
     */
    select?: inducks_entryurlSelect<ExtArgs> | null
    /**
     * Filter, which inducks_entryurl to fetch.
     */
    where: inducks_entryurlWhereUniqueInput
  }


  /**
   * inducks_entryurl findUniqueOrThrow
   */
  export type inducks_entryurlFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entryurl
     */
    select?: inducks_entryurlSelect<ExtArgs> | null
    /**
     * Filter, which inducks_entryurl to fetch.
     */
    where: inducks_entryurlWhereUniqueInput
  }


  /**
   * inducks_entryurl findFirst
   */
  export type inducks_entryurlFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entryurl
     */
    select?: inducks_entryurlSelect<ExtArgs> | null
    /**
     * Filter, which inducks_entryurl to fetch.
     */
    where?: inducks_entryurlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_entryurls to fetch.
     */
    orderBy?: inducks_entryurlOrderByWithRelationInput | inducks_entryurlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_entryurls.
     */
    cursor?: inducks_entryurlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_entryurls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_entryurls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_entryurls.
     */
    distinct?: Inducks_entryurlScalarFieldEnum | Inducks_entryurlScalarFieldEnum[]
  }


  /**
   * inducks_entryurl findFirstOrThrow
   */
  export type inducks_entryurlFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entryurl
     */
    select?: inducks_entryurlSelect<ExtArgs> | null
    /**
     * Filter, which inducks_entryurl to fetch.
     */
    where?: inducks_entryurlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_entryurls to fetch.
     */
    orderBy?: inducks_entryurlOrderByWithRelationInput | inducks_entryurlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_entryurls.
     */
    cursor?: inducks_entryurlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_entryurls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_entryurls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_entryurls.
     */
    distinct?: Inducks_entryurlScalarFieldEnum | Inducks_entryurlScalarFieldEnum[]
  }


  /**
   * inducks_entryurl findMany
   */
  export type inducks_entryurlFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entryurl
     */
    select?: inducks_entryurlSelect<ExtArgs> | null
    /**
     * Filter, which inducks_entryurls to fetch.
     */
    where?: inducks_entryurlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_entryurls to fetch.
     */
    orderBy?: inducks_entryurlOrderByWithRelationInput | inducks_entryurlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_entryurls.
     */
    cursor?: inducks_entryurlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_entryurls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_entryurls.
     */
    skip?: number
    distinct?: Inducks_entryurlScalarFieldEnum | Inducks_entryurlScalarFieldEnum[]
  }


  /**
   * inducks_entryurl create
   */
  export type inducks_entryurlCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entryurl
     */
    select?: inducks_entryurlSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_entryurl.
     */
    data?: XOR<inducks_entryurlCreateInput, inducks_entryurlUncheckedCreateInput>
  }


  /**
   * inducks_entryurl createMany
   */
  export type inducks_entryurlCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_entryurls.
     */
    data: inducks_entryurlCreateManyInput | inducks_entryurlCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_entryurl update
   */
  export type inducks_entryurlUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entryurl
     */
    select?: inducks_entryurlSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_entryurl.
     */
    data: XOR<inducks_entryurlUpdateInput, inducks_entryurlUncheckedUpdateInput>
    /**
     * Choose, which inducks_entryurl to update.
     */
    where: inducks_entryurlWhereUniqueInput
  }


  /**
   * inducks_entryurl updateMany
   */
  export type inducks_entryurlUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_entryurls.
     */
    data: XOR<inducks_entryurlUpdateManyMutationInput, inducks_entryurlUncheckedUpdateManyInput>
    /**
     * Filter which inducks_entryurls to update
     */
    where?: inducks_entryurlWhereInput
  }


  /**
   * inducks_entryurl upsert
   */
  export type inducks_entryurlUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entryurl
     */
    select?: inducks_entryurlSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_entryurl to update in case it exists.
     */
    where: inducks_entryurlWhereUniqueInput
    /**
     * In case the inducks_entryurl found by the `where` argument doesn't exist, create a new inducks_entryurl with this data.
     */
    create: XOR<inducks_entryurlCreateInput, inducks_entryurlUncheckedCreateInput>
    /**
     * In case the inducks_entryurl was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_entryurlUpdateInput, inducks_entryurlUncheckedUpdateInput>
  }


  /**
   * inducks_entryurl delete
   */
  export type inducks_entryurlDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entryurl
     */
    select?: inducks_entryurlSelect<ExtArgs> | null
    /**
     * Filter which inducks_entryurl to delete.
     */
    where: inducks_entryurlWhereUniqueInput
  }


  /**
   * inducks_entryurl deleteMany
   */
  export type inducks_entryurlDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_entryurls to delete
     */
    where?: inducks_entryurlWhereInput
  }


  /**
   * inducks_entryurl without action
   */
  export type inducks_entryurlDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_entryurl
     */
    select?: inducks_entryurlSelect<ExtArgs> | null
  }



  /**
   * Model inducks_equiv
   */

  export type AggregateInducks_equiv = {
    _count: Inducks_equivCountAggregateOutputType | null
    _avg: Inducks_equivAvgAggregateOutputType | null
    _sum: Inducks_equivSumAggregateOutputType | null
    _min: Inducks_equivMinAggregateOutputType | null
    _max: Inducks_equivMaxAggregateOutputType | null
  }

  export type Inducks_equivAvgAggregateOutputType = {
    equivid: number | null
  }

  export type Inducks_equivSumAggregateOutputType = {
    equivid: number | null
  }

  export type Inducks_equivMinAggregateOutputType = {
    issuecode: string | null
    equivid: number | null
    equivcomment: string | null
  }

  export type Inducks_equivMaxAggregateOutputType = {
    issuecode: string | null
    equivid: number | null
    equivcomment: string | null
  }

  export type Inducks_equivCountAggregateOutputType = {
    issuecode: number
    equivid: number
    equivcomment: number
    _all: number
  }


  export type Inducks_equivAvgAggregateInputType = {
    equivid?: true
  }

  export type Inducks_equivSumAggregateInputType = {
    equivid?: true
  }

  export type Inducks_equivMinAggregateInputType = {
    issuecode?: true
    equivid?: true
    equivcomment?: true
  }

  export type Inducks_equivMaxAggregateInputType = {
    issuecode?: true
    equivid?: true
    equivcomment?: true
  }

  export type Inducks_equivCountAggregateInputType = {
    issuecode?: true
    equivid?: true
    equivcomment?: true
    _all?: true
  }

  export type Inducks_equivAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_equiv to aggregate.
     */
    where?: inducks_equivWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_equivs to fetch.
     */
    orderBy?: inducks_equivOrderByWithRelationInput | inducks_equivOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_equivWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_equivs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_equivs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_equivs
    **/
    _count?: true | Inducks_equivCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Inducks_equivAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Inducks_equivSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_equivMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_equivMaxAggregateInputType
  }

  export type GetInducks_equivAggregateType<T extends Inducks_equivAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_equiv]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_equiv[P]>
      : GetScalarType<T[P], AggregateInducks_equiv[P]>
  }




  export type inducks_equivGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_equivWhereInput
    orderBy?: inducks_equivOrderByWithAggregationInput | inducks_equivOrderByWithAggregationInput[]
    by: Inducks_equivScalarFieldEnum[] | Inducks_equivScalarFieldEnum
    having?: inducks_equivScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_equivCountAggregateInputType | true
    _avg?: Inducks_equivAvgAggregateInputType
    _sum?: Inducks_equivSumAggregateInputType
    _min?: Inducks_equivMinAggregateInputType
    _max?: Inducks_equivMaxAggregateInputType
  }

  export type Inducks_equivGroupByOutputType = {
    issuecode: string
    equivid: number
    equivcomment: string | null
    _count: Inducks_equivCountAggregateOutputType | null
    _avg: Inducks_equivAvgAggregateOutputType | null
    _sum: Inducks_equivSumAggregateOutputType | null
    _min: Inducks_equivMinAggregateOutputType | null
    _max: Inducks_equivMaxAggregateOutputType | null
  }

  type GetInducks_equivGroupByPayload<T extends inducks_equivGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_equivGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_equivGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_equivGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_equivGroupByOutputType[P]>
        }
      >
    >


  export type inducks_equivSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    issuecode?: boolean
    equivid?: boolean
    equivcomment?: boolean
  }, ExtArgs["result"]["inducks_equiv"]>

  export type inducks_equivSelectScalar = {
    issuecode?: boolean
    equivid?: boolean
    equivcomment?: boolean
  }


  export type $inducks_equivPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_equiv"
    objects: {}
    scalars: $Extensions.GetResult<{
      issuecode: string
      equivid: number
      equivcomment: string | null
    }, ExtArgs["result"]["inducks_equiv"]>
    composites: {}
  }


  type inducks_equivGetPayload<S extends boolean | null | undefined | inducks_equivDefaultArgs> = $Result.GetResult<Prisma.$inducks_equivPayload, S>

  type inducks_equivCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_equivFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_equivCountAggregateInputType | true
    }

  export interface inducks_equivDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_equiv'], meta: { name: 'inducks_equiv' } }
    /**
     * Find zero or one Inducks_equiv that matches the filter.
     * @param {inducks_equivFindUniqueArgs} args - Arguments to find a Inducks_equiv
     * @example
     * // Get one Inducks_equiv
     * const inducks_equiv = await prisma.inducks_equiv.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_equivFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_equivFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_equivClient<$Result.GetResult<Prisma.$inducks_equivPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_equiv that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_equivFindUniqueOrThrowArgs} args - Arguments to find a Inducks_equiv
     * @example
     * // Get one Inducks_equiv
     * const inducks_equiv = await prisma.inducks_equiv.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_equivFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_equivFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_equivClient<$Result.GetResult<Prisma.$inducks_equivPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_equiv that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_equivFindFirstArgs} args - Arguments to find a Inducks_equiv
     * @example
     * // Get one Inducks_equiv
     * const inducks_equiv = await prisma.inducks_equiv.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_equivFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_equivFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_equivClient<$Result.GetResult<Prisma.$inducks_equivPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_equiv that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_equivFindFirstOrThrowArgs} args - Arguments to find a Inducks_equiv
     * @example
     * // Get one Inducks_equiv
     * const inducks_equiv = await prisma.inducks_equiv.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_equivFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_equivFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_equivClient<$Result.GetResult<Prisma.$inducks_equivPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_equivs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_equivFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_equivs
     * const inducks_equivs = await prisma.inducks_equiv.findMany()
     * 
     * // Get first 10 Inducks_equivs
     * const inducks_equivs = await prisma.inducks_equiv.findMany({ take: 10 })
     * 
     * // Only select the `issuecode`
     * const inducks_equivWithIssuecodeOnly = await prisma.inducks_equiv.findMany({ select: { issuecode: true } })
     * 
    **/
    findMany<T extends inducks_equivFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_equivFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_equivPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_equiv.
     * @param {inducks_equivCreateArgs} args - Arguments to create a Inducks_equiv.
     * @example
     * // Create one Inducks_equiv
     * const Inducks_equiv = await prisma.inducks_equiv.create({
     *   data: {
     *     // ... data to create a Inducks_equiv
     *   }
     * })
     * 
    **/
    create<T extends inducks_equivCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_equivCreateArgs<ExtArgs>>
    ): Prisma__inducks_equivClient<$Result.GetResult<Prisma.$inducks_equivPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_equivs.
     *     @param {inducks_equivCreateManyArgs} args - Arguments to create many Inducks_equivs.
     *     @example
     *     // Create many Inducks_equivs
     *     const inducks_equiv = await prisma.inducks_equiv.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_equivCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_equivCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_equiv.
     * @param {inducks_equivDeleteArgs} args - Arguments to delete one Inducks_equiv.
     * @example
     * // Delete one Inducks_equiv
     * const Inducks_equiv = await prisma.inducks_equiv.delete({
     *   where: {
     *     // ... filter to delete one Inducks_equiv
     *   }
     * })
     * 
    **/
    delete<T extends inducks_equivDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_equivDeleteArgs<ExtArgs>>
    ): Prisma__inducks_equivClient<$Result.GetResult<Prisma.$inducks_equivPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_equiv.
     * @param {inducks_equivUpdateArgs} args - Arguments to update one Inducks_equiv.
     * @example
     * // Update one Inducks_equiv
     * const inducks_equiv = await prisma.inducks_equiv.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_equivUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_equivUpdateArgs<ExtArgs>>
    ): Prisma__inducks_equivClient<$Result.GetResult<Prisma.$inducks_equivPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_equivs.
     * @param {inducks_equivDeleteManyArgs} args - Arguments to filter Inducks_equivs to delete.
     * @example
     * // Delete a few Inducks_equivs
     * const { count } = await prisma.inducks_equiv.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_equivDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_equivDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_equivs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_equivUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_equivs
     * const inducks_equiv = await prisma.inducks_equiv.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_equivUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_equivUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_equiv.
     * @param {inducks_equivUpsertArgs} args - Arguments to update or create a Inducks_equiv.
     * @example
     * // Update or create a Inducks_equiv
     * const inducks_equiv = await prisma.inducks_equiv.upsert({
     *   create: {
     *     // ... data to create a Inducks_equiv
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_equiv we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_equivUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_equivUpsertArgs<ExtArgs>>
    ): Prisma__inducks_equivClient<$Result.GetResult<Prisma.$inducks_equivPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_equivs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_equivCountArgs} args - Arguments to filter Inducks_equivs to count.
     * @example
     * // Count the number of Inducks_equivs
     * const count = await prisma.inducks_equiv.count({
     *   where: {
     *     // ... the filter for the Inducks_equivs we want to count
     *   }
     * })
    **/
    count<T extends inducks_equivCountArgs>(
      args?: Subset<T, inducks_equivCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_equivCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_equiv.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_equivAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_equivAggregateArgs>(args: Subset<T, Inducks_equivAggregateArgs>): Prisma.PrismaPromise<GetInducks_equivAggregateType<T>>

    /**
     * Group by Inducks_equiv.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_equivGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_equivGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_equivGroupByArgs['orderBy'] }
        : { orderBy?: inducks_equivGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_equivGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_equivGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_equiv model
   */
  readonly fields: inducks_equivFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_equiv.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_equivClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_equiv model
   */ 
  interface inducks_equivFieldRefs {
    readonly issuecode: FieldRef<"inducks_equiv", 'String'>
    readonly equivid: FieldRef<"inducks_equiv", 'Int'>
    readonly equivcomment: FieldRef<"inducks_equiv", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_equiv findUnique
   */
  export type inducks_equivFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_equiv
     */
    select?: inducks_equivSelect<ExtArgs> | null
    /**
     * Filter, which inducks_equiv to fetch.
     */
    where: inducks_equivWhereUniqueInput
  }


  /**
   * inducks_equiv findUniqueOrThrow
   */
  export type inducks_equivFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_equiv
     */
    select?: inducks_equivSelect<ExtArgs> | null
    /**
     * Filter, which inducks_equiv to fetch.
     */
    where: inducks_equivWhereUniqueInput
  }


  /**
   * inducks_equiv findFirst
   */
  export type inducks_equivFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_equiv
     */
    select?: inducks_equivSelect<ExtArgs> | null
    /**
     * Filter, which inducks_equiv to fetch.
     */
    where?: inducks_equivWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_equivs to fetch.
     */
    orderBy?: inducks_equivOrderByWithRelationInput | inducks_equivOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_equivs.
     */
    cursor?: inducks_equivWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_equivs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_equivs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_equivs.
     */
    distinct?: Inducks_equivScalarFieldEnum | Inducks_equivScalarFieldEnum[]
  }


  /**
   * inducks_equiv findFirstOrThrow
   */
  export type inducks_equivFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_equiv
     */
    select?: inducks_equivSelect<ExtArgs> | null
    /**
     * Filter, which inducks_equiv to fetch.
     */
    where?: inducks_equivWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_equivs to fetch.
     */
    orderBy?: inducks_equivOrderByWithRelationInput | inducks_equivOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_equivs.
     */
    cursor?: inducks_equivWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_equivs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_equivs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_equivs.
     */
    distinct?: Inducks_equivScalarFieldEnum | Inducks_equivScalarFieldEnum[]
  }


  /**
   * inducks_equiv findMany
   */
  export type inducks_equivFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_equiv
     */
    select?: inducks_equivSelect<ExtArgs> | null
    /**
     * Filter, which inducks_equivs to fetch.
     */
    where?: inducks_equivWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_equivs to fetch.
     */
    orderBy?: inducks_equivOrderByWithRelationInput | inducks_equivOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_equivs.
     */
    cursor?: inducks_equivWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_equivs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_equivs.
     */
    skip?: number
    distinct?: Inducks_equivScalarFieldEnum | Inducks_equivScalarFieldEnum[]
  }


  /**
   * inducks_equiv create
   */
  export type inducks_equivCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_equiv
     */
    select?: inducks_equivSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_equiv.
     */
    data: XOR<inducks_equivCreateInput, inducks_equivUncheckedCreateInput>
  }


  /**
   * inducks_equiv createMany
   */
  export type inducks_equivCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_equivs.
     */
    data: inducks_equivCreateManyInput | inducks_equivCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_equiv update
   */
  export type inducks_equivUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_equiv
     */
    select?: inducks_equivSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_equiv.
     */
    data: XOR<inducks_equivUpdateInput, inducks_equivUncheckedUpdateInput>
    /**
     * Choose, which inducks_equiv to update.
     */
    where: inducks_equivWhereUniqueInput
  }


  /**
   * inducks_equiv updateMany
   */
  export type inducks_equivUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_equivs.
     */
    data: XOR<inducks_equivUpdateManyMutationInput, inducks_equivUncheckedUpdateManyInput>
    /**
     * Filter which inducks_equivs to update
     */
    where?: inducks_equivWhereInput
  }


  /**
   * inducks_equiv upsert
   */
  export type inducks_equivUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_equiv
     */
    select?: inducks_equivSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_equiv to update in case it exists.
     */
    where: inducks_equivWhereUniqueInput
    /**
     * In case the inducks_equiv found by the `where` argument doesn't exist, create a new inducks_equiv with this data.
     */
    create: XOR<inducks_equivCreateInput, inducks_equivUncheckedCreateInput>
    /**
     * In case the inducks_equiv was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_equivUpdateInput, inducks_equivUncheckedUpdateInput>
  }


  /**
   * inducks_equiv delete
   */
  export type inducks_equivDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_equiv
     */
    select?: inducks_equivSelect<ExtArgs> | null
    /**
     * Filter which inducks_equiv to delete.
     */
    where: inducks_equivWhereUniqueInput
  }


  /**
   * inducks_equiv deleteMany
   */
  export type inducks_equivDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_equivs to delete
     */
    where?: inducks_equivWhereInput
  }


  /**
   * inducks_equiv without action
   */
  export type inducks_equivDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_equiv
     */
    select?: inducks_equivSelect<ExtArgs> | null
  }



  /**
   * Model inducks_herocharacter
   */

  export type AggregateInducks_herocharacter = {
    _count: Inducks_herocharacterCountAggregateOutputType | null
    _avg: Inducks_herocharacterAvgAggregateOutputType | null
    _sum: Inducks_herocharacterSumAggregateOutputType | null
    _min: Inducks_herocharacterMinAggregateOutputType | null
    _max: Inducks_herocharacterMaxAggregateOutputType | null
  }

  export type Inducks_herocharacterAvgAggregateOutputType = {
    number: number | null
  }

  export type Inducks_herocharacterSumAggregateOutputType = {
    number: number | null
  }

  export type Inducks_herocharacterMinAggregateOutputType = {
    storycode: string | null
    charactercode: string | null
    number: number | null
    doubt: $Enums.inducks_herocharacter_doubt | null
  }

  export type Inducks_herocharacterMaxAggregateOutputType = {
    storycode: string | null
    charactercode: string | null
    number: number | null
    doubt: $Enums.inducks_herocharacter_doubt | null
  }

  export type Inducks_herocharacterCountAggregateOutputType = {
    storycode: number
    charactercode: number
    number: number
    doubt: number
    _all: number
  }


  export type Inducks_herocharacterAvgAggregateInputType = {
    number?: true
  }

  export type Inducks_herocharacterSumAggregateInputType = {
    number?: true
  }

  export type Inducks_herocharacterMinAggregateInputType = {
    storycode?: true
    charactercode?: true
    number?: true
    doubt?: true
  }

  export type Inducks_herocharacterMaxAggregateInputType = {
    storycode?: true
    charactercode?: true
    number?: true
    doubt?: true
  }

  export type Inducks_herocharacterCountAggregateInputType = {
    storycode?: true
    charactercode?: true
    number?: true
    doubt?: true
    _all?: true
  }

  export type Inducks_herocharacterAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_herocharacter to aggregate.
     */
    where?: inducks_herocharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_herocharacters to fetch.
     */
    orderBy?: inducks_herocharacterOrderByWithRelationInput | inducks_herocharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_herocharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_herocharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_herocharacters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_herocharacters
    **/
    _count?: true | Inducks_herocharacterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Inducks_herocharacterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Inducks_herocharacterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_herocharacterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_herocharacterMaxAggregateInputType
  }

  export type GetInducks_herocharacterAggregateType<T extends Inducks_herocharacterAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_herocharacter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_herocharacter[P]>
      : GetScalarType<T[P], AggregateInducks_herocharacter[P]>
  }




  export type inducks_herocharacterGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_herocharacterWhereInput
    orderBy?: inducks_herocharacterOrderByWithAggregationInput | inducks_herocharacterOrderByWithAggregationInput[]
    by: Inducks_herocharacterScalarFieldEnum[] | Inducks_herocharacterScalarFieldEnum
    having?: inducks_herocharacterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_herocharacterCountAggregateInputType | true
    _avg?: Inducks_herocharacterAvgAggregateInputType
    _sum?: Inducks_herocharacterSumAggregateInputType
    _min?: Inducks_herocharacterMinAggregateInputType
    _max?: Inducks_herocharacterMaxAggregateInputType
  }

  export type Inducks_herocharacterGroupByOutputType = {
    storycode: string
    charactercode: string
    number: number | null
    doubt: $Enums.inducks_herocharacter_doubt | null
    _count: Inducks_herocharacterCountAggregateOutputType | null
    _avg: Inducks_herocharacterAvgAggregateOutputType | null
    _sum: Inducks_herocharacterSumAggregateOutputType | null
    _min: Inducks_herocharacterMinAggregateOutputType | null
    _max: Inducks_herocharacterMaxAggregateOutputType | null
  }

  type GetInducks_herocharacterGroupByPayload<T extends inducks_herocharacterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_herocharacterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_herocharacterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_herocharacterGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_herocharacterGroupByOutputType[P]>
        }
      >
    >


  export type inducks_herocharacterSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    storycode?: boolean
    charactercode?: boolean
    number?: boolean
    doubt?: boolean
  }, ExtArgs["result"]["inducks_herocharacter"]>

  export type inducks_herocharacterSelectScalar = {
    storycode?: boolean
    charactercode?: boolean
    number?: boolean
    doubt?: boolean
  }


  export type $inducks_herocharacterPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_herocharacter"
    objects: {}
    scalars: $Extensions.GetResult<{
      storycode: string
      charactercode: string
      number: number | null
      doubt: $Enums.inducks_herocharacter_doubt | null
    }, ExtArgs["result"]["inducks_herocharacter"]>
    composites: {}
  }


  type inducks_herocharacterGetPayload<S extends boolean | null | undefined | inducks_herocharacterDefaultArgs> = $Result.GetResult<Prisma.$inducks_herocharacterPayload, S>

  type inducks_herocharacterCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_herocharacterFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_herocharacterCountAggregateInputType | true
    }

  export interface inducks_herocharacterDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_herocharacter'], meta: { name: 'inducks_herocharacter' } }
    /**
     * Find zero or one Inducks_herocharacter that matches the filter.
     * @param {inducks_herocharacterFindUniqueArgs} args - Arguments to find a Inducks_herocharacter
     * @example
     * // Get one Inducks_herocharacter
     * const inducks_herocharacter = await prisma.inducks_herocharacter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_herocharacterFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_herocharacterFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_herocharacterClient<$Result.GetResult<Prisma.$inducks_herocharacterPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_herocharacter that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_herocharacterFindUniqueOrThrowArgs} args - Arguments to find a Inducks_herocharacter
     * @example
     * // Get one Inducks_herocharacter
     * const inducks_herocharacter = await prisma.inducks_herocharacter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_herocharacterFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_herocharacterFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_herocharacterClient<$Result.GetResult<Prisma.$inducks_herocharacterPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_herocharacter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_herocharacterFindFirstArgs} args - Arguments to find a Inducks_herocharacter
     * @example
     * // Get one Inducks_herocharacter
     * const inducks_herocharacter = await prisma.inducks_herocharacter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_herocharacterFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_herocharacterFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_herocharacterClient<$Result.GetResult<Prisma.$inducks_herocharacterPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_herocharacter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_herocharacterFindFirstOrThrowArgs} args - Arguments to find a Inducks_herocharacter
     * @example
     * // Get one Inducks_herocharacter
     * const inducks_herocharacter = await prisma.inducks_herocharacter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_herocharacterFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_herocharacterFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_herocharacterClient<$Result.GetResult<Prisma.$inducks_herocharacterPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_herocharacters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_herocharacterFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_herocharacters
     * const inducks_herocharacters = await prisma.inducks_herocharacter.findMany()
     * 
     * // Get first 10 Inducks_herocharacters
     * const inducks_herocharacters = await prisma.inducks_herocharacter.findMany({ take: 10 })
     * 
     * // Only select the `storycode`
     * const inducks_herocharacterWithStorycodeOnly = await prisma.inducks_herocharacter.findMany({ select: { storycode: true } })
     * 
    **/
    findMany<T extends inducks_herocharacterFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_herocharacterFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_herocharacterPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_herocharacter.
     * @param {inducks_herocharacterCreateArgs} args - Arguments to create a Inducks_herocharacter.
     * @example
     * // Create one Inducks_herocharacter
     * const Inducks_herocharacter = await prisma.inducks_herocharacter.create({
     *   data: {
     *     // ... data to create a Inducks_herocharacter
     *   }
     * })
     * 
    **/
    create<T extends inducks_herocharacterCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_herocharacterCreateArgs<ExtArgs>>
    ): Prisma__inducks_herocharacterClient<$Result.GetResult<Prisma.$inducks_herocharacterPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_herocharacters.
     *     @param {inducks_herocharacterCreateManyArgs} args - Arguments to create many Inducks_herocharacters.
     *     @example
     *     // Create many Inducks_herocharacters
     *     const inducks_herocharacter = await prisma.inducks_herocharacter.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_herocharacterCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_herocharacterCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_herocharacter.
     * @param {inducks_herocharacterDeleteArgs} args - Arguments to delete one Inducks_herocharacter.
     * @example
     * // Delete one Inducks_herocharacter
     * const Inducks_herocharacter = await prisma.inducks_herocharacter.delete({
     *   where: {
     *     // ... filter to delete one Inducks_herocharacter
     *   }
     * })
     * 
    **/
    delete<T extends inducks_herocharacterDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_herocharacterDeleteArgs<ExtArgs>>
    ): Prisma__inducks_herocharacterClient<$Result.GetResult<Prisma.$inducks_herocharacterPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_herocharacter.
     * @param {inducks_herocharacterUpdateArgs} args - Arguments to update one Inducks_herocharacter.
     * @example
     * // Update one Inducks_herocharacter
     * const inducks_herocharacter = await prisma.inducks_herocharacter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_herocharacterUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_herocharacterUpdateArgs<ExtArgs>>
    ): Prisma__inducks_herocharacterClient<$Result.GetResult<Prisma.$inducks_herocharacterPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_herocharacters.
     * @param {inducks_herocharacterDeleteManyArgs} args - Arguments to filter Inducks_herocharacters to delete.
     * @example
     * // Delete a few Inducks_herocharacters
     * const { count } = await prisma.inducks_herocharacter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_herocharacterDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_herocharacterDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_herocharacters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_herocharacterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_herocharacters
     * const inducks_herocharacter = await prisma.inducks_herocharacter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_herocharacterUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_herocharacterUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_herocharacter.
     * @param {inducks_herocharacterUpsertArgs} args - Arguments to update or create a Inducks_herocharacter.
     * @example
     * // Update or create a Inducks_herocharacter
     * const inducks_herocharacter = await prisma.inducks_herocharacter.upsert({
     *   create: {
     *     // ... data to create a Inducks_herocharacter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_herocharacter we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_herocharacterUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_herocharacterUpsertArgs<ExtArgs>>
    ): Prisma__inducks_herocharacterClient<$Result.GetResult<Prisma.$inducks_herocharacterPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_herocharacters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_herocharacterCountArgs} args - Arguments to filter Inducks_herocharacters to count.
     * @example
     * // Count the number of Inducks_herocharacters
     * const count = await prisma.inducks_herocharacter.count({
     *   where: {
     *     // ... the filter for the Inducks_herocharacters we want to count
     *   }
     * })
    **/
    count<T extends inducks_herocharacterCountArgs>(
      args?: Subset<T, inducks_herocharacterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_herocharacterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_herocharacter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_herocharacterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_herocharacterAggregateArgs>(args: Subset<T, Inducks_herocharacterAggregateArgs>): Prisma.PrismaPromise<GetInducks_herocharacterAggregateType<T>>

    /**
     * Group by Inducks_herocharacter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_herocharacterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_herocharacterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_herocharacterGroupByArgs['orderBy'] }
        : { orderBy?: inducks_herocharacterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_herocharacterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_herocharacterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_herocharacter model
   */
  readonly fields: inducks_herocharacterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_herocharacter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_herocharacterClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_herocharacter model
   */ 
  interface inducks_herocharacterFieldRefs {
    readonly storycode: FieldRef<"inducks_herocharacter", 'String'>
    readonly charactercode: FieldRef<"inducks_herocharacter", 'String'>
    readonly number: FieldRef<"inducks_herocharacter", 'Int'>
    readonly doubt: FieldRef<"inducks_herocharacter", 'inducks_herocharacter_doubt'>
  }
    

  // Custom InputTypes

  /**
   * inducks_herocharacter findUnique
   */
  export type inducks_herocharacterFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_herocharacter
     */
    select?: inducks_herocharacterSelect<ExtArgs> | null
    /**
     * Filter, which inducks_herocharacter to fetch.
     */
    where: inducks_herocharacterWhereUniqueInput
  }


  /**
   * inducks_herocharacter findUniqueOrThrow
   */
  export type inducks_herocharacterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_herocharacter
     */
    select?: inducks_herocharacterSelect<ExtArgs> | null
    /**
     * Filter, which inducks_herocharacter to fetch.
     */
    where: inducks_herocharacterWhereUniqueInput
  }


  /**
   * inducks_herocharacter findFirst
   */
  export type inducks_herocharacterFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_herocharacter
     */
    select?: inducks_herocharacterSelect<ExtArgs> | null
    /**
     * Filter, which inducks_herocharacter to fetch.
     */
    where?: inducks_herocharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_herocharacters to fetch.
     */
    orderBy?: inducks_herocharacterOrderByWithRelationInput | inducks_herocharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_herocharacters.
     */
    cursor?: inducks_herocharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_herocharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_herocharacters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_herocharacters.
     */
    distinct?: Inducks_herocharacterScalarFieldEnum | Inducks_herocharacterScalarFieldEnum[]
  }


  /**
   * inducks_herocharacter findFirstOrThrow
   */
  export type inducks_herocharacterFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_herocharacter
     */
    select?: inducks_herocharacterSelect<ExtArgs> | null
    /**
     * Filter, which inducks_herocharacter to fetch.
     */
    where?: inducks_herocharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_herocharacters to fetch.
     */
    orderBy?: inducks_herocharacterOrderByWithRelationInput | inducks_herocharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_herocharacters.
     */
    cursor?: inducks_herocharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_herocharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_herocharacters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_herocharacters.
     */
    distinct?: Inducks_herocharacterScalarFieldEnum | Inducks_herocharacterScalarFieldEnum[]
  }


  /**
   * inducks_herocharacter findMany
   */
  export type inducks_herocharacterFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_herocharacter
     */
    select?: inducks_herocharacterSelect<ExtArgs> | null
    /**
     * Filter, which inducks_herocharacters to fetch.
     */
    where?: inducks_herocharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_herocharacters to fetch.
     */
    orderBy?: inducks_herocharacterOrderByWithRelationInput | inducks_herocharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_herocharacters.
     */
    cursor?: inducks_herocharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_herocharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_herocharacters.
     */
    skip?: number
    distinct?: Inducks_herocharacterScalarFieldEnum | Inducks_herocharacterScalarFieldEnum[]
  }


  /**
   * inducks_herocharacter create
   */
  export type inducks_herocharacterCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_herocharacter
     */
    select?: inducks_herocharacterSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_herocharacter.
     */
    data: XOR<inducks_herocharacterCreateInput, inducks_herocharacterUncheckedCreateInput>
  }


  /**
   * inducks_herocharacter createMany
   */
  export type inducks_herocharacterCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_herocharacters.
     */
    data: inducks_herocharacterCreateManyInput | inducks_herocharacterCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_herocharacter update
   */
  export type inducks_herocharacterUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_herocharacter
     */
    select?: inducks_herocharacterSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_herocharacter.
     */
    data: XOR<inducks_herocharacterUpdateInput, inducks_herocharacterUncheckedUpdateInput>
    /**
     * Choose, which inducks_herocharacter to update.
     */
    where: inducks_herocharacterWhereUniqueInput
  }


  /**
   * inducks_herocharacter updateMany
   */
  export type inducks_herocharacterUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_herocharacters.
     */
    data: XOR<inducks_herocharacterUpdateManyMutationInput, inducks_herocharacterUncheckedUpdateManyInput>
    /**
     * Filter which inducks_herocharacters to update
     */
    where?: inducks_herocharacterWhereInput
  }


  /**
   * inducks_herocharacter upsert
   */
  export type inducks_herocharacterUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_herocharacter
     */
    select?: inducks_herocharacterSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_herocharacter to update in case it exists.
     */
    where: inducks_herocharacterWhereUniqueInput
    /**
     * In case the inducks_herocharacter found by the `where` argument doesn't exist, create a new inducks_herocharacter with this data.
     */
    create: XOR<inducks_herocharacterCreateInput, inducks_herocharacterUncheckedCreateInput>
    /**
     * In case the inducks_herocharacter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_herocharacterUpdateInput, inducks_herocharacterUncheckedUpdateInput>
  }


  /**
   * inducks_herocharacter delete
   */
  export type inducks_herocharacterDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_herocharacter
     */
    select?: inducks_herocharacterSelect<ExtArgs> | null
    /**
     * Filter which inducks_herocharacter to delete.
     */
    where: inducks_herocharacterWhereUniqueInput
  }


  /**
   * inducks_herocharacter deleteMany
   */
  export type inducks_herocharacterDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_herocharacters to delete
     */
    where?: inducks_herocharacterWhereInput
  }


  /**
   * inducks_herocharacter without action
   */
  export type inducks_herocharacterDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_herocharacter
     */
    select?: inducks_herocharacterSelect<ExtArgs> | null
  }



  /**
   * Model inducks_inputfile
   */

  export type AggregateInducks_inputfile = {
    _count: Inducks_inputfileCountAggregateOutputType | null
    _avg: Inducks_inputfileAvgAggregateOutputType | null
    _sum: Inducks_inputfileSumAggregateOutputType | null
    _min: Inducks_inputfileMinAggregateOutputType | null
    _max: Inducks_inputfileMaxAggregateOutputType | null
  }

  export type Inducks_inputfileAvgAggregateOutputType = {
    inputfilecode: number | null
  }

  export type Inducks_inputfileSumAggregateOutputType = {
    inputfilecode: number | null
  }

  export type Inducks_inputfileMinAggregateOutputType = {
    inputfilecode: number | null
    path: string | null
    filename: string | null
    layout: string | null
    locked: $Enums.inducks_inputfile_locked | null
    maintenanceteamcode: string | null
    countrycode: string | null
    languagecode: string | null
    producercode: string | null
    secundary: $Enums.inducks_inputfile_secundary | null
  }

  export type Inducks_inputfileMaxAggregateOutputType = {
    inputfilecode: number | null
    path: string | null
    filename: string | null
    layout: string | null
    locked: $Enums.inducks_inputfile_locked | null
    maintenanceteamcode: string | null
    countrycode: string | null
    languagecode: string | null
    producercode: string | null
    secundary: $Enums.inducks_inputfile_secundary | null
  }

  export type Inducks_inputfileCountAggregateOutputType = {
    inputfilecode: number
    path: number
    filename: number
    layout: number
    locked: number
    maintenanceteamcode: number
    countrycode: number
    languagecode: number
    producercode: number
    secundary: number
    _all: number
  }


  export type Inducks_inputfileAvgAggregateInputType = {
    inputfilecode?: true
  }

  export type Inducks_inputfileSumAggregateInputType = {
    inputfilecode?: true
  }

  export type Inducks_inputfileMinAggregateInputType = {
    inputfilecode?: true
    path?: true
    filename?: true
    layout?: true
    locked?: true
    maintenanceteamcode?: true
    countrycode?: true
    languagecode?: true
    producercode?: true
    secundary?: true
  }

  export type Inducks_inputfileMaxAggregateInputType = {
    inputfilecode?: true
    path?: true
    filename?: true
    layout?: true
    locked?: true
    maintenanceteamcode?: true
    countrycode?: true
    languagecode?: true
    producercode?: true
    secundary?: true
  }

  export type Inducks_inputfileCountAggregateInputType = {
    inputfilecode?: true
    path?: true
    filename?: true
    layout?: true
    locked?: true
    maintenanceteamcode?: true
    countrycode?: true
    languagecode?: true
    producercode?: true
    secundary?: true
    _all?: true
  }

  export type Inducks_inputfileAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_inputfile to aggregate.
     */
    where?: inducks_inputfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_inputfiles to fetch.
     */
    orderBy?: inducks_inputfileOrderByWithRelationInput | inducks_inputfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_inputfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_inputfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_inputfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_inputfiles
    **/
    _count?: true | Inducks_inputfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Inducks_inputfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Inducks_inputfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_inputfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_inputfileMaxAggregateInputType
  }

  export type GetInducks_inputfileAggregateType<T extends Inducks_inputfileAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_inputfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_inputfile[P]>
      : GetScalarType<T[P], AggregateInducks_inputfile[P]>
  }




  export type inducks_inputfileGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_inputfileWhereInput
    orderBy?: inducks_inputfileOrderByWithAggregationInput | inducks_inputfileOrderByWithAggregationInput[]
    by: Inducks_inputfileScalarFieldEnum[] | Inducks_inputfileScalarFieldEnum
    having?: inducks_inputfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_inputfileCountAggregateInputType | true
    _avg?: Inducks_inputfileAvgAggregateInputType
    _sum?: Inducks_inputfileSumAggregateInputType
    _min?: Inducks_inputfileMinAggregateInputType
    _max?: Inducks_inputfileMaxAggregateInputType
  }

  export type Inducks_inputfileGroupByOutputType = {
    inputfilecode: number
    path: string | null
    filename: string | null
    layout: string | null
    locked: $Enums.inducks_inputfile_locked | null
    maintenanceteamcode: string | null
    countrycode: string | null
    languagecode: string | null
    producercode: string | null
    secundary: $Enums.inducks_inputfile_secundary | null
    _count: Inducks_inputfileCountAggregateOutputType | null
    _avg: Inducks_inputfileAvgAggregateOutputType | null
    _sum: Inducks_inputfileSumAggregateOutputType | null
    _min: Inducks_inputfileMinAggregateOutputType | null
    _max: Inducks_inputfileMaxAggregateOutputType | null
  }

  type GetInducks_inputfileGroupByPayload<T extends inducks_inputfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_inputfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_inputfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_inputfileGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_inputfileGroupByOutputType[P]>
        }
      >
    >


  export type inducks_inputfileSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    inputfilecode?: boolean
    path?: boolean
    filename?: boolean
    layout?: boolean
    locked?: boolean
    maintenanceteamcode?: boolean
    countrycode?: boolean
    languagecode?: boolean
    producercode?: boolean
    secundary?: boolean
  }, ExtArgs["result"]["inducks_inputfile"]>

  export type inducks_inputfileSelectScalar = {
    inputfilecode?: boolean
    path?: boolean
    filename?: boolean
    layout?: boolean
    locked?: boolean
    maintenanceteamcode?: boolean
    countrycode?: boolean
    languagecode?: boolean
    producercode?: boolean
    secundary?: boolean
  }


  export type $inducks_inputfilePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_inputfile"
    objects: {}
    scalars: $Extensions.GetResult<{
      inputfilecode: number
      path: string | null
      filename: string | null
      layout: string | null
      locked: $Enums.inducks_inputfile_locked | null
      maintenanceteamcode: string | null
      countrycode: string | null
      languagecode: string | null
      producercode: string | null
      secundary: $Enums.inducks_inputfile_secundary | null
    }, ExtArgs["result"]["inducks_inputfile"]>
    composites: {}
  }


  type inducks_inputfileGetPayload<S extends boolean | null | undefined | inducks_inputfileDefaultArgs> = $Result.GetResult<Prisma.$inducks_inputfilePayload, S>

  type inducks_inputfileCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_inputfileFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_inputfileCountAggregateInputType | true
    }

  export interface inducks_inputfileDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_inputfile'], meta: { name: 'inducks_inputfile' } }
    /**
     * Find zero or one Inducks_inputfile that matches the filter.
     * @param {inducks_inputfileFindUniqueArgs} args - Arguments to find a Inducks_inputfile
     * @example
     * // Get one Inducks_inputfile
     * const inducks_inputfile = await prisma.inducks_inputfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_inputfileFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_inputfileFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_inputfileClient<$Result.GetResult<Prisma.$inducks_inputfilePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_inputfile that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_inputfileFindUniqueOrThrowArgs} args - Arguments to find a Inducks_inputfile
     * @example
     * // Get one Inducks_inputfile
     * const inducks_inputfile = await prisma.inducks_inputfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_inputfileFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_inputfileFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_inputfileClient<$Result.GetResult<Prisma.$inducks_inputfilePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_inputfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_inputfileFindFirstArgs} args - Arguments to find a Inducks_inputfile
     * @example
     * // Get one Inducks_inputfile
     * const inducks_inputfile = await prisma.inducks_inputfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_inputfileFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_inputfileFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_inputfileClient<$Result.GetResult<Prisma.$inducks_inputfilePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_inputfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_inputfileFindFirstOrThrowArgs} args - Arguments to find a Inducks_inputfile
     * @example
     * // Get one Inducks_inputfile
     * const inducks_inputfile = await prisma.inducks_inputfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_inputfileFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_inputfileFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_inputfileClient<$Result.GetResult<Prisma.$inducks_inputfilePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_inputfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_inputfileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_inputfiles
     * const inducks_inputfiles = await prisma.inducks_inputfile.findMany()
     * 
     * // Get first 10 Inducks_inputfiles
     * const inducks_inputfiles = await prisma.inducks_inputfile.findMany({ take: 10 })
     * 
     * // Only select the `inputfilecode`
     * const inducks_inputfileWithInputfilecodeOnly = await prisma.inducks_inputfile.findMany({ select: { inputfilecode: true } })
     * 
    **/
    findMany<T extends inducks_inputfileFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_inputfileFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_inputfilePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_inputfile.
     * @param {inducks_inputfileCreateArgs} args - Arguments to create a Inducks_inputfile.
     * @example
     * // Create one Inducks_inputfile
     * const Inducks_inputfile = await prisma.inducks_inputfile.create({
     *   data: {
     *     // ... data to create a Inducks_inputfile
     *   }
     * })
     * 
    **/
    create<T extends inducks_inputfileCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_inputfileCreateArgs<ExtArgs>>
    ): Prisma__inducks_inputfileClient<$Result.GetResult<Prisma.$inducks_inputfilePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_inputfiles.
     *     @param {inducks_inputfileCreateManyArgs} args - Arguments to create many Inducks_inputfiles.
     *     @example
     *     // Create many Inducks_inputfiles
     *     const inducks_inputfile = await prisma.inducks_inputfile.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_inputfileCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_inputfileCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_inputfile.
     * @param {inducks_inputfileDeleteArgs} args - Arguments to delete one Inducks_inputfile.
     * @example
     * // Delete one Inducks_inputfile
     * const Inducks_inputfile = await prisma.inducks_inputfile.delete({
     *   where: {
     *     // ... filter to delete one Inducks_inputfile
     *   }
     * })
     * 
    **/
    delete<T extends inducks_inputfileDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_inputfileDeleteArgs<ExtArgs>>
    ): Prisma__inducks_inputfileClient<$Result.GetResult<Prisma.$inducks_inputfilePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_inputfile.
     * @param {inducks_inputfileUpdateArgs} args - Arguments to update one Inducks_inputfile.
     * @example
     * // Update one Inducks_inputfile
     * const inducks_inputfile = await prisma.inducks_inputfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_inputfileUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_inputfileUpdateArgs<ExtArgs>>
    ): Prisma__inducks_inputfileClient<$Result.GetResult<Prisma.$inducks_inputfilePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_inputfiles.
     * @param {inducks_inputfileDeleteManyArgs} args - Arguments to filter Inducks_inputfiles to delete.
     * @example
     * // Delete a few Inducks_inputfiles
     * const { count } = await prisma.inducks_inputfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_inputfileDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_inputfileDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_inputfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_inputfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_inputfiles
     * const inducks_inputfile = await prisma.inducks_inputfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_inputfileUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_inputfileUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_inputfile.
     * @param {inducks_inputfileUpsertArgs} args - Arguments to update or create a Inducks_inputfile.
     * @example
     * // Update or create a Inducks_inputfile
     * const inducks_inputfile = await prisma.inducks_inputfile.upsert({
     *   create: {
     *     // ... data to create a Inducks_inputfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_inputfile we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_inputfileUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_inputfileUpsertArgs<ExtArgs>>
    ): Prisma__inducks_inputfileClient<$Result.GetResult<Prisma.$inducks_inputfilePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_inputfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_inputfileCountArgs} args - Arguments to filter Inducks_inputfiles to count.
     * @example
     * // Count the number of Inducks_inputfiles
     * const count = await prisma.inducks_inputfile.count({
     *   where: {
     *     // ... the filter for the Inducks_inputfiles we want to count
     *   }
     * })
    **/
    count<T extends inducks_inputfileCountArgs>(
      args?: Subset<T, inducks_inputfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_inputfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_inputfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_inputfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_inputfileAggregateArgs>(args: Subset<T, Inducks_inputfileAggregateArgs>): Prisma.PrismaPromise<GetInducks_inputfileAggregateType<T>>

    /**
     * Group by Inducks_inputfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_inputfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_inputfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_inputfileGroupByArgs['orderBy'] }
        : { orderBy?: inducks_inputfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_inputfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_inputfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_inputfile model
   */
  readonly fields: inducks_inputfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_inputfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_inputfileClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_inputfile model
   */ 
  interface inducks_inputfileFieldRefs {
    readonly inputfilecode: FieldRef<"inducks_inputfile", 'Int'>
    readonly path: FieldRef<"inducks_inputfile", 'String'>
    readonly filename: FieldRef<"inducks_inputfile", 'String'>
    readonly layout: FieldRef<"inducks_inputfile", 'String'>
    readonly locked: FieldRef<"inducks_inputfile", 'inducks_inputfile_locked'>
    readonly maintenanceteamcode: FieldRef<"inducks_inputfile", 'String'>
    readonly countrycode: FieldRef<"inducks_inputfile", 'String'>
    readonly languagecode: FieldRef<"inducks_inputfile", 'String'>
    readonly producercode: FieldRef<"inducks_inputfile", 'String'>
    readonly secundary: FieldRef<"inducks_inputfile", 'inducks_inputfile_secundary'>
  }
    

  // Custom InputTypes

  /**
   * inducks_inputfile findUnique
   */
  export type inducks_inputfileFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_inputfile
     */
    select?: inducks_inputfileSelect<ExtArgs> | null
    /**
     * Filter, which inducks_inputfile to fetch.
     */
    where: inducks_inputfileWhereUniqueInput
  }


  /**
   * inducks_inputfile findUniqueOrThrow
   */
  export type inducks_inputfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_inputfile
     */
    select?: inducks_inputfileSelect<ExtArgs> | null
    /**
     * Filter, which inducks_inputfile to fetch.
     */
    where: inducks_inputfileWhereUniqueInput
  }


  /**
   * inducks_inputfile findFirst
   */
  export type inducks_inputfileFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_inputfile
     */
    select?: inducks_inputfileSelect<ExtArgs> | null
    /**
     * Filter, which inducks_inputfile to fetch.
     */
    where?: inducks_inputfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_inputfiles to fetch.
     */
    orderBy?: inducks_inputfileOrderByWithRelationInput | inducks_inputfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_inputfiles.
     */
    cursor?: inducks_inputfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_inputfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_inputfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_inputfiles.
     */
    distinct?: Inducks_inputfileScalarFieldEnum | Inducks_inputfileScalarFieldEnum[]
  }


  /**
   * inducks_inputfile findFirstOrThrow
   */
  export type inducks_inputfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_inputfile
     */
    select?: inducks_inputfileSelect<ExtArgs> | null
    /**
     * Filter, which inducks_inputfile to fetch.
     */
    where?: inducks_inputfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_inputfiles to fetch.
     */
    orderBy?: inducks_inputfileOrderByWithRelationInput | inducks_inputfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_inputfiles.
     */
    cursor?: inducks_inputfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_inputfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_inputfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_inputfiles.
     */
    distinct?: Inducks_inputfileScalarFieldEnum | Inducks_inputfileScalarFieldEnum[]
  }


  /**
   * inducks_inputfile findMany
   */
  export type inducks_inputfileFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_inputfile
     */
    select?: inducks_inputfileSelect<ExtArgs> | null
    /**
     * Filter, which inducks_inputfiles to fetch.
     */
    where?: inducks_inputfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_inputfiles to fetch.
     */
    orderBy?: inducks_inputfileOrderByWithRelationInput | inducks_inputfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_inputfiles.
     */
    cursor?: inducks_inputfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_inputfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_inputfiles.
     */
    skip?: number
    distinct?: Inducks_inputfileScalarFieldEnum | Inducks_inputfileScalarFieldEnum[]
  }


  /**
   * inducks_inputfile create
   */
  export type inducks_inputfileCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_inputfile
     */
    select?: inducks_inputfileSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_inputfile.
     */
    data: XOR<inducks_inputfileCreateInput, inducks_inputfileUncheckedCreateInput>
  }


  /**
   * inducks_inputfile createMany
   */
  export type inducks_inputfileCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_inputfiles.
     */
    data: inducks_inputfileCreateManyInput | inducks_inputfileCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_inputfile update
   */
  export type inducks_inputfileUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_inputfile
     */
    select?: inducks_inputfileSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_inputfile.
     */
    data: XOR<inducks_inputfileUpdateInput, inducks_inputfileUncheckedUpdateInput>
    /**
     * Choose, which inducks_inputfile to update.
     */
    where: inducks_inputfileWhereUniqueInput
  }


  /**
   * inducks_inputfile updateMany
   */
  export type inducks_inputfileUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_inputfiles.
     */
    data: XOR<inducks_inputfileUpdateManyMutationInput, inducks_inputfileUncheckedUpdateManyInput>
    /**
     * Filter which inducks_inputfiles to update
     */
    where?: inducks_inputfileWhereInput
  }


  /**
   * inducks_inputfile upsert
   */
  export type inducks_inputfileUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_inputfile
     */
    select?: inducks_inputfileSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_inputfile to update in case it exists.
     */
    where: inducks_inputfileWhereUniqueInput
    /**
     * In case the inducks_inputfile found by the `where` argument doesn't exist, create a new inducks_inputfile with this data.
     */
    create: XOR<inducks_inputfileCreateInput, inducks_inputfileUncheckedCreateInput>
    /**
     * In case the inducks_inputfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_inputfileUpdateInput, inducks_inputfileUncheckedUpdateInput>
  }


  /**
   * inducks_inputfile delete
   */
  export type inducks_inputfileDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_inputfile
     */
    select?: inducks_inputfileSelect<ExtArgs> | null
    /**
     * Filter which inducks_inputfile to delete.
     */
    where: inducks_inputfileWhereUniqueInput
  }


  /**
   * inducks_inputfile deleteMany
   */
  export type inducks_inputfileDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_inputfiles to delete
     */
    where?: inducks_inputfileWhereInput
  }


  /**
   * inducks_inputfile without action
   */
  export type inducks_inputfileDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_inputfile
     */
    select?: inducks_inputfileSelect<ExtArgs> | null
  }



  /**
   * Model inducks_issue
   */

  export type AggregateInducks_issue = {
    _count: Inducks_issueCountAggregateOutputType | null
    _avg: Inducks_issueAvgAggregateOutputType | null
    _sum: Inducks_issueSumAggregateOutputType | null
    _min: Inducks_issueMinAggregateOutputType | null
    _max: Inducks_issueMaxAggregateOutputType | null
  }

  export type Inducks_issueAvgAggregateOutputType = {
    inputfilecode: number | null
  }

  export type Inducks_issueSumAggregateOutputType = {
    inputfilecode: number | null
  }

  export type Inducks_issueMinAggregateOutputType = {
    issuecode: string | null
    issuerangecode: string | null
    publicationcode: string | null
    issuenumber: string | null
    title: string | null
    size: string | null
    pages: string | null
    price: string | null
    printrun: string | null
    attached: string | null
    oldestdate: string | null
    fullyindexed: $Enums.inducks_issue_fullyindexed | null
    issuecomment: string | null
    error: $Enums.inducks_issue_error | null
    filledoldestdate: string | null
    locked: $Enums.inducks_issue_locked | null
    inxforbidden: $Enums.inducks_issue_inxforbidden | null
    inputfilecode: number | null
    maintenanceteamcode: string | null
  }

  export type Inducks_issueMaxAggregateOutputType = {
    issuecode: string | null
    issuerangecode: string | null
    publicationcode: string | null
    issuenumber: string | null
    title: string | null
    size: string | null
    pages: string | null
    price: string | null
    printrun: string | null
    attached: string | null
    oldestdate: string | null
    fullyindexed: $Enums.inducks_issue_fullyindexed | null
    issuecomment: string | null
    error: $Enums.inducks_issue_error | null
    filledoldestdate: string | null
    locked: $Enums.inducks_issue_locked | null
    inxforbidden: $Enums.inducks_issue_inxforbidden | null
    inputfilecode: number | null
    maintenanceteamcode: string | null
  }

  export type Inducks_issueCountAggregateOutputType = {
    issuecode: number
    issuerangecode: number
    publicationcode: number
    issuenumber: number
    title: number
    size: number
    pages: number
    price: number
    printrun: number
    attached: number
    oldestdate: number
    fullyindexed: number
    issuecomment: number
    error: number
    filledoldestdate: number
    locked: number
    inxforbidden: number
    inputfilecode: number
    maintenanceteamcode: number
    _all: number
  }


  export type Inducks_issueAvgAggregateInputType = {
    inputfilecode?: true
  }

  export type Inducks_issueSumAggregateInputType = {
    inputfilecode?: true
  }

  export type Inducks_issueMinAggregateInputType = {
    issuecode?: true
    issuerangecode?: true
    publicationcode?: true
    issuenumber?: true
    title?: true
    size?: true
    pages?: true
    price?: true
    printrun?: true
    attached?: true
    oldestdate?: true
    fullyindexed?: true
    issuecomment?: true
    error?: true
    filledoldestdate?: true
    locked?: true
    inxforbidden?: true
    inputfilecode?: true
    maintenanceteamcode?: true
  }

  export type Inducks_issueMaxAggregateInputType = {
    issuecode?: true
    issuerangecode?: true
    publicationcode?: true
    issuenumber?: true
    title?: true
    size?: true
    pages?: true
    price?: true
    printrun?: true
    attached?: true
    oldestdate?: true
    fullyindexed?: true
    issuecomment?: true
    error?: true
    filledoldestdate?: true
    locked?: true
    inxforbidden?: true
    inputfilecode?: true
    maintenanceteamcode?: true
  }

  export type Inducks_issueCountAggregateInputType = {
    issuecode?: true
    issuerangecode?: true
    publicationcode?: true
    issuenumber?: true
    title?: true
    size?: true
    pages?: true
    price?: true
    printrun?: true
    attached?: true
    oldestdate?: true
    fullyindexed?: true
    issuecomment?: true
    error?: true
    filledoldestdate?: true
    locked?: true
    inxforbidden?: true
    inputfilecode?: true
    maintenanceteamcode?: true
    _all?: true
  }

  export type Inducks_issueAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_issue to aggregate.
     */
    where?: inducks_issueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_issues to fetch.
     */
    orderBy?: inducks_issueOrderByWithRelationInput | inducks_issueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_issueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_issues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_issues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_issues
    **/
    _count?: true | Inducks_issueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Inducks_issueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Inducks_issueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_issueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_issueMaxAggregateInputType
  }

  export type GetInducks_issueAggregateType<T extends Inducks_issueAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_issue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_issue[P]>
      : GetScalarType<T[P], AggregateInducks_issue[P]>
  }




  export type inducks_issueGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_issueWhereInput
    orderBy?: inducks_issueOrderByWithAggregationInput | inducks_issueOrderByWithAggregationInput[]
    by: Inducks_issueScalarFieldEnum[] | Inducks_issueScalarFieldEnum
    having?: inducks_issueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_issueCountAggregateInputType | true
    _avg?: Inducks_issueAvgAggregateInputType
    _sum?: Inducks_issueSumAggregateInputType
    _min?: Inducks_issueMinAggregateInputType
    _max?: Inducks_issueMaxAggregateInputType
  }

  export type Inducks_issueGroupByOutputType = {
    issuecode: string
    issuerangecode: string | null
    publicationcode: string | null
    issuenumber: string | null
    title: string | null
    size: string | null
    pages: string | null
    price: string | null
    printrun: string | null
    attached: string | null
    oldestdate: string | null
    fullyindexed: $Enums.inducks_issue_fullyindexed | null
    issuecomment: string | null
    error: $Enums.inducks_issue_error | null
    filledoldestdate: string | null
    locked: $Enums.inducks_issue_locked | null
    inxforbidden: $Enums.inducks_issue_inxforbidden | null
    inputfilecode: number | null
    maintenanceteamcode: string | null
    _count: Inducks_issueCountAggregateOutputType | null
    _avg: Inducks_issueAvgAggregateOutputType | null
    _sum: Inducks_issueSumAggregateOutputType | null
    _min: Inducks_issueMinAggregateOutputType | null
    _max: Inducks_issueMaxAggregateOutputType | null
  }

  type GetInducks_issueGroupByPayload<T extends inducks_issueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_issueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_issueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_issueGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_issueGroupByOutputType[P]>
        }
      >
    >


  export type inducks_issueSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    issuecode?: boolean
    issuerangecode?: boolean
    publicationcode?: boolean
    issuenumber?: boolean
    title?: boolean
    size?: boolean
    pages?: boolean
    price?: boolean
    printrun?: boolean
    attached?: boolean
    oldestdate?: boolean
    fullyindexed?: boolean
    issuecomment?: boolean
    error?: boolean
    filledoldestdate?: boolean
    locked?: boolean
    inxforbidden?: boolean
    inputfilecode?: boolean
    maintenanceteamcode?: boolean
  }, ExtArgs["result"]["inducks_issue"]>

  export type inducks_issueSelectScalar = {
    issuecode?: boolean
    issuerangecode?: boolean
    publicationcode?: boolean
    issuenumber?: boolean
    title?: boolean
    size?: boolean
    pages?: boolean
    price?: boolean
    printrun?: boolean
    attached?: boolean
    oldestdate?: boolean
    fullyindexed?: boolean
    issuecomment?: boolean
    error?: boolean
    filledoldestdate?: boolean
    locked?: boolean
    inxforbidden?: boolean
    inputfilecode?: boolean
    maintenanceteamcode?: boolean
  }


  export type $inducks_issuePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_issue"
    objects: {}
    scalars: $Extensions.GetResult<{
      issuecode: string
      issuerangecode: string | null
      publicationcode: string | null
      issuenumber: string | null
      title: string | null
      size: string | null
      pages: string | null
      price: string | null
      printrun: string | null
      attached: string | null
      oldestdate: string | null
      fullyindexed: $Enums.inducks_issue_fullyindexed | null
      issuecomment: string | null
      error: $Enums.inducks_issue_error | null
      filledoldestdate: string | null
      locked: $Enums.inducks_issue_locked | null
      inxforbidden: $Enums.inducks_issue_inxforbidden | null
      inputfilecode: number | null
      maintenanceteamcode: string | null
    }, ExtArgs["result"]["inducks_issue"]>
    composites: {}
  }


  type inducks_issueGetPayload<S extends boolean | null | undefined | inducks_issueDefaultArgs> = $Result.GetResult<Prisma.$inducks_issuePayload, S>

  type inducks_issueCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_issueFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_issueCountAggregateInputType | true
    }

  export interface inducks_issueDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_issue'], meta: { name: 'inducks_issue' } }
    /**
     * Find zero or one Inducks_issue that matches the filter.
     * @param {inducks_issueFindUniqueArgs} args - Arguments to find a Inducks_issue
     * @example
     * // Get one Inducks_issue
     * const inducks_issue = await prisma.inducks_issue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_issueFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issueFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_issueClient<$Result.GetResult<Prisma.$inducks_issuePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_issue that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_issueFindUniqueOrThrowArgs} args - Arguments to find a Inducks_issue
     * @example
     * // Get one Inducks_issue
     * const inducks_issue = await prisma.inducks_issue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_issueFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issueFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_issueClient<$Result.GetResult<Prisma.$inducks_issuePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_issue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issueFindFirstArgs} args - Arguments to find a Inducks_issue
     * @example
     * // Get one Inducks_issue
     * const inducks_issue = await prisma.inducks_issue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_issueFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issueFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_issueClient<$Result.GetResult<Prisma.$inducks_issuePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_issue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issueFindFirstOrThrowArgs} args - Arguments to find a Inducks_issue
     * @example
     * // Get one Inducks_issue
     * const inducks_issue = await prisma.inducks_issue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_issueFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issueFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_issueClient<$Result.GetResult<Prisma.$inducks_issuePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_issues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issueFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_issues
     * const inducks_issues = await prisma.inducks_issue.findMany()
     * 
     * // Get first 10 Inducks_issues
     * const inducks_issues = await prisma.inducks_issue.findMany({ take: 10 })
     * 
     * // Only select the `issuecode`
     * const inducks_issueWithIssuecodeOnly = await prisma.inducks_issue.findMany({ select: { issuecode: true } })
     * 
    **/
    findMany<T extends inducks_issueFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issueFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_issuePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_issue.
     * @param {inducks_issueCreateArgs} args - Arguments to create a Inducks_issue.
     * @example
     * // Create one Inducks_issue
     * const Inducks_issue = await prisma.inducks_issue.create({
     *   data: {
     *     // ... data to create a Inducks_issue
     *   }
     * })
     * 
    **/
    create<T extends inducks_issueCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issueCreateArgs<ExtArgs>>
    ): Prisma__inducks_issueClient<$Result.GetResult<Prisma.$inducks_issuePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_issues.
     *     @param {inducks_issueCreateManyArgs} args - Arguments to create many Inducks_issues.
     *     @example
     *     // Create many Inducks_issues
     *     const inducks_issue = await prisma.inducks_issue.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_issueCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issueCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_issue.
     * @param {inducks_issueDeleteArgs} args - Arguments to delete one Inducks_issue.
     * @example
     * // Delete one Inducks_issue
     * const Inducks_issue = await prisma.inducks_issue.delete({
     *   where: {
     *     // ... filter to delete one Inducks_issue
     *   }
     * })
     * 
    **/
    delete<T extends inducks_issueDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issueDeleteArgs<ExtArgs>>
    ): Prisma__inducks_issueClient<$Result.GetResult<Prisma.$inducks_issuePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_issue.
     * @param {inducks_issueUpdateArgs} args - Arguments to update one Inducks_issue.
     * @example
     * // Update one Inducks_issue
     * const inducks_issue = await prisma.inducks_issue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_issueUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issueUpdateArgs<ExtArgs>>
    ): Prisma__inducks_issueClient<$Result.GetResult<Prisma.$inducks_issuePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_issues.
     * @param {inducks_issueDeleteManyArgs} args - Arguments to filter Inducks_issues to delete.
     * @example
     * // Delete a few Inducks_issues
     * const { count } = await prisma.inducks_issue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_issueDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issueDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_issues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_issues
     * const inducks_issue = await prisma.inducks_issue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_issueUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issueUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_issue.
     * @param {inducks_issueUpsertArgs} args - Arguments to update or create a Inducks_issue.
     * @example
     * // Update or create a Inducks_issue
     * const inducks_issue = await prisma.inducks_issue.upsert({
     *   create: {
     *     // ... data to create a Inducks_issue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_issue we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_issueUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issueUpsertArgs<ExtArgs>>
    ): Prisma__inducks_issueClient<$Result.GetResult<Prisma.$inducks_issuePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_issues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issueCountArgs} args - Arguments to filter Inducks_issues to count.
     * @example
     * // Count the number of Inducks_issues
     * const count = await prisma.inducks_issue.count({
     *   where: {
     *     // ... the filter for the Inducks_issues we want to count
     *   }
     * })
    **/
    count<T extends inducks_issueCountArgs>(
      args?: Subset<T, inducks_issueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_issueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_issue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_issueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_issueAggregateArgs>(args: Subset<T, Inducks_issueAggregateArgs>): Prisma.PrismaPromise<GetInducks_issueAggregateType<T>>

    /**
     * Group by Inducks_issue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_issueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_issueGroupByArgs['orderBy'] }
        : { orderBy?: inducks_issueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_issueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_issueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_issue model
   */
  readonly fields: inducks_issueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_issue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_issueClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_issue model
   */ 
  interface inducks_issueFieldRefs {
    readonly issuecode: FieldRef<"inducks_issue", 'String'>
    readonly issuerangecode: FieldRef<"inducks_issue", 'String'>
    readonly publicationcode: FieldRef<"inducks_issue", 'String'>
    readonly issuenumber: FieldRef<"inducks_issue", 'String'>
    readonly title: FieldRef<"inducks_issue", 'String'>
    readonly size: FieldRef<"inducks_issue", 'String'>
    readonly pages: FieldRef<"inducks_issue", 'String'>
    readonly price: FieldRef<"inducks_issue", 'String'>
    readonly printrun: FieldRef<"inducks_issue", 'String'>
    readonly attached: FieldRef<"inducks_issue", 'String'>
    readonly oldestdate: FieldRef<"inducks_issue", 'String'>
    readonly fullyindexed: FieldRef<"inducks_issue", 'inducks_issue_fullyindexed'>
    readonly issuecomment: FieldRef<"inducks_issue", 'String'>
    readonly error: FieldRef<"inducks_issue", 'inducks_issue_error'>
    readonly filledoldestdate: FieldRef<"inducks_issue", 'String'>
    readonly locked: FieldRef<"inducks_issue", 'inducks_issue_locked'>
    readonly inxforbidden: FieldRef<"inducks_issue", 'inducks_issue_inxforbidden'>
    readonly inputfilecode: FieldRef<"inducks_issue", 'Int'>
    readonly maintenanceteamcode: FieldRef<"inducks_issue", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_issue findUnique
   */
  export type inducks_issueFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issue
     */
    select?: inducks_issueSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issue to fetch.
     */
    where: inducks_issueWhereUniqueInput
  }


  /**
   * inducks_issue findUniqueOrThrow
   */
  export type inducks_issueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issue
     */
    select?: inducks_issueSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issue to fetch.
     */
    where: inducks_issueWhereUniqueInput
  }


  /**
   * inducks_issue findFirst
   */
  export type inducks_issueFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issue
     */
    select?: inducks_issueSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issue to fetch.
     */
    where?: inducks_issueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_issues to fetch.
     */
    orderBy?: inducks_issueOrderByWithRelationInput | inducks_issueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_issues.
     */
    cursor?: inducks_issueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_issues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_issues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_issues.
     */
    distinct?: Inducks_issueScalarFieldEnum | Inducks_issueScalarFieldEnum[]
  }


  /**
   * inducks_issue findFirstOrThrow
   */
  export type inducks_issueFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issue
     */
    select?: inducks_issueSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issue to fetch.
     */
    where?: inducks_issueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_issues to fetch.
     */
    orderBy?: inducks_issueOrderByWithRelationInput | inducks_issueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_issues.
     */
    cursor?: inducks_issueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_issues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_issues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_issues.
     */
    distinct?: Inducks_issueScalarFieldEnum | Inducks_issueScalarFieldEnum[]
  }


  /**
   * inducks_issue findMany
   */
  export type inducks_issueFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issue
     */
    select?: inducks_issueSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issues to fetch.
     */
    where?: inducks_issueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_issues to fetch.
     */
    orderBy?: inducks_issueOrderByWithRelationInput | inducks_issueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_issues.
     */
    cursor?: inducks_issueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_issues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_issues.
     */
    skip?: number
    distinct?: Inducks_issueScalarFieldEnum | Inducks_issueScalarFieldEnum[]
  }


  /**
   * inducks_issue create
   */
  export type inducks_issueCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issue
     */
    select?: inducks_issueSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_issue.
     */
    data: XOR<inducks_issueCreateInput, inducks_issueUncheckedCreateInput>
  }


  /**
   * inducks_issue createMany
   */
  export type inducks_issueCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_issues.
     */
    data: inducks_issueCreateManyInput | inducks_issueCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_issue update
   */
  export type inducks_issueUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issue
     */
    select?: inducks_issueSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_issue.
     */
    data: XOR<inducks_issueUpdateInput, inducks_issueUncheckedUpdateInput>
    /**
     * Choose, which inducks_issue to update.
     */
    where: inducks_issueWhereUniqueInput
  }


  /**
   * inducks_issue updateMany
   */
  export type inducks_issueUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_issues.
     */
    data: XOR<inducks_issueUpdateManyMutationInput, inducks_issueUncheckedUpdateManyInput>
    /**
     * Filter which inducks_issues to update
     */
    where?: inducks_issueWhereInput
  }


  /**
   * inducks_issue upsert
   */
  export type inducks_issueUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issue
     */
    select?: inducks_issueSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_issue to update in case it exists.
     */
    where: inducks_issueWhereUniqueInput
    /**
     * In case the inducks_issue found by the `where` argument doesn't exist, create a new inducks_issue with this data.
     */
    create: XOR<inducks_issueCreateInput, inducks_issueUncheckedCreateInput>
    /**
     * In case the inducks_issue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_issueUpdateInput, inducks_issueUncheckedUpdateInput>
  }


  /**
   * inducks_issue delete
   */
  export type inducks_issueDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issue
     */
    select?: inducks_issueSelect<ExtArgs> | null
    /**
     * Filter which inducks_issue to delete.
     */
    where: inducks_issueWhereUniqueInput
  }


  /**
   * inducks_issue deleteMany
   */
  export type inducks_issueDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_issues to delete
     */
    where?: inducks_issueWhereInput
  }


  /**
   * inducks_issue without action
   */
  export type inducks_issueDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issue
     */
    select?: inducks_issueSelect<ExtArgs> | null
  }



  /**
   * Model inducks_issuecollecting
   */

  export type AggregateInducks_issuecollecting = {
    _count: Inducks_issuecollectingCountAggregateOutputType | null
    _min: Inducks_issuecollectingMinAggregateOutputType | null
    _max: Inducks_issuecollectingMaxAggregateOutputType | null
  }

  export type Inducks_issuecollectingMinAggregateOutputType = {
    collectingissuecode: string | null
    collectedissuecode: string | null
  }

  export type Inducks_issuecollectingMaxAggregateOutputType = {
    collectingissuecode: string | null
    collectedissuecode: string | null
  }

  export type Inducks_issuecollectingCountAggregateOutputType = {
    collectingissuecode: number
    collectedissuecode: number
    _all: number
  }


  export type Inducks_issuecollectingMinAggregateInputType = {
    collectingissuecode?: true
    collectedissuecode?: true
  }

  export type Inducks_issuecollectingMaxAggregateInputType = {
    collectingissuecode?: true
    collectedissuecode?: true
  }

  export type Inducks_issuecollectingCountAggregateInputType = {
    collectingissuecode?: true
    collectedissuecode?: true
    _all?: true
  }

  export type Inducks_issuecollectingAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_issuecollecting to aggregate.
     */
    where?: inducks_issuecollectingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_issuecollectings to fetch.
     */
    orderBy?: inducks_issuecollectingOrderByWithRelationInput | inducks_issuecollectingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_issuecollectingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_issuecollectings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_issuecollectings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_issuecollectings
    **/
    _count?: true | Inducks_issuecollectingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_issuecollectingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_issuecollectingMaxAggregateInputType
  }

  export type GetInducks_issuecollectingAggregateType<T extends Inducks_issuecollectingAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_issuecollecting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_issuecollecting[P]>
      : GetScalarType<T[P], AggregateInducks_issuecollecting[P]>
  }




  export type inducks_issuecollectingGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_issuecollectingWhereInput
    orderBy?: inducks_issuecollectingOrderByWithAggregationInput | inducks_issuecollectingOrderByWithAggregationInput[]
    by: Inducks_issuecollectingScalarFieldEnum[] | Inducks_issuecollectingScalarFieldEnum
    having?: inducks_issuecollectingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_issuecollectingCountAggregateInputType | true
    _min?: Inducks_issuecollectingMinAggregateInputType
    _max?: Inducks_issuecollectingMaxAggregateInputType
  }

  export type Inducks_issuecollectingGroupByOutputType = {
    collectingissuecode: string
    collectedissuecode: string
    _count: Inducks_issuecollectingCountAggregateOutputType | null
    _min: Inducks_issuecollectingMinAggregateOutputType | null
    _max: Inducks_issuecollectingMaxAggregateOutputType | null
  }

  type GetInducks_issuecollectingGroupByPayload<T extends inducks_issuecollectingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_issuecollectingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_issuecollectingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_issuecollectingGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_issuecollectingGroupByOutputType[P]>
        }
      >
    >


  export type inducks_issuecollectingSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    collectingissuecode?: boolean
    collectedissuecode?: boolean
  }, ExtArgs["result"]["inducks_issuecollecting"]>

  export type inducks_issuecollectingSelectScalar = {
    collectingissuecode?: boolean
    collectedissuecode?: boolean
  }


  export type $inducks_issuecollectingPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_issuecollecting"
    objects: {}
    scalars: $Extensions.GetResult<{
      collectingissuecode: string
      collectedissuecode: string
    }, ExtArgs["result"]["inducks_issuecollecting"]>
    composites: {}
  }


  type inducks_issuecollectingGetPayload<S extends boolean | null | undefined | inducks_issuecollectingDefaultArgs> = $Result.GetResult<Prisma.$inducks_issuecollectingPayload, S>

  type inducks_issuecollectingCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_issuecollectingFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_issuecollectingCountAggregateInputType | true
    }

  export interface inducks_issuecollectingDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_issuecollecting'], meta: { name: 'inducks_issuecollecting' } }
    /**
     * Find zero or one Inducks_issuecollecting that matches the filter.
     * @param {inducks_issuecollectingFindUniqueArgs} args - Arguments to find a Inducks_issuecollecting
     * @example
     * // Get one Inducks_issuecollecting
     * const inducks_issuecollecting = await prisma.inducks_issuecollecting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_issuecollectingFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issuecollectingFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_issuecollectingClient<$Result.GetResult<Prisma.$inducks_issuecollectingPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_issuecollecting that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_issuecollectingFindUniqueOrThrowArgs} args - Arguments to find a Inducks_issuecollecting
     * @example
     * // Get one Inducks_issuecollecting
     * const inducks_issuecollecting = await prisma.inducks_issuecollecting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_issuecollectingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issuecollectingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_issuecollectingClient<$Result.GetResult<Prisma.$inducks_issuecollectingPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_issuecollecting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issuecollectingFindFirstArgs} args - Arguments to find a Inducks_issuecollecting
     * @example
     * // Get one Inducks_issuecollecting
     * const inducks_issuecollecting = await prisma.inducks_issuecollecting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_issuecollectingFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issuecollectingFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_issuecollectingClient<$Result.GetResult<Prisma.$inducks_issuecollectingPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_issuecollecting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issuecollectingFindFirstOrThrowArgs} args - Arguments to find a Inducks_issuecollecting
     * @example
     * // Get one Inducks_issuecollecting
     * const inducks_issuecollecting = await prisma.inducks_issuecollecting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_issuecollectingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issuecollectingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_issuecollectingClient<$Result.GetResult<Prisma.$inducks_issuecollectingPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_issuecollectings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issuecollectingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_issuecollectings
     * const inducks_issuecollectings = await prisma.inducks_issuecollecting.findMany()
     * 
     * // Get first 10 Inducks_issuecollectings
     * const inducks_issuecollectings = await prisma.inducks_issuecollecting.findMany({ take: 10 })
     * 
     * // Only select the `collectingissuecode`
     * const inducks_issuecollectingWithCollectingissuecodeOnly = await prisma.inducks_issuecollecting.findMany({ select: { collectingissuecode: true } })
     * 
    **/
    findMany<T extends inducks_issuecollectingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issuecollectingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_issuecollectingPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_issuecollecting.
     * @param {inducks_issuecollectingCreateArgs} args - Arguments to create a Inducks_issuecollecting.
     * @example
     * // Create one Inducks_issuecollecting
     * const Inducks_issuecollecting = await prisma.inducks_issuecollecting.create({
     *   data: {
     *     // ... data to create a Inducks_issuecollecting
     *   }
     * })
     * 
    **/
    create<T extends inducks_issuecollectingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issuecollectingCreateArgs<ExtArgs>>
    ): Prisma__inducks_issuecollectingClient<$Result.GetResult<Prisma.$inducks_issuecollectingPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_issuecollectings.
     *     @param {inducks_issuecollectingCreateManyArgs} args - Arguments to create many Inducks_issuecollectings.
     *     @example
     *     // Create many Inducks_issuecollectings
     *     const inducks_issuecollecting = await prisma.inducks_issuecollecting.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_issuecollectingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issuecollectingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_issuecollecting.
     * @param {inducks_issuecollectingDeleteArgs} args - Arguments to delete one Inducks_issuecollecting.
     * @example
     * // Delete one Inducks_issuecollecting
     * const Inducks_issuecollecting = await prisma.inducks_issuecollecting.delete({
     *   where: {
     *     // ... filter to delete one Inducks_issuecollecting
     *   }
     * })
     * 
    **/
    delete<T extends inducks_issuecollectingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issuecollectingDeleteArgs<ExtArgs>>
    ): Prisma__inducks_issuecollectingClient<$Result.GetResult<Prisma.$inducks_issuecollectingPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_issuecollecting.
     * @param {inducks_issuecollectingUpdateArgs} args - Arguments to update one Inducks_issuecollecting.
     * @example
     * // Update one Inducks_issuecollecting
     * const inducks_issuecollecting = await prisma.inducks_issuecollecting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_issuecollectingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issuecollectingUpdateArgs<ExtArgs>>
    ): Prisma__inducks_issuecollectingClient<$Result.GetResult<Prisma.$inducks_issuecollectingPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_issuecollectings.
     * @param {inducks_issuecollectingDeleteManyArgs} args - Arguments to filter Inducks_issuecollectings to delete.
     * @example
     * // Delete a few Inducks_issuecollectings
     * const { count } = await prisma.inducks_issuecollecting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_issuecollectingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issuecollectingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_issuecollectings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issuecollectingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_issuecollectings
     * const inducks_issuecollecting = await prisma.inducks_issuecollecting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_issuecollectingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issuecollectingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_issuecollecting.
     * @param {inducks_issuecollectingUpsertArgs} args - Arguments to update or create a Inducks_issuecollecting.
     * @example
     * // Update or create a Inducks_issuecollecting
     * const inducks_issuecollecting = await prisma.inducks_issuecollecting.upsert({
     *   create: {
     *     // ... data to create a Inducks_issuecollecting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_issuecollecting we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_issuecollectingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issuecollectingUpsertArgs<ExtArgs>>
    ): Prisma__inducks_issuecollectingClient<$Result.GetResult<Prisma.$inducks_issuecollectingPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_issuecollectings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issuecollectingCountArgs} args - Arguments to filter Inducks_issuecollectings to count.
     * @example
     * // Count the number of Inducks_issuecollectings
     * const count = await prisma.inducks_issuecollecting.count({
     *   where: {
     *     // ... the filter for the Inducks_issuecollectings we want to count
     *   }
     * })
    **/
    count<T extends inducks_issuecollectingCountArgs>(
      args?: Subset<T, inducks_issuecollectingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_issuecollectingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_issuecollecting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_issuecollectingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_issuecollectingAggregateArgs>(args: Subset<T, Inducks_issuecollectingAggregateArgs>): Prisma.PrismaPromise<GetInducks_issuecollectingAggregateType<T>>

    /**
     * Group by Inducks_issuecollecting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issuecollectingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_issuecollectingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_issuecollectingGroupByArgs['orderBy'] }
        : { orderBy?: inducks_issuecollectingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_issuecollectingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_issuecollectingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_issuecollecting model
   */
  readonly fields: inducks_issuecollectingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_issuecollecting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_issuecollectingClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_issuecollecting model
   */ 
  interface inducks_issuecollectingFieldRefs {
    readonly collectingissuecode: FieldRef<"inducks_issuecollecting", 'String'>
    readonly collectedissuecode: FieldRef<"inducks_issuecollecting", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_issuecollecting findUnique
   */
  export type inducks_issuecollectingFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuecollecting
     */
    select?: inducks_issuecollectingSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issuecollecting to fetch.
     */
    where: inducks_issuecollectingWhereUniqueInput
  }


  /**
   * inducks_issuecollecting findUniqueOrThrow
   */
  export type inducks_issuecollectingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuecollecting
     */
    select?: inducks_issuecollectingSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issuecollecting to fetch.
     */
    where: inducks_issuecollectingWhereUniqueInput
  }


  /**
   * inducks_issuecollecting findFirst
   */
  export type inducks_issuecollectingFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuecollecting
     */
    select?: inducks_issuecollectingSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issuecollecting to fetch.
     */
    where?: inducks_issuecollectingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_issuecollectings to fetch.
     */
    orderBy?: inducks_issuecollectingOrderByWithRelationInput | inducks_issuecollectingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_issuecollectings.
     */
    cursor?: inducks_issuecollectingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_issuecollectings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_issuecollectings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_issuecollectings.
     */
    distinct?: Inducks_issuecollectingScalarFieldEnum | Inducks_issuecollectingScalarFieldEnum[]
  }


  /**
   * inducks_issuecollecting findFirstOrThrow
   */
  export type inducks_issuecollectingFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuecollecting
     */
    select?: inducks_issuecollectingSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issuecollecting to fetch.
     */
    where?: inducks_issuecollectingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_issuecollectings to fetch.
     */
    orderBy?: inducks_issuecollectingOrderByWithRelationInput | inducks_issuecollectingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_issuecollectings.
     */
    cursor?: inducks_issuecollectingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_issuecollectings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_issuecollectings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_issuecollectings.
     */
    distinct?: Inducks_issuecollectingScalarFieldEnum | Inducks_issuecollectingScalarFieldEnum[]
  }


  /**
   * inducks_issuecollecting findMany
   */
  export type inducks_issuecollectingFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuecollecting
     */
    select?: inducks_issuecollectingSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issuecollectings to fetch.
     */
    where?: inducks_issuecollectingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_issuecollectings to fetch.
     */
    orderBy?: inducks_issuecollectingOrderByWithRelationInput | inducks_issuecollectingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_issuecollectings.
     */
    cursor?: inducks_issuecollectingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_issuecollectings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_issuecollectings.
     */
    skip?: number
    distinct?: Inducks_issuecollectingScalarFieldEnum | Inducks_issuecollectingScalarFieldEnum[]
  }


  /**
   * inducks_issuecollecting create
   */
  export type inducks_issuecollectingCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuecollecting
     */
    select?: inducks_issuecollectingSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_issuecollecting.
     */
    data: XOR<inducks_issuecollectingCreateInput, inducks_issuecollectingUncheckedCreateInput>
  }


  /**
   * inducks_issuecollecting createMany
   */
  export type inducks_issuecollectingCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_issuecollectings.
     */
    data: inducks_issuecollectingCreateManyInput | inducks_issuecollectingCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_issuecollecting update
   */
  export type inducks_issuecollectingUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuecollecting
     */
    select?: inducks_issuecollectingSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_issuecollecting.
     */
    data: XOR<inducks_issuecollectingUpdateInput, inducks_issuecollectingUncheckedUpdateInput>
    /**
     * Choose, which inducks_issuecollecting to update.
     */
    where: inducks_issuecollectingWhereUniqueInput
  }


  /**
   * inducks_issuecollecting updateMany
   */
  export type inducks_issuecollectingUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_issuecollectings.
     */
    data: XOR<inducks_issuecollectingUpdateManyMutationInput, inducks_issuecollectingUncheckedUpdateManyInput>
    /**
     * Filter which inducks_issuecollectings to update
     */
    where?: inducks_issuecollectingWhereInput
  }


  /**
   * inducks_issuecollecting upsert
   */
  export type inducks_issuecollectingUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuecollecting
     */
    select?: inducks_issuecollectingSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_issuecollecting to update in case it exists.
     */
    where: inducks_issuecollectingWhereUniqueInput
    /**
     * In case the inducks_issuecollecting found by the `where` argument doesn't exist, create a new inducks_issuecollecting with this data.
     */
    create: XOR<inducks_issuecollectingCreateInput, inducks_issuecollectingUncheckedCreateInput>
    /**
     * In case the inducks_issuecollecting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_issuecollectingUpdateInput, inducks_issuecollectingUncheckedUpdateInput>
  }


  /**
   * inducks_issuecollecting delete
   */
  export type inducks_issuecollectingDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuecollecting
     */
    select?: inducks_issuecollectingSelect<ExtArgs> | null
    /**
     * Filter which inducks_issuecollecting to delete.
     */
    where: inducks_issuecollectingWhereUniqueInput
  }


  /**
   * inducks_issuecollecting deleteMany
   */
  export type inducks_issuecollectingDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_issuecollectings to delete
     */
    where?: inducks_issuecollectingWhereInput
  }


  /**
   * inducks_issuecollecting without action
   */
  export type inducks_issuecollectingDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuecollecting
     */
    select?: inducks_issuecollectingSelect<ExtArgs> | null
  }



  /**
   * Model inducks_issuedate
   */

  export type AggregateInducks_issuedate = {
    _count: Inducks_issuedateCountAggregateOutputType | null
    _min: Inducks_issuedateMinAggregateOutputType | null
    _max: Inducks_issuedateMaxAggregateOutputType | null
  }

  export type Inducks_issuedateMinAggregateOutputType = {
    issuecode: string | null
    date: string | null
    kindofdate: string | null
    doubt: $Enums.inducks_issuedate_doubt | null
  }

  export type Inducks_issuedateMaxAggregateOutputType = {
    issuecode: string | null
    date: string | null
    kindofdate: string | null
    doubt: $Enums.inducks_issuedate_doubt | null
  }

  export type Inducks_issuedateCountAggregateOutputType = {
    issuecode: number
    date: number
    kindofdate: number
    doubt: number
    _all: number
  }


  export type Inducks_issuedateMinAggregateInputType = {
    issuecode?: true
    date?: true
    kindofdate?: true
    doubt?: true
  }

  export type Inducks_issuedateMaxAggregateInputType = {
    issuecode?: true
    date?: true
    kindofdate?: true
    doubt?: true
  }

  export type Inducks_issuedateCountAggregateInputType = {
    issuecode?: true
    date?: true
    kindofdate?: true
    doubt?: true
    _all?: true
  }

  export type Inducks_issuedateAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_issuedate to aggregate.
     */
    where?: inducks_issuedateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_issuedates to fetch.
     */
    orderBy?: inducks_issuedateOrderByWithRelationInput | inducks_issuedateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_issuedateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_issuedates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_issuedates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_issuedates
    **/
    _count?: true | Inducks_issuedateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_issuedateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_issuedateMaxAggregateInputType
  }

  export type GetInducks_issuedateAggregateType<T extends Inducks_issuedateAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_issuedate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_issuedate[P]>
      : GetScalarType<T[P], AggregateInducks_issuedate[P]>
  }




  export type inducks_issuedateGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_issuedateWhereInput
    orderBy?: inducks_issuedateOrderByWithAggregationInput | inducks_issuedateOrderByWithAggregationInput[]
    by: Inducks_issuedateScalarFieldEnum[] | Inducks_issuedateScalarFieldEnum
    having?: inducks_issuedateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_issuedateCountAggregateInputType | true
    _min?: Inducks_issuedateMinAggregateInputType
    _max?: Inducks_issuedateMaxAggregateInputType
  }

  export type Inducks_issuedateGroupByOutputType = {
    issuecode: string
    date: string
    kindofdate: string | null
    doubt: $Enums.inducks_issuedate_doubt | null
    _count: Inducks_issuedateCountAggregateOutputType | null
    _min: Inducks_issuedateMinAggregateOutputType | null
    _max: Inducks_issuedateMaxAggregateOutputType | null
  }

  type GetInducks_issuedateGroupByPayload<T extends inducks_issuedateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_issuedateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_issuedateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_issuedateGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_issuedateGroupByOutputType[P]>
        }
      >
    >


  export type inducks_issuedateSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    issuecode?: boolean
    date?: boolean
    kindofdate?: boolean
    doubt?: boolean
  }, ExtArgs["result"]["inducks_issuedate"]>

  export type inducks_issuedateSelectScalar = {
    issuecode?: boolean
    date?: boolean
    kindofdate?: boolean
    doubt?: boolean
  }


  export type $inducks_issuedatePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_issuedate"
    objects: {}
    scalars: $Extensions.GetResult<{
      issuecode: string
      date: string
      kindofdate: string | null
      doubt: $Enums.inducks_issuedate_doubt | null
    }, ExtArgs["result"]["inducks_issuedate"]>
    composites: {}
  }


  type inducks_issuedateGetPayload<S extends boolean | null | undefined | inducks_issuedateDefaultArgs> = $Result.GetResult<Prisma.$inducks_issuedatePayload, S>

  type inducks_issuedateCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_issuedateFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_issuedateCountAggregateInputType | true
    }

  export interface inducks_issuedateDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_issuedate'], meta: { name: 'inducks_issuedate' } }
    /**
     * Find zero or one Inducks_issuedate that matches the filter.
     * @param {inducks_issuedateFindUniqueArgs} args - Arguments to find a Inducks_issuedate
     * @example
     * // Get one Inducks_issuedate
     * const inducks_issuedate = await prisma.inducks_issuedate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_issuedateFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issuedateFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_issuedateClient<$Result.GetResult<Prisma.$inducks_issuedatePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_issuedate that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_issuedateFindUniqueOrThrowArgs} args - Arguments to find a Inducks_issuedate
     * @example
     * // Get one Inducks_issuedate
     * const inducks_issuedate = await prisma.inducks_issuedate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_issuedateFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issuedateFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_issuedateClient<$Result.GetResult<Prisma.$inducks_issuedatePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_issuedate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issuedateFindFirstArgs} args - Arguments to find a Inducks_issuedate
     * @example
     * // Get one Inducks_issuedate
     * const inducks_issuedate = await prisma.inducks_issuedate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_issuedateFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issuedateFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_issuedateClient<$Result.GetResult<Prisma.$inducks_issuedatePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_issuedate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issuedateFindFirstOrThrowArgs} args - Arguments to find a Inducks_issuedate
     * @example
     * // Get one Inducks_issuedate
     * const inducks_issuedate = await prisma.inducks_issuedate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_issuedateFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issuedateFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_issuedateClient<$Result.GetResult<Prisma.$inducks_issuedatePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_issuedates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issuedateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_issuedates
     * const inducks_issuedates = await prisma.inducks_issuedate.findMany()
     * 
     * // Get first 10 Inducks_issuedates
     * const inducks_issuedates = await prisma.inducks_issuedate.findMany({ take: 10 })
     * 
     * // Only select the `issuecode`
     * const inducks_issuedateWithIssuecodeOnly = await prisma.inducks_issuedate.findMany({ select: { issuecode: true } })
     * 
    **/
    findMany<T extends inducks_issuedateFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issuedateFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_issuedatePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_issuedate.
     * @param {inducks_issuedateCreateArgs} args - Arguments to create a Inducks_issuedate.
     * @example
     * // Create one Inducks_issuedate
     * const Inducks_issuedate = await prisma.inducks_issuedate.create({
     *   data: {
     *     // ... data to create a Inducks_issuedate
     *   }
     * })
     * 
    **/
    create<T extends inducks_issuedateCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issuedateCreateArgs<ExtArgs>>
    ): Prisma__inducks_issuedateClient<$Result.GetResult<Prisma.$inducks_issuedatePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_issuedates.
     *     @param {inducks_issuedateCreateManyArgs} args - Arguments to create many Inducks_issuedates.
     *     @example
     *     // Create many Inducks_issuedates
     *     const inducks_issuedate = await prisma.inducks_issuedate.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_issuedateCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issuedateCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_issuedate.
     * @param {inducks_issuedateDeleteArgs} args - Arguments to delete one Inducks_issuedate.
     * @example
     * // Delete one Inducks_issuedate
     * const Inducks_issuedate = await prisma.inducks_issuedate.delete({
     *   where: {
     *     // ... filter to delete one Inducks_issuedate
     *   }
     * })
     * 
    **/
    delete<T extends inducks_issuedateDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issuedateDeleteArgs<ExtArgs>>
    ): Prisma__inducks_issuedateClient<$Result.GetResult<Prisma.$inducks_issuedatePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_issuedate.
     * @param {inducks_issuedateUpdateArgs} args - Arguments to update one Inducks_issuedate.
     * @example
     * // Update one Inducks_issuedate
     * const inducks_issuedate = await prisma.inducks_issuedate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_issuedateUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issuedateUpdateArgs<ExtArgs>>
    ): Prisma__inducks_issuedateClient<$Result.GetResult<Prisma.$inducks_issuedatePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_issuedates.
     * @param {inducks_issuedateDeleteManyArgs} args - Arguments to filter Inducks_issuedates to delete.
     * @example
     * // Delete a few Inducks_issuedates
     * const { count } = await prisma.inducks_issuedate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_issuedateDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issuedateDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_issuedates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issuedateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_issuedates
     * const inducks_issuedate = await prisma.inducks_issuedate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_issuedateUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issuedateUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_issuedate.
     * @param {inducks_issuedateUpsertArgs} args - Arguments to update or create a Inducks_issuedate.
     * @example
     * // Update or create a Inducks_issuedate
     * const inducks_issuedate = await prisma.inducks_issuedate.upsert({
     *   create: {
     *     // ... data to create a Inducks_issuedate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_issuedate we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_issuedateUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issuedateUpsertArgs<ExtArgs>>
    ): Prisma__inducks_issuedateClient<$Result.GetResult<Prisma.$inducks_issuedatePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_issuedates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issuedateCountArgs} args - Arguments to filter Inducks_issuedates to count.
     * @example
     * // Count the number of Inducks_issuedates
     * const count = await prisma.inducks_issuedate.count({
     *   where: {
     *     // ... the filter for the Inducks_issuedates we want to count
     *   }
     * })
    **/
    count<T extends inducks_issuedateCountArgs>(
      args?: Subset<T, inducks_issuedateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_issuedateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_issuedate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_issuedateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_issuedateAggregateArgs>(args: Subset<T, Inducks_issuedateAggregateArgs>): Prisma.PrismaPromise<GetInducks_issuedateAggregateType<T>>

    /**
     * Group by Inducks_issuedate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issuedateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_issuedateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_issuedateGroupByArgs['orderBy'] }
        : { orderBy?: inducks_issuedateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_issuedateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_issuedateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_issuedate model
   */
  readonly fields: inducks_issuedateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_issuedate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_issuedateClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_issuedate model
   */ 
  interface inducks_issuedateFieldRefs {
    readonly issuecode: FieldRef<"inducks_issuedate", 'String'>
    readonly date: FieldRef<"inducks_issuedate", 'String'>
    readonly kindofdate: FieldRef<"inducks_issuedate", 'String'>
    readonly doubt: FieldRef<"inducks_issuedate", 'inducks_issuedate_doubt'>
  }
    

  // Custom InputTypes

  /**
   * inducks_issuedate findUnique
   */
  export type inducks_issuedateFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuedate
     */
    select?: inducks_issuedateSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issuedate to fetch.
     */
    where: inducks_issuedateWhereUniqueInput
  }


  /**
   * inducks_issuedate findUniqueOrThrow
   */
  export type inducks_issuedateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuedate
     */
    select?: inducks_issuedateSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issuedate to fetch.
     */
    where: inducks_issuedateWhereUniqueInput
  }


  /**
   * inducks_issuedate findFirst
   */
  export type inducks_issuedateFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuedate
     */
    select?: inducks_issuedateSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issuedate to fetch.
     */
    where?: inducks_issuedateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_issuedates to fetch.
     */
    orderBy?: inducks_issuedateOrderByWithRelationInput | inducks_issuedateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_issuedates.
     */
    cursor?: inducks_issuedateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_issuedates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_issuedates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_issuedates.
     */
    distinct?: Inducks_issuedateScalarFieldEnum | Inducks_issuedateScalarFieldEnum[]
  }


  /**
   * inducks_issuedate findFirstOrThrow
   */
  export type inducks_issuedateFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuedate
     */
    select?: inducks_issuedateSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issuedate to fetch.
     */
    where?: inducks_issuedateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_issuedates to fetch.
     */
    orderBy?: inducks_issuedateOrderByWithRelationInput | inducks_issuedateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_issuedates.
     */
    cursor?: inducks_issuedateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_issuedates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_issuedates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_issuedates.
     */
    distinct?: Inducks_issuedateScalarFieldEnum | Inducks_issuedateScalarFieldEnum[]
  }


  /**
   * inducks_issuedate findMany
   */
  export type inducks_issuedateFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuedate
     */
    select?: inducks_issuedateSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issuedates to fetch.
     */
    where?: inducks_issuedateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_issuedates to fetch.
     */
    orderBy?: inducks_issuedateOrderByWithRelationInput | inducks_issuedateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_issuedates.
     */
    cursor?: inducks_issuedateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_issuedates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_issuedates.
     */
    skip?: number
    distinct?: Inducks_issuedateScalarFieldEnum | Inducks_issuedateScalarFieldEnum[]
  }


  /**
   * inducks_issuedate create
   */
  export type inducks_issuedateCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuedate
     */
    select?: inducks_issuedateSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_issuedate.
     */
    data: XOR<inducks_issuedateCreateInput, inducks_issuedateUncheckedCreateInput>
  }


  /**
   * inducks_issuedate createMany
   */
  export type inducks_issuedateCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_issuedates.
     */
    data: inducks_issuedateCreateManyInput | inducks_issuedateCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_issuedate update
   */
  export type inducks_issuedateUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuedate
     */
    select?: inducks_issuedateSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_issuedate.
     */
    data: XOR<inducks_issuedateUpdateInput, inducks_issuedateUncheckedUpdateInput>
    /**
     * Choose, which inducks_issuedate to update.
     */
    where: inducks_issuedateWhereUniqueInput
  }


  /**
   * inducks_issuedate updateMany
   */
  export type inducks_issuedateUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_issuedates.
     */
    data: XOR<inducks_issuedateUpdateManyMutationInput, inducks_issuedateUncheckedUpdateManyInput>
    /**
     * Filter which inducks_issuedates to update
     */
    where?: inducks_issuedateWhereInput
  }


  /**
   * inducks_issuedate upsert
   */
  export type inducks_issuedateUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuedate
     */
    select?: inducks_issuedateSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_issuedate to update in case it exists.
     */
    where: inducks_issuedateWhereUniqueInput
    /**
     * In case the inducks_issuedate found by the `where` argument doesn't exist, create a new inducks_issuedate with this data.
     */
    create: XOR<inducks_issuedateCreateInput, inducks_issuedateUncheckedCreateInput>
    /**
     * In case the inducks_issuedate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_issuedateUpdateInput, inducks_issuedateUncheckedUpdateInput>
  }


  /**
   * inducks_issuedate delete
   */
  export type inducks_issuedateDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuedate
     */
    select?: inducks_issuedateSelect<ExtArgs> | null
    /**
     * Filter which inducks_issuedate to delete.
     */
    where: inducks_issuedateWhereUniqueInput
  }


  /**
   * inducks_issuedate deleteMany
   */
  export type inducks_issuedateDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_issuedates to delete
     */
    where?: inducks_issuedateWhereInput
  }


  /**
   * inducks_issuedate without action
   */
  export type inducks_issuedateDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuedate
     */
    select?: inducks_issuedateSelect<ExtArgs> | null
  }



  /**
   * Model inducks_issuejob
   */

  export type AggregateInducks_issuejob = {
    _count: Inducks_issuejobCountAggregateOutputType | null
    _min: Inducks_issuejobMinAggregateOutputType | null
    _max: Inducks_issuejobMaxAggregateOutputType | null
  }

  export type Inducks_issuejobMinAggregateOutputType = {
    issuecode: string | null
    personcode: string | null
    inxtransletcol: string | null
    issuejobcomment: string | null
    doubt: $Enums.inducks_issuejob_doubt | null
  }

  export type Inducks_issuejobMaxAggregateOutputType = {
    issuecode: string | null
    personcode: string | null
    inxtransletcol: string | null
    issuejobcomment: string | null
    doubt: $Enums.inducks_issuejob_doubt | null
  }

  export type Inducks_issuejobCountAggregateOutputType = {
    issuecode: number
    personcode: number
    inxtransletcol: number
    issuejobcomment: number
    doubt: number
    _all: number
  }


  export type Inducks_issuejobMinAggregateInputType = {
    issuecode?: true
    personcode?: true
    inxtransletcol?: true
    issuejobcomment?: true
    doubt?: true
  }

  export type Inducks_issuejobMaxAggregateInputType = {
    issuecode?: true
    personcode?: true
    inxtransletcol?: true
    issuejobcomment?: true
    doubt?: true
  }

  export type Inducks_issuejobCountAggregateInputType = {
    issuecode?: true
    personcode?: true
    inxtransletcol?: true
    issuejobcomment?: true
    doubt?: true
    _all?: true
  }

  export type Inducks_issuejobAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_issuejob to aggregate.
     */
    where?: inducks_issuejobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_issuejobs to fetch.
     */
    orderBy?: inducks_issuejobOrderByWithRelationInput | inducks_issuejobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_issuejobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_issuejobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_issuejobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_issuejobs
    **/
    _count?: true | Inducks_issuejobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_issuejobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_issuejobMaxAggregateInputType
  }

  export type GetInducks_issuejobAggregateType<T extends Inducks_issuejobAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_issuejob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_issuejob[P]>
      : GetScalarType<T[P], AggregateInducks_issuejob[P]>
  }




  export type inducks_issuejobGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_issuejobWhereInput
    orderBy?: inducks_issuejobOrderByWithAggregationInput | inducks_issuejobOrderByWithAggregationInput[]
    by: Inducks_issuejobScalarFieldEnum[] | Inducks_issuejobScalarFieldEnum
    having?: inducks_issuejobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_issuejobCountAggregateInputType | true
    _min?: Inducks_issuejobMinAggregateInputType
    _max?: Inducks_issuejobMaxAggregateInputType
  }

  export type Inducks_issuejobGroupByOutputType = {
    issuecode: string
    personcode: string
    inxtransletcol: string
    issuejobcomment: string | null
    doubt: $Enums.inducks_issuejob_doubt | null
    _count: Inducks_issuejobCountAggregateOutputType | null
    _min: Inducks_issuejobMinAggregateOutputType | null
    _max: Inducks_issuejobMaxAggregateOutputType | null
  }

  type GetInducks_issuejobGroupByPayload<T extends inducks_issuejobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_issuejobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_issuejobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_issuejobGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_issuejobGroupByOutputType[P]>
        }
      >
    >


  export type inducks_issuejobSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    issuecode?: boolean
    personcode?: boolean
    inxtransletcol?: boolean
    issuejobcomment?: boolean
    doubt?: boolean
  }, ExtArgs["result"]["inducks_issuejob"]>

  export type inducks_issuejobSelectScalar = {
    issuecode?: boolean
    personcode?: boolean
    inxtransletcol?: boolean
    issuejobcomment?: boolean
    doubt?: boolean
  }


  export type $inducks_issuejobPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_issuejob"
    objects: {}
    scalars: $Extensions.GetResult<{
      issuecode: string
      personcode: string
      inxtransletcol: string
      issuejobcomment: string | null
      doubt: $Enums.inducks_issuejob_doubt | null
    }, ExtArgs["result"]["inducks_issuejob"]>
    composites: {}
  }


  type inducks_issuejobGetPayload<S extends boolean | null | undefined | inducks_issuejobDefaultArgs> = $Result.GetResult<Prisma.$inducks_issuejobPayload, S>

  type inducks_issuejobCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_issuejobFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_issuejobCountAggregateInputType | true
    }

  export interface inducks_issuejobDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_issuejob'], meta: { name: 'inducks_issuejob' } }
    /**
     * Find zero or one Inducks_issuejob that matches the filter.
     * @param {inducks_issuejobFindUniqueArgs} args - Arguments to find a Inducks_issuejob
     * @example
     * // Get one Inducks_issuejob
     * const inducks_issuejob = await prisma.inducks_issuejob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_issuejobFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issuejobFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_issuejobClient<$Result.GetResult<Prisma.$inducks_issuejobPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_issuejob that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_issuejobFindUniqueOrThrowArgs} args - Arguments to find a Inducks_issuejob
     * @example
     * // Get one Inducks_issuejob
     * const inducks_issuejob = await prisma.inducks_issuejob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_issuejobFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issuejobFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_issuejobClient<$Result.GetResult<Prisma.$inducks_issuejobPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_issuejob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issuejobFindFirstArgs} args - Arguments to find a Inducks_issuejob
     * @example
     * // Get one Inducks_issuejob
     * const inducks_issuejob = await prisma.inducks_issuejob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_issuejobFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issuejobFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_issuejobClient<$Result.GetResult<Prisma.$inducks_issuejobPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_issuejob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issuejobFindFirstOrThrowArgs} args - Arguments to find a Inducks_issuejob
     * @example
     * // Get one Inducks_issuejob
     * const inducks_issuejob = await prisma.inducks_issuejob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_issuejobFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issuejobFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_issuejobClient<$Result.GetResult<Prisma.$inducks_issuejobPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_issuejobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issuejobFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_issuejobs
     * const inducks_issuejobs = await prisma.inducks_issuejob.findMany()
     * 
     * // Get first 10 Inducks_issuejobs
     * const inducks_issuejobs = await prisma.inducks_issuejob.findMany({ take: 10 })
     * 
     * // Only select the `issuecode`
     * const inducks_issuejobWithIssuecodeOnly = await prisma.inducks_issuejob.findMany({ select: { issuecode: true } })
     * 
    **/
    findMany<T extends inducks_issuejobFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issuejobFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_issuejobPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_issuejob.
     * @param {inducks_issuejobCreateArgs} args - Arguments to create a Inducks_issuejob.
     * @example
     * // Create one Inducks_issuejob
     * const Inducks_issuejob = await prisma.inducks_issuejob.create({
     *   data: {
     *     // ... data to create a Inducks_issuejob
     *   }
     * })
     * 
    **/
    create<T extends inducks_issuejobCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issuejobCreateArgs<ExtArgs>>
    ): Prisma__inducks_issuejobClient<$Result.GetResult<Prisma.$inducks_issuejobPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_issuejobs.
     *     @param {inducks_issuejobCreateManyArgs} args - Arguments to create many Inducks_issuejobs.
     *     @example
     *     // Create many Inducks_issuejobs
     *     const inducks_issuejob = await prisma.inducks_issuejob.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_issuejobCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issuejobCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_issuejob.
     * @param {inducks_issuejobDeleteArgs} args - Arguments to delete one Inducks_issuejob.
     * @example
     * // Delete one Inducks_issuejob
     * const Inducks_issuejob = await prisma.inducks_issuejob.delete({
     *   where: {
     *     // ... filter to delete one Inducks_issuejob
     *   }
     * })
     * 
    **/
    delete<T extends inducks_issuejobDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issuejobDeleteArgs<ExtArgs>>
    ): Prisma__inducks_issuejobClient<$Result.GetResult<Prisma.$inducks_issuejobPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_issuejob.
     * @param {inducks_issuejobUpdateArgs} args - Arguments to update one Inducks_issuejob.
     * @example
     * // Update one Inducks_issuejob
     * const inducks_issuejob = await prisma.inducks_issuejob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_issuejobUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issuejobUpdateArgs<ExtArgs>>
    ): Prisma__inducks_issuejobClient<$Result.GetResult<Prisma.$inducks_issuejobPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_issuejobs.
     * @param {inducks_issuejobDeleteManyArgs} args - Arguments to filter Inducks_issuejobs to delete.
     * @example
     * // Delete a few Inducks_issuejobs
     * const { count } = await prisma.inducks_issuejob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_issuejobDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issuejobDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_issuejobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issuejobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_issuejobs
     * const inducks_issuejob = await prisma.inducks_issuejob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_issuejobUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issuejobUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_issuejob.
     * @param {inducks_issuejobUpsertArgs} args - Arguments to update or create a Inducks_issuejob.
     * @example
     * // Update or create a Inducks_issuejob
     * const inducks_issuejob = await prisma.inducks_issuejob.upsert({
     *   create: {
     *     // ... data to create a Inducks_issuejob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_issuejob we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_issuejobUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issuejobUpsertArgs<ExtArgs>>
    ): Prisma__inducks_issuejobClient<$Result.GetResult<Prisma.$inducks_issuejobPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_issuejobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issuejobCountArgs} args - Arguments to filter Inducks_issuejobs to count.
     * @example
     * // Count the number of Inducks_issuejobs
     * const count = await prisma.inducks_issuejob.count({
     *   where: {
     *     // ... the filter for the Inducks_issuejobs we want to count
     *   }
     * })
    **/
    count<T extends inducks_issuejobCountArgs>(
      args?: Subset<T, inducks_issuejobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_issuejobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_issuejob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_issuejobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_issuejobAggregateArgs>(args: Subset<T, Inducks_issuejobAggregateArgs>): Prisma.PrismaPromise<GetInducks_issuejobAggregateType<T>>

    /**
     * Group by Inducks_issuejob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issuejobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_issuejobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_issuejobGroupByArgs['orderBy'] }
        : { orderBy?: inducks_issuejobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_issuejobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_issuejobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_issuejob model
   */
  readonly fields: inducks_issuejobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_issuejob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_issuejobClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_issuejob model
   */ 
  interface inducks_issuejobFieldRefs {
    readonly issuecode: FieldRef<"inducks_issuejob", 'String'>
    readonly personcode: FieldRef<"inducks_issuejob", 'String'>
    readonly inxtransletcol: FieldRef<"inducks_issuejob", 'String'>
    readonly issuejobcomment: FieldRef<"inducks_issuejob", 'String'>
    readonly doubt: FieldRef<"inducks_issuejob", 'inducks_issuejob_doubt'>
  }
    

  // Custom InputTypes

  /**
   * inducks_issuejob findUnique
   */
  export type inducks_issuejobFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuejob
     */
    select?: inducks_issuejobSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issuejob to fetch.
     */
    where: inducks_issuejobWhereUniqueInput
  }


  /**
   * inducks_issuejob findUniqueOrThrow
   */
  export type inducks_issuejobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuejob
     */
    select?: inducks_issuejobSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issuejob to fetch.
     */
    where: inducks_issuejobWhereUniqueInput
  }


  /**
   * inducks_issuejob findFirst
   */
  export type inducks_issuejobFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuejob
     */
    select?: inducks_issuejobSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issuejob to fetch.
     */
    where?: inducks_issuejobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_issuejobs to fetch.
     */
    orderBy?: inducks_issuejobOrderByWithRelationInput | inducks_issuejobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_issuejobs.
     */
    cursor?: inducks_issuejobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_issuejobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_issuejobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_issuejobs.
     */
    distinct?: Inducks_issuejobScalarFieldEnum | Inducks_issuejobScalarFieldEnum[]
  }


  /**
   * inducks_issuejob findFirstOrThrow
   */
  export type inducks_issuejobFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuejob
     */
    select?: inducks_issuejobSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issuejob to fetch.
     */
    where?: inducks_issuejobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_issuejobs to fetch.
     */
    orderBy?: inducks_issuejobOrderByWithRelationInput | inducks_issuejobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_issuejobs.
     */
    cursor?: inducks_issuejobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_issuejobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_issuejobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_issuejobs.
     */
    distinct?: Inducks_issuejobScalarFieldEnum | Inducks_issuejobScalarFieldEnum[]
  }


  /**
   * inducks_issuejob findMany
   */
  export type inducks_issuejobFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuejob
     */
    select?: inducks_issuejobSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issuejobs to fetch.
     */
    where?: inducks_issuejobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_issuejobs to fetch.
     */
    orderBy?: inducks_issuejobOrderByWithRelationInput | inducks_issuejobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_issuejobs.
     */
    cursor?: inducks_issuejobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_issuejobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_issuejobs.
     */
    skip?: number
    distinct?: Inducks_issuejobScalarFieldEnum | Inducks_issuejobScalarFieldEnum[]
  }


  /**
   * inducks_issuejob create
   */
  export type inducks_issuejobCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuejob
     */
    select?: inducks_issuejobSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_issuejob.
     */
    data: XOR<inducks_issuejobCreateInput, inducks_issuejobUncheckedCreateInput>
  }


  /**
   * inducks_issuejob createMany
   */
  export type inducks_issuejobCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_issuejobs.
     */
    data: inducks_issuejobCreateManyInput | inducks_issuejobCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_issuejob update
   */
  export type inducks_issuejobUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuejob
     */
    select?: inducks_issuejobSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_issuejob.
     */
    data: XOR<inducks_issuejobUpdateInput, inducks_issuejobUncheckedUpdateInput>
    /**
     * Choose, which inducks_issuejob to update.
     */
    where: inducks_issuejobWhereUniqueInput
  }


  /**
   * inducks_issuejob updateMany
   */
  export type inducks_issuejobUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_issuejobs.
     */
    data: XOR<inducks_issuejobUpdateManyMutationInput, inducks_issuejobUncheckedUpdateManyInput>
    /**
     * Filter which inducks_issuejobs to update
     */
    where?: inducks_issuejobWhereInput
  }


  /**
   * inducks_issuejob upsert
   */
  export type inducks_issuejobUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuejob
     */
    select?: inducks_issuejobSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_issuejob to update in case it exists.
     */
    where: inducks_issuejobWhereUniqueInput
    /**
     * In case the inducks_issuejob found by the `where` argument doesn't exist, create a new inducks_issuejob with this data.
     */
    create: XOR<inducks_issuejobCreateInput, inducks_issuejobUncheckedCreateInput>
    /**
     * In case the inducks_issuejob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_issuejobUpdateInput, inducks_issuejobUncheckedUpdateInput>
  }


  /**
   * inducks_issuejob delete
   */
  export type inducks_issuejobDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuejob
     */
    select?: inducks_issuejobSelect<ExtArgs> | null
    /**
     * Filter which inducks_issuejob to delete.
     */
    where: inducks_issuejobWhereUniqueInput
  }


  /**
   * inducks_issuejob deleteMany
   */
  export type inducks_issuejobDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_issuejobs to delete
     */
    where?: inducks_issuejobWhereInput
  }


  /**
   * inducks_issuejob without action
   */
  export type inducks_issuejobDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuejob
     */
    select?: inducks_issuejobSelect<ExtArgs> | null
  }



  /**
   * Model inducks_issueprice
   */

  export type AggregateInducks_issueprice = {
    _count: Inducks_issuepriceCountAggregateOutputType | null
    _avg: Inducks_issuepriceAvgAggregateOutputType | null
    _sum: Inducks_issuepriceSumAggregateOutputType | null
    _min: Inducks_issuepriceMinAggregateOutputType | null
    _max: Inducks_issuepriceMaxAggregateOutputType | null
  }

  export type Inducks_issuepriceAvgAggregateOutputType = {
    sequencenumber: number | null
  }

  export type Inducks_issuepriceSumAggregateOutputType = {
    sequencenumber: number | null
  }

  export type Inducks_issuepriceMinAggregateOutputType = {
    issuecode: string | null
    amount: string | null
    currency: string | null
    comment: string | null
    sequencenumber: number | null
  }

  export type Inducks_issuepriceMaxAggregateOutputType = {
    issuecode: string | null
    amount: string | null
    currency: string | null
    comment: string | null
    sequencenumber: number | null
  }

  export type Inducks_issuepriceCountAggregateOutputType = {
    issuecode: number
    amount: number
    currency: number
    comment: number
    sequencenumber: number
    _all: number
  }


  export type Inducks_issuepriceAvgAggregateInputType = {
    sequencenumber?: true
  }

  export type Inducks_issuepriceSumAggregateInputType = {
    sequencenumber?: true
  }

  export type Inducks_issuepriceMinAggregateInputType = {
    issuecode?: true
    amount?: true
    currency?: true
    comment?: true
    sequencenumber?: true
  }

  export type Inducks_issuepriceMaxAggregateInputType = {
    issuecode?: true
    amount?: true
    currency?: true
    comment?: true
    sequencenumber?: true
  }

  export type Inducks_issuepriceCountAggregateInputType = {
    issuecode?: true
    amount?: true
    currency?: true
    comment?: true
    sequencenumber?: true
    _all?: true
  }

  export type Inducks_issuepriceAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_issueprice to aggregate.
     */
    where?: inducks_issuepriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_issueprices to fetch.
     */
    orderBy?: inducks_issuepriceOrderByWithRelationInput | inducks_issuepriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_issuepriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_issueprices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_issueprices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_issueprices
    **/
    _count?: true | Inducks_issuepriceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Inducks_issuepriceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Inducks_issuepriceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_issuepriceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_issuepriceMaxAggregateInputType
  }

  export type GetInducks_issuepriceAggregateType<T extends Inducks_issuepriceAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_issueprice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_issueprice[P]>
      : GetScalarType<T[P], AggregateInducks_issueprice[P]>
  }




  export type inducks_issuepriceGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_issuepriceWhereInput
    orderBy?: inducks_issuepriceOrderByWithAggregationInput | inducks_issuepriceOrderByWithAggregationInput[]
    by: Inducks_issuepriceScalarFieldEnum[] | Inducks_issuepriceScalarFieldEnum
    having?: inducks_issuepriceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_issuepriceCountAggregateInputType | true
    _avg?: Inducks_issuepriceAvgAggregateInputType
    _sum?: Inducks_issuepriceSumAggregateInputType
    _min?: Inducks_issuepriceMinAggregateInputType
    _max?: Inducks_issuepriceMaxAggregateInputType
  }

  export type Inducks_issuepriceGroupByOutputType = {
    issuecode: string
    amount: string
    currency: string | null
    comment: string | null
    sequencenumber: number | null
    _count: Inducks_issuepriceCountAggregateOutputType | null
    _avg: Inducks_issuepriceAvgAggregateOutputType | null
    _sum: Inducks_issuepriceSumAggregateOutputType | null
    _min: Inducks_issuepriceMinAggregateOutputType | null
    _max: Inducks_issuepriceMaxAggregateOutputType | null
  }

  type GetInducks_issuepriceGroupByPayload<T extends inducks_issuepriceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_issuepriceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_issuepriceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_issuepriceGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_issuepriceGroupByOutputType[P]>
        }
      >
    >


  export type inducks_issuepriceSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    issuecode?: boolean
    amount?: boolean
    currency?: boolean
    comment?: boolean
    sequencenumber?: boolean
  }, ExtArgs["result"]["inducks_issueprice"]>

  export type inducks_issuepriceSelectScalar = {
    issuecode?: boolean
    amount?: boolean
    currency?: boolean
    comment?: boolean
    sequencenumber?: boolean
  }


  export type $inducks_issuepricePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_issueprice"
    objects: {}
    scalars: $Extensions.GetResult<{
      issuecode: string
      amount: string
      currency: string | null
      comment: string | null
      sequencenumber: number | null
    }, ExtArgs["result"]["inducks_issueprice"]>
    composites: {}
  }


  type inducks_issuepriceGetPayload<S extends boolean | null | undefined | inducks_issuepriceDefaultArgs> = $Result.GetResult<Prisma.$inducks_issuepricePayload, S>

  type inducks_issuepriceCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_issuepriceFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_issuepriceCountAggregateInputType | true
    }

  export interface inducks_issuepriceDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_issueprice'], meta: { name: 'inducks_issueprice' } }
    /**
     * Find zero or one Inducks_issueprice that matches the filter.
     * @param {inducks_issuepriceFindUniqueArgs} args - Arguments to find a Inducks_issueprice
     * @example
     * // Get one Inducks_issueprice
     * const inducks_issueprice = await prisma.inducks_issueprice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_issuepriceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issuepriceFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_issuepriceClient<$Result.GetResult<Prisma.$inducks_issuepricePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_issueprice that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_issuepriceFindUniqueOrThrowArgs} args - Arguments to find a Inducks_issueprice
     * @example
     * // Get one Inducks_issueprice
     * const inducks_issueprice = await prisma.inducks_issueprice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_issuepriceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issuepriceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_issuepriceClient<$Result.GetResult<Prisma.$inducks_issuepricePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_issueprice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issuepriceFindFirstArgs} args - Arguments to find a Inducks_issueprice
     * @example
     * // Get one Inducks_issueprice
     * const inducks_issueprice = await prisma.inducks_issueprice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_issuepriceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issuepriceFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_issuepriceClient<$Result.GetResult<Prisma.$inducks_issuepricePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_issueprice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issuepriceFindFirstOrThrowArgs} args - Arguments to find a Inducks_issueprice
     * @example
     * // Get one Inducks_issueprice
     * const inducks_issueprice = await prisma.inducks_issueprice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_issuepriceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issuepriceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_issuepriceClient<$Result.GetResult<Prisma.$inducks_issuepricePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_issueprices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issuepriceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_issueprices
     * const inducks_issueprices = await prisma.inducks_issueprice.findMany()
     * 
     * // Get first 10 Inducks_issueprices
     * const inducks_issueprices = await prisma.inducks_issueprice.findMany({ take: 10 })
     * 
     * // Only select the `issuecode`
     * const inducks_issuepriceWithIssuecodeOnly = await prisma.inducks_issueprice.findMany({ select: { issuecode: true } })
     * 
    **/
    findMany<T extends inducks_issuepriceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issuepriceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_issuepricePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_issueprice.
     * @param {inducks_issuepriceCreateArgs} args - Arguments to create a Inducks_issueprice.
     * @example
     * // Create one Inducks_issueprice
     * const Inducks_issueprice = await prisma.inducks_issueprice.create({
     *   data: {
     *     // ... data to create a Inducks_issueprice
     *   }
     * })
     * 
    **/
    create<T extends inducks_issuepriceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issuepriceCreateArgs<ExtArgs>>
    ): Prisma__inducks_issuepriceClient<$Result.GetResult<Prisma.$inducks_issuepricePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_issueprices.
     *     @param {inducks_issuepriceCreateManyArgs} args - Arguments to create many Inducks_issueprices.
     *     @example
     *     // Create many Inducks_issueprices
     *     const inducks_issueprice = await prisma.inducks_issueprice.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_issuepriceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issuepriceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_issueprice.
     * @param {inducks_issuepriceDeleteArgs} args - Arguments to delete one Inducks_issueprice.
     * @example
     * // Delete one Inducks_issueprice
     * const Inducks_issueprice = await prisma.inducks_issueprice.delete({
     *   where: {
     *     // ... filter to delete one Inducks_issueprice
     *   }
     * })
     * 
    **/
    delete<T extends inducks_issuepriceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issuepriceDeleteArgs<ExtArgs>>
    ): Prisma__inducks_issuepriceClient<$Result.GetResult<Prisma.$inducks_issuepricePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_issueprice.
     * @param {inducks_issuepriceUpdateArgs} args - Arguments to update one Inducks_issueprice.
     * @example
     * // Update one Inducks_issueprice
     * const inducks_issueprice = await prisma.inducks_issueprice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_issuepriceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issuepriceUpdateArgs<ExtArgs>>
    ): Prisma__inducks_issuepriceClient<$Result.GetResult<Prisma.$inducks_issuepricePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_issueprices.
     * @param {inducks_issuepriceDeleteManyArgs} args - Arguments to filter Inducks_issueprices to delete.
     * @example
     * // Delete a few Inducks_issueprices
     * const { count } = await prisma.inducks_issueprice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_issuepriceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issuepriceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_issueprices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issuepriceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_issueprices
     * const inducks_issueprice = await prisma.inducks_issueprice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_issuepriceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issuepriceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_issueprice.
     * @param {inducks_issuepriceUpsertArgs} args - Arguments to update or create a Inducks_issueprice.
     * @example
     * // Update or create a Inducks_issueprice
     * const inducks_issueprice = await prisma.inducks_issueprice.upsert({
     *   create: {
     *     // ... data to create a Inducks_issueprice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_issueprice we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_issuepriceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issuepriceUpsertArgs<ExtArgs>>
    ): Prisma__inducks_issuepriceClient<$Result.GetResult<Prisma.$inducks_issuepricePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_issueprices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issuepriceCountArgs} args - Arguments to filter Inducks_issueprices to count.
     * @example
     * // Count the number of Inducks_issueprices
     * const count = await prisma.inducks_issueprice.count({
     *   where: {
     *     // ... the filter for the Inducks_issueprices we want to count
     *   }
     * })
    **/
    count<T extends inducks_issuepriceCountArgs>(
      args?: Subset<T, inducks_issuepriceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_issuepriceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_issueprice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_issuepriceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_issuepriceAggregateArgs>(args: Subset<T, Inducks_issuepriceAggregateArgs>): Prisma.PrismaPromise<GetInducks_issuepriceAggregateType<T>>

    /**
     * Group by Inducks_issueprice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issuepriceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_issuepriceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_issuepriceGroupByArgs['orderBy'] }
        : { orderBy?: inducks_issuepriceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_issuepriceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_issuepriceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_issueprice model
   */
  readonly fields: inducks_issuepriceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_issueprice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_issuepriceClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_issueprice model
   */ 
  interface inducks_issuepriceFieldRefs {
    readonly issuecode: FieldRef<"inducks_issueprice", 'String'>
    readonly amount: FieldRef<"inducks_issueprice", 'String'>
    readonly currency: FieldRef<"inducks_issueprice", 'String'>
    readonly comment: FieldRef<"inducks_issueprice", 'String'>
    readonly sequencenumber: FieldRef<"inducks_issueprice", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * inducks_issueprice findUnique
   */
  export type inducks_issuepriceFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issueprice
     */
    select?: inducks_issuepriceSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issueprice to fetch.
     */
    where: inducks_issuepriceWhereUniqueInput
  }


  /**
   * inducks_issueprice findUniqueOrThrow
   */
  export type inducks_issuepriceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issueprice
     */
    select?: inducks_issuepriceSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issueprice to fetch.
     */
    where: inducks_issuepriceWhereUniqueInput
  }


  /**
   * inducks_issueprice findFirst
   */
  export type inducks_issuepriceFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issueprice
     */
    select?: inducks_issuepriceSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issueprice to fetch.
     */
    where?: inducks_issuepriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_issueprices to fetch.
     */
    orderBy?: inducks_issuepriceOrderByWithRelationInput | inducks_issuepriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_issueprices.
     */
    cursor?: inducks_issuepriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_issueprices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_issueprices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_issueprices.
     */
    distinct?: Inducks_issuepriceScalarFieldEnum | Inducks_issuepriceScalarFieldEnum[]
  }


  /**
   * inducks_issueprice findFirstOrThrow
   */
  export type inducks_issuepriceFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issueprice
     */
    select?: inducks_issuepriceSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issueprice to fetch.
     */
    where?: inducks_issuepriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_issueprices to fetch.
     */
    orderBy?: inducks_issuepriceOrderByWithRelationInput | inducks_issuepriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_issueprices.
     */
    cursor?: inducks_issuepriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_issueprices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_issueprices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_issueprices.
     */
    distinct?: Inducks_issuepriceScalarFieldEnum | Inducks_issuepriceScalarFieldEnum[]
  }


  /**
   * inducks_issueprice findMany
   */
  export type inducks_issuepriceFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issueprice
     */
    select?: inducks_issuepriceSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issueprices to fetch.
     */
    where?: inducks_issuepriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_issueprices to fetch.
     */
    orderBy?: inducks_issuepriceOrderByWithRelationInput | inducks_issuepriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_issueprices.
     */
    cursor?: inducks_issuepriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_issueprices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_issueprices.
     */
    skip?: number
    distinct?: Inducks_issuepriceScalarFieldEnum | Inducks_issuepriceScalarFieldEnum[]
  }


  /**
   * inducks_issueprice create
   */
  export type inducks_issuepriceCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issueprice
     */
    select?: inducks_issuepriceSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_issueprice.
     */
    data: XOR<inducks_issuepriceCreateInput, inducks_issuepriceUncheckedCreateInput>
  }


  /**
   * inducks_issueprice createMany
   */
  export type inducks_issuepriceCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_issueprices.
     */
    data: inducks_issuepriceCreateManyInput | inducks_issuepriceCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_issueprice update
   */
  export type inducks_issuepriceUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issueprice
     */
    select?: inducks_issuepriceSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_issueprice.
     */
    data: XOR<inducks_issuepriceUpdateInput, inducks_issuepriceUncheckedUpdateInput>
    /**
     * Choose, which inducks_issueprice to update.
     */
    where: inducks_issuepriceWhereUniqueInput
  }


  /**
   * inducks_issueprice updateMany
   */
  export type inducks_issuepriceUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_issueprices.
     */
    data: XOR<inducks_issuepriceUpdateManyMutationInput, inducks_issuepriceUncheckedUpdateManyInput>
    /**
     * Filter which inducks_issueprices to update
     */
    where?: inducks_issuepriceWhereInput
  }


  /**
   * inducks_issueprice upsert
   */
  export type inducks_issuepriceUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issueprice
     */
    select?: inducks_issuepriceSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_issueprice to update in case it exists.
     */
    where: inducks_issuepriceWhereUniqueInput
    /**
     * In case the inducks_issueprice found by the `where` argument doesn't exist, create a new inducks_issueprice with this data.
     */
    create: XOR<inducks_issuepriceCreateInput, inducks_issuepriceUncheckedCreateInput>
    /**
     * In case the inducks_issueprice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_issuepriceUpdateInput, inducks_issuepriceUncheckedUpdateInput>
  }


  /**
   * inducks_issueprice delete
   */
  export type inducks_issuepriceDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issueprice
     */
    select?: inducks_issuepriceSelect<ExtArgs> | null
    /**
     * Filter which inducks_issueprice to delete.
     */
    where: inducks_issuepriceWhereUniqueInput
  }


  /**
   * inducks_issueprice deleteMany
   */
  export type inducks_issuepriceDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_issueprices to delete
     */
    where?: inducks_issuepriceWhereInput
  }


  /**
   * inducks_issueprice without action
   */
  export type inducks_issuepriceDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issueprice
     */
    select?: inducks_issuepriceSelect<ExtArgs> | null
  }



  /**
   * Model inducks_issuequotation
   */

  export type AggregateInducks_issuequotation = {
    _count: Inducks_issuequotationCountAggregateOutputType | null
    _avg: Inducks_issuequotationAvgAggregateOutputType | null
    _sum: Inducks_issuequotationSumAggregateOutputType | null
    _min: Inducks_issuequotationMinAggregateOutputType | null
    _max: Inducks_issuequotationMaxAggregateOutputType | null
  }

  export type Inducks_issuequotationAvgAggregateOutputType = {
    ID: number | null
    estimationmin: number | null
    estimationmax: number | null
  }

  export type Inducks_issuequotationSumAggregateOutputType = {
    ID: number | null
    estimationmin: number | null
    estimationmax: number | null
  }

  export type Inducks_issuequotationMinAggregateOutputType = {
    ID: number | null
    publicationcode: string | null
    issuenumber: string | null
    estimationmin: number | null
    estimationmax: number | null
    scrapedate: Date | null
    source: string | null
    issuecode: string | null
  }

  export type Inducks_issuequotationMaxAggregateOutputType = {
    ID: number | null
    publicationcode: string | null
    issuenumber: string | null
    estimationmin: number | null
    estimationmax: number | null
    scrapedate: Date | null
    source: string | null
    issuecode: string | null
  }

  export type Inducks_issuequotationCountAggregateOutputType = {
    ID: number
    publicationcode: number
    issuenumber: number
    estimationmin: number
    estimationmax: number
    scrapedate: number
    source: number
    issuecode: number
    _all: number
  }


  export type Inducks_issuequotationAvgAggregateInputType = {
    ID?: true
    estimationmin?: true
    estimationmax?: true
  }

  export type Inducks_issuequotationSumAggregateInputType = {
    ID?: true
    estimationmin?: true
    estimationmax?: true
  }

  export type Inducks_issuequotationMinAggregateInputType = {
    ID?: true
    publicationcode?: true
    issuenumber?: true
    estimationmin?: true
    estimationmax?: true
    scrapedate?: true
    source?: true
    issuecode?: true
  }

  export type Inducks_issuequotationMaxAggregateInputType = {
    ID?: true
    publicationcode?: true
    issuenumber?: true
    estimationmin?: true
    estimationmax?: true
    scrapedate?: true
    source?: true
    issuecode?: true
  }

  export type Inducks_issuequotationCountAggregateInputType = {
    ID?: true
    publicationcode?: true
    issuenumber?: true
    estimationmin?: true
    estimationmax?: true
    scrapedate?: true
    source?: true
    issuecode?: true
    _all?: true
  }

  export type Inducks_issuequotationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_issuequotation to aggregate.
     */
    where?: inducks_issuequotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_issuequotations to fetch.
     */
    orderBy?: inducks_issuequotationOrderByWithRelationInput | inducks_issuequotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_issuequotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_issuequotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_issuequotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_issuequotations
    **/
    _count?: true | Inducks_issuequotationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Inducks_issuequotationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Inducks_issuequotationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_issuequotationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_issuequotationMaxAggregateInputType
  }

  export type GetInducks_issuequotationAggregateType<T extends Inducks_issuequotationAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_issuequotation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_issuequotation[P]>
      : GetScalarType<T[P], AggregateInducks_issuequotation[P]>
  }




  export type inducks_issuequotationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_issuequotationWhereInput
    orderBy?: inducks_issuequotationOrderByWithAggregationInput | inducks_issuequotationOrderByWithAggregationInput[]
    by: Inducks_issuequotationScalarFieldEnum[] | Inducks_issuequotationScalarFieldEnum
    having?: inducks_issuequotationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_issuequotationCountAggregateInputType | true
    _avg?: Inducks_issuequotationAvgAggregateInputType
    _sum?: Inducks_issuequotationSumAggregateInputType
    _min?: Inducks_issuequotationMinAggregateInputType
    _max?: Inducks_issuequotationMaxAggregateInputType
  }

  export type Inducks_issuequotationGroupByOutputType = {
    ID: number
    publicationcode: string
    issuenumber: string
    estimationmin: number | null
    estimationmax: number | null
    scrapedate: Date | null
    source: string
    issuecode: string | null
    _count: Inducks_issuequotationCountAggregateOutputType | null
    _avg: Inducks_issuequotationAvgAggregateOutputType | null
    _sum: Inducks_issuequotationSumAggregateOutputType | null
    _min: Inducks_issuequotationMinAggregateOutputType | null
    _max: Inducks_issuequotationMaxAggregateOutputType | null
  }

  type GetInducks_issuequotationGroupByPayload<T extends inducks_issuequotationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_issuequotationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_issuequotationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_issuequotationGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_issuequotationGroupByOutputType[P]>
        }
      >
    >


  export type inducks_issuequotationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    publicationcode?: boolean
    issuenumber?: boolean
    estimationmin?: boolean
    estimationmax?: boolean
    scrapedate?: boolean
    source?: boolean
    issuecode?: boolean
  }, ExtArgs["result"]["inducks_issuequotation"]>

  export type inducks_issuequotationSelectScalar = {
    ID?: boolean
    publicationcode?: boolean
    issuenumber?: boolean
    estimationmin?: boolean
    estimationmax?: boolean
    scrapedate?: boolean
    source?: boolean
    issuecode?: boolean
  }


  export type $inducks_issuequotationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_issuequotation"
    objects: {}
    scalars: $Extensions.GetResult<{
      ID: number
      publicationcode: string
      issuenumber: string
      estimationmin: number | null
      estimationmax: number | null
      scrapedate: Date | null
      source: string
      issuecode: string | null
    }, ExtArgs["result"]["inducks_issuequotation"]>
    composites: {}
  }


  type inducks_issuequotationGetPayload<S extends boolean | null | undefined | inducks_issuequotationDefaultArgs> = $Result.GetResult<Prisma.$inducks_issuequotationPayload, S>

  type inducks_issuequotationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_issuequotationFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_issuequotationCountAggregateInputType | true
    }

  export interface inducks_issuequotationDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_issuequotation'], meta: { name: 'inducks_issuequotation' } }
    /**
     * Find zero or one Inducks_issuequotation that matches the filter.
     * @param {inducks_issuequotationFindUniqueArgs} args - Arguments to find a Inducks_issuequotation
     * @example
     * // Get one Inducks_issuequotation
     * const inducks_issuequotation = await prisma.inducks_issuequotation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_issuequotationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issuequotationFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_issuequotationClient<$Result.GetResult<Prisma.$inducks_issuequotationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_issuequotation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_issuequotationFindUniqueOrThrowArgs} args - Arguments to find a Inducks_issuequotation
     * @example
     * // Get one Inducks_issuequotation
     * const inducks_issuequotation = await prisma.inducks_issuequotation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_issuequotationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issuequotationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_issuequotationClient<$Result.GetResult<Prisma.$inducks_issuequotationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_issuequotation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issuequotationFindFirstArgs} args - Arguments to find a Inducks_issuequotation
     * @example
     * // Get one Inducks_issuequotation
     * const inducks_issuequotation = await prisma.inducks_issuequotation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_issuequotationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issuequotationFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_issuequotationClient<$Result.GetResult<Prisma.$inducks_issuequotationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_issuequotation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issuequotationFindFirstOrThrowArgs} args - Arguments to find a Inducks_issuequotation
     * @example
     * // Get one Inducks_issuequotation
     * const inducks_issuequotation = await prisma.inducks_issuequotation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_issuequotationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issuequotationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_issuequotationClient<$Result.GetResult<Prisma.$inducks_issuequotationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_issuequotations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issuequotationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_issuequotations
     * const inducks_issuequotations = await prisma.inducks_issuequotation.findMany()
     * 
     * // Get first 10 Inducks_issuequotations
     * const inducks_issuequotations = await prisma.inducks_issuequotation.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const inducks_issuequotationWithIDOnly = await prisma.inducks_issuequotation.findMany({ select: { ID: true } })
     * 
    **/
    findMany<T extends inducks_issuequotationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issuequotationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_issuequotationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_issuequotation.
     * @param {inducks_issuequotationCreateArgs} args - Arguments to create a Inducks_issuequotation.
     * @example
     * // Create one Inducks_issuequotation
     * const Inducks_issuequotation = await prisma.inducks_issuequotation.create({
     *   data: {
     *     // ... data to create a Inducks_issuequotation
     *   }
     * })
     * 
    **/
    create<T extends inducks_issuequotationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issuequotationCreateArgs<ExtArgs>>
    ): Prisma__inducks_issuequotationClient<$Result.GetResult<Prisma.$inducks_issuequotationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_issuequotations.
     *     @param {inducks_issuequotationCreateManyArgs} args - Arguments to create many Inducks_issuequotations.
     *     @example
     *     // Create many Inducks_issuequotations
     *     const inducks_issuequotation = await prisma.inducks_issuequotation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_issuequotationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issuequotationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_issuequotation.
     * @param {inducks_issuequotationDeleteArgs} args - Arguments to delete one Inducks_issuequotation.
     * @example
     * // Delete one Inducks_issuequotation
     * const Inducks_issuequotation = await prisma.inducks_issuequotation.delete({
     *   where: {
     *     // ... filter to delete one Inducks_issuequotation
     *   }
     * })
     * 
    **/
    delete<T extends inducks_issuequotationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issuequotationDeleteArgs<ExtArgs>>
    ): Prisma__inducks_issuequotationClient<$Result.GetResult<Prisma.$inducks_issuequotationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_issuequotation.
     * @param {inducks_issuequotationUpdateArgs} args - Arguments to update one Inducks_issuequotation.
     * @example
     * // Update one Inducks_issuequotation
     * const inducks_issuequotation = await prisma.inducks_issuequotation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_issuequotationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issuequotationUpdateArgs<ExtArgs>>
    ): Prisma__inducks_issuequotationClient<$Result.GetResult<Prisma.$inducks_issuequotationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_issuequotations.
     * @param {inducks_issuequotationDeleteManyArgs} args - Arguments to filter Inducks_issuequotations to delete.
     * @example
     * // Delete a few Inducks_issuequotations
     * const { count } = await prisma.inducks_issuequotation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_issuequotationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issuequotationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_issuequotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issuequotationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_issuequotations
     * const inducks_issuequotation = await prisma.inducks_issuequotation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_issuequotationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issuequotationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_issuequotation.
     * @param {inducks_issuequotationUpsertArgs} args - Arguments to update or create a Inducks_issuequotation.
     * @example
     * // Update or create a Inducks_issuequotation
     * const inducks_issuequotation = await prisma.inducks_issuequotation.upsert({
     *   create: {
     *     // ... data to create a Inducks_issuequotation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_issuequotation we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_issuequotationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issuequotationUpsertArgs<ExtArgs>>
    ): Prisma__inducks_issuequotationClient<$Result.GetResult<Prisma.$inducks_issuequotationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_issuequotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issuequotationCountArgs} args - Arguments to filter Inducks_issuequotations to count.
     * @example
     * // Count the number of Inducks_issuequotations
     * const count = await prisma.inducks_issuequotation.count({
     *   where: {
     *     // ... the filter for the Inducks_issuequotations we want to count
     *   }
     * })
    **/
    count<T extends inducks_issuequotationCountArgs>(
      args?: Subset<T, inducks_issuequotationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_issuequotationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_issuequotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_issuequotationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_issuequotationAggregateArgs>(args: Subset<T, Inducks_issuequotationAggregateArgs>): Prisma.PrismaPromise<GetInducks_issuequotationAggregateType<T>>

    /**
     * Group by Inducks_issuequotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issuequotationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_issuequotationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_issuequotationGroupByArgs['orderBy'] }
        : { orderBy?: inducks_issuequotationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_issuequotationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_issuequotationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_issuequotation model
   */
  readonly fields: inducks_issuequotationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_issuequotation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_issuequotationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_issuequotation model
   */ 
  interface inducks_issuequotationFieldRefs {
    readonly ID: FieldRef<"inducks_issuequotation", 'Int'>
    readonly publicationcode: FieldRef<"inducks_issuequotation", 'String'>
    readonly issuenumber: FieldRef<"inducks_issuequotation", 'String'>
    readonly estimationmin: FieldRef<"inducks_issuequotation", 'Float'>
    readonly estimationmax: FieldRef<"inducks_issuequotation", 'Float'>
    readonly scrapedate: FieldRef<"inducks_issuequotation", 'DateTime'>
    readonly source: FieldRef<"inducks_issuequotation", 'String'>
    readonly issuecode: FieldRef<"inducks_issuequotation", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_issuequotation findUnique
   */
  export type inducks_issuequotationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuequotation
     */
    select?: inducks_issuequotationSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issuequotation to fetch.
     */
    where: inducks_issuequotationWhereUniqueInput
  }


  /**
   * inducks_issuequotation findUniqueOrThrow
   */
  export type inducks_issuequotationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuequotation
     */
    select?: inducks_issuequotationSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issuequotation to fetch.
     */
    where: inducks_issuequotationWhereUniqueInput
  }


  /**
   * inducks_issuequotation findFirst
   */
  export type inducks_issuequotationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuequotation
     */
    select?: inducks_issuequotationSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issuequotation to fetch.
     */
    where?: inducks_issuequotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_issuequotations to fetch.
     */
    orderBy?: inducks_issuequotationOrderByWithRelationInput | inducks_issuequotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_issuequotations.
     */
    cursor?: inducks_issuequotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_issuequotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_issuequotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_issuequotations.
     */
    distinct?: Inducks_issuequotationScalarFieldEnum | Inducks_issuequotationScalarFieldEnum[]
  }


  /**
   * inducks_issuequotation findFirstOrThrow
   */
  export type inducks_issuequotationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuequotation
     */
    select?: inducks_issuequotationSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issuequotation to fetch.
     */
    where?: inducks_issuequotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_issuequotations to fetch.
     */
    orderBy?: inducks_issuequotationOrderByWithRelationInput | inducks_issuequotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_issuequotations.
     */
    cursor?: inducks_issuequotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_issuequotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_issuequotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_issuequotations.
     */
    distinct?: Inducks_issuequotationScalarFieldEnum | Inducks_issuequotationScalarFieldEnum[]
  }


  /**
   * inducks_issuequotation findMany
   */
  export type inducks_issuequotationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuequotation
     */
    select?: inducks_issuequotationSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issuequotations to fetch.
     */
    where?: inducks_issuequotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_issuequotations to fetch.
     */
    orderBy?: inducks_issuequotationOrderByWithRelationInput | inducks_issuequotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_issuequotations.
     */
    cursor?: inducks_issuequotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_issuequotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_issuequotations.
     */
    skip?: number
    distinct?: Inducks_issuequotationScalarFieldEnum | Inducks_issuequotationScalarFieldEnum[]
  }


  /**
   * inducks_issuequotation create
   */
  export type inducks_issuequotationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuequotation
     */
    select?: inducks_issuequotationSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_issuequotation.
     */
    data: XOR<inducks_issuequotationCreateInput, inducks_issuequotationUncheckedCreateInput>
  }


  /**
   * inducks_issuequotation createMany
   */
  export type inducks_issuequotationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_issuequotations.
     */
    data: inducks_issuequotationCreateManyInput | inducks_issuequotationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_issuequotation update
   */
  export type inducks_issuequotationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuequotation
     */
    select?: inducks_issuequotationSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_issuequotation.
     */
    data: XOR<inducks_issuequotationUpdateInput, inducks_issuequotationUncheckedUpdateInput>
    /**
     * Choose, which inducks_issuequotation to update.
     */
    where: inducks_issuequotationWhereUniqueInput
  }


  /**
   * inducks_issuequotation updateMany
   */
  export type inducks_issuequotationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_issuequotations.
     */
    data: XOR<inducks_issuequotationUpdateManyMutationInput, inducks_issuequotationUncheckedUpdateManyInput>
    /**
     * Filter which inducks_issuequotations to update
     */
    where?: inducks_issuequotationWhereInput
  }


  /**
   * inducks_issuequotation upsert
   */
  export type inducks_issuequotationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuequotation
     */
    select?: inducks_issuequotationSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_issuequotation to update in case it exists.
     */
    where: inducks_issuequotationWhereUniqueInput
    /**
     * In case the inducks_issuequotation found by the `where` argument doesn't exist, create a new inducks_issuequotation with this data.
     */
    create: XOR<inducks_issuequotationCreateInput, inducks_issuequotationUncheckedCreateInput>
    /**
     * In case the inducks_issuequotation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_issuequotationUpdateInput, inducks_issuequotationUncheckedUpdateInput>
  }


  /**
   * inducks_issuequotation delete
   */
  export type inducks_issuequotationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuequotation
     */
    select?: inducks_issuequotationSelect<ExtArgs> | null
    /**
     * Filter which inducks_issuequotation to delete.
     */
    where: inducks_issuequotationWhereUniqueInput
  }


  /**
   * inducks_issuequotation deleteMany
   */
  export type inducks_issuequotationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_issuequotations to delete
     */
    where?: inducks_issuequotationWhereInput
  }


  /**
   * inducks_issuequotation without action
   */
  export type inducks_issuequotationDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuequotation
     */
    select?: inducks_issuequotationSelect<ExtArgs> | null
  }



  /**
   * Model inducks_issuerange
   */

  export type AggregateInducks_issuerange = {
    _count: Inducks_issuerangeCountAggregateOutputType | null
    _min: Inducks_issuerangeMinAggregateOutputType | null
    _max: Inducks_issuerangeMaxAggregateOutputType | null
  }

  export type Inducks_issuerangeMinAggregateOutputType = {
    issuerangecode: string | null
    publicationcode: string | null
    title: string | null
    circulation: string | null
    issuerangecomment: string | null
    numbersarefake: $Enums.inducks_issuerange_numbersarefake | null
    error: $Enums.inducks_issuerange_error | null
  }

  export type Inducks_issuerangeMaxAggregateOutputType = {
    issuerangecode: string | null
    publicationcode: string | null
    title: string | null
    circulation: string | null
    issuerangecomment: string | null
    numbersarefake: $Enums.inducks_issuerange_numbersarefake | null
    error: $Enums.inducks_issuerange_error | null
  }

  export type Inducks_issuerangeCountAggregateOutputType = {
    issuerangecode: number
    publicationcode: number
    title: number
    circulation: number
    issuerangecomment: number
    numbersarefake: number
    error: number
    _all: number
  }


  export type Inducks_issuerangeMinAggregateInputType = {
    issuerangecode?: true
    publicationcode?: true
    title?: true
    circulation?: true
    issuerangecomment?: true
    numbersarefake?: true
    error?: true
  }

  export type Inducks_issuerangeMaxAggregateInputType = {
    issuerangecode?: true
    publicationcode?: true
    title?: true
    circulation?: true
    issuerangecomment?: true
    numbersarefake?: true
    error?: true
  }

  export type Inducks_issuerangeCountAggregateInputType = {
    issuerangecode?: true
    publicationcode?: true
    title?: true
    circulation?: true
    issuerangecomment?: true
    numbersarefake?: true
    error?: true
    _all?: true
  }

  export type Inducks_issuerangeAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_issuerange to aggregate.
     */
    where?: inducks_issuerangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_issueranges to fetch.
     */
    orderBy?: inducks_issuerangeOrderByWithRelationInput | inducks_issuerangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_issuerangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_issueranges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_issueranges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_issueranges
    **/
    _count?: true | Inducks_issuerangeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_issuerangeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_issuerangeMaxAggregateInputType
  }

  export type GetInducks_issuerangeAggregateType<T extends Inducks_issuerangeAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_issuerange]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_issuerange[P]>
      : GetScalarType<T[P], AggregateInducks_issuerange[P]>
  }




  export type inducks_issuerangeGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_issuerangeWhereInput
    orderBy?: inducks_issuerangeOrderByWithAggregationInput | inducks_issuerangeOrderByWithAggregationInput[]
    by: Inducks_issuerangeScalarFieldEnum[] | Inducks_issuerangeScalarFieldEnum
    having?: inducks_issuerangeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_issuerangeCountAggregateInputType | true
    _min?: Inducks_issuerangeMinAggregateInputType
    _max?: Inducks_issuerangeMaxAggregateInputType
  }

  export type Inducks_issuerangeGroupByOutputType = {
    issuerangecode: string
    publicationcode: string | null
    title: string | null
    circulation: string | null
    issuerangecomment: string | null
    numbersarefake: $Enums.inducks_issuerange_numbersarefake | null
    error: $Enums.inducks_issuerange_error | null
    _count: Inducks_issuerangeCountAggregateOutputType | null
    _min: Inducks_issuerangeMinAggregateOutputType | null
    _max: Inducks_issuerangeMaxAggregateOutputType | null
  }

  type GetInducks_issuerangeGroupByPayload<T extends inducks_issuerangeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_issuerangeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_issuerangeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_issuerangeGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_issuerangeGroupByOutputType[P]>
        }
      >
    >


  export type inducks_issuerangeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    issuerangecode?: boolean
    publicationcode?: boolean
    title?: boolean
    circulation?: boolean
    issuerangecomment?: boolean
    numbersarefake?: boolean
    error?: boolean
  }, ExtArgs["result"]["inducks_issuerange"]>

  export type inducks_issuerangeSelectScalar = {
    issuerangecode?: boolean
    publicationcode?: boolean
    title?: boolean
    circulation?: boolean
    issuerangecomment?: boolean
    numbersarefake?: boolean
    error?: boolean
  }


  export type $inducks_issuerangePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_issuerange"
    objects: {}
    scalars: $Extensions.GetResult<{
      issuerangecode: string
      publicationcode: string | null
      title: string | null
      circulation: string | null
      issuerangecomment: string | null
      numbersarefake: $Enums.inducks_issuerange_numbersarefake | null
      error: $Enums.inducks_issuerange_error | null
    }, ExtArgs["result"]["inducks_issuerange"]>
    composites: {}
  }


  type inducks_issuerangeGetPayload<S extends boolean | null | undefined | inducks_issuerangeDefaultArgs> = $Result.GetResult<Prisma.$inducks_issuerangePayload, S>

  type inducks_issuerangeCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_issuerangeFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_issuerangeCountAggregateInputType | true
    }

  export interface inducks_issuerangeDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_issuerange'], meta: { name: 'inducks_issuerange' } }
    /**
     * Find zero or one Inducks_issuerange that matches the filter.
     * @param {inducks_issuerangeFindUniqueArgs} args - Arguments to find a Inducks_issuerange
     * @example
     * // Get one Inducks_issuerange
     * const inducks_issuerange = await prisma.inducks_issuerange.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_issuerangeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issuerangeFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_issuerangeClient<$Result.GetResult<Prisma.$inducks_issuerangePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_issuerange that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_issuerangeFindUniqueOrThrowArgs} args - Arguments to find a Inducks_issuerange
     * @example
     * // Get one Inducks_issuerange
     * const inducks_issuerange = await prisma.inducks_issuerange.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_issuerangeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issuerangeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_issuerangeClient<$Result.GetResult<Prisma.$inducks_issuerangePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_issuerange that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issuerangeFindFirstArgs} args - Arguments to find a Inducks_issuerange
     * @example
     * // Get one Inducks_issuerange
     * const inducks_issuerange = await prisma.inducks_issuerange.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_issuerangeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issuerangeFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_issuerangeClient<$Result.GetResult<Prisma.$inducks_issuerangePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_issuerange that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issuerangeFindFirstOrThrowArgs} args - Arguments to find a Inducks_issuerange
     * @example
     * // Get one Inducks_issuerange
     * const inducks_issuerange = await prisma.inducks_issuerange.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_issuerangeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issuerangeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_issuerangeClient<$Result.GetResult<Prisma.$inducks_issuerangePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_issueranges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issuerangeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_issueranges
     * const inducks_issueranges = await prisma.inducks_issuerange.findMany()
     * 
     * // Get first 10 Inducks_issueranges
     * const inducks_issueranges = await prisma.inducks_issuerange.findMany({ take: 10 })
     * 
     * // Only select the `issuerangecode`
     * const inducks_issuerangeWithIssuerangecodeOnly = await prisma.inducks_issuerange.findMany({ select: { issuerangecode: true } })
     * 
    **/
    findMany<T extends inducks_issuerangeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issuerangeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_issuerangePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_issuerange.
     * @param {inducks_issuerangeCreateArgs} args - Arguments to create a Inducks_issuerange.
     * @example
     * // Create one Inducks_issuerange
     * const Inducks_issuerange = await prisma.inducks_issuerange.create({
     *   data: {
     *     // ... data to create a Inducks_issuerange
     *   }
     * })
     * 
    **/
    create<T extends inducks_issuerangeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issuerangeCreateArgs<ExtArgs>>
    ): Prisma__inducks_issuerangeClient<$Result.GetResult<Prisma.$inducks_issuerangePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_issueranges.
     *     @param {inducks_issuerangeCreateManyArgs} args - Arguments to create many Inducks_issueranges.
     *     @example
     *     // Create many Inducks_issueranges
     *     const inducks_issuerange = await prisma.inducks_issuerange.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_issuerangeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issuerangeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_issuerange.
     * @param {inducks_issuerangeDeleteArgs} args - Arguments to delete one Inducks_issuerange.
     * @example
     * // Delete one Inducks_issuerange
     * const Inducks_issuerange = await prisma.inducks_issuerange.delete({
     *   where: {
     *     // ... filter to delete one Inducks_issuerange
     *   }
     * })
     * 
    **/
    delete<T extends inducks_issuerangeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issuerangeDeleteArgs<ExtArgs>>
    ): Prisma__inducks_issuerangeClient<$Result.GetResult<Prisma.$inducks_issuerangePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_issuerange.
     * @param {inducks_issuerangeUpdateArgs} args - Arguments to update one Inducks_issuerange.
     * @example
     * // Update one Inducks_issuerange
     * const inducks_issuerange = await prisma.inducks_issuerange.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_issuerangeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issuerangeUpdateArgs<ExtArgs>>
    ): Prisma__inducks_issuerangeClient<$Result.GetResult<Prisma.$inducks_issuerangePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_issueranges.
     * @param {inducks_issuerangeDeleteManyArgs} args - Arguments to filter Inducks_issueranges to delete.
     * @example
     * // Delete a few Inducks_issueranges
     * const { count } = await prisma.inducks_issuerange.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_issuerangeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issuerangeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_issueranges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issuerangeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_issueranges
     * const inducks_issuerange = await prisma.inducks_issuerange.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_issuerangeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issuerangeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_issuerange.
     * @param {inducks_issuerangeUpsertArgs} args - Arguments to update or create a Inducks_issuerange.
     * @example
     * // Update or create a Inducks_issuerange
     * const inducks_issuerange = await prisma.inducks_issuerange.upsert({
     *   create: {
     *     // ... data to create a Inducks_issuerange
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_issuerange we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_issuerangeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issuerangeUpsertArgs<ExtArgs>>
    ): Prisma__inducks_issuerangeClient<$Result.GetResult<Prisma.$inducks_issuerangePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_issueranges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issuerangeCountArgs} args - Arguments to filter Inducks_issueranges to count.
     * @example
     * // Count the number of Inducks_issueranges
     * const count = await prisma.inducks_issuerange.count({
     *   where: {
     *     // ... the filter for the Inducks_issueranges we want to count
     *   }
     * })
    **/
    count<T extends inducks_issuerangeCountArgs>(
      args?: Subset<T, inducks_issuerangeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_issuerangeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_issuerange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_issuerangeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_issuerangeAggregateArgs>(args: Subset<T, Inducks_issuerangeAggregateArgs>): Prisma.PrismaPromise<GetInducks_issuerangeAggregateType<T>>

    /**
     * Group by Inducks_issuerange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issuerangeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_issuerangeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_issuerangeGroupByArgs['orderBy'] }
        : { orderBy?: inducks_issuerangeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_issuerangeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_issuerangeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_issuerange model
   */
  readonly fields: inducks_issuerangeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_issuerange.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_issuerangeClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_issuerange model
   */ 
  interface inducks_issuerangeFieldRefs {
    readonly issuerangecode: FieldRef<"inducks_issuerange", 'String'>
    readonly publicationcode: FieldRef<"inducks_issuerange", 'String'>
    readonly title: FieldRef<"inducks_issuerange", 'String'>
    readonly circulation: FieldRef<"inducks_issuerange", 'String'>
    readonly issuerangecomment: FieldRef<"inducks_issuerange", 'String'>
    readonly numbersarefake: FieldRef<"inducks_issuerange", 'inducks_issuerange_numbersarefake'>
    readonly error: FieldRef<"inducks_issuerange", 'inducks_issuerange_error'>
  }
    

  // Custom InputTypes

  /**
   * inducks_issuerange findUnique
   */
  export type inducks_issuerangeFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuerange
     */
    select?: inducks_issuerangeSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issuerange to fetch.
     */
    where: inducks_issuerangeWhereUniqueInput
  }


  /**
   * inducks_issuerange findUniqueOrThrow
   */
  export type inducks_issuerangeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuerange
     */
    select?: inducks_issuerangeSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issuerange to fetch.
     */
    where: inducks_issuerangeWhereUniqueInput
  }


  /**
   * inducks_issuerange findFirst
   */
  export type inducks_issuerangeFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuerange
     */
    select?: inducks_issuerangeSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issuerange to fetch.
     */
    where?: inducks_issuerangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_issueranges to fetch.
     */
    orderBy?: inducks_issuerangeOrderByWithRelationInput | inducks_issuerangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_issueranges.
     */
    cursor?: inducks_issuerangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_issueranges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_issueranges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_issueranges.
     */
    distinct?: Inducks_issuerangeScalarFieldEnum | Inducks_issuerangeScalarFieldEnum[]
  }


  /**
   * inducks_issuerange findFirstOrThrow
   */
  export type inducks_issuerangeFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuerange
     */
    select?: inducks_issuerangeSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issuerange to fetch.
     */
    where?: inducks_issuerangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_issueranges to fetch.
     */
    orderBy?: inducks_issuerangeOrderByWithRelationInput | inducks_issuerangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_issueranges.
     */
    cursor?: inducks_issuerangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_issueranges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_issueranges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_issueranges.
     */
    distinct?: Inducks_issuerangeScalarFieldEnum | Inducks_issuerangeScalarFieldEnum[]
  }


  /**
   * inducks_issuerange findMany
   */
  export type inducks_issuerangeFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuerange
     */
    select?: inducks_issuerangeSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issueranges to fetch.
     */
    where?: inducks_issuerangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_issueranges to fetch.
     */
    orderBy?: inducks_issuerangeOrderByWithRelationInput | inducks_issuerangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_issueranges.
     */
    cursor?: inducks_issuerangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_issueranges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_issueranges.
     */
    skip?: number
    distinct?: Inducks_issuerangeScalarFieldEnum | Inducks_issuerangeScalarFieldEnum[]
  }


  /**
   * inducks_issuerange create
   */
  export type inducks_issuerangeCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuerange
     */
    select?: inducks_issuerangeSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_issuerange.
     */
    data: XOR<inducks_issuerangeCreateInput, inducks_issuerangeUncheckedCreateInput>
  }


  /**
   * inducks_issuerange createMany
   */
  export type inducks_issuerangeCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_issueranges.
     */
    data: inducks_issuerangeCreateManyInput | inducks_issuerangeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_issuerange update
   */
  export type inducks_issuerangeUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuerange
     */
    select?: inducks_issuerangeSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_issuerange.
     */
    data: XOR<inducks_issuerangeUpdateInput, inducks_issuerangeUncheckedUpdateInput>
    /**
     * Choose, which inducks_issuerange to update.
     */
    where: inducks_issuerangeWhereUniqueInput
  }


  /**
   * inducks_issuerange updateMany
   */
  export type inducks_issuerangeUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_issueranges.
     */
    data: XOR<inducks_issuerangeUpdateManyMutationInput, inducks_issuerangeUncheckedUpdateManyInput>
    /**
     * Filter which inducks_issueranges to update
     */
    where?: inducks_issuerangeWhereInput
  }


  /**
   * inducks_issuerange upsert
   */
  export type inducks_issuerangeUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuerange
     */
    select?: inducks_issuerangeSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_issuerange to update in case it exists.
     */
    where: inducks_issuerangeWhereUniqueInput
    /**
     * In case the inducks_issuerange found by the `where` argument doesn't exist, create a new inducks_issuerange with this data.
     */
    create: XOR<inducks_issuerangeCreateInput, inducks_issuerangeUncheckedCreateInput>
    /**
     * In case the inducks_issuerange was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_issuerangeUpdateInput, inducks_issuerangeUncheckedUpdateInput>
  }


  /**
   * inducks_issuerange delete
   */
  export type inducks_issuerangeDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuerange
     */
    select?: inducks_issuerangeSelect<ExtArgs> | null
    /**
     * Filter which inducks_issuerange to delete.
     */
    where: inducks_issuerangeWhereUniqueInput
  }


  /**
   * inducks_issuerange deleteMany
   */
  export type inducks_issuerangeDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_issueranges to delete
     */
    where?: inducks_issuerangeWhereInput
  }


  /**
   * inducks_issuerange without action
   */
  export type inducks_issuerangeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issuerange
     */
    select?: inducks_issuerangeSelect<ExtArgs> | null
  }



  /**
   * Model inducks_issueurl
   */

  export type AggregateInducks_issueurl = {
    _count: Inducks_issueurlCountAggregateOutputType | null
    _min: Inducks_issueurlMinAggregateOutputType | null
    _max: Inducks_issueurlMaxAggregateOutputType | null
  }

  export type Inducks_issueurlMinAggregateOutputType = {
    issuecode: string | null
    sitecode: string | null
    url: string | null
  }

  export type Inducks_issueurlMaxAggregateOutputType = {
    issuecode: string | null
    sitecode: string | null
    url: string | null
  }

  export type Inducks_issueurlCountAggregateOutputType = {
    issuecode: number
    sitecode: number
    url: number
    _all: number
  }


  export type Inducks_issueurlMinAggregateInputType = {
    issuecode?: true
    sitecode?: true
    url?: true
  }

  export type Inducks_issueurlMaxAggregateInputType = {
    issuecode?: true
    sitecode?: true
    url?: true
  }

  export type Inducks_issueurlCountAggregateInputType = {
    issuecode?: true
    sitecode?: true
    url?: true
    _all?: true
  }

  export type Inducks_issueurlAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_issueurl to aggregate.
     */
    where?: inducks_issueurlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_issueurls to fetch.
     */
    orderBy?: inducks_issueurlOrderByWithRelationInput | inducks_issueurlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_issueurlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_issueurls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_issueurls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_issueurls
    **/
    _count?: true | Inducks_issueurlCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_issueurlMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_issueurlMaxAggregateInputType
  }

  export type GetInducks_issueurlAggregateType<T extends Inducks_issueurlAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_issueurl]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_issueurl[P]>
      : GetScalarType<T[P], AggregateInducks_issueurl[P]>
  }




  export type inducks_issueurlGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_issueurlWhereInput
    orderBy?: inducks_issueurlOrderByWithAggregationInput | inducks_issueurlOrderByWithAggregationInput[]
    by: Inducks_issueurlScalarFieldEnum[] | Inducks_issueurlScalarFieldEnum
    having?: inducks_issueurlScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_issueurlCountAggregateInputType | true
    _min?: Inducks_issueurlMinAggregateInputType
    _max?: Inducks_issueurlMaxAggregateInputType
  }

  export type Inducks_issueurlGroupByOutputType = {
    issuecode: string
    sitecode: string
    url: string | null
    _count: Inducks_issueurlCountAggregateOutputType | null
    _min: Inducks_issueurlMinAggregateOutputType | null
    _max: Inducks_issueurlMaxAggregateOutputType | null
  }

  type GetInducks_issueurlGroupByPayload<T extends inducks_issueurlGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_issueurlGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_issueurlGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_issueurlGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_issueurlGroupByOutputType[P]>
        }
      >
    >


  export type inducks_issueurlSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    issuecode?: boolean
    sitecode?: boolean
    url?: boolean
  }, ExtArgs["result"]["inducks_issueurl"]>

  export type inducks_issueurlSelectScalar = {
    issuecode?: boolean
    sitecode?: boolean
    url?: boolean
  }


  export type $inducks_issueurlPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_issueurl"
    objects: {}
    scalars: $Extensions.GetResult<{
      issuecode: string
      sitecode: string
      url: string | null
    }, ExtArgs["result"]["inducks_issueurl"]>
    composites: {}
  }


  type inducks_issueurlGetPayload<S extends boolean | null | undefined | inducks_issueurlDefaultArgs> = $Result.GetResult<Prisma.$inducks_issueurlPayload, S>

  type inducks_issueurlCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_issueurlFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_issueurlCountAggregateInputType | true
    }

  export interface inducks_issueurlDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_issueurl'], meta: { name: 'inducks_issueurl' } }
    /**
     * Find zero or one Inducks_issueurl that matches the filter.
     * @param {inducks_issueurlFindUniqueArgs} args - Arguments to find a Inducks_issueurl
     * @example
     * // Get one Inducks_issueurl
     * const inducks_issueurl = await prisma.inducks_issueurl.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_issueurlFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issueurlFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_issueurlClient<$Result.GetResult<Prisma.$inducks_issueurlPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_issueurl that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_issueurlFindUniqueOrThrowArgs} args - Arguments to find a Inducks_issueurl
     * @example
     * // Get one Inducks_issueurl
     * const inducks_issueurl = await prisma.inducks_issueurl.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_issueurlFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issueurlFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_issueurlClient<$Result.GetResult<Prisma.$inducks_issueurlPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_issueurl that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issueurlFindFirstArgs} args - Arguments to find a Inducks_issueurl
     * @example
     * // Get one Inducks_issueurl
     * const inducks_issueurl = await prisma.inducks_issueurl.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_issueurlFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issueurlFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_issueurlClient<$Result.GetResult<Prisma.$inducks_issueurlPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_issueurl that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issueurlFindFirstOrThrowArgs} args - Arguments to find a Inducks_issueurl
     * @example
     * // Get one Inducks_issueurl
     * const inducks_issueurl = await prisma.inducks_issueurl.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_issueurlFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issueurlFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_issueurlClient<$Result.GetResult<Prisma.$inducks_issueurlPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_issueurls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issueurlFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_issueurls
     * const inducks_issueurls = await prisma.inducks_issueurl.findMany()
     * 
     * // Get first 10 Inducks_issueurls
     * const inducks_issueurls = await prisma.inducks_issueurl.findMany({ take: 10 })
     * 
     * // Only select the `issuecode`
     * const inducks_issueurlWithIssuecodeOnly = await prisma.inducks_issueurl.findMany({ select: { issuecode: true } })
     * 
    **/
    findMany<T extends inducks_issueurlFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issueurlFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_issueurlPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_issueurl.
     * @param {inducks_issueurlCreateArgs} args - Arguments to create a Inducks_issueurl.
     * @example
     * // Create one Inducks_issueurl
     * const Inducks_issueurl = await prisma.inducks_issueurl.create({
     *   data: {
     *     // ... data to create a Inducks_issueurl
     *   }
     * })
     * 
    **/
    create<T extends inducks_issueurlCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issueurlCreateArgs<ExtArgs>>
    ): Prisma__inducks_issueurlClient<$Result.GetResult<Prisma.$inducks_issueurlPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_issueurls.
     *     @param {inducks_issueurlCreateManyArgs} args - Arguments to create many Inducks_issueurls.
     *     @example
     *     // Create many Inducks_issueurls
     *     const inducks_issueurl = await prisma.inducks_issueurl.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_issueurlCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issueurlCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_issueurl.
     * @param {inducks_issueurlDeleteArgs} args - Arguments to delete one Inducks_issueurl.
     * @example
     * // Delete one Inducks_issueurl
     * const Inducks_issueurl = await prisma.inducks_issueurl.delete({
     *   where: {
     *     // ... filter to delete one Inducks_issueurl
     *   }
     * })
     * 
    **/
    delete<T extends inducks_issueurlDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issueurlDeleteArgs<ExtArgs>>
    ): Prisma__inducks_issueurlClient<$Result.GetResult<Prisma.$inducks_issueurlPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_issueurl.
     * @param {inducks_issueurlUpdateArgs} args - Arguments to update one Inducks_issueurl.
     * @example
     * // Update one Inducks_issueurl
     * const inducks_issueurl = await prisma.inducks_issueurl.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_issueurlUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issueurlUpdateArgs<ExtArgs>>
    ): Prisma__inducks_issueurlClient<$Result.GetResult<Prisma.$inducks_issueurlPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_issueurls.
     * @param {inducks_issueurlDeleteManyArgs} args - Arguments to filter Inducks_issueurls to delete.
     * @example
     * // Delete a few Inducks_issueurls
     * const { count } = await prisma.inducks_issueurl.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_issueurlDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_issueurlDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_issueurls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issueurlUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_issueurls
     * const inducks_issueurl = await prisma.inducks_issueurl.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_issueurlUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issueurlUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_issueurl.
     * @param {inducks_issueurlUpsertArgs} args - Arguments to update or create a Inducks_issueurl.
     * @example
     * // Update or create a Inducks_issueurl
     * const inducks_issueurl = await prisma.inducks_issueurl.upsert({
     *   create: {
     *     // ... data to create a Inducks_issueurl
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_issueurl we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_issueurlUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_issueurlUpsertArgs<ExtArgs>>
    ): Prisma__inducks_issueurlClient<$Result.GetResult<Prisma.$inducks_issueurlPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_issueurls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issueurlCountArgs} args - Arguments to filter Inducks_issueurls to count.
     * @example
     * // Count the number of Inducks_issueurls
     * const count = await prisma.inducks_issueurl.count({
     *   where: {
     *     // ... the filter for the Inducks_issueurls we want to count
     *   }
     * })
    **/
    count<T extends inducks_issueurlCountArgs>(
      args?: Subset<T, inducks_issueurlCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_issueurlCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_issueurl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_issueurlAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_issueurlAggregateArgs>(args: Subset<T, Inducks_issueurlAggregateArgs>): Prisma.PrismaPromise<GetInducks_issueurlAggregateType<T>>

    /**
     * Group by Inducks_issueurl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_issueurlGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_issueurlGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_issueurlGroupByArgs['orderBy'] }
        : { orderBy?: inducks_issueurlGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_issueurlGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_issueurlGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_issueurl model
   */
  readonly fields: inducks_issueurlFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_issueurl.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_issueurlClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_issueurl model
   */ 
  interface inducks_issueurlFieldRefs {
    readonly issuecode: FieldRef<"inducks_issueurl", 'String'>
    readonly sitecode: FieldRef<"inducks_issueurl", 'String'>
    readonly url: FieldRef<"inducks_issueurl", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_issueurl findUnique
   */
  export type inducks_issueurlFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issueurl
     */
    select?: inducks_issueurlSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issueurl to fetch.
     */
    where: inducks_issueurlWhereUniqueInput
  }


  /**
   * inducks_issueurl findUniqueOrThrow
   */
  export type inducks_issueurlFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issueurl
     */
    select?: inducks_issueurlSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issueurl to fetch.
     */
    where: inducks_issueurlWhereUniqueInput
  }


  /**
   * inducks_issueurl findFirst
   */
  export type inducks_issueurlFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issueurl
     */
    select?: inducks_issueurlSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issueurl to fetch.
     */
    where?: inducks_issueurlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_issueurls to fetch.
     */
    orderBy?: inducks_issueurlOrderByWithRelationInput | inducks_issueurlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_issueurls.
     */
    cursor?: inducks_issueurlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_issueurls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_issueurls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_issueurls.
     */
    distinct?: Inducks_issueurlScalarFieldEnum | Inducks_issueurlScalarFieldEnum[]
  }


  /**
   * inducks_issueurl findFirstOrThrow
   */
  export type inducks_issueurlFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issueurl
     */
    select?: inducks_issueurlSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issueurl to fetch.
     */
    where?: inducks_issueurlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_issueurls to fetch.
     */
    orderBy?: inducks_issueurlOrderByWithRelationInput | inducks_issueurlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_issueurls.
     */
    cursor?: inducks_issueurlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_issueurls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_issueurls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_issueurls.
     */
    distinct?: Inducks_issueurlScalarFieldEnum | Inducks_issueurlScalarFieldEnum[]
  }


  /**
   * inducks_issueurl findMany
   */
  export type inducks_issueurlFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issueurl
     */
    select?: inducks_issueurlSelect<ExtArgs> | null
    /**
     * Filter, which inducks_issueurls to fetch.
     */
    where?: inducks_issueurlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_issueurls to fetch.
     */
    orderBy?: inducks_issueurlOrderByWithRelationInput | inducks_issueurlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_issueurls.
     */
    cursor?: inducks_issueurlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_issueurls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_issueurls.
     */
    skip?: number
    distinct?: Inducks_issueurlScalarFieldEnum | Inducks_issueurlScalarFieldEnum[]
  }


  /**
   * inducks_issueurl create
   */
  export type inducks_issueurlCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issueurl
     */
    select?: inducks_issueurlSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_issueurl.
     */
    data: XOR<inducks_issueurlCreateInput, inducks_issueurlUncheckedCreateInput>
  }


  /**
   * inducks_issueurl createMany
   */
  export type inducks_issueurlCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_issueurls.
     */
    data: inducks_issueurlCreateManyInput | inducks_issueurlCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_issueurl update
   */
  export type inducks_issueurlUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issueurl
     */
    select?: inducks_issueurlSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_issueurl.
     */
    data: XOR<inducks_issueurlUpdateInput, inducks_issueurlUncheckedUpdateInput>
    /**
     * Choose, which inducks_issueurl to update.
     */
    where: inducks_issueurlWhereUniqueInput
  }


  /**
   * inducks_issueurl updateMany
   */
  export type inducks_issueurlUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_issueurls.
     */
    data: XOR<inducks_issueurlUpdateManyMutationInput, inducks_issueurlUncheckedUpdateManyInput>
    /**
     * Filter which inducks_issueurls to update
     */
    where?: inducks_issueurlWhereInput
  }


  /**
   * inducks_issueurl upsert
   */
  export type inducks_issueurlUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issueurl
     */
    select?: inducks_issueurlSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_issueurl to update in case it exists.
     */
    where: inducks_issueurlWhereUniqueInput
    /**
     * In case the inducks_issueurl found by the `where` argument doesn't exist, create a new inducks_issueurl with this data.
     */
    create: XOR<inducks_issueurlCreateInput, inducks_issueurlUncheckedCreateInput>
    /**
     * In case the inducks_issueurl was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_issueurlUpdateInput, inducks_issueurlUncheckedUpdateInput>
  }


  /**
   * inducks_issueurl delete
   */
  export type inducks_issueurlDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issueurl
     */
    select?: inducks_issueurlSelect<ExtArgs> | null
    /**
     * Filter which inducks_issueurl to delete.
     */
    where: inducks_issueurlWhereUniqueInput
  }


  /**
   * inducks_issueurl deleteMany
   */
  export type inducks_issueurlDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_issueurls to delete
     */
    where?: inducks_issueurlWhereInput
  }


  /**
   * inducks_issueurl without action
   */
  export type inducks_issueurlDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_issueurl
     */
    select?: inducks_issueurlSelect<ExtArgs> | null
  }



  /**
   * Model inducks_language
   */

  export type AggregateInducks_language = {
    _count: Inducks_languageCountAggregateOutputType | null
    _min: Inducks_languageMinAggregateOutputType | null
    _max: Inducks_languageMaxAggregateOutputType | null
  }

  export type Inducks_languageMinAggregateOutputType = {
    languagecode: string | null
    defaultlanguagecode: string | null
    languagename: string | null
  }

  export type Inducks_languageMaxAggregateOutputType = {
    languagecode: string | null
    defaultlanguagecode: string | null
    languagename: string | null
  }

  export type Inducks_languageCountAggregateOutputType = {
    languagecode: number
    defaultlanguagecode: number
    languagename: number
    _all: number
  }


  export type Inducks_languageMinAggregateInputType = {
    languagecode?: true
    defaultlanguagecode?: true
    languagename?: true
  }

  export type Inducks_languageMaxAggregateInputType = {
    languagecode?: true
    defaultlanguagecode?: true
    languagename?: true
  }

  export type Inducks_languageCountAggregateInputType = {
    languagecode?: true
    defaultlanguagecode?: true
    languagename?: true
    _all?: true
  }

  export type Inducks_languageAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_language to aggregate.
     */
    where?: inducks_languageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_languages to fetch.
     */
    orderBy?: inducks_languageOrderByWithRelationInput | inducks_languageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_languageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_languages
    **/
    _count?: true | Inducks_languageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_languageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_languageMaxAggregateInputType
  }

  export type GetInducks_languageAggregateType<T extends Inducks_languageAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_language]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_language[P]>
      : GetScalarType<T[P], AggregateInducks_language[P]>
  }




  export type inducks_languageGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_languageWhereInput
    orderBy?: inducks_languageOrderByWithAggregationInput | inducks_languageOrderByWithAggregationInput[]
    by: Inducks_languageScalarFieldEnum[] | Inducks_languageScalarFieldEnum
    having?: inducks_languageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_languageCountAggregateInputType | true
    _min?: Inducks_languageMinAggregateInputType
    _max?: Inducks_languageMaxAggregateInputType
  }

  export type Inducks_languageGroupByOutputType = {
    languagecode: string
    defaultlanguagecode: string | null
    languagename: string | null
    _count: Inducks_languageCountAggregateOutputType | null
    _min: Inducks_languageMinAggregateOutputType | null
    _max: Inducks_languageMaxAggregateOutputType | null
  }

  type GetInducks_languageGroupByPayload<T extends inducks_languageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_languageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_languageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_languageGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_languageGroupByOutputType[P]>
        }
      >
    >


  export type inducks_languageSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    languagecode?: boolean
    defaultlanguagecode?: boolean
    languagename?: boolean
  }, ExtArgs["result"]["inducks_language"]>

  export type inducks_languageSelectScalar = {
    languagecode?: boolean
    defaultlanguagecode?: boolean
    languagename?: boolean
  }


  export type $inducks_languagePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_language"
    objects: {}
    scalars: $Extensions.GetResult<{
      languagecode: string
      defaultlanguagecode: string | null
      languagename: string | null
    }, ExtArgs["result"]["inducks_language"]>
    composites: {}
  }


  type inducks_languageGetPayload<S extends boolean | null | undefined | inducks_languageDefaultArgs> = $Result.GetResult<Prisma.$inducks_languagePayload, S>

  type inducks_languageCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_languageFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_languageCountAggregateInputType | true
    }

  export interface inducks_languageDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_language'], meta: { name: 'inducks_language' } }
    /**
     * Find zero or one Inducks_language that matches the filter.
     * @param {inducks_languageFindUniqueArgs} args - Arguments to find a Inducks_language
     * @example
     * // Get one Inducks_language
     * const inducks_language = await prisma.inducks_language.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_languageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_languageFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_languageClient<$Result.GetResult<Prisma.$inducks_languagePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_language that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_languageFindUniqueOrThrowArgs} args - Arguments to find a Inducks_language
     * @example
     * // Get one Inducks_language
     * const inducks_language = await prisma.inducks_language.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_languageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_languageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_languageClient<$Result.GetResult<Prisma.$inducks_languagePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_language that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_languageFindFirstArgs} args - Arguments to find a Inducks_language
     * @example
     * // Get one Inducks_language
     * const inducks_language = await prisma.inducks_language.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_languageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_languageFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_languageClient<$Result.GetResult<Prisma.$inducks_languagePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_language that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_languageFindFirstOrThrowArgs} args - Arguments to find a Inducks_language
     * @example
     * // Get one Inducks_language
     * const inducks_language = await prisma.inducks_language.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_languageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_languageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_languageClient<$Result.GetResult<Prisma.$inducks_languagePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_languages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_languageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_languages
     * const inducks_languages = await prisma.inducks_language.findMany()
     * 
     * // Get first 10 Inducks_languages
     * const inducks_languages = await prisma.inducks_language.findMany({ take: 10 })
     * 
     * // Only select the `languagecode`
     * const inducks_languageWithLanguagecodeOnly = await prisma.inducks_language.findMany({ select: { languagecode: true } })
     * 
    **/
    findMany<T extends inducks_languageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_languageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_languagePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_language.
     * @param {inducks_languageCreateArgs} args - Arguments to create a Inducks_language.
     * @example
     * // Create one Inducks_language
     * const Inducks_language = await prisma.inducks_language.create({
     *   data: {
     *     // ... data to create a Inducks_language
     *   }
     * })
     * 
    **/
    create<T extends inducks_languageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_languageCreateArgs<ExtArgs>>
    ): Prisma__inducks_languageClient<$Result.GetResult<Prisma.$inducks_languagePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_languages.
     *     @param {inducks_languageCreateManyArgs} args - Arguments to create many Inducks_languages.
     *     @example
     *     // Create many Inducks_languages
     *     const inducks_language = await prisma.inducks_language.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_languageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_languageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_language.
     * @param {inducks_languageDeleteArgs} args - Arguments to delete one Inducks_language.
     * @example
     * // Delete one Inducks_language
     * const Inducks_language = await prisma.inducks_language.delete({
     *   where: {
     *     // ... filter to delete one Inducks_language
     *   }
     * })
     * 
    **/
    delete<T extends inducks_languageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_languageDeleteArgs<ExtArgs>>
    ): Prisma__inducks_languageClient<$Result.GetResult<Prisma.$inducks_languagePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_language.
     * @param {inducks_languageUpdateArgs} args - Arguments to update one Inducks_language.
     * @example
     * // Update one Inducks_language
     * const inducks_language = await prisma.inducks_language.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_languageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_languageUpdateArgs<ExtArgs>>
    ): Prisma__inducks_languageClient<$Result.GetResult<Prisma.$inducks_languagePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_languages.
     * @param {inducks_languageDeleteManyArgs} args - Arguments to filter Inducks_languages to delete.
     * @example
     * // Delete a few Inducks_languages
     * const { count } = await prisma.inducks_language.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_languageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_languageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_languageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_languages
     * const inducks_language = await prisma.inducks_language.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_languageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_languageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_language.
     * @param {inducks_languageUpsertArgs} args - Arguments to update or create a Inducks_language.
     * @example
     * // Update or create a Inducks_language
     * const inducks_language = await prisma.inducks_language.upsert({
     *   create: {
     *     // ... data to create a Inducks_language
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_language we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_languageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_languageUpsertArgs<ExtArgs>>
    ): Prisma__inducks_languageClient<$Result.GetResult<Prisma.$inducks_languagePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_languageCountArgs} args - Arguments to filter Inducks_languages to count.
     * @example
     * // Count the number of Inducks_languages
     * const count = await prisma.inducks_language.count({
     *   where: {
     *     // ... the filter for the Inducks_languages we want to count
     *   }
     * })
    **/
    count<T extends inducks_languageCountArgs>(
      args?: Subset<T, inducks_languageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_languageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_languageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_languageAggregateArgs>(args: Subset<T, Inducks_languageAggregateArgs>): Prisma.PrismaPromise<GetInducks_languageAggregateType<T>>

    /**
     * Group by Inducks_language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_languageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_languageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_languageGroupByArgs['orderBy'] }
        : { orderBy?: inducks_languageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_languageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_languageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_language model
   */
  readonly fields: inducks_languageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_language.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_languageClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_language model
   */ 
  interface inducks_languageFieldRefs {
    readonly languagecode: FieldRef<"inducks_language", 'String'>
    readonly defaultlanguagecode: FieldRef<"inducks_language", 'String'>
    readonly languagename: FieldRef<"inducks_language", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_language findUnique
   */
  export type inducks_languageFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_language
     */
    select?: inducks_languageSelect<ExtArgs> | null
    /**
     * Filter, which inducks_language to fetch.
     */
    where: inducks_languageWhereUniqueInput
  }


  /**
   * inducks_language findUniqueOrThrow
   */
  export type inducks_languageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_language
     */
    select?: inducks_languageSelect<ExtArgs> | null
    /**
     * Filter, which inducks_language to fetch.
     */
    where: inducks_languageWhereUniqueInput
  }


  /**
   * inducks_language findFirst
   */
  export type inducks_languageFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_language
     */
    select?: inducks_languageSelect<ExtArgs> | null
    /**
     * Filter, which inducks_language to fetch.
     */
    where?: inducks_languageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_languages to fetch.
     */
    orderBy?: inducks_languageOrderByWithRelationInput | inducks_languageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_languages.
     */
    cursor?: inducks_languageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_languages.
     */
    distinct?: Inducks_languageScalarFieldEnum | Inducks_languageScalarFieldEnum[]
  }


  /**
   * inducks_language findFirstOrThrow
   */
  export type inducks_languageFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_language
     */
    select?: inducks_languageSelect<ExtArgs> | null
    /**
     * Filter, which inducks_language to fetch.
     */
    where?: inducks_languageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_languages to fetch.
     */
    orderBy?: inducks_languageOrderByWithRelationInput | inducks_languageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_languages.
     */
    cursor?: inducks_languageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_languages.
     */
    distinct?: Inducks_languageScalarFieldEnum | Inducks_languageScalarFieldEnum[]
  }


  /**
   * inducks_language findMany
   */
  export type inducks_languageFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_language
     */
    select?: inducks_languageSelect<ExtArgs> | null
    /**
     * Filter, which inducks_languages to fetch.
     */
    where?: inducks_languageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_languages to fetch.
     */
    orderBy?: inducks_languageOrderByWithRelationInput | inducks_languageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_languages.
     */
    cursor?: inducks_languageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_languages.
     */
    skip?: number
    distinct?: Inducks_languageScalarFieldEnum | Inducks_languageScalarFieldEnum[]
  }


  /**
   * inducks_language create
   */
  export type inducks_languageCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_language
     */
    select?: inducks_languageSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_language.
     */
    data: XOR<inducks_languageCreateInput, inducks_languageUncheckedCreateInput>
  }


  /**
   * inducks_language createMany
   */
  export type inducks_languageCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_languages.
     */
    data: inducks_languageCreateManyInput | inducks_languageCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_language update
   */
  export type inducks_languageUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_language
     */
    select?: inducks_languageSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_language.
     */
    data: XOR<inducks_languageUpdateInput, inducks_languageUncheckedUpdateInput>
    /**
     * Choose, which inducks_language to update.
     */
    where: inducks_languageWhereUniqueInput
  }


  /**
   * inducks_language updateMany
   */
  export type inducks_languageUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_languages.
     */
    data: XOR<inducks_languageUpdateManyMutationInput, inducks_languageUncheckedUpdateManyInput>
    /**
     * Filter which inducks_languages to update
     */
    where?: inducks_languageWhereInput
  }


  /**
   * inducks_language upsert
   */
  export type inducks_languageUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_language
     */
    select?: inducks_languageSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_language to update in case it exists.
     */
    where: inducks_languageWhereUniqueInput
    /**
     * In case the inducks_language found by the `where` argument doesn't exist, create a new inducks_language with this data.
     */
    create: XOR<inducks_languageCreateInput, inducks_languageUncheckedCreateInput>
    /**
     * In case the inducks_language was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_languageUpdateInput, inducks_languageUncheckedUpdateInput>
  }


  /**
   * inducks_language delete
   */
  export type inducks_languageDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_language
     */
    select?: inducks_languageSelect<ExtArgs> | null
    /**
     * Filter which inducks_language to delete.
     */
    where: inducks_languageWhereUniqueInput
  }


  /**
   * inducks_language deleteMany
   */
  export type inducks_languageDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_languages to delete
     */
    where?: inducks_languageWhereInput
  }


  /**
   * inducks_language without action
   */
  export type inducks_languageDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_language
     */
    select?: inducks_languageSelect<ExtArgs> | null
  }



  /**
   * Model inducks_languagename
   */

  export type AggregateInducks_languagename = {
    _count: Inducks_languagenameCountAggregateOutputType | null
    _min: Inducks_languagenameMinAggregateOutputType | null
    _max: Inducks_languagenameMaxAggregateOutputType | null
  }

  export type Inducks_languagenameMinAggregateOutputType = {
    desclanguagecode: string | null
    languagecode: string | null
    languagename: string | null
  }

  export type Inducks_languagenameMaxAggregateOutputType = {
    desclanguagecode: string | null
    languagecode: string | null
    languagename: string | null
  }

  export type Inducks_languagenameCountAggregateOutputType = {
    desclanguagecode: number
    languagecode: number
    languagename: number
    _all: number
  }


  export type Inducks_languagenameMinAggregateInputType = {
    desclanguagecode?: true
    languagecode?: true
    languagename?: true
  }

  export type Inducks_languagenameMaxAggregateInputType = {
    desclanguagecode?: true
    languagecode?: true
    languagename?: true
  }

  export type Inducks_languagenameCountAggregateInputType = {
    desclanguagecode?: true
    languagecode?: true
    languagename?: true
    _all?: true
  }

  export type Inducks_languagenameAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_languagename to aggregate.
     */
    where?: inducks_languagenameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_languagenames to fetch.
     */
    orderBy?: inducks_languagenameOrderByWithRelationInput | inducks_languagenameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_languagenameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_languagenames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_languagenames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_languagenames
    **/
    _count?: true | Inducks_languagenameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_languagenameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_languagenameMaxAggregateInputType
  }

  export type GetInducks_languagenameAggregateType<T extends Inducks_languagenameAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_languagename]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_languagename[P]>
      : GetScalarType<T[P], AggregateInducks_languagename[P]>
  }




  export type inducks_languagenameGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_languagenameWhereInput
    orderBy?: inducks_languagenameOrderByWithAggregationInput | inducks_languagenameOrderByWithAggregationInput[]
    by: Inducks_languagenameScalarFieldEnum[] | Inducks_languagenameScalarFieldEnum
    having?: inducks_languagenameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_languagenameCountAggregateInputType | true
    _min?: Inducks_languagenameMinAggregateInputType
    _max?: Inducks_languagenameMaxAggregateInputType
  }

  export type Inducks_languagenameGroupByOutputType = {
    desclanguagecode: string
    languagecode: string
    languagename: string | null
    _count: Inducks_languagenameCountAggregateOutputType | null
    _min: Inducks_languagenameMinAggregateOutputType | null
    _max: Inducks_languagenameMaxAggregateOutputType | null
  }

  type GetInducks_languagenameGroupByPayload<T extends inducks_languagenameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_languagenameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_languagenameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_languagenameGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_languagenameGroupByOutputType[P]>
        }
      >
    >


  export type inducks_languagenameSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    desclanguagecode?: boolean
    languagecode?: boolean
    languagename?: boolean
  }, ExtArgs["result"]["inducks_languagename"]>

  export type inducks_languagenameSelectScalar = {
    desclanguagecode?: boolean
    languagecode?: boolean
    languagename?: boolean
  }


  export type $inducks_languagenamePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_languagename"
    objects: {}
    scalars: $Extensions.GetResult<{
      desclanguagecode: string
      languagecode: string
      languagename: string | null
    }, ExtArgs["result"]["inducks_languagename"]>
    composites: {}
  }


  type inducks_languagenameGetPayload<S extends boolean | null | undefined | inducks_languagenameDefaultArgs> = $Result.GetResult<Prisma.$inducks_languagenamePayload, S>

  type inducks_languagenameCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_languagenameFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_languagenameCountAggregateInputType | true
    }

  export interface inducks_languagenameDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_languagename'], meta: { name: 'inducks_languagename' } }
    /**
     * Find zero or one Inducks_languagename that matches the filter.
     * @param {inducks_languagenameFindUniqueArgs} args - Arguments to find a Inducks_languagename
     * @example
     * // Get one Inducks_languagename
     * const inducks_languagename = await prisma.inducks_languagename.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_languagenameFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_languagenameFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_languagenameClient<$Result.GetResult<Prisma.$inducks_languagenamePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_languagename that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_languagenameFindUniqueOrThrowArgs} args - Arguments to find a Inducks_languagename
     * @example
     * // Get one Inducks_languagename
     * const inducks_languagename = await prisma.inducks_languagename.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_languagenameFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_languagenameFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_languagenameClient<$Result.GetResult<Prisma.$inducks_languagenamePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_languagename that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_languagenameFindFirstArgs} args - Arguments to find a Inducks_languagename
     * @example
     * // Get one Inducks_languagename
     * const inducks_languagename = await prisma.inducks_languagename.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_languagenameFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_languagenameFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_languagenameClient<$Result.GetResult<Prisma.$inducks_languagenamePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_languagename that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_languagenameFindFirstOrThrowArgs} args - Arguments to find a Inducks_languagename
     * @example
     * // Get one Inducks_languagename
     * const inducks_languagename = await prisma.inducks_languagename.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_languagenameFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_languagenameFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_languagenameClient<$Result.GetResult<Prisma.$inducks_languagenamePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_languagenames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_languagenameFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_languagenames
     * const inducks_languagenames = await prisma.inducks_languagename.findMany()
     * 
     * // Get first 10 Inducks_languagenames
     * const inducks_languagenames = await prisma.inducks_languagename.findMany({ take: 10 })
     * 
     * // Only select the `desclanguagecode`
     * const inducks_languagenameWithDesclanguagecodeOnly = await prisma.inducks_languagename.findMany({ select: { desclanguagecode: true } })
     * 
    **/
    findMany<T extends inducks_languagenameFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_languagenameFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_languagenamePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_languagename.
     * @param {inducks_languagenameCreateArgs} args - Arguments to create a Inducks_languagename.
     * @example
     * // Create one Inducks_languagename
     * const Inducks_languagename = await prisma.inducks_languagename.create({
     *   data: {
     *     // ... data to create a Inducks_languagename
     *   }
     * })
     * 
    **/
    create<T extends inducks_languagenameCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_languagenameCreateArgs<ExtArgs>>
    ): Prisma__inducks_languagenameClient<$Result.GetResult<Prisma.$inducks_languagenamePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_languagenames.
     *     @param {inducks_languagenameCreateManyArgs} args - Arguments to create many Inducks_languagenames.
     *     @example
     *     // Create many Inducks_languagenames
     *     const inducks_languagename = await prisma.inducks_languagename.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_languagenameCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_languagenameCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_languagename.
     * @param {inducks_languagenameDeleteArgs} args - Arguments to delete one Inducks_languagename.
     * @example
     * // Delete one Inducks_languagename
     * const Inducks_languagename = await prisma.inducks_languagename.delete({
     *   where: {
     *     // ... filter to delete one Inducks_languagename
     *   }
     * })
     * 
    **/
    delete<T extends inducks_languagenameDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_languagenameDeleteArgs<ExtArgs>>
    ): Prisma__inducks_languagenameClient<$Result.GetResult<Prisma.$inducks_languagenamePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_languagename.
     * @param {inducks_languagenameUpdateArgs} args - Arguments to update one Inducks_languagename.
     * @example
     * // Update one Inducks_languagename
     * const inducks_languagename = await prisma.inducks_languagename.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_languagenameUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_languagenameUpdateArgs<ExtArgs>>
    ): Prisma__inducks_languagenameClient<$Result.GetResult<Prisma.$inducks_languagenamePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_languagenames.
     * @param {inducks_languagenameDeleteManyArgs} args - Arguments to filter Inducks_languagenames to delete.
     * @example
     * // Delete a few Inducks_languagenames
     * const { count } = await prisma.inducks_languagename.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_languagenameDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_languagenameDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_languagenames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_languagenameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_languagenames
     * const inducks_languagename = await prisma.inducks_languagename.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_languagenameUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_languagenameUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_languagename.
     * @param {inducks_languagenameUpsertArgs} args - Arguments to update or create a Inducks_languagename.
     * @example
     * // Update or create a Inducks_languagename
     * const inducks_languagename = await prisma.inducks_languagename.upsert({
     *   create: {
     *     // ... data to create a Inducks_languagename
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_languagename we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_languagenameUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_languagenameUpsertArgs<ExtArgs>>
    ): Prisma__inducks_languagenameClient<$Result.GetResult<Prisma.$inducks_languagenamePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_languagenames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_languagenameCountArgs} args - Arguments to filter Inducks_languagenames to count.
     * @example
     * // Count the number of Inducks_languagenames
     * const count = await prisma.inducks_languagename.count({
     *   where: {
     *     // ... the filter for the Inducks_languagenames we want to count
     *   }
     * })
    **/
    count<T extends inducks_languagenameCountArgs>(
      args?: Subset<T, inducks_languagenameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_languagenameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_languagename.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_languagenameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_languagenameAggregateArgs>(args: Subset<T, Inducks_languagenameAggregateArgs>): Prisma.PrismaPromise<GetInducks_languagenameAggregateType<T>>

    /**
     * Group by Inducks_languagename.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_languagenameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_languagenameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_languagenameGroupByArgs['orderBy'] }
        : { orderBy?: inducks_languagenameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_languagenameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_languagenameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_languagename model
   */
  readonly fields: inducks_languagenameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_languagename.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_languagenameClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_languagename model
   */ 
  interface inducks_languagenameFieldRefs {
    readonly desclanguagecode: FieldRef<"inducks_languagename", 'String'>
    readonly languagecode: FieldRef<"inducks_languagename", 'String'>
    readonly languagename: FieldRef<"inducks_languagename", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_languagename findUnique
   */
  export type inducks_languagenameFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_languagename
     */
    select?: inducks_languagenameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_languagename to fetch.
     */
    where: inducks_languagenameWhereUniqueInput
  }


  /**
   * inducks_languagename findUniqueOrThrow
   */
  export type inducks_languagenameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_languagename
     */
    select?: inducks_languagenameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_languagename to fetch.
     */
    where: inducks_languagenameWhereUniqueInput
  }


  /**
   * inducks_languagename findFirst
   */
  export type inducks_languagenameFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_languagename
     */
    select?: inducks_languagenameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_languagename to fetch.
     */
    where?: inducks_languagenameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_languagenames to fetch.
     */
    orderBy?: inducks_languagenameOrderByWithRelationInput | inducks_languagenameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_languagenames.
     */
    cursor?: inducks_languagenameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_languagenames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_languagenames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_languagenames.
     */
    distinct?: Inducks_languagenameScalarFieldEnum | Inducks_languagenameScalarFieldEnum[]
  }


  /**
   * inducks_languagename findFirstOrThrow
   */
  export type inducks_languagenameFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_languagename
     */
    select?: inducks_languagenameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_languagename to fetch.
     */
    where?: inducks_languagenameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_languagenames to fetch.
     */
    orderBy?: inducks_languagenameOrderByWithRelationInput | inducks_languagenameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_languagenames.
     */
    cursor?: inducks_languagenameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_languagenames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_languagenames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_languagenames.
     */
    distinct?: Inducks_languagenameScalarFieldEnum | Inducks_languagenameScalarFieldEnum[]
  }


  /**
   * inducks_languagename findMany
   */
  export type inducks_languagenameFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_languagename
     */
    select?: inducks_languagenameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_languagenames to fetch.
     */
    where?: inducks_languagenameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_languagenames to fetch.
     */
    orderBy?: inducks_languagenameOrderByWithRelationInput | inducks_languagenameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_languagenames.
     */
    cursor?: inducks_languagenameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_languagenames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_languagenames.
     */
    skip?: number
    distinct?: Inducks_languagenameScalarFieldEnum | Inducks_languagenameScalarFieldEnum[]
  }


  /**
   * inducks_languagename create
   */
  export type inducks_languagenameCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_languagename
     */
    select?: inducks_languagenameSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_languagename.
     */
    data: XOR<inducks_languagenameCreateInput, inducks_languagenameUncheckedCreateInput>
  }


  /**
   * inducks_languagename createMany
   */
  export type inducks_languagenameCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_languagenames.
     */
    data: inducks_languagenameCreateManyInput | inducks_languagenameCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_languagename update
   */
  export type inducks_languagenameUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_languagename
     */
    select?: inducks_languagenameSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_languagename.
     */
    data: XOR<inducks_languagenameUpdateInput, inducks_languagenameUncheckedUpdateInput>
    /**
     * Choose, which inducks_languagename to update.
     */
    where: inducks_languagenameWhereUniqueInput
  }


  /**
   * inducks_languagename updateMany
   */
  export type inducks_languagenameUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_languagenames.
     */
    data: XOR<inducks_languagenameUpdateManyMutationInput, inducks_languagenameUncheckedUpdateManyInput>
    /**
     * Filter which inducks_languagenames to update
     */
    where?: inducks_languagenameWhereInput
  }


  /**
   * inducks_languagename upsert
   */
  export type inducks_languagenameUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_languagename
     */
    select?: inducks_languagenameSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_languagename to update in case it exists.
     */
    where: inducks_languagenameWhereUniqueInput
    /**
     * In case the inducks_languagename found by the `where` argument doesn't exist, create a new inducks_languagename with this data.
     */
    create: XOR<inducks_languagenameCreateInput, inducks_languagenameUncheckedCreateInput>
    /**
     * In case the inducks_languagename was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_languagenameUpdateInput, inducks_languagenameUncheckedUpdateInput>
  }


  /**
   * inducks_languagename delete
   */
  export type inducks_languagenameDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_languagename
     */
    select?: inducks_languagenameSelect<ExtArgs> | null
    /**
     * Filter which inducks_languagename to delete.
     */
    where: inducks_languagenameWhereUniqueInput
  }


  /**
   * inducks_languagename deleteMany
   */
  export type inducks_languagenameDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_languagenames to delete
     */
    where?: inducks_languagenameWhereInput
  }


  /**
   * inducks_languagename without action
   */
  export type inducks_languagenameDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_languagename
     */
    select?: inducks_languagenameSelect<ExtArgs> | null
  }



  /**
   * Model inducks_log
   */

  export type AggregateInducks_log = {
    _count: Inducks_logCountAggregateOutputType | null
    _avg: Inducks_logAvgAggregateOutputType | null
    _sum: Inducks_logSumAggregateOutputType | null
    _min: Inducks_logMinAggregateOutputType | null
    _max: Inducks_logMaxAggregateOutputType | null
  }

  export type Inducks_logAvgAggregateOutputType = {
    number: number | null
    inputfilecode: number | null
  }

  export type Inducks_logSumAggregateOutputType = {
    number: number | null
    inputfilecode: number | null
  }

  export type Inducks_logMinAggregateOutputType = {
    number: number | null
    logkey: string | null
    storycode: string | null
    logid: string | null
    logtype: string | null
    par1: string | null
    par2: string | null
    par3: string | null
    marked: $Enums.inducks_log_marked | null
    inputfilecode: number | null
    maintenanceteamcode: string | null
  }

  export type Inducks_logMaxAggregateOutputType = {
    number: number | null
    logkey: string | null
    storycode: string | null
    logid: string | null
    logtype: string | null
    par1: string | null
    par2: string | null
    par3: string | null
    marked: $Enums.inducks_log_marked | null
    inputfilecode: number | null
    maintenanceteamcode: string | null
  }

  export type Inducks_logCountAggregateOutputType = {
    number: number
    logkey: number
    storycode: number
    logid: number
    logtype: number
    par1: number
    par2: number
    par3: number
    marked: number
    inputfilecode: number
    maintenanceteamcode: number
    _all: number
  }


  export type Inducks_logAvgAggregateInputType = {
    number?: true
    inputfilecode?: true
  }

  export type Inducks_logSumAggregateInputType = {
    number?: true
    inputfilecode?: true
  }

  export type Inducks_logMinAggregateInputType = {
    number?: true
    logkey?: true
    storycode?: true
    logid?: true
    logtype?: true
    par1?: true
    par2?: true
    par3?: true
    marked?: true
    inputfilecode?: true
    maintenanceteamcode?: true
  }

  export type Inducks_logMaxAggregateInputType = {
    number?: true
    logkey?: true
    storycode?: true
    logid?: true
    logtype?: true
    par1?: true
    par2?: true
    par3?: true
    marked?: true
    inputfilecode?: true
    maintenanceteamcode?: true
  }

  export type Inducks_logCountAggregateInputType = {
    number?: true
    logkey?: true
    storycode?: true
    logid?: true
    logtype?: true
    par1?: true
    par2?: true
    par3?: true
    marked?: true
    inputfilecode?: true
    maintenanceteamcode?: true
    _all?: true
  }

  export type Inducks_logAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_log to aggregate.
     */
    where?: inducks_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_logs to fetch.
     */
    orderBy?: inducks_logOrderByWithRelationInput | inducks_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_logs
    **/
    _count?: true | Inducks_logCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Inducks_logAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Inducks_logSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_logMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_logMaxAggregateInputType
  }

  export type GetInducks_logAggregateType<T extends Inducks_logAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_log]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_log[P]>
      : GetScalarType<T[P], AggregateInducks_log[P]>
  }




  export type inducks_logGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_logWhereInput
    orderBy?: inducks_logOrderByWithAggregationInput | inducks_logOrderByWithAggregationInput[]
    by: Inducks_logScalarFieldEnum[] | Inducks_logScalarFieldEnum
    having?: inducks_logScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_logCountAggregateInputType | true
    _avg?: Inducks_logAvgAggregateInputType
    _sum?: Inducks_logSumAggregateInputType
    _min?: Inducks_logMinAggregateInputType
    _max?: Inducks_logMaxAggregateInputType
  }

  export type Inducks_logGroupByOutputType = {
    number: number
    logkey: string | null
    storycode: string | null
    logid: string | null
    logtype: string | null
    par1: string | null
    par2: string | null
    par3: string | null
    marked: $Enums.inducks_log_marked | null
    inputfilecode: number | null
    maintenanceteamcode: string | null
    _count: Inducks_logCountAggregateOutputType | null
    _avg: Inducks_logAvgAggregateOutputType | null
    _sum: Inducks_logSumAggregateOutputType | null
    _min: Inducks_logMinAggregateOutputType | null
    _max: Inducks_logMaxAggregateOutputType | null
  }

  type GetInducks_logGroupByPayload<T extends inducks_logGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_logGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_logGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_logGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_logGroupByOutputType[P]>
        }
      >
    >


  export type inducks_logSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    number?: boolean
    logkey?: boolean
    storycode?: boolean
    logid?: boolean
    logtype?: boolean
    par1?: boolean
    par2?: boolean
    par3?: boolean
    marked?: boolean
    inputfilecode?: boolean
    maintenanceteamcode?: boolean
  }, ExtArgs["result"]["inducks_log"]>

  export type inducks_logSelectScalar = {
    number?: boolean
    logkey?: boolean
    storycode?: boolean
    logid?: boolean
    logtype?: boolean
    par1?: boolean
    par2?: boolean
    par3?: boolean
    marked?: boolean
    inputfilecode?: boolean
    maintenanceteamcode?: boolean
  }


  export type $inducks_logPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_log"
    objects: {}
    scalars: $Extensions.GetResult<{
      number: number
      logkey: string | null
      storycode: string | null
      logid: string | null
      logtype: string | null
      par1: string | null
      par2: string | null
      par3: string | null
      marked: $Enums.inducks_log_marked | null
      inputfilecode: number | null
      maintenanceteamcode: string | null
    }, ExtArgs["result"]["inducks_log"]>
    composites: {}
  }


  type inducks_logGetPayload<S extends boolean | null | undefined | inducks_logDefaultArgs> = $Result.GetResult<Prisma.$inducks_logPayload, S>

  type inducks_logCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_logFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_logCountAggregateInputType | true
    }

  export interface inducks_logDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_log'], meta: { name: 'inducks_log' } }
    /**
     * Find zero or one Inducks_log that matches the filter.
     * @param {inducks_logFindUniqueArgs} args - Arguments to find a Inducks_log
     * @example
     * // Get one Inducks_log
     * const inducks_log = await prisma.inducks_log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_logFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_logFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_logClient<$Result.GetResult<Prisma.$inducks_logPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_log that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_logFindUniqueOrThrowArgs} args - Arguments to find a Inducks_log
     * @example
     * // Get one Inducks_log
     * const inducks_log = await prisma.inducks_log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_logFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_logFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_logClient<$Result.GetResult<Prisma.$inducks_logPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_logFindFirstArgs} args - Arguments to find a Inducks_log
     * @example
     * // Get one Inducks_log
     * const inducks_log = await prisma.inducks_log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_logFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_logFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_logClient<$Result.GetResult<Prisma.$inducks_logPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_logFindFirstOrThrowArgs} args - Arguments to find a Inducks_log
     * @example
     * // Get one Inducks_log
     * const inducks_log = await prisma.inducks_log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_logFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_logFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_logClient<$Result.GetResult<Prisma.$inducks_logPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_logFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_logs
     * const inducks_logs = await prisma.inducks_log.findMany()
     * 
     * // Get first 10 Inducks_logs
     * const inducks_logs = await prisma.inducks_log.findMany({ take: 10 })
     * 
     * // Only select the `number`
     * const inducks_logWithNumberOnly = await prisma.inducks_log.findMany({ select: { number: true } })
     * 
    **/
    findMany<T extends inducks_logFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_logFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_logPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_log.
     * @param {inducks_logCreateArgs} args - Arguments to create a Inducks_log.
     * @example
     * // Create one Inducks_log
     * const Inducks_log = await prisma.inducks_log.create({
     *   data: {
     *     // ... data to create a Inducks_log
     *   }
     * })
     * 
    **/
    create<T extends inducks_logCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_logCreateArgs<ExtArgs>>
    ): Prisma__inducks_logClient<$Result.GetResult<Prisma.$inducks_logPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_logs.
     *     @param {inducks_logCreateManyArgs} args - Arguments to create many Inducks_logs.
     *     @example
     *     // Create many Inducks_logs
     *     const inducks_log = await prisma.inducks_log.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_logCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_logCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_log.
     * @param {inducks_logDeleteArgs} args - Arguments to delete one Inducks_log.
     * @example
     * // Delete one Inducks_log
     * const Inducks_log = await prisma.inducks_log.delete({
     *   where: {
     *     // ... filter to delete one Inducks_log
     *   }
     * })
     * 
    **/
    delete<T extends inducks_logDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_logDeleteArgs<ExtArgs>>
    ): Prisma__inducks_logClient<$Result.GetResult<Prisma.$inducks_logPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_log.
     * @param {inducks_logUpdateArgs} args - Arguments to update one Inducks_log.
     * @example
     * // Update one Inducks_log
     * const inducks_log = await prisma.inducks_log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_logUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_logUpdateArgs<ExtArgs>>
    ): Prisma__inducks_logClient<$Result.GetResult<Prisma.$inducks_logPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_logs.
     * @param {inducks_logDeleteManyArgs} args - Arguments to filter Inducks_logs to delete.
     * @example
     * // Delete a few Inducks_logs
     * const { count } = await prisma.inducks_log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_logDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_logDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_logUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_logs
     * const inducks_log = await prisma.inducks_log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_logUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_logUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_log.
     * @param {inducks_logUpsertArgs} args - Arguments to update or create a Inducks_log.
     * @example
     * // Update or create a Inducks_log
     * const inducks_log = await prisma.inducks_log.upsert({
     *   create: {
     *     // ... data to create a Inducks_log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_log we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_logUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_logUpsertArgs<ExtArgs>>
    ): Prisma__inducks_logClient<$Result.GetResult<Prisma.$inducks_logPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_logCountArgs} args - Arguments to filter Inducks_logs to count.
     * @example
     * // Count the number of Inducks_logs
     * const count = await prisma.inducks_log.count({
     *   where: {
     *     // ... the filter for the Inducks_logs we want to count
     *   }
     * })
    **/
    count<T extends inducks_logCountArgs>(
      args?: Subset<T, inducks_logCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_logCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_logAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_logAggregateArgs>(args: Subset<T, Inducks_logAggregateArgs>): Prisma.PrismaPromise<GetInducks_logAggregateType<T>>

    /**
     * Group by Inducks_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_logGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_logGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_logGroupByArgs['orderBy'] }
        : { orderBy?: inducks_logGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_logGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_logGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_log model
   */
  readonly fields: inducks_logFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_logClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_log model
   */ 
  interface inducks_logFieldRefs {
    readonly number: FieldRef<"inducks_log", 'Int'>
    readonly logkey: FieldRef<"inducks_log", 'String'>
    readonly storycode: FieldRef<"inducks_log", 'String'>
    readonly logid: FieldRef<"inducks_log", 'String'>
    readonly logtype: FieldRef<"inducks_log", 'String'>
    readonly par1: FieldRef<"inducks_log", 'String'>
    readonly par2: FieldRef<"inducks_log", 'String'>
    readonly par3: FieldRef<"inducks_log", 'String'>
    readonly marked: FieldRef<"inducks_log", 'inducks_log_marked'>
    readonly inputfilecode: FieldRef<"inducks_log", 'Int'>
    readonly maintenanceteamcode: FieldRef<"inducks_log", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_log findUnique
   */
  export type inducks_logFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_log
     */
    select?: inducks_logSelect<ExtArgs> | null
    /**
     * Filter, which inducks_log to fetch.
     */
    where: inducks_logWhereUniqueInput
  }


  /**
   * inducks_log findUniqueOrThrow
   */
  export type inducks_logFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_log
     */
    select?: inducks_logSelect<ExtArgs> | null
    /**
     * Filter, which inducks_log to fetch.
     */
    where: inducks_logWhereUniqueInput
  }


  /**
   * inducks_log findFirst
   */
  export type inducks_logFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_log
     */
    select?: inducks_logSelect<ExtArgs> | null
    /**
     * Filter, which inducks_log to fetch.
     */
    where?: inducks_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_logs to fetch.
     */
    orderBy?: inducks_logOrderByWithRelationInput | inducks_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_logs.
     */
    cursor?: inducks_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_logs.
     */
    distinct?: Inducks_logScalarFieldEnum | Inducks_logScalarFieldEnum[]
  }


  /**
   * inducks_log findFirstOrThrow
   */
  export type inducks_logFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_log
     */
    select?: inducks_logSelect<ExtArgs> | null
    /**
     * Filter, which inducks_log to fetch.
     */
    where?: inducks_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_logs to fetch.
     */
    orderBy?: inducks_logOrderByWithRelationInput | inducks_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_logs.
     */
    cursor?: inducks_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_logs.
     */
    distinct?: Inducks_logScalarFieldEnum | Inducks_logScalarFieldEnum[]
  }


  /**
   * inducks_log findMany
   */
  export type inducks_logFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_log
     */
    select?: inducks_logSelect<ExtArgs> | null
    /**
     * Filter, which inducks_logs to fetch.
     */
    where?: inducks_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_logs to fetch.
     */
    orderBy?: inducks_logOrderByWithRelationInput | inducks_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_logs.
     */
    cursor?: inducks_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_logs.
     */
    skip?: number
    distinct?: Inducks_logScalarFieldEnum | Inducks_logScalarFieldEnum[]
  }


  /**
   * inducks_log create
   */
  export type inducks_logCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_log
     */
    select?: inducks_logSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_log.
     */
    data: XOR<inducks_logCreateInput, inducks_logUncheckedCreateInput>
  }


  /**
   * inducks_log createMany
   */
  export type inducks_logCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_logs.
     */
    data: inducks_logCreateManyInput | inducks_logCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_log update
   */
  export type inducks_logUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_log
     */
    select?: inducks_logSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_log.
     */
    data: XOR<inducks_logUpdateInput, inducks_logUncheckedUpdateInput>
    /**
     * Choose, which inducks_log to update.
     */
    where: inducks_logWhereUniqueInput
  }


  /**
   * inducks_log updateMany
   */
  export type inducks_logUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_logs.
     */
    data: XOR<inducks_logUpdateManyMutationInput, inducks_logUncheckedUpdateManyInput>
    /**
     * Filter which inducks_logs to update
     */
    where?: inducks_logWhereInput
  }


  /**
   * inducks_log upsert
   */
  export type inducks_logUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_log
     */
    select?: inducks_logSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_log to update in case it exists.
     */
    where: inducks_logWhereUniqueInput
    /**
     * In case the inducks_log found by the `where` argument doesn't exist, create a new inducks_log with this data.
     */
    create: XOR<inducks_logCreateInput, inducks_logUncheckedCreateInput>
    /**
     * In case the inducks_log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_logUpdateInput, inducks_logUncheckedUpdateInput>
  }


  /**
   * inducks_log delete
   */
  export type inducks_logDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_log
     */
    select?: inducks_logSelect<ExtArgs> | null
    /**
     * Filter which inducks_log to delete.
     */
    where: inducks_logWhereUniqueInput
  }


  /**
   * inducks_log deleteMany
   */
  export type inducks_logDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_logs to delete
     */
    where?: inducks_logWhereInput
  }


  /**
   * inducks_log without action
   */
  export type inducks_logDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_log
     */
    select?: inducks_logSelect<ExtArgs> | null
  }



  /**
   * Model inducks_logdata
   */

  export type AggregateInducks_logdata = {
    _count: Inducks_logdataCountAggregateOutputType | null
    _avg: Inducks_logdataAvgAggregateOutputType | null
    _sum: Inducks_logdataSumAggregateOutputType | null
    _min: Inducks_logdataMinAggregateOutputType | null
    _max: Inducks_logdataMaxAggregateOutputType | null
  }

  export type Inducks_logdataAvgAggregateOutputType = {
    category: number | null
  }

  export type Inducks_logdataSumAggregateOutputType = {
    category: number | null
  }

  export type Inducks_logdataMinAggregateOutputType = {
    logid: string | null
    category: number | null
    logtext: string | null
  }

  export type Inducks_logdataMaxAggregateOutputType = {
    logid: string | null
    category: number | null
    logtext: string | null
  }

  export type Inducks_logdataCountAggregateOutputType = {
    logid: number
    category: number
    logtext: number
    _all: number
  }


  export type Inducks_logdataAvgAggregateInputType = {
    category?: true
  }

  export type Inducks_logdataSumAggregateInputType = {
    category?: true
  }

  export type Inducks_logdataMinAggregateInputType = {
    logid?: true
    category?: true
    logtext?: true
  }

  export type Inducks_logdataMaxAggregateInputType = {
    logid?: true
    category?: true
    logtext?: true
  }

  export type Inducks_logdataCountAggregateInputType = {
    logid?: true
    category?: true
    logtext?: true
    _all?: true
  }

  export type Inducks_logdataAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_logdata to aggregate.
     */
    where?: inducks_logdataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_logdata to fetch.
     */
    orderBy?: inducks_logdataOrderByWithRelationInput | inducks_logdataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_logdataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_logdata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_logdata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_logdata
    **/
    _count?: true | Inducks_logdataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Inducks_logdataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Inducks_logdataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_logdataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_logdataMaxAggregateInputType
  }

  export type GetInducks_logdataAggregateType<T extends Inducks_logdataAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_logdata]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_logdata[P]>
      : GetScalarType<T[P], AggregateInducks_logdata[P]>
  }




  export type inducks_logdataGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_logdataWhereInput
    orderBy?: inducks_logdataOrderByWithAggregationInput | inducks_logdataOrderByWithAggregationInput[]
    by: Inducks_logdataScalarFieldEnum[] | Inducks_logdataScalarFieldEnum
    having?: inducks_logdataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_logdataCountAggregateInputType | true
    _avg?: Inducks_logdataAvgAggregateInputType
    _sum?: Inducks_logdataSumAggregateInputType
    _min?: Inducks_logdataMinAggregateInputType
    _max?: Inducks_logdataMaxAggregateInputType
  }

  export type Inducks_logdataGroupByOutputType = {
    logid: string
    category: number | null
    logtext: string | null
    _count: Inducks_logdataCountAggregateOutputType | null
    _avg: Inducks_logdataAvgAggregateOutputType | null
    _sum: Inducks_logdataSumAggregateOutputType | null
    _min: Inducks_logdataMinAggregateOutputType | null
    _max: Inducks_logdataMaxAggregateOutputType | null
  }

  type GetInducks_logdataGroupByPayload<T extends inducks_logdataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_logdataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_logdataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_logdataGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_logdataGroupByOutputType[P]>
        }
      >
    >


  export type inducks_logdataSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    logid?: boolean
    category?: boolean
    logtext?: boolean
  }, ExtArgs["result"]["inducks_logdata"]>

  export type inducks_logdataSelectScalar = {
    logid?: boolean
    category?: boolean
    logtext?: boolean
  }


  export type $inducks_logdataPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_logdata"
    objects: {}
    scalars: $Extensions.GetResult<{
      logid: string
      category: number | null
      logtext: string | null
    }, ExtArgs["result"]["inducks_logdata"]>
    composites: {}
  }


  type inducks_logdataGetPayload<S extends boolean | null | undefined | inducks_logdataDefaultArgs> = $Result.GetResult<Prisma.$inducks_logdataPayload, S>

  type inducks_logdataCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_logdataFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_logdataCountAggregateInputType | true
    }

  export interface inducks_logdataDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_logdata'], meta: { name: 'inducks_logdata' } }
    /**
     * Find zero or one Inducks_logdata that matches the filter.
     * @param {inducks_logdataFindUniqueArgs} args - Arguments to find a Inducks_logdata
     * @example
     * // Get one Inducks_logdata
     * const inducks_logdata = await prisma.inducks_logdata.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_logdataFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_logdataFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_logdataClient<$Result.GetResult<Prisma.$inducks_logdataPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_logdata that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_logdataFindUniqueOrThrowArgs} args - Arguments to find a Inducks_logdata
     * @example
     * // Get one Inducks_logdata
     * const inducks_logdata = await prisma.inducks_logdata.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_logdataFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_logdataFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_logdataClient<$Result.GetResult<Prisma.$inducks_logdataPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_logdata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_logdataFindFirstArgs} args - Arguments to find a Inducks_logdata
     * @example
     * // Get one Inducks_logdata
     * const inducks_logdata = await prisma.inducks_logdata.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_logdataFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_logdataFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_logdataClient<$Result.GetResult<Prisma.$inducks_logdataPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_logdata that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_logdataFindFirstOrThrowArgs} args - Arguments to find a Inducks_logdata
     * @example
     * // Get one Inducks_logdata
     * const inducks_logdata = await prisma.inducks_logdata.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_logdataFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_logdataFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_logdataClient<$Result.GetResult<Prisma.$inducks_logdataPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_logdata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_logdataFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_logdata
     * const inducks_logdata = await prisma.inducks_logdata.findMany()
     * 
     * // Get first 10 Inducks_logdata
     * const inducks_logdata = await prisma.inducks_logdata.findMany({ take: 10 })
     * 
     * // Only select the `logid`
     * const inducks_logdataWithLogidOnly = await prisma.inducks_logdata.findMany({ select: { logid: true } })
     * 
    **/
    findMany<T extends inducks_logdataFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_logdataFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_logdataPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_logdata.
     * @param {inducks_logdataCreateArgs} args - Arguments to create a Inducks_logdata.
     * @example
     * // Create one Inducks_logdata
     * const Inducks_logdata = await prisma.inducks_logdata.create({
     *   data: {
     *     // ... data to create a Inducks_logdata
     *   }
     * })
     * 
    **/
    create<T extends inducks_logdataCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_logdataCreateArgs<ExtArgs>>
    ): Prisma__inducks_logdataClient<$Result.GetResult<Prisma.$inducks_logdataPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_logdata.
     *     @param {inducks_logdataCreateManyArgs} args - Arguments to create many Inducks_logdata.
     *     @example
     *     // Create many Inducks_logdata
     *     const inducks_logdata = await prisma.inducks_logdata.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_logdataCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_logdataCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_logdata.
     * @param {inducks_logdataDeleteArgs} args - Arguments to delete one Inducks_logdata.
     * @example
     * // Delete one Inducks_logdata
     * const Inducks_logdata = await prisma.inducks_logdata.delete({
     *   where: {
     *     // ... filter to delete one Inducks_logdata
     *   }
     * })
     * 
    **/
    delete<T extends inducks_logdataDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_logdataDeleteArgs<ExtArgs>>
    ): Prisma__inducks_logdataClient<$Result.GetResult<Prisma.$inducks_logdataPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_logdata.
     * @param {inducks_logdataUpdateArgs} args - Arguments to update one Inducks_logdata.
     * @example
     * // Update one Inducks_logdata
     * const inducks_logdata = await prisma.inducks_logdata.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_logdataUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_logdataUpdateArgs<ExtArgs>>
    ): Prisma__inducks_logdataClient<$Result.GetResult<Prisma.$inducks_logdataPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_logdata.
     * @param {inducks_logdataDeleteManyArgs} args - Arguments to filter Inducks_logdata to delete.
     * @example
     * // Delete a few Inducks_logdata
     * const { count } = await prisma.inducks_logdata.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_logdataDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_logdataDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_logdata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_logdataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_logdata
     * const inducks_logdata = await prisma.inducks_logdata.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_logdataUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_logdataUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_logdata.
     * @param {inducks_logdataUpsertArgs} args - Arguments to update or create a Inducks_logdata.
     * @example
     * // Update or create a Inducks_logdata
     * const inducks_logdata = await prisma.inducks_logdata.upsert({
     *   create: {
     *     // ... data to create a Inducks_logdata
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_logdata we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_logdataUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_logdataUpsertArgs<ExtArgs>>
    ): Prisma__inducks_logdataClient<$Result.GetResult<Prisma.$inducks_logdataPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_logdata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_logdataCountArgs} args - Arguments to filter Inducks_logdata to count.
     * @example
     * // Count the number of Inducks_logdata
     * const count = await prisma.inducks_logdata.count({
     *   where: {
     *     // ... the filter for the Inducks_logdata we want to count
     *   }
     * })
    **/
    count<T extends inducks_logdataCountArgs>(
      args?: Subset<T, inducks_logdataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_logdataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_logdata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_logdataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_logdataAggregateArgs>(args: Subset<T, Inducks_logdataAggregateArgs>): Prisma.PrismaPromise<GetInducks_logdataAggregateType<T>>

    /**
     * Group by Inducks_logdata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_logdataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_logdataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_logdataGroupByArgs['orderBy'] }
        : { orderBy?: inducks_logdataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_logdataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_logdataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_logdata model
   */
  readonly fields: inducks_logdataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_logdata.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_logdataClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_logdata model
   */ 
  interface inducks_logdataFieldRefs {
    readonly logid: FieldRef<"inducks_logdata", 'String'>
    readonly category: FieldRef<"inducks_logdata", 'Int'>
    readonly logtext: FieldRef<"inducks_logdata", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_logdata findUnique
   */
  export type inducks_logdataFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_logdata
     */
    select?: inducks_logdataSelect<ExtArgs> | null
    /**
     * Filter, which inducks_logdata to fetch.
     */
    where: inducks_logdataWhereUniqueInput
  }


  /**
   * inducks_logdata findUniqueOrThrow
   */
  export type inducks_logdataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_logdata
     */
    select?: inducks_logdataSelect<ExtArgs> | null
    /**
     * Filter, which inducks_logdata to fetch.
     */
    where: inducks_logdataWhereUniqueInput
  }


  /**
   * inducks_logdata findFirst
   */
  export type inducks_logdataFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_logdata
     */
    select?: inducks_logdataSelect<ExtArgs> | null
    /**
     * Filter, which inducks_logdata to fetch.
     */
    where?: inducks_logdataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_logdata to fetch.
     */
    orderBy?: inducks_logdataOrderByWithRelationInput | inducks_logdataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_logdata.
     */
    cursor?: inducks_logdataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_logdata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_logdata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_logdata.
     */
    distinct?: Inducks_logdataScalarFieldEnum | Inducks_logdataScalarFieldEnum[]
  }


  /**
   * inducks_logdata findFirstOrThrow
   */
  export type inducks_logdataFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_logdata
     */
    select?: inducks_logdataSelect<ExtArgs> | null
    /**
     * Filter, which inducks_logdata to fetch.
     */
    where?: inducks_logdataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_logdata to fetch.
     */
    orderBy?: inducks_logdataOrderByWithRelationInput | inducks_logdataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_logdata.
     */
    cursor?: inducks_logdataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_logdata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_logdata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_logdata.
     */
    distinct?: Inducks_logdataScalarFieldEnum | Inducks_logdataScalarFieldEnum[]
  }


  /**
   * inducks_logdata findMany
   */
  export type inducks_logdataFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_logdata
     */
    select?: inducks_logdataSelect<ExtArgs> | null
    /**
     * Filter, which inducks_logdata to fetch.
     */
    where?: inducks_logdataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_logdata to fetch.
     */
    orderBy?: inducks_logdataOrderByWithRelationInput | inducks_logdataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_logdata.
     */
    cursor?: inducks_logdataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_logdata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_logdata.
     */
    skip?: number
    distinct?: Inducks_logdataScalarFieldEnum | Inducks_logdataScalarFieldEnum[]
  }


  /**
   * inducks_logdata create
   */
  export type inducks_logdataCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_logdata
     */
    select?: inducks_logdataSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_logdata.
     */
    data: XOR<inducks_logdataCreateInput, inducks_logdataUncheckedCreateInput>
  }


  /**
   * inducks_logdata createMany
   */
  export type inducks_logdataCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_logdata.
     */
    data: inducks_logdataCreateManyInput | inducks_logdataCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_logdata update
   */
  export type inducks_logdataUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_logdata
     */
    select?: inducks_logdataSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_logdata.
     */
    data: XOR<inducks_logdataUpdateInput, inducks_logdataUncheckedUpdateInput>
    /**
     * Choose, which inducks_logdata to update.
     */
    where: inducks_logdataWhereUniqueInput
  }


  /**
   * inducks_logdata updateMany
   */
  export type inducks_logdataUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_logdata.
     */
    data: XOR<inducks_logdataUpdateManyMutationInput, inducks_logdataUncheckedUpdateManyInput>
    /**
     * Filter which inducks_logdata to update
     */
    where?: inducks_logdataWhereInput
  }


  /**
   * inducks_logdata upsert
   */
  export type inducks_logdataUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_logdata
     */
    select?: inducks_logdataSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_logdata to update in case it exists.
     */
    where: inducks_logdataWhereUniqueInput
    /**
     * In case the inducks_logdata found by the `where` argument doesn't exist, create a new inducks_logdata with this data.
     */
    create: XOR<inducks_logdataCreateInput, inducks_logdataUncheckedCreateInput>
    /**
     * In case the inducks_logdata was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_logdataUpdateInput, inducks_logdataUncheckedUpdateInput>
  }


  /**
   * inducks_logdata delete
   */
  export type inducks_logdataDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_logdata
     */
    select?: inducks_logdataSelect<ExtArgs> | null
    /**
     * Filter which inducks_logdata to delete.
     */
    where: inducks_logdataWhereUniqueInput
  }


  /**
   * inducks_logdata deleteMany
   */
  export type inducks_logdataDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_logdata to delete
     */
    where?: inducks_logdataWhereInput
  }


  /**
   * inducks_logdata without action
   */
  export type inducks_logdataDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_logdata
     */
    select?: inducks_logdataSelect<ExtArgs> | null
  }



  /**
   * Model inducks_logocharacter
   */

  export type AggregateInducks_logocharacter = {
    _count: Inducks_logocharacterCountAggregateOutputType | null
    _avg: Inducks_logocharacterAvgAggregateOutputType | null
    _sum: Inducks_logocharacterSumAggregateOutputType | null
    _min: Inducks_logocharacterMinAggregateOutputType | null
    _max: Inducks_logocharacterMaxAggregateOutputType | null
  }

  export type Inducks_logocharacterAvgAggregateOutputType = {
    number: number | null
  }

  export type Inducks_logocharacterSumAggregateOutputType = {
    number: number | null
  }

  export type Inducks_logocharacterMinAggregateOutputType = {
    entrycode: string | null
    charactercode: string | null
    reallyintitle: $Enums.inducks_logocharacter_reallyintitle | null
    number: number | null
    logocharactercomment: string | null
  }

  export type Inducks_logocharacterMaxAggregateOutputType = {
    entrycode: string | null
    charactercode: string | null
    reallyintitle: $Enums.inducks_logocharacter_reallyintitle | null
    number: number | null
    logocharactercomment: string | null
  }

  export type Inducks_logocharacterCountAggregateOutputType = {
    entrycode: number
    charactercode: number
    reallyintitle: number
    number: number
    logocharactercomment: number
    _all: number
  }


  export type Inducks_logocharacterAvgAggregateInputType = {
    number?: true
  }

  export type Inducks_logocharacterSumAggregateInputType = {
    number?: true
  }

  export type Inducks_logocharacterMinAggregateInputType = {
    entrycode?: true
    charactercode?: true
    reallyintitle?: true
    number?: true
    logocharactercomment?: true
  }

  export type Inducks_logocharacterMaxAggregateInputType = {
    entrycode?: true
    charactercode?: true
    reallyintitle?: true
    number?: true
    logocharactercomment?: true
  }

  export type Inducks_logocharacterCountAggregateInputType = {
    entrycode?: true
    charactercode?: true
    reallyintitle?: true
    number?: true
    logocharactercomment?: true
    _all?: true
  }

  export type Inducks_logocharacterAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_logocharacter to aggregate.
     */
    where?: inducks_logocharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_logocharacters to fetch.
     */
    orderBy?: inducks_logocharacterOrderByWithRelationInput | inducks_logocharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_logocharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_logocharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_logocharacters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_logocharacters
    **/
    _count?: true | Inducks_logocharacterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Inducks_logocharacterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Inducks_logocharacterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_logocharacterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_logocharacterMaxAggregateInputType
  }

  export type GetInducks_logocharacterAggregateType<T extends Inducks_logocharacterAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_logocharacter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_logocharacter[P]>
      : GetScalarType<T[P], AggregateInducks_logocharacter[P]>
  }




  export type inducks_logocharacterGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_logocharacterWhereInput
    orderBy?: inducks_logocharacterOrderByWithAggregationInput | inducks_logocharacterOrderByWithAggregationInput[]
    by: Inducks_logocharacterScalarFieldEnum[] | Inducks_logocharacterScalarFieldEnum
    having?: inducks_logocharacterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_logocharacterCountAggregateInputType | true
    _avg?: Inducks_logocharacterAvgAggregateInputType
    _sum?: Inducks_logocharacterSumAggregateInputType
    _min?: Inducks_logocharacterMinAggregateInputType
    _max?: Inducks_logocharacterMaxAggregateInputType
  }

  export type Inducks_logocharacterGroupByOutputType = {
    entrycode: string
    charactercode: string
    reallyintitle: $Enums.inducks_logocharacter_reallyintitle | null
    number: number | null
    logocharactercomment: string | null
    _count: Inducks_logocharacterCountAggregateOutputType | null
    _avg: Inducks_logocharacterAvgAggregateOutputType | null
    _sum: Inducks_logocharacterSumAggregateOutputType | null
    _min: Inducks_logocharacterMinAggregateOutputType | null
    _max: Inducks_logocharacterMaxAggregateOutputType | null
  }

  type GetInducks_logocharacterGroupByPayload<T extends inducks_logocharacterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_logocharacterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_logocharacterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_logocharacterGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_logocharacterGroupByOutputType[P]>
        }
      >
    >


  export type inducks_logocharacterSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    entrycode?: boolean
    charactercode?: boolean
    reallyintitle?: boolean
    number?: boolean
    logocharactercomment?: boolean
  }, ExtArgs["result"]["inducks_logocharacter"]>

  export type inducks_logocharacterSelectScalar = {
    entrycode?: boolean
    charactercode?: boolean
    reallyintitle?: boolean
    number?: boolean
    logocharactercomment?: boolean
  }


  export type $inducks_logocharacterPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_logocharacter"
    objects: {}
    scalars: $Extensions.GetResult<{
      entrycode: string
      charactercode: string
      reallyintitle: $Enums.inducks_logocharacter_reallyintitle | null
      number: number | null
      logocharactercomment: string | null
    }, ExtArgs["result"]["inducks_logocharacter"]>
    composites: {}
  }


  type inducks_logocharacterGetPayload<S extends boolean | null | undefined | inducks_logocharacterDefaultArgs> = $Result.GetResult<Prisma.$inducks_logocharacterPayload, S>

  type inducks_logocharacterCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_logocharacterFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_logocharacterCountAggregateInputType | true
    }

  export interface inducks_logocharacterDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_logocharacter'], meta: { name: 'inducks_logocharacter' } }
    /**
     * Find zero or one Inducks_logocharacter that matches the filter.
     * @param {inducks_logocharacterFindUniqueArgs} args - Arguments to find a Inducks_logocharacter
     * @example
     * // Get one Inducks_logocharacter
     * const inducks_logocharacter = await prisma.inducks_logocharacter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_logocharacterFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_logocharacterFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_logocharacterClient<$Result.GetResult<Prisma.$inducks_logocharacterPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_logocharacter that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_logocharacterFindUniqueOrThrowArgs} args - Arguments to find a Inducks_logocharacter
     * @example
     * // Get one Inducks_logocharacter
     * const inducks_logocharacter = await prisma.inducks_logocharacter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_logocharacterFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_logocharacterFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_logocharacterClient<$Result.GetResult<Prisma.$inducks_logocharacterPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_logocharacter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_logocharacterFindFirstArgs} args - Arguments to find a Inducks_logocharacter
     * @example
     * // Get one Inducks_logocharacter
     * const inducks_logocharacter = await prisma.inducks_logocharacter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_logocharacterFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_logocharacterFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_logocharacterClient<$Result.GetResult<Prisma.$inducks_logocharacterPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_logocharacter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_logocharacterFindFirstOrThrowArgs} args - Arguments to find a Inducks_logocharacter
     * @example
     * // Get one Inducks_logocharacter
     * const inducks_logocharacter = await prisma.inducks_logocharacter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_logocharacterFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_logocharacterFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_logocharacterClient<$Result.GetResult<Prisma.$inducks_logocharacterPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_logocharacters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_logocharacterFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_logocharacters
     * const inducks_logocharacters = await prisma.inducks_logocharacter.findMany()
     * 
     * // Get first 10 Inducks_logocharacters
     * const inducks_logocharacters = await prisma.inducks_logocharacter.findMany({ take: 10 })
     * 
     * // Only select the `entrycode`
     * const inducks_logocharacterWithEntrycodeOnly = await prisma.inducks_logocharacter.findMany({ select: { entrycode: true } })
     * 
    **/
    findMany<T extends inducks_logocharacterFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_logocharacterFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_logocharacterPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_logocharacter.
     * @param {inducks_logocharacterCreateArgs} args - Arguments to create a Inducks_logocharacter.
     * @example
     * // Create one Inducks_logocharacter
     * const Inducks_logocharacter = await prisma.inducks_logocharacter.create({
     *   data: {
     *     // ... data to create a Inducks_logocharacter
     *   }
     * })
     * 
    **/
    create<T extends inducks_logocharacterCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_logocharacterCreateArgs<ExtArgs>>
    ): Prisma__inducks_logocharacterClient<$Result.GetResult<Prisma.$inducks_logocharacterPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_logocharacters.
     *     @param {inducks_logocharacterCreateManyArgs} args - Arguments to create many Inducks_logocharacters.
     *     @example
     *     // Create many Inducks_logocharacters
     *     const inducks_logocharacter = await prisma.inducks_logocharacter.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_logocharacterCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_logocharacterCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_logocharacter.
     * @param {inducks_logocharacterDeleteArgs} args - Arguments to delete one Inducks_logocharacter.
     * @example
     * // Delete one Inducks_logocharacter
     * const Inducks_logocharacter = await prisma.inducks_logocharacter.delete({
     *   where: {
     *     // ... filter to delete one Inducks_logocharacter
     *   }
     * })
     * 
    **/
    delete<T extends inducks_logocharacterDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_logocharacterDeleteArgs<ExtArgs>>
    ): Prisma__inducks_logocharacterClient<$Result.GetResult<Prisma.$inducks_logocharacterPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_logocharacter.
     * @param {inducks_logocharacterUpdateArgs} args - Arguments to update one Inducks_logocharacter.
     * @example
     * // Update one Inducks_logocharacter
     * const inducks_logocharacter = await prisma.inducks_logocharacter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_logocharacterUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_logocharacterUpdateArgs<ExtArgs>>
    ): Prisma__inducks_logocharacterClient<$Result.GetResult<Prisma.$inducks_logocharacterPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_logocharacters.
     * @param {inducks_logocharacterDeleteManyArgs} args - Arguments to filter Inducks_logocharacters to delete.
     * @example
     * // Delete a few Inducks_logocharacters
     * const { count } = await prisma.inducks_logocharacter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_logocharacterDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_logocharacterDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_logocharacters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_logocharacterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_logocharacters
     * const inducks_logocharacter = await prisma.inducks_logocharacter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_logocharacterUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_logocharacterUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_logocharacter.
     * @param {inducks_logocharacterUpsertArgs} args - Arguments to update or create a Inducks_logocharacter.
     * @example
     * // Update or create a Inducks_logocharacter
     * const inducks_logocharacter = await prisma.inducks_logocharacter.upsert({
     *   create: {
     *     // ... data to create a Inducks_logocharacter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_logocharacter we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_logocharacterUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_logocharacterUpsertArgs<ExtArgs>>
    ): Prisma__inducks_logocharacterClient<$Result.GetResult<Prisma.$inducks_logocharacterPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_logocharacters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_logocharacterCountArgs} args - Arguments to filter Inducks_logocharacters to count.
     * @example
     * // Count the number of Inducks_logocharacters
     * const count = await prisma.inducks_logocharacter.count({
     *   where: {
     *     // ... the filter for the Inducks_logocharacters we want to count
     *   }
     * })
    **/
    count<T extends inducks_logocharacterCountArgs>(
      args?: Subset<T, inducks_logocharacterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_logocharacterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_logocharacter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_logocharacterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_logocharacterAggregateArgs>(args: Subset<T, Inducks_logocharacterAggregateArgs>): Prisma.PrismaPromise<GetInducks_logocharacterAggregateType<T>>

    /**
     * Group by Inducks_logocharacter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_logocharacterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_logocharacterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_logocharacterGroupByArgs['orderBy'] }
        : { orderBy?: inducks_logocharacterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_logocharacterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_logocharacterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_logocharacter model
   */
  readonly fields: inducks_logocharacterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_logocharacter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_logocharacterClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_logocharacter model
   */ 
  interface inducks_logocharacterFieldRefs {
    readonly entrycode: FieldRef<"inducks_logocharacter", 'String'>
    readonly charactercode: FieldRef<"inducks_logocharacter", 'String'>
    readonly reallyintitle: FieldRef<"inducks_logocharacter", 'inducks_logocharacter_reallyintitle'>
    readonly number: FieldRef<"inducks_logocharacter", 'Int'>
    readonly logocharactercomment: FieldRef<"inducks_logocharacter", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_logocharacter findUnique
   */
  export type inducks_logocharacterFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_logocharacter
     */
    select?: inducks_logocharacterSelect<ExtArgs> | null
    /**
     * Filter, which inducks_logocharacter to fetch.
     */
    where: inducks_logocharacterWhereUniqueInput
  }


  /**
   * inducks_logocharacter findUniqueOrThrow
   */
  export type inducks_logocharacterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_logocharacter
     */
    select?: inducks_logocharacterSelect<ExtArgs> | null
    /**
     * Filter, which inducks_logocharacter to fetch.
     */
    where: inducks_logocharacterWhereUniqueInput
  }


  /**
   * inducks_logocharacter findFirst
   */
  export type inducks_logocharacterFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_logocharacter
     */
    select?: inducks_logocharacterSelect<ExtArgs> | null
    /**
     * Filter, which inducks_logocharacter to fetch.
     */
    where?: inducks_logocharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_logocharacters to fetch.
     */
    orderBy?: inducks_logocharacterOrderByWithRelationInput | inducks_logocharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_logocharacters.
     */
    cursor?: inducks_logocharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_logocharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_logocharacters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_logocharacters.
     */
    distinct?: Inducks_logocharacterScalarFieldEnum | Inducks_logocharacterScalarFieldEnum[]
  }


  /**
   * inducks_logocharacter findFirstOrThrow
   */
  export type inducks_logocharacterFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_logocharacter
     */
    select?: inducks_logocharacterSelect<ExtArgs> | null
    /**
     * Filter, which inducks_logocharacter to fetch.
     */
    where?: inducks_logocharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_logocharacters to fetch.
     */
    orderBy?: inducks_logocharacterOrderByWithRelationInput | inducks_logocharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_logocharacters.
     */
    cursor?: inducks_logocharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_logocharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_logocharacters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_logocharacters.
     */
    distinct?: Inducks_logocharacterScalarFieldEnum | Inducks_logocharacterScalarFieldEnum[]
  }


  /**
   * inducks_logocharacter findMany
   */
  export type inducks_logocharacterFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_logocharacter
     */
    select?: inducks_logocharacterSelect<ExtArgs> | null
    /**
     * Filter, which inducks_logocharacters to fetch.
     */
    where?: inducks_logocharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_logocharacters to fetch.
     */
    orderBy?: inducks_logocharacterOrderByWithRelationInput | inducks_logocharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_logocharacters.
     */
    cursor?: inducks_logocharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_logocharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_logocharacters.
     */
    skip?: number
    distinct?: Inducks_logocharacterScalarFieldEnum | Inducks_logocharacterScalarFieldEnum[]
  }


  /**
   * inducks_logocharacter create
   */
  export type inducks_logocharacterCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_logocharacter
     */
    select?: inducks_logocharacterSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_logocharacter.
     */
    data: XOR<inducks_logocharacterCreateInput, inducks_logocharacterUncheckedCreateInput>
  }


  /**
   * inducks_logocharacter createMany
   */
  export type inducks_logocharacterCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_logocharacters.
     */
    data: inducks_logocharacterCreateManyInput | inducks_logocharacterCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_logocharacter update
   */
  export type inducks_logocharacterUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_logocharacter
     */
    select?: inducks_logocharacterSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_logocharacter.
     */
    data: XOR<inducks_logocharacterUpdateInput, inducks_logocharacterUncheckedUpdateInput>
    /**
     * Choose, which inducks_logocharacter to update.
     */
    where: inducks_logocharacterWhereUniqueInput
  }


  /**
   * inducks_logocharacter updateMany
   */
  export type inducks_logocharacterUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_logocharacters.
     */
    data: XOR<inducks_logocharacterUpdateManyMutationInput, inducks_logocharacterUncheckedUpdateManyInput>
    /**
     * Filter which inducks_logocharacters to update
     */
    where?: inducks_logocharacterWhereInput
  }


  /**
   * inducks_logocharacter upsert
   */
  export type inducks_logocharacterUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_logocharacter
     */
    select?: inducks_logocharacterSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_logocharacter to update in case it exists.
     */
    where: inducks_logocharacterWhereUniqueInput
    /**
     * In case the inducks_logocharacter found by the `where` argument doesn't exist, create a new inducks_logocharacter with this data.
     */
    create: XOR<inducks_logocharacterCreateInput, inducks_logocharacterUncheckedCreateInput>
    /**
     * In case the inducks_logocharacter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_logocharacterUpdateInput, inducks_logocharacterUncheckedUpdateInput>
  }


  /**
   * inducks_logocharacter delete
   */
  export type inducks_logocharacterDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_logocharacter
     */
    select?: inducks_logocharacterSelect<ExtArgs> | null
    /**
     * Filter which inducks_logocharacter to delete.
     */
    where: inducks_logocharacterWhereUniqueInput
  }


  /**
   * inducks_logocharacter deleteMany
   */
  export type inducks_logocharacterDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_logocharacters to delete
     */
    where?: inducks_logocharacterWhereInput
  }


  /**
   * inducks_logocharacter without action
   */
  export type inducks_logocharacterDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_logocharacter
     */
    select?: inducks_logocharacterSelect<ExtArgs> | null
  }



  /**
   * Model inducks_movie
   */

  export type AggregateInducks_movie = {
    _count: Inducks_movieCountAggregateOutputType | null
    _avg: Inducks_movieAvgAggregateOutputType | null
    _sum: Inducks_movieSumAggregateOutputType | null
    _min: Inducks_movieMinAggregateOutputType | null
    _max: Inducks_movieMaxAggregateOutputType | null
  }

  export type Inducks_movieAvgAggregateOutputType = {
    inputfilecode: number | null
  }

  export type Inducks_movieSumAggregateOutputType = {
    inputfilecode: number | null
  }

  export type Inducks_movieMinAggregateOutputType = {
    moviecode: string | null
    title: string | null
    moviecomment: string | null
    appsummary: string | null
    moviejobsummary: string | null
    locked: $Enums.inducks_movie_locked | null
    inputfilecode: number | null
    maintenanceteamcode: string | null
    aka: string | null
    creationdate: string | null
    moviedescription: string | null
    distributor: string | null
    genre: string | null
    orderer: string | null
    publicationdate: string | null
    source: string | null
    tim: string | null
  }

  export type Inducks_movieMaxAggregateOutputType = {
    moviecode: string | null
    title: string | null
    moviecomment: string | null
    appsummary: string | null
    moviejobsummary: string | null
    locked: $Enums.inducks_movie_locked | null
    inputfilecode: number | null
    maintenanceteamcode: string | null
    aka: string | null
    creationdate: string | null
    moviedescription: string | null
    distributor: string | null
    genre: string | null
    orderer: string | null
    publicationdate: string | null
    source: string | null
    tim: string | null
  }

  export type Inducks_movieCountAggregateOutputType = {
    moviecode: number
    title: number
    moviecomment: number
    appsummary: number
    moviejobsummary: number
    locked: number
    inputfilecode: number
    maintenanceteamcode: number
    aka: number
    creationdate: number
    moviedescription: number
    distributor: number
    genre: number
    orderer: number
    publicationdate: number
    source: number
    tim: number
    _all: number
  }


  export type Inducks_movieAvgAggregateInputType = {
    inputfilecode?: true
  }

  export type Inducks_movieSumAggregateInputType = {
    inputfilecode?: true
  }

  export type Inducks_movieMinAggregateInputType = {
    moviecode?: true
    title?: true
    moviecomment?: true
    appsummary?: true
    moviejobsummary?: true
    locked?: true
    inputfilecode?: true
    maintenanceteamcode?: true
    aka?: true
    creationdate?: true
    moviedescription?: true
    distributor?: true
    genre?: true
    orderer?: true
    publicationdate?: true
    source?: true
    tim?: true
  }

  export type Inducks_movieMaxAggregateInputType = {
    moviecode?: true
    title?: true
    moviecomment?: true
    appsummary?: true
    moviejobsummary?: true
    locked?: true
    inputfilecode?: true
    maintenanceteamcode?: true
    aka?: true
    creationdate?: true
    moviedescription?: true
    distributor?: true
    genre?: true
    orderer?: true
    publicationdate?: true
    source?: true
    tim?: true
  }

  export type Inducks_movieCountAggregateInputType = {
    moviecode?: true
    title?: true
    moviecomment?: true
    appsummary?: true
    moviejobsummary?: true
    locked?: true
    inputfilecode?: true
    maintenanceteamcode?: true
    aka?: true
    creationdate?: true
    moviedescription?: true
    distributor?: true
    genre?: true
    orderer?: true
    publicationdate?: true
    source?: true
    tim?: true
    _all?: true
  }

  export type Inducks_movieAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_movie to aggregate.
     */
    where?: inducks_movieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_movies to fetch.
     */
    orderBy?: inducks_movieOrderByWithRelationInput | inducks_movieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_movieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_movies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_movies
    **/
    _count?: true | Inducks_movieCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Inducks_movieAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Inducks_movieSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_movieMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_movieMaxAggregateInputType
  }

  export type GetInducks_movieAggregateType<T extends Inducks_movieAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_movie]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_movie[P]>
      : GetScalarType<T[P], AggregateInducks_movie[P]>
  }




  export type inducks_movieGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_movieWhereInput
    orderBy?: inducks_movieOrderByWithAggregationInput | inducks_movieOrderByWithAggregationInput[]
    by: Inducks_movieScalarFieldEnum[] | Inducks_movieScalarFieldEnum
    having?: inducks_movieScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_movieCountAggregateInputType | true
    _avg?: Inducks_movieAvgAggregateInputType
    _sum?: Inducks_movieSumAggregateInputType
    _min?: Inducks_movieMinAggregateInputType
    _max?: Inducks_movieMaxAggregateInputType
  }

  export type Inducks_movieGroupByOutputType = {
    moviecode: string
    title: string | null
    moviecomment: string | null
    appsummary: string | null
    moviejobsummary: string | null
    locked: $Enums.inducks_movie_locked | null
    inputfilecode: number | null
    maintenanceteamcode: string | null
    aka: string | null
    creationdate: string | null
    moviedescription: string | null
    distributor: string | null
    genre: string | null
    orderer: string | null
    publicationdate: string | null
    source: string | null
    tim: string | null
    _count: Inducks_movieCountAggregateOutputType | null
    _avg: Inducks_movieAvgAggregateOutputType | null
    _sum: Inducks_movieSumAggregateOutputType | null
    _min: Inducks_movieMinAggregateOutputType | null
    _max: Inducks_movieMaxAggregateOutputType | null
  }

  type GetInducks_movieGroupByPayload<T extends inducks_movieGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_movieGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_movieGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_movieGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_movieGroupByOutputType[P]>
        }
      >
    >


  export type inducks_movieSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moviecode?: boolean
    title?: boolean
    moviecomment?: boolean
    appsummary?: boolean
    moviejobsummary?: boolean
    locked?: boolean
    inputfilecode?: boolean
    maintenanceteamcode?: boolean
    aka?: boolean
    creationdate?: boolean
    moviedescription?: boolean
    distributor?: boolean
    genre?: boolean
    orderer?: boolean
    publicationdate?: boolean
    source?: boolean
    tim?: boolean
  }, ExtArgs["result"]["inducks_movie"]>

  export type inducks_movieSelectScalar = {
    moviecode?: boolean
    title?: boolean
    moviecomment?: boolean
    appsummary?: boolean
    moviejobsummary?: boolean
    locked?: boolean
    inputfilecode?: boolean
    maintenanceteamcode?: boolean
    aka?: boolean
    creationdate?: boolean
    moviedescription?: boolean
    distributor?: boolean
    genre?: boolean
    orderer?: boolean
    publicationdate?: boolean
    source?: boolean
    tim?: boolean
  }


  export type $inducks_moviePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_movie"
    objects: {}
    scalars: $Extensions.GetResult<{
      moviecode: string
      title: string | null
      moviecomment: string | null
      appsummary: string | null
      moviejobsummary: string | null
      locked: $Enums.inducks_movie_locked | null
      inputfilecode: number | null
      maintenanceteamcode: string | null
      aka: string | null
      creationdate: string | null
      moviedescription: string | null
      distributor: string | null
      genre: string | null
      orderer: string | null
      publicationdate: string | null
      source: string | null
      tim: string | null
    }, ExtArgs["result"]["inducks_movie"]>
    composites: {}
  }


  type inducks_movieGetPayload<S extends boolean | null | undefined | inducks_movieDefaultArgs> = $Result.GetResult<Prisma.$inducks_moviePayload, S>

  type inducks_movieCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_movieFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_movieCountAggregateInputType | true
    }

  export interface inducks_movieDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_movie'], meta: { name: 'inducks_movie' } }
    /**
     * Find zero or one Inducks_movie that matches the filter.
     * @param {inducks_movieFindUniqueArgs} args - Arguments to find a Inducks_movie
     * @example
     * // Get one Inducks_movie
     * const inducks_movie = await prisma.inducks_movie.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_movieFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_movieFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_movieClient<$Result.GetResult<Prisma.$inducks_moviePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_movie that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_movieFindUniqueOrThrowArgs} args - Arguments to find a Inducks_movie
     * @example
     * // Get one Inducks_movie
     * const inducks_movie = await prisma.inducks_movie.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_movieFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_movieFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_movieClient<$Result.GetResult<Prisma.$inducks_moviePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_movie that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_movieFindFirstArgs} args - Arguments to find a Inducks_movie
     * @example
     * // Get one Inducks_movie
     * const inducks_movie = await prisma.inducks_movie.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_movieFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_movieFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_movieClient<$Result.GetResult<Prisma.$inducks_moviePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_movie that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_movieFindFirstOrThrowArgs} args - Arguments to find a Inducks_movie
     * @example
     * // Get one Inducks_movie
     * const inducks_movie = await prisma.inducks_movie.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_movieFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_movieFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_movieClient<$Result.GetResult<Prisma.$inducks_moviePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_movies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_movieFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_movies
     * const inducks_movies = await prisma.inducks_movie.findMany()
     * 
     * // Get first 10 Inducks_movies
     * const inducks_movies = await prisma.inducks_movie.findMany({ take: 10 })
     * 
     * // Only select the `moviecode`
     * const inducks_movieWithMoviecodeOnly = await prisma.inducks_movie.findMany({ select: { moviecode: true } })
     * 
    **/
    findMany<T extends inducks_movieFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_movieFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_moviePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_movie.
     * @param {inducks_movieCreateArgs} args - Arguments to create a Inducks_movie.
     * @example
     * // Create one Inducks_movie
     * const Inducks_movie = await prisma.inducks_movie.create({
     *   data: {
     *     // ... data to create a Inducks_movie
     *   }
     * })
     * 
    **/
    create<T extends inducks_movieCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_movieCreateArgs<ExtArgs>>
    ): Prisma__inducks_movieClient<$Result.GetResult<Prisma.$inducks_moviePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_movies.
     *     @param {inducks_movieCreateManyArgs} args - Arguments to create many Inducks_movies.
     *     @example
     *     // Create many Inducks_movies
     *     const inducks_movie = await prisma.inducks_movie.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_movieCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_movieCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_movie.
     * @param {inducks_movieDeleteArgs} args - Arguments to delete one Inducks_movie.
     * @example
     * // Delete one Inducks_movie
     * const Inducks_movie = await prisma.inducks_movie.delete({
     *   where: {
     *     // ... filter to delete one Inducks_movie
     *   }
     * })
     * 
    **/
    delete<T extends inducks_movieDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_movieDeleteArgs<ExtArgs>>
    ): Prisma__inducks_movieClient<$Result.GetResult<Prisma.$inducks_moviePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_movie.
     * @param {inducks_movieUpdateArgs} args - Arguments to update one Inducks_movie.
     * @example
     * // Update one Inducks_movie
     * const inducks_movie = await prisma.inducks_movie.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_movieUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_movieUpdateArgs<ExtArgs>>
    ): Prisma__inducks_movieClient<$Result.GetResult<Prisma.$inducks_moviePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_movies.
     * @param {inducks_movieDeleteManyArgs} args - Arguments to filter Inducks_movies to delete.
     * @example
     * // Delete a few Inducks_movies
     * const { count } = await prisma.inducks_movie.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_movieDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_movieDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_movies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_movieUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_movies
     * const inducks_movie = await prisma.inducks_movie.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_movieUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_movieUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_movie.
     * @param {inducks_movieUpsertArgs} args - Arguments to update or create a Inducks_movie.
     * @example
     * // Update or create a Inducks_movie
     * const inducks_movie = await prisma.inducks_movie.upsert({
     *   create: {
     *     // ... data to create a Inducks_movie
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_movie we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_movieUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_movieUpsertArgs<ExtArgs>>
    ): Prisma__inducks_movieClient<$Result.GetResult<Prisma.$inducks_moviePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_movies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_movieCountArgs} args - Arguments to filter Inducks_movies to count.
     * @example
     * // Count the number of Inducks_movies
     * const count = await prisma.inducks_movie.count({
     *   where: {
     *     // ... the filter for the Inducks_movies we want to count
     *   }
     * })
    **/
    count<T extends inducks_movieCountArgs>(
      args?: Subset<T, inducks_movieCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_movieCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_movie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_movieAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_movieAggregateArgs>(args: Subset<T, Inducks_movieAggregateArgs>): Prisma.PrismaPromise<GetInducks_movieAggregateType<T>>

    /**
     * Group by Inducks_movie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_movieGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_movieGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_movieGroupByArgs['orderBy'] }
        : { orderBy?: inducks_movieGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_movieGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_movieGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_movie model
   */
  readonly fields: inducks_movieFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_movie.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_movieClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_movie model
   */ 
  interface inducks_movieFieldRefs {
    readonly moviecode: FieldRef<"inducks_movie", 'String'>
    readonly title: FieldRef<"inducks_movie", 'String'>
    readonly moviecomment: FieldRef<"inducks_movie", 'String'>
    readonly appsummary: FieldRef<"inducks_movie", 'String'>
    readonly moviejobsummary: FieldRef<"inducks_movie", 'String'>
    readonly locked: FieldRef<"inducks_movie", 'inducks_movie_locked'>
    readonly inputfilecode: FieldRef<"inducks_movie", 'Int'>
    readonly maintenanceteamcode: FieldRef<"inducks_movie", 'String'>
    readonly aka: FieldRef<"inducks_movie", 'String'>
    readonly creationdate: FieldRef<"inducks_movie", 'String'>
    readonly moviedescription: FieldRef<"inducks_movie", 'String'>
    readonly distributor: FieldRef<"inducks_movie", 'String'>
    readonly genre: FieldRef<"inducks_movie", 'String'>
    readonly orderer: FieldRef<"inducks_movie", 'String'>
    readonly publicationdate: FieldRef<"inducks_movie", 'String'>
    readonly source: FieldRef<"inducks_movie", 'String'>
    readonly tim: FieldRef<"inducks_movie", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_movie findUnique
   */
  export type inducks_movieFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_movie
     */
    select?: inducks_movieSelect<ExtArgs> | null
    /**
     * Filter, which inducks_movie to fetch.
     */
    where: inducks_movieWhereUniqueInput
  }


  /**
   * inducks_movie findUniqueOrThrow
   */
  export type inducks_movieFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_movie
     */
    select?: inducks_movieSelect<ExtArgs> | null
    /**
     * Filter, which inducks_movie to fetch.
     */
    where: inducks_movieWhereUniqueInput
  }


  /**
   * inducks_movie findFirst
   */
  export type inducks_movieFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_movie
     */
    select?: inducks_movieSelect<ExtArgs> | null
    /**
     * Filter, which inducks_movie to fetch.
     */
    where?: inducks_movieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_movies to fetch.
     */
    orderBy?: inducks_movieOrderByWithRelationInput | inducks_movieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_movies.
     */
    cursor?: inducks_movieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_movies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_movies.
     */
    distinct?: Inducks_movieScalarFieldEnum | Inducks_movieScalarFieldEnum[]
  }


  /**
   * inducks_movie findFirstOrThrow
   */
  export type inducks_movieFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_movie
     */
    select?: inducks_movieSelect<ExtArgs> | null
    /**
     * Filter, which inducks_movie to fetch.
     */
    where?: inducks_movieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_movies to fetch.
     */
    orderBy?: inducks_movieOrderByWithRelationInput | inducks_movieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_movies.
     */
    cursor?: inducks_movieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_movies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_movies.
     */
    distinct?: Inducks_movieScalarFieldEnum | Inducks_movieScalarFieldEnum[]
  }


  /**
   * inducks_movie findMany
   */
  export type inducks_movieFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_movie
     */
    select?: inducks_movieSelect<ExtArgs> | null
    /**
     * Filter, which inducks_movies to fetch.
     */
    where?: inducks_movieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_movies to fetch.
     */
    orderBy?: inducks_movieOrderByWithRelationInput | inducks_movieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_movies.
     */
    cursor?: inducks_movieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_movies.
     */
    skip?: number
    distinct?: Inducks_movieScalarFieldEnum | Inducks_movieScalarFieldEnum[]
  }


  /**
   * inducks_movie create
   */
  export type inducks_movieCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_movie
     */
    select?: inducks_movieSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_movie.
     */
    data: XOR<inducks_movieCreateInput, inducks_movieUncheckedCreateInput>
  }


  /**
   * inducks_movie createMany
   */
  export type inducks_movieCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_movies.
     */
    data: inducks_movieCreateManyInput | inducks_movieCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_movie update
   */
  export type inducks_movieUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_movie
     */
    select?: inducks_movieSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_movie.
     */
    data: XOR<inducks_movieUpdateInput, inducks_movieUncheckedUpdateInput>
    /**
     * Choose, which inducks_movie to update.
     */
    where: inducks_movieWhereUniqueInput
  }


  /**
   * inducks_movie updateMany
   */
  export type inducks_movieUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_movies.
     */
    data: XOR<inducks_movieUpdateManyMutationInput, inducks_movieUncheckedUpdateManyInput>
    /**
     * Filter which inducks_movies to update
     */
    where?: inducks_movieWhereInput
  }


  /**
   * inducks_movie upsert
   */
  export type inducks_movieUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_movie
     */
    select?: inducks_movieSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_movie to update in case it exists.
     */
    where: inducks_movieWhereUniqueInput
    /**
     * In case the inducks_movie found by the `where` argument doesn't exist, create a new inducks_movie with this data.
     */
    create: XOR<inducks_movieCreateInput, inducks_movieUncheckedCreateInput>
    /**
     * In case the inducks_movie was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_movieUpdateInput, inducks_movieUncheckedUpdateInput>
  }


  /**
   * inducks_movie delete
   */
  export type inducks_movieDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_movie
     */
    select?: inducks_movieSelect<ExtArgs> | null
    /**
     * Filter which inducks_movie to delete.
     */
    where: inducks_movieWhereUniqueInput
  }


  /**
   * inducks_movie deleteMany
   */
  export type inducks_movieDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_movies to delete
     */
    where?: inducks_movieWhereInput
  }


  /**
   * inducks_movie without action
   */
  export type inducks_movieDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_movie
     */
    select?: inducks_movieSelect<ExtArgs> | null
  }



  /**
   * Model inducks_moviecharacter
   */

  export type AggregateInducks_moviecharacter = {
    _count: Inducks_moviecharacterCountAggregateOutputType | null
    _min: Inducks_moviecharacterMinAggregateOutputType | null
    _max: Inducks_moviecharacterMaxAggregateOutputType | null
  }

  export type Inducks_moviecharacterMinAggregateOutputType = {
    moviecode: string | null
    charactercode: string | null
    istitlecharacter: $Enums.inducks_moviecharacter_istitlecharacter | null
  }

  export type Inducks_moviecharacterMaxAggregateOutputType = {
    moviecode: string | null
    charactercode: string | null
    istitlecharacter: $Enums.inducks_moviecharacter_istitlecharacter | null
  }

  export type Inducks_moviecharacterCountAggregateOutputType = {
    moviecode: number
    charactercode: number
    istitlecharacter: number
    _all: number
  }


  export type Inducks_moviecharacterMinAggregateInputType = {
    moviecode?: true
    charactercode?: true
    istitlecharacter?: true
  }

  export type Inducks_moviecharacterMaxAggregateInputType = {
    moviecode?: true
    charactercode?: true
    istitlecharacter?: true
  }

  export type Inducks_moviecharacterCountAggregateInputType = {
    moviecode?: true
    charactercode?: true
    istitlecharacter?: true
    _all?: true
  }

  export type Inducks_moviecharacterAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_moviecharacter to aggregate.
     */
    where?: inducks_moviecharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_moviecharacters to fetch.
     */
    orderBy?: inducks_moviecharacterOrderByWithRelationInput | inducks_moviecharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_moviecharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_moviecharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_moviecharacters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_moviecharacters
    **/
    _count?: true | Inducks_moviecharacterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_moviecharacterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_moviecharacterMaxAggregateInputType
  }

  export type GetInducks_moviecharacterAggregateType<T extends Inducks_moviecharacterAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_moviecharacter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_moviecharacter[P]>
      : GetScalarType<T[P], AggregateInducks_moviecharacter[P]>
  }




  export type inducks_moviecharacterGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_moviecharacterWhereInput
    orderBy?: inducks_moviecharacterOrderByWithAggregationInput | inducks_moviecharacterOrderByWithAggregationInput[]
    by: Inducks_moviecharacterScalarFieldEnum[] | Inducks_moviecharacterScalarFieldEnum
    having?: inducks_moviecharacterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_moviecharacterCountAggregateInputType | true
    _min?: Inducks_moviecharacterMinAggregateInputType
    _max?: Inducks_moviecharacterMaxAggregateInputType
  }

  export type Inducks_moviecharacterGroupByOutputType = {
    moviecode: string
    charactercode: string
    istitlecharacter: $Enums.inducks_moviecharacter_istitlecharacter | null
    _count: Inducks_moviecharacterCountAggregateOutputType | null
    _min: Inducks_moviecharacterMinAggregateOutputType | null
    _max: Inducks_moviecharacterMaxAggregateOutputType | null
  }

  type GetInducks_moviecharacterGroupByPayload<T extends inducks_moviecharacterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_moviecharacterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_moviecharacterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_moviecharacterGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_moviecharacterGroupByOutputType[P]>
        }
      >
    >


  export type inducks_moviecharacterSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moviecode?: boolean
    charactercode?: boolean
    istitlecharacter?: boolean
  }, ExtArgs["result"]["inducks_moviecharacter"]>

  export type inducks_moviecharacterSelectScalar = {
    moviecode?: boolean
    charactercode?: boolean
    istitlecharacter?: boolean
  }


  export type $inducks_moviecharacterPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_moviecharacter"
    objects: {}
    scalars: $Extensions.GetResult<{
      moviecode: string
      charactercode: string
      istitlecharacter: $Enums.inducks_moviecharacter_istitlecharacter | null
    }, ExtArgs["result"]["inducks_moviecharacter"]>
    composites: {}
  }


  type inducks_moviecharacterGetPayload<S extends boolean | null | undefined | inducks_moviecharacterDefaultArgs> = $Result.GetResult<Prisma.$inducks_moviecharacterPayload, S>

  type inducks_moviecharacterCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_moviecharacterFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_moviecharacterCountAggregateInputType | true
    }

  export interface inducks_moviecharacterDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_moviecharacter'], meta: { name: 'inducks_moviecharacter' } }
    /**
     * Find zero or one Inducks_moviecharacter that matches the filter.
     * @param {inducks_moviecharacterFindUniqueArgs} args - Arguments to find a Inducks_moviecharacter
     * @example
     * // Get one Inducks_moviecharacter
     * const inducks_moviecharacter = await prisma.inducks_moviecharacter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_moviecharacterFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_moviecharacterFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_moviecharacterClient<$Result.GetResult<Prisma.$inducks_moviecharacterPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_moviecharacter that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_moviecharacterFindUniqueOrThrowArgs} args - Arguments to find a Inducks_moviecharacter
     * @example
     * // Get one Inducks_moviecharacter
     * const inducks_moviecharacter = await prisma.inducks_moviecharacter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_moviecharacterFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_moviecharacterFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_moviecharacterClient<$Result.GetResult<Prisma.$inducks_moviecharacterPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_moviecharacter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_moviecharacterFindFirstArgs} args - Arguments to find a Inducks_moviecharacter
     * @example
     * // Get one Inducks_moviecharacter
     * const inducks_moviecharacter = await prisma.inducks_moviecharacter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_moviecharacterFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_moviecharacterFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_moviecharacterClient<$Result.GetResult<Prisma.$inducks_moviecharacterPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_moviecharacter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_moviecharacterFindFirstOrThrowArgs} args - Arguments to find a Inducks_moviecharacter
     * @example
     * // Get one Inducks_moviecharacter
     * const inducks_moviecharacter = await prisma.inducks_moviecharacter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_moviecharacterFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_moviecharacterFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_moviecharacterClient<$Result.GetResult<Prisma.$inducks_moviecharacterPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_moviecharacters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_moviecharacterFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_moviecharacters
     * const inducks_moviecharacters = await prisma.inducks_moviecharacter.findMany()
     * 
     * // Get first 10 Inducks_moviecharacters
     * const inducks_moviecharacters = await prisma.inducks_moviecharacter.findMany({ take: 10 })
     * 
     * // Only select the `moviecode`
     * const inducks_moviecharacterWithMoviecodeOnly = await prisma.inducks_moviecharacter.findMany({ select: { moviecode: true } })
     * 
    **/
    findMany<T extends inducks_moviecharacterFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_moviecharacterFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_moviecharacterPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_moviecharacter.
     * @param {inducks_moviecharacterCreateArgs} args - Arguments to create a Inducks_moviecharacter.
     * @example
     * // Create one Inducks_moviecharacter
     * const Inducks_moviecharacter = await prisma.inducks_moviecharacter.create({
     *   data: {
     *     // ... data to create a Inducks_moviecharacter
     *   }
     * })
     * 
    **/
    create<T extends inducks_moviecharacterCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_moviecharacterCreateArgs<ExtArgs>>
    ): Prisma__inducks_moviecharacterClient<$Result.GetResult<Prisma.$inducks_moviecharacterPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_moviecharacters.
     *     @param {inducks_moviecharacterCreateManyArgs} args - Arguments to create many Inducks_moviecharacters.
     *     @example
     *     // Create many Inducks_moviecharacters
     *     const inducks_moviecharacter = await prisma.inducks_moviecharacter.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_moviecharacterCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_moviecharacterCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_moviecharacter.
     * @param {inducks_moviecharacterDeleteArgs} args - Arguments to delete one Inducks_moviecharacter.
     * @example
     * // Delete one Inducks_moviecharacter
     * const Inducks_moviecharacter = await prisma.inducks_moviecharacter.delete({
     *   where: {
     *     // ... filter to delete one Inducks_moviecharacter
     *   }
     * })
     * 
    **/
    delete<T extends inducks_moviecharacterDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_moviecharacterDeleteArgs<ExtArgs>>
    ): Prisma__inducks_moviecharacterClient<$Result.GetResult<Prisma.$inducks_moviecharacterPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_moviecharacter.
     * @param {inducks_moviecharacterUpdateArgs} args - Arguments to update one Inducks_moviecharacter.
     * @example
     * // Update one Inducks_moviecharacter
     * const inducks_moviecharacter = await prisma.inducks_moviecharacter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_moviecharacterUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_moviecharacterUpdateArgs<ExtArgs>>
    ): Prisma__inducks_moviecharacterClient<$Result.GetResult<Prisma.$inducks_moviecharacterPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_moviecharacters.
     * @param {inducks_moviecharacterDeleteManyArgs} args - Arguments to filter Inducks_moviecharacters to delete.
     * @example
     * // Delete a few Inducks_moviecharacters
     * const { count } = await prisma.inducks_moviecharacter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_moviecharacterDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_moviecharacterDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_moviecharacters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_moviecharacterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_moviecharacters
     * const inducks_moviecharacter = await prisma.inducks_moviecharacter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_moviecharacterUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_moviecharacterUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_moviecharacter.
     * @param {inducks_moviecharacterUpsertArgs} args - Arguments to update or create a Inducks_moviecharacter.
     * @example
     * // Update or create a Inducks_moviecharacter
     * const inducks_moviecharacter = await prisma.inducks_moviecharacter.upsert({
     *   create: {
     *     // ... data to create a Inducks_moviecharacter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_moviecharacter we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_moviecharacterUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_moviecharacterUpsertArgs<ExtArgs>>
    ): Prisma__inducks_moviecharacterClient<$Result.GetResult<Prisma.$inducks_moviecharacterPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_moviecharacters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_moviecharacterCountArgs} args - Arguments to filter Inducks_moviecharacters to count.
     * @example
     * // Count the number of Inducks_moviecharacters
     * const count = await prisma.inducks_moviecharacter.count({
     *   where: {
     *     // ... the filter for the Inducks_moviecharacters we want to count
     *   }
     * })
    **/
    count<T extends inducks_moviecharacterCountArgs>(
      args?: Subset<T, inducks_moviecharacterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_moviecharacterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_moviecharacter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_moviecharacterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_moviecharacterAggregateArgs>(args: Subset<T, Inducks_moviecharacterAggregateArgs>): Prisma.PrismaPromise<GetInducks_moviecharacterAggregateType<T>>

    /**
     * Group by Inducks_moviecharacter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_moviecharacterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_moviecharacterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_moviecharacterGroupByArgs['orderBy'] }
        : { orderBy?: inducks_moviecharacterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_moviecharacterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_moviecharacterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_moviecharacter model
   */
  readonly fields: inducks_moviecharacterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_moviecharacter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_moviecharacterClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_moviecharacter model
   */ 
  interface inducks_moviecharacterFieldRefs {
    readonly moviecode: FieldRef<"inducks_moviecharacter", 'String'>
    readonly charactercode: FieldRef<"inducks_moviecharacter", 'String'>
    readonly istitlecharacter: FieldRef<"inducks_moviecharacter", 'inducks_moviecharacter_istitlecharacter'>
  }
    

  // Custom InputTypes

  /**
   * inducks_moviecharacter findUnique
   */
  export type inducks_moviecharacterFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_moviecharacter
     */
    select?: inducks_moviecharacterSelect<ExtArgs> | null
    /**
     * Filter, which inducks_moviecharacter to fetch.
     */
    where: inducks_moviecharacterWhereUniqueInput
  }


  /**
   * inducks_moviecharacter findUniqueOrThrow
   */
  export type inducks_moviecharacterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_moviecharacter
     */
    select?: inducks_moviecharacterSelect<ExtArgs> | null
    /**
     * Filter, which inducks_moviecharacter to fetch.
     */
    where: inducks_moviecharacterWhereUniqueInput
  }


  /**
   * inducks_moviecharacter findFirst
   */
  export type inducks_moviecharacterFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_moviecharacter
     */
    select?: inducks_moviecharacterSelect<ExtArgs> | null
    /**
     * Filter, which inducks_moviecharacter to fetch.
     */
    where?: inducks_moviecharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_moviecharacters to fetch.
     */
    orderBy?: inducks_moviecharacterOrderByWithRelationInput | inducks_moviecharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_moviecharacters.
     */
    cursor?: inducks_moviecharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_moviecharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_moviecharacters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_moviecharacters.
     */
    distinct?: Inducks_moviecharacterScalarFieldEnum | Inducks_moviecharacterScalarFieldEnum[]
  }


  /**
   * inducks_moviecharacter findFirstOrThrow
   */
  export type inducks_moviecharacterFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_moviecharacter
     */
    select?: inducks_moviecharacterSelect<ExtArgs> | null
    /**
     * Filter, which inducks_moviecharacter to fetch.
     */
    where?: inducks_moviecharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_moviecharacters to fetch.
     */
    orderBy?: inducks_moviecharacterOrderByWithRelationInput | inducks_moviecharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_moviecharacters.
     */
    cursor?: inducks_moviecharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_moviecharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_moviecharacters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_moviecharacters.
     */
    distinct?: Inducks_moviecharacterScalarFieldEnum | Inducks_moviecharacterScalarFieldEnum[]
  }


  /**
   * inducks_moviecharacter findMany
   */
  export type inducks_moviecharacterFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_moviecharacter
     */
    select?: inducks_moviecharacterSelect<ExtArgs> | null
    /**
     * Filter, which inducks_moviecharacters to fetch.
     */
    where?: inducks_moviecharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_moviecharacters to fetch.
     */
    orderBy?: inducks_moviecharacterOrderByWithRelationInput | inducks_moviecharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_moviecharacters.
     */
    cursor?: inducks_moviecharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_moviecharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_moviecharacters.
     */
    skip?: number
    distinct?: Inducks_moviecharacterScalarFieldEnum | Inducks_moviecharacterScalarFieldEnum[]
  }


  /**
   * inducks_moviecharacter create
   */
  export type inducks_moviecharacterCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_moviecharacter
     */
    select?: inducks_moviecharacterSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_moviecharacter.
     */
    data: XOR<inducks_moviecharacterCreateInput, inducks_moviecharacterUncheckedCreateInput>
  }


  /**
   * inducks_moviecharacter createMany
   */
  export type inducks_moviecharacterCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_moviecharacters.
     */
    data: inducks_moviecharacterCreateManyInput | inducks_moviecharacterCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_moviecharacter update
   */
  export type inducks_moviecharacterUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_moviecharacter
     */
    select?: inducks_moviecharacterSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_moviecharacter.
     */
    data: XOR<inducks_moviecharacterUpdateInput, inducks_moviecharacterUncheckedUpdateInput>
    /**
     * Choose, which inducks_moviecharacter to update.
     */
    where: inducks_moviecharacterWhereUniqueInput
  }


  /**
   * inducks_moviecharacter updateMany
   */
  export type inducks_moviecharacterUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_moviecharacters.
     */
    data: XOR<inducks_moviecharacterUpdateManyMutationInput, inducks_moviecharacterUncheckedUpdateManyInput>
    /**
     * Filter which inducks_moviecharacters to update
     */
    where?: inducks_moviecharacterWhereInput
  }


  /**
   * inducks_moviecharacter upsert
   */
  export type inducks_moviecharacterUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_moviecharacter
     */
    select?: inducks_moviecharacterSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_moviecharacter to update in case it exists.
     */
    where: inducks_moviecharacterWhereUniqueInput
    /**
     * In case the inducks_moviecharacter found by the `where` argument doesn't exist, create a new inducks_moviecharacter with this data.
     */
    create: XOR<inducks_moviecharacterCreateInput, inducks_moviecharacterUncheckedCreateInput>
    /**
     * In case the inducks_moviecharacter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_moviecharacterUpdateInput, inducks_moviecharacterUncheckedUpdateInput>
  }


  /**
   * inducks_moviecharacter delete
   */
  export type inducks_moviecharacterDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_moviecharacter
     */
    select?: inducks_moviecharacterSelect<ExtArgs> | null
    /**
     * Filter which inducks_moviecharacter to delete.
     */
    where: inducks_moviecharacterWhereUniqueInput
  }


  /**
   * inducks_moviecharacter deleteMany
   */
  export type inducks_moviecharacterDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_moviecharacters to delete
     */
    where?: inducks_moviecharacterWhereInput
  }


  /**
   * inducks_moviecharacter without action
   */
  export type inducks_moviecharacterDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_moviecharacter
     */
    select?: inducks_moviecharacterSelect<ExtArgs> | null
  }



  /**
   * Model inducks_moviejob
   */

  export type AggregateInducks_moviejob = {
    _count: Inducks_moviejobCountAggregateOutputType | null
    _min: Inducks_moviejobMinAggregateOutputType | null
    _max: Inducks_moviejobMaxAggregateOutputType | null
  }

  export type Inducks_moviejobMinAggregateOutputType = {
    moviecode: string | null
    personcode: string | null
    role: string | null
    moviejobcomment: string | null
    indirect: $Enums.inducks_moviejob_indirect | null
    doubt: $Enums.inducks_moviejob_doubt | null
  }

  export type Inducks_moviejobMaxAggregateOutputType = {
    moviecode: string | null
    personcode: string | null
    role: string | null
    moviejobcomment: string | null
    indirect: $Enums.inducks_moviejob_indirect | null
    doubt: $Enums.inducks_moviejob_doubt | null
  }

  export type Inducks_moviejobCountAggregateOutputType = {
    moviecode: number
    personcode: number
    role: number
    moviejobcomment: number
    indirect: number
    doubt: number
    _all: number
  }


  export type Inducks_moviejobMinAggregateInputType = {
    moviecode?: true
    personcode?: true
    role?: true
    moviejobcomment?: true
    indirect?: true
    doubt?: true
  }

  export type Inducks_moviejobMaxAggregateInputType = {
    moviecode?: true
    personcode?: true
    role?: true
    moviejobcomment?: true
    indirect?: true
    doubt?: true
  }

  export type Inducks_moviejobCountAggregateInputType = {
    moviecode?: true
    personcode?: true
    role?: true
    moviejobcomment?: true
    indirect?: true
    doubt?: true
    _all?: true
  }

  export type Inducks_moviejobAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_moviejob to aggregate.
     */
    where?: inducks_moviejobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_moviejobs to fetch.
     */
    orderBy?: inducks_moviejobOrderByWithRelationInput | inducks_moviejobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_moviejobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_moviejobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_moviejobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_moviejobs
    **/
    _count?: true | Inducks_moviejobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_moviejobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_moviejobMaxAggregateInputType
  }

  export type GetInducks_moviejobAggregateType<T extends Inducks_moviejobAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_moviejob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_moviejob[P]>
      : GetScalarType<T[P], AggregateInducks_moviejob[P]>
  }




  export type inducks_moviejobGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_moviejobWhereInput
    orderBy?: inducks_moviejobOrderByWithAggregationInput | inducks_moviejobOrderByWithAggregationInput[]
    by: Inducks_moviejobScalarFieldEnum[] | Inducks_moviejobScalarFieldEnum
    having?: inducks_moviejobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_moviejobCountAggregateInputType | true
    _min?: Inducks_moviejobMinAggregateInputType
    _max?: Inducks_moviejobMaxAggregateInputType
  }

  export type Inducks_moviejobGroupByOutputType = {
    moviecode: string
    personcode: string
    role: string
    moviejobcomment: string | null
    indirect: $Enums.inducks_moviejob_indirect | null
    doubt: $Enums.inducks_moviejob_doubt | null
    _count: Inducks_moviejobCountAggregateOutputType | null
    _min: Inducks_moviejobMinAggregateOutputType | null
    _max: Inducks_moviejobMaxAggregateOutputType | null
  }

  type GetInducks_moviejobGroupByPayload<T extends inducks_moviejobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_moviejobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_moviejobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_moviejobGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_moviejobGroupByOutputType[P]>
        }
      >
    >


  export type inducks_moviejobSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moviecode?: boolean
    personcode?: boolean
    role?: boolean
    moviejobcomment?: boolean
    indirect?: boolean
    doubt?: boolean
  }, ExtArgs["result"]["inducks_moviejob"]>

  export type inducks_moviejobSelectScalar = {
    moviecode?: boolean
    personcode?: boolean
    role?: boolean
    moviejobcomment?: boolean
    indirect?: boolean
    doubt?: boolean
  }


  export type $inducks_moviejobPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_moviejob"
    objects: {}
    scalars: $Extensions.GetResult<{
      moviecode: string
      personcode: string
      role: string
      moviejobcomment: string | null
      indirect: $Enums.inducks_moviejob_indirect | null
      doubt: $Enums.inducks_moviejob_doubt | null
    }, ExtArgs["result"]["inducks_moviejob"]>
    composites: {}
  }


  type inducks_moviejobGetPayload<S extends boolean | null | undefined | inducks_moviejobDefaultArgs> = $Result.GetResult<Prisma.$inducks_moviejobPayload, S>

  type inducks_moviejobCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_moviejobFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_moviejobCountAggregateInputType | true
    }

  export interface inducks_moviejobDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_moviejob'], meta: { name: 'inducks_moviejob' } }
    /**
     * Find zero or one Inducks_moviejob that matches the filter.
     * @param {inducks_moviejobFindUniqueArgs} args - Arguments to find a Inducks_moviejob
     * @example
     * // Get one Inducks_moviejob
     * const inducks_moviejob = await prisma.inducks_moviejob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_moviejobFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_moviejobFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_moviejobClient<$Result.GetResult<Prisma.$inducks_moviejobPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_moviejob that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_moviejobFindUniqueOrThrowArgs} args - Arguments to find a Inducks_moviejob
     * @example
     * // Get one Inducks_moviejob
     * const inducks_moviejob = await prisma.inducks_moviejob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_moviejobFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_moviejobFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_moviejobClient<$Result.GetResult<Prisma.$inducks_moviejobPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_moviejob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_moviejobFindFirstArgs} args - Arguments to find a Inducks_moviejob
     * @example
     * // Get one Inducks_moviejob
     * const inducks_moviejob = await prisma.inducks_moviejob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_moviejobFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_moviejobFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_moviejobClient<$Result.GetResult<Prisma.$inducks_moviejobPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_moviejob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_moviejobFindFirstOrThrowArgs} args - Arguments to find a Inducks_moviejob
     * @example
     * // Get one Inducks_moviejob
     * const inducks_moviejob = await prisma.inducks_moviejob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_moviejobFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_moviejobFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_moviejobClient<$Result.GetResult<Prisma.$inducks_moviejobPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_moviejobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_moviejobFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_moviejobs
     * const inducks_moviejobs = await prisma.inducks_moviejob.findMany()
     * 
     * // Get first 10 Inducks_moviejobs
     * const inducks_moviejobs = await prisma.inducks_moviejob.findMany({ take: 10 })
     * 
     * // Only select the `moviecode`
     * const inducks_moviejobWithMoviecodeOnly = await prisma.inducks_moviejob.findMany({ select: { moviecode: true } })
     * 
    **/
    findMany<T extends inducks_moviejobFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_moviejobFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_moviejobPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_moviejob.
     * @param {inducks_moviejobCreateArgs} args - Arguments to create a Inducks_moviejob.
     * @example
     * // Create one Inducks_moviejob
     * const Inducks_moviejob = await prisma.inducks_moviejob.create({
     *   data: {
     *     // ... data to create a Inducks_moviejob
     *   }
     * })
     * 
    **/
    create<T extends inducks_moviejobCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_moviejobCreateArgs<ExtArgs>>
    ): Prisma__inducks_moviejobClient<$Result.GetResult<Prisma.$inducks_moviejobPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_moviejobs.
     *     @param {inducks_moviejobCreateManyArgs} args - Arguments to create many Inducks_moviejobs.
     *     @example
     *     // Create many Inducks_moviejobs
     *     const inducks_moviejob = await prisma.inducks_moviejob.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_moviejobCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_moviejobCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_moviejob.
     * @param {inducks_moviejobDeleteArgs} args - Arguments to delete one Inducks_moviejob.
     * @example
     * // Delete one Inducks_moviejob
     * const Inducks_moviejob = await prisma.inducks_moviejob.delete({
     *   where: {
     *     // ... filter to delete one Inducks_moviejob
     *   }
     * })
     * 
    **/
    delete<T extends inducks_moviejobDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_moviejobDeleteArgs<ExtArgs>>
    ): Prisma__inducks_moviejobClient<$Result.GetResult<Prisma.$inducks_moviejobPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_moviejob.
     * @param {inducks_moviejobUpdateArgs} args - Arguments to update one Inducks_moviejob.
     * @example
     * // Update one Inducks_moviejob
     * const inducks_moviejob = await prisma.inducks_moviejob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_moviejobUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_moviejobUpdateArgs<ExtArgs>>
    ): Prisma__inducks_moviejobClient<$Result.GetResult<Prisma.$inducks_moviejobPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_moviejobs.
     * @param {inducks_moviejobDeleteManyArgs} args - Arguments to filter Inducks_moviejobs to delete.
     * @example
     * // Delete a few Inducks_moviejobs
     * const { count } = await prisma.inducks_moviejob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_moviejobDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_moviejobDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_moviejobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_moviejobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_moviejobs
     * const inducks_moviejob = await prisma.inducks_moviejob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_moviejobUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_moviejobUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_moviejob.
     * @param {inducks_moviejobUpsertArgs} args - Arguments to update or create a Inducks_moviejob.
     * @example
     * // Update or create a Inducks_moviejob
     * const inducks_moviejob = await prisma.inducks_moviejob.upsert({
     *   create: {
     *     // ... data to create a Inducks_moviejob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_moviejob we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_moviejobUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_moviejobUpsertArgs<ExtArgs>>
    ): Prisma__inducks_moviejobClient<$Result.GetResult<Prisma.$inducks_moviejobPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_moviejobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_moviejobCountArgs} args - Arguments to filter Inducks_moviejobs to count.
     * @example
     * // Count the number of Inducks_moviejobs
     * const count = await prisma.inducks_moviejob.count({
     *   where: {
     *     // ... the filter for the Inducks_moviejobs we want to count
     *   }
     * })
    **/
    count<T extends inducks_moviejobCountArgs>(
      args?: Subset<T, inducks_moviejobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_moviejobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_moviejob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_moviejobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_moviejobAggregateArgs>(args: Subset<T, Inducks_moviejobAggregateArgs>): Prisma.PrismaPromise<GetInducks_moviejobAggregateType<T>>

    /**
     * Group by Inducks_moviejob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_moviejobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_moviejobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_moviejobGroupByArgs['orderBy'] }
        : { orderBy?: inducks_moviejobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_moviejobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_moviejobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_moviejob model
   */
  readonly fields: inducks_moviejobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_moviejob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_moviejobClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_moviejob model
   */ 
  interface inducks_moviejobFieldRefs {
    readonly moviecode: FieldRef<"inducks_moviejob", 'String'>
    readonly personcode: FieldRef<"inducks_moviejob", 'String'>
    readonly role: FieldRef<"inducks_moviejob", 'String'>
    readonly moviejobcomment: FieldRef<"inducks_moviejob", 'String'>
    readonly indirect: FieldRef<"inducks_moviejob", 'inducks_moviejob_indirect'>
    readonly doubt: FieldRef<"inducks_moviejob", 'inducks_moviejob_doubt'>
  }
    

  // Custom InputTypes

  /**
   * inducks_moviejob findUnique
   */
  export type inducks_moviejobFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_moviejob
     */
    select?: inducks_moviejobSelect<ExtArgs> | null
    /**
     * Filter, which inducks_moviejob to fetch.
     */
    where: inducks_moviejobWhereUniqueInput
  }


  /**
   * inducks_moviejob findUniqueOrThrow
   */
  export type inducks_moviejobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_moviejob
     */
    select?: inducks_moviejobSelect<ExtArgs> | null
    /**
     * Filter, which inducks_moviejob to fetch.
     */
    where: inducks_moviejobWhereUniqueInput
  }


  /**
   * inducks_moviejob findFirst
   */
  export type inducks_moviejobFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_moviejob
     */
    select?: inducks_moviejobSelect<ExtArgs> | null
    /**
     * Filter, which inducks_moviejob to fetch.
     */
    where?: inducks_moviejobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_moviejobs to fetch.
     */
    orderBy?: inducks_moviejobOrderByWithRelationInput | inducks_moviejobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_moviejobs.
     */
    cursor?: inducks_moviejobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_moviejobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_moviejobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_moviejobs.
     */
    distinct?: Inducks_moviejobScalarFieldEnum | Inducks_moviejobScalarFieldEnum[]
  }


  /**
   * inducks_moviejob findFirstOrThrow
   */
  export type inducks_moviejobFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_moviejob
     */
    select?: inducks_moviejobSelect<ExtArgs> | null
    /**
     * Filter, which inducks_moviejob to fetch.
     */
    where?: inducks_moviejobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_moviejobs to fetch.
     */
    orderBy?: inducks_moviejobOrderByWithRelationInput | inducks_moviejobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_moviejobs.
     */
    cursor?: inducks_moviejobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_moviejobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_moviejobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_moviejobs.
     */
    distinct?: Inducks_moviejobScalarFieldEnum | Inducks_moviejobScalarFieldEnum[]
  }


  /**
   * inducks_moviejob findMany
   */
  export type inducks_moviejobFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_moviejob
     */
    select?: inducks_moviejobSelect<ExtArgs> | null
    /**
     * Filter, which inducks_moviejobs to fetch.
     */
    where?: inducks_moviejobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_moviejobs to fetch.
     */
    orderBy?: inducks_moviejobOrderByWithRelationInput | inducks_moviejobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_moviejobs.
     */
    cursor?: inducks_moviejobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_moviejobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_moviejobs.
     */
    skip?: number
    distinct?: Inducks_moviejobScalarFieldEnum | Inducks_moviejobScalarFieldEnum[]
  }


  /**
   * inducks_moviejob create
   */
  export type inducks_moviejobCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_moviejob
     */
    select?: inducks_moviejobSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_moviejob.
     */
    data: XOR<inducks_moviejobCreateInput, inducks_moviejobUncheckedCreateInput>
  }


  /**
   * inducks_moviejob createMany
   */
  export type inducks_moviejobCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_moviejobs.
     */
    data: inducks_moviejobCreateManyInput | inducks_moviejobCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_moviejob update
   */
  export type inducks_moviejobUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_moviejob
     */
    select?: inducks_moviejobSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_moviejob.
     */
    data: XOR<inducks_moviejobUpdateInput, inducks_moviejobUncheckedUpdateInput>
    /**
     * Choose, which inducks_moviejob to update.
     */
    where: inducks_moviejobWhereUniqueInput
  }


  /**
   * inducks_moviejob updateMany
   */
  export type inducks_moviejobUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_moviejobs.
     */
    data: XOR<inducks_moviejobUpdateManyMutationInput, inducks_moviejobUncheckedUpdateManyInput>
    /**
     * Filter which inducks_moviejobs to update
     */
    where?: inducks_moviejobWhereInput
  }


  /**
   * inducks_moviejob upsert
   */
  export type inducks_moviejobUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_moviejob
     */
    select?: inducks_moviejobSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_moviejob to update in case it exists.
     */
    where: inducks_moviejobWhereUniqueInput
    /**
     * In case the inducks_moviejob found by the `where` argument doesn't exist, create a new inducks_moviejob with this data.
     */
    create: XOR<inducks_moviejobCreateInput, inducks_moviejobUncheckedCreateInput>
    /**
     * In case the inducks_moviejob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_moviejobUpdateInput, inducks_moviejobUncheckedUpdateInput>
  }


  /**
   * inducks_moviejob delete
   */
  export type inducks_moviejobDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_moviejob
     */
    select?: inducks_moviejobSelect<ExtArgs> | null
    /**
     * Filter which inducks_moviejob to delete.
     */
    where: inducks_moviejobWhereUniqueInput
  }


  /**
   * inducks_moviejob deleteMany
   */
  export type inducks_moviejobDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_moviejobs to delete
     */
    where?: inducks_moviejobWhereInput
  }


  /**
   * inducks_moviejob without action
   */
  export type inducks_moviejobDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_moviejob
     */
    select?: inducks_moviejobSelect<ExtArgs> | null
  }



  /**
   * Model inducks_moviereference
   */

  export type AggregateInducks_moviereference = {
    _count: Inducks_moviereferenceCountAggregateOutputType | null
    _avg: Inducks_moviereferenceAvgAggregateOutputType | null
    _sum: Inducks_moviereferenceSumAggregateOutputType | null
    _min: Inducks_moviereferenceMinAggregateOutputType | null
    _max: Inducks_moviereferenceMaxAggregateOutputType | null
  }

  export type Inducks_moviereferenceAvgAggregateOutputType = {
    referencereasonid: number | null
  }

  export type Inducks_moviereferenceSumAggregateOutputType = {
    referencereasonid: number | null
  }

  export type Inducks_moviereferenceMinAggregateOutputType = {
    storycode: string | null
    moviecode: string | null
    referencereasonid: number | null
    frommovietostory: $Enums.inducks_moviereference_frommovietostory | null
  }

  export type Inducks_moviereferenceMaxAggregateOutputType = {
    storycode: string | null
    moviecode: string | null
    referencereasonid: number | null
    frommovietostory: $Enums.inducks_moviereference_frommovietostory | null
  }

  export type Inducks_moviereferenceCountAggregateOutputType = {
    storycode: number
    moviecode: number
    referencereasonid: number
    frommovietostory: number
    _all: number
  }


  export type Inducks_moviereferenceAvgAggregateInputType = {
    referencereasonid?: true
  }

  export type Inducks_moviereferenceSumAggregateInputType = {
    referencereasonid?: true
  }

  export type Inducks_moviereferenceMinAggregateInputType = {
    storycode?: true
    moviecode?: true
    referencereasonid?: true
    frommovietostory?: true
  }

  export type Inducks_moviereferenceMaxAggregateInputType = {
    storycode?: true
    moviecode?: true
    referencereasonid?: true
    frommovietostory?: true
  }

  export type Inducks_moviereferenceCountAggregateInputType = {
    storycode?: true
    moviecode?: true
    referencereasonid?: true
    frommovietostory?: true
    _all?: true
  }

  export type Inducks_moviereferenceAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_moviereference to aggregate.
     */
    where?: inducks_moviereferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_moviereferences to fetch.
     */
    orderBy?: inducks_moviereferenceOrderByWithRelationInput | inducks_moviereferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_moviereferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_moviereferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_moviereferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_moviereferences
    **/
    _count?: true | Inducks_moviereferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Inducks_moviereferenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Inducks_moviereferenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_moviereferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_moviereferenceMaxAggregateInputType
  }

  export type GetInducks_moviereferenceAggregateType<T extends Inducks_moviereferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_moviereference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_moviereference[P]>
      : GetScalarType<T[P], AggregateInducks_moviereference[P]>
  }




  export type inducks_moviereferenceGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_moviereferenceWhereInput
    orderBy?: inducks_moviereferenceOrderByWithAggregationInput | inducks_moviereferenceOrderByWithAggregationInput[]
    by: Inducks_moviereferenceScalarFieldEnum[] | Inducks_moviereferenceScalarFieldEnum
    having?: inducks_moviereferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_moviereferenceCountAggregateInputType | true
    _avg?: Inducks_moviereferenceAvgAggregateInputType
    _sum?: Inducks_moviereferenceSumAggregateInputType
    _min?: Inducks_moviereferenceMinAggregateInputType
    _max?: Inducks_moviereferenceMaxAggregateInputType
  }

  export type Inducks_moviereferenceGroupByOutputType = {
    storycode: string
    moviecode: string
    referencereasonid: number | null
    frommovietostory: $Enums.inducks_moviereference_frommovietostory | null
    _count: Inducks_moviereferenceCountAggregateOutputType | null
    _avg: Inducks_moviereferenceAvgAggregateOutputType | null
    _sum: Inducks_moviereferenceSumAggregateOutputType | null
    _min: Inducks_moviereferenceMinAggregateOutputType | null
    _max: Inducks_moviereferenceMaxAggregateOutputType | null
  }

  type GetInducks_moviereferenceGroupByPayload<T extends inducks_moviereferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_moviereferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_moviereferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_moviereferenceGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_moviereferenceGroupByOutputType[P]>
        }
      >
    >


  export type inducks_moviereferenceSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    storycode?: boolean
    moviecode?: boolean
    referencereasonid?: boolean
    frommovietostory?: boolean
  }, ExtArgs["result"]["inducks_moviereference"]>

  export type inducks_moviereferenceSelectScalar = {
    storycode?: boolean
    moviecode?: boolean
    referencereasonid?: boolean
    frommovietostory?: boolean
  }


  export type $inducks_moviereferencePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_moviereference"
    objects: {}
    scalars: $Extensions.GetResult<{
      storycode: string
      moviecode: string
      referencereasonid: number | null
      frommovietostory: $Enums.inducks_moviereference_frommovietostory | null
    }, ExtArgs["result"]["inducks_moviereference"]>
    composites: {}
  }


  type inducks_moviereferenceGetPayload<S extends boolean | null | undefined | inducks_moviereferenceDefaultArgs> = $Result.GetResult<Prisma.$inducks_moviereferencePayload, S>

  type inducks_moviereferenceCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_moviereferenceFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_moviereferenceCountAggregateInputType | true
    }

  export interface inducks_moviereferenceDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_moviereference'], meta: { name: 'inducks_moviereference' } }
    /**
     * Find zero or one Inducks_moviereference that matches the filter.
     * @param {inducks_moviereferenceFindUniqueArgs} args - Arguments to find a Inducks_moviereference
     * @example
     * // Get one Inducks_moviereference
     * const inducks_moviereference = await prisma.inducks_moviereference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_moviereferenceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_moviereferenceFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_moviereferenceClient<$Result.GetResult<Prisma.$inducks_moviereferencePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_moviereference that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_moviereferenceFindUniqueOrThrowArgs} args - Arguments to find a Inducks_moviereference
     * @example
     * // Get one Inducks_moviereference
     * const inducks_moviereference = await prisma.inducks_moviereference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_moviereferenceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_moviereferenceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_moviereferenceClient<$Result.GetResult<Prisma.$inducks_moviereferencePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_moviereference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_moviereferenceFindFirstArgs} args - Arguments to find a Inducks_moviereference
     * @example
     * // Get one Inducks_moviereference
     * const inducks_moviereference = await prisma.inducks_moviereference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_moviereferenceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_moviereferenceFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_moviereferenceClient<$Result.GetResult<Prisma.$inducks_moviereferencePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_moviereference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_moviereferenceFindFirstOrThrowArgs} args - Arguments to find a Inducks_moviereference
     * @example
     * // Get one Inducks_moviereference
     * const inducks_moviereference = await prisma.inducks_moviereference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_moviereferenceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_moviereferenceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_moviereferenceClient<$Result.GetResult<Prisma.$inducks_moviereferencePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_moviereferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_moviereferenceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_moviereferences
     * const inducks_moviereferences = await prisma.inducks_moviereference.findMany()
     * 
     * // Get first 10 Inducks_moviereferences
     * const inducks_moviereferences = await prisma.inducks_moviereference.findMany({ take: 10 })
     * 
     * // Only select the `storycode`
     * const inducks_moviereferenceWithStorycodeOnly = await prisma.inducks_moviereference.findMany({ select: { storycode: true } })
     * 
    **/
    findMany<T extends inducks_moviereferenceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_moviereferenceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_moviereferencePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_moviereference.
     * @param {inducks_moviereferenceCreateArgs} args - Arguments to create a Inducks_moviereference.
     * @example
     * // Create one Inducks_moviereference
     * const Inducks_moviereference = await prisma.inducks_moviereference.create({
     *   data: {
     *     // ... data to create a Inducks_moviereference
     *   }
     * })
     * 
    **/
    create<T extends inducks_moviereferenceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_moviereferenceCreateArgs<ExtArgs>>
    ): Prisma__inducks_moviereferenceClient<$Result.GetResult<Prisma.$inducks_moviereferencePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_moviereferences.
     *     @param {inducks_moviereferenceCreateManyArgs} args - Arguments to create many Inducks_moviereferences.
     *     @example
     *     // Create many Inducks_moviereferences
     *     const inducks_moviereference = await prisma.inducks_moviereference.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_moviereferenceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_moviereferenceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_moviereference.
     * @param {inducks_moviereferenceDeleteArgs} args - Arguments to delete one Inducks_moviereference.
     * @example
     * // Delete one Inducks_moviereference
     * const Inducks_moviereference = await prisma.inducks_moviereference.delete({
     *   where: {
     *     // ... filter to delete one Inducks_moviereference
     *   }
     * })
     * 
    **/
    delete<T extends inducks_moviereferenceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_moviereferenceDeleteArgs<ExtArgs>>
    ): Prisma__inducks_moviereferenceClient<$Result.GetResult<Prisma.$inducks_moviereferencePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_moviereference.
     * @param {inducks_moviereferenceUpdateArgs} args - Arguments to update one Inducks_moviereference.
     * @example
     * // Update one Inducks_moviereference
     * const inducks_moviereference = await prisma.inducks_moviereference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_moviereferenceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_moviereferenceUpdateArgs<ExtArgs>>
    ): Prisma__inducks_moviereferenceClient<$Result.GetResult<Prisma.$inducks_moviereferencePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_moviereferences.
     * @param {inducks_moviereferenceDeleteManyArgs} args - Arguments to filter Inducks_moviereferences to delete.
     * @example
     * // Delete a few Inducks_moviereferences
     * const { count } = await prisma.inducks_moviereference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_moviereferenceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_moviereferenceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_moviereferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_moviereferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_moviereferences
     * const inducks_moviereference = await prisma.inducks_moviereference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_moviereferenceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_moviereferenceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_moviereference.
     * @param {inducks_moviereferenceUpsertArgs} args - Arguments to update or create a Inducks_moviereference.
     * @example
     * // Update or create a Inducks_moviereference
     * const inducks_moviereference = await prisma.inducks_moviereference.upsert({
     *   create: {
     *     // ... data to create a Inducks_moviereference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_moviereference we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_moviereferenceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_moviereferenceUpsertArgs<ExtArgs>>
    ): Prisma__inducks_moviereferenceClient<$Result.GetResult<Prisma.$inducks_moviereferencePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_moviereferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_moviereferenceCountArgs} args - Arguments to filter Inducks_moviereferences to count.
     * @example
     * // Count the number of Inducks_moviereferences
     * const count = await prisma.inducks_moviereference.count({
     *   where: {
     *     // ... the filter for the Inducks_moviereferences we want to count
     *   }
     * })
    **/
    count<T extends inducks_moviereferenceCountArgs>(
      args?: Subset<T, inducks_moviereferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_moviereferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_moviereference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_moviereferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_moviereferenceAggregateArgs>(args: Subset<T, Inducks_moviereferenceAggregateArgs>): Prisma.PrismaPromise<GetInducks_moviereferenceAggregateType<T>>

    /**
     * Group by Inducks_moviereference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_moviereferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_moviereferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_moviereferenceGroupByArgs['orderBy'] }
        : { orderBy?: inducks_moviereferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_moviereferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_moviereferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_moviereference model
   */
  readonly fields: inducks_moviereferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_moviereference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_moviereferenceClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_moviereference model
   */ 
  interface inducks_moviereferenceFieldRefs {
    readonly storycode: FieldRef<"inducks_moviereference", 'String'>
    readonly moviecode: FieldRef<"inducks_moviereference", 'String'>
    readonly referencereasonid: FieldRef<"inducks_moviereference", 'Int'>
    readonly frommovietostory: FieldRef<"inducks_moviereference", 'inducks_moviereference_frommovietostory'>
  }
    

  // Custom InputTypes

  /**
   * inducks_moviereference findUnique
   */
  export type inducks_moviereferenceFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_moviereference
     */
    select?: inducks_moviereferenceSelect<ExtArgs> | null
    /**
     * Filter, which inducks_moviereference to fetch.
     */
    where: inducks_moviereferenceWhereUniqueInput
  }


  /**
   * inducks_moviereference findUniqueOrThrow
   */
  export type inducks_moviereferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_moviereference
     */
    select?: inducks_moviereferenceSelect<ExtArgs> | null
    /**
     * Filter, which inducks_moviereference to fetch.
     */
    where: inducks_moviereferenceWhereUniqueInput
  }


  /**
   * inducks_moviereference findFirst
   */
  export type inducks_moviereferenceFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_moviereference
     */
    select?: inducks_moviereferenceSelect<ExtArgs> | null
    /**
     * Filter, which inducks_moviereference to fetch.
     */
    where?: inducks_moviereferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_moviereferences to fetch.
     */
    orderBy?: inducks_moviereferenceOrderByWithRelationInput | inducks_moviereferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_moviereferences.
     */
    cursor?: inducks_moviereferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_moviereferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_moviereferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_moviereferences.
     */
    distinct?: Inducks_moviereferenceScalarFieldEnum | Inducks_moviereferenceScalarFieldEnum[]
  }


  /**
   * inducks_moviereference findFirstOrThrow
   */
  export type inducks_moviereferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_moviereference
     */
    select?: inducks_moviereferenceSelect<ExtArgs> | null
    /**
     * Filter, which inducks_moviereference to fetch.
     */
    where?: inducks_moviereferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_moviereferences to fetch.
     */
    orderBy?: inducks_moviereferenceOrderByWithRelationInput | inducks_moviereferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_moviereferences.
     */
    cursor?: inducks_moviereferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_moviereferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_moviereferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_moviereferences.
     */
    distinct?: Inducks_moviereferenceScalarFieldEnum | Inducks_moviereferenceScalarFieldEnum[]
  }


  /**
   * inducks_moviereference findMany
   */
  export type inducks_moviereferenceFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_moviereference
     */
    select?: inducks_moviereferenceSelect<ExtArgs> | null
    /**
     * Filter, which inducks_moviereferences to fetch.
     */
    where?: inducks_moviereferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_moviereferences to fetch.
     */
    orderBy?: inducks_moviereferenceOrderByWithRelationInput | inducks_moviereferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_moviereferences.
     */
    cursor?: inducks_moviereferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_moviereferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_moviereferences.
     */
    skip?: number
    distinct?: Inducks_moviereferenceScalarFieldEnum | Inducks_moviereferenceScalarFieldEnum[]
  }


  /**
   * inducks_moviereference create
   */
  export type inducks_moviereferenceCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_moviereference
     */
    select?: inducks_moviereferenceSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_moviereference.
     */
    data: XOR<inducks_moviereferenceCreateInput, inducks_moviereferenceUncheckedCreateInput>
  }


  /**
   * inducks_moviereference createMany
   */
  export type inducks_moviereferenceCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_moviereferences.
     */
    data: inducks_moviereferenceCreateManyInput | inducks_moviereferenceCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_moviereference update
   */
  export type inducks_moviereferenceUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_moviereference
     */
    select?: inducks_moviereferenceSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_moviereference.
     */
    data: XOR<inducks_moviereferenceUpdateInput, inducks_moviereferenceUncheckedUpdateInput>
    /**
     * Choose, which inducks_moviereference to update.
     */
    where: inducks_moviereferenceWhereUniqueInput
  }


  /**
   * inducks_moviereference updateMany
   */
  export type inducks_moviereferenceUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_moviereferences.
     */
    data: XOR<inducks_moviereferenceUpdateManyMutationInput, inducks_moviereferenceUncheckedUpdateManyInput>
    /**
     * Filter which inducks_moviereferences to update
     */
    where?: inducks_moviereferenceWhereInput
  }


  /**
   * inducks_moviereference upsert
   */
  export type inducks_moviereferenceUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_moviereference
     */
    select?: inducks_moviereferenceSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_moviereference to update in case it exists.
     */
    where: inducks_moviereferenceWhereUniqueInput
    /**
     * In case the inducks_moviereference found by the `where` argument doesn't exist, create a new inducks_moviereference with this data.
     */
    create: XOR<inducks_moviereferenceCreateInput, inducks_moviereferenceUncheckedCreateInput>
    /**
     * In case the inducks_moviereference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_moviereferenceUpdateInput, inducks_moviereferenceUncheckedUpdateInput>
  }


  /**
   * inducks_moviereference delete
   */
  export type inducks_moviereferenceDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_moviereference
     */
    select?: inducks_moviereferenceSelect<ExtArgs> | null
    /**
     * Filter which inducks_moviereference to delete.
     */
    where: inducks_moviereferenceWhereUniqueInput
  }


  /**
   * inducks_moviereference deleteMany
   */
  export type inducks_moviereferenceDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_moviereferences to delete
     */
    where?: inducks_moviereferenceWhereInput
  }


  /**
   * inducks_moviereference without action
   */
  export type inducks_moviereferenceDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_moviereference
     */
    select?: inducks_moviereferenceSelect<ExtArgs> | null
  }



  /**
   * Model inducks_person
   */

  export type AggregateInducks_person = {
    _count: Inducks_personCountAggregateOutputType | null
    _avg: Inducks_personAvgAggregateOutputType | null
    _sum: Inducks_personSumAggregateOutputType | null
    _min: Inducks_personMinAggregateOutputType | null
    _max: Inducks_personMaxAggregateOutputType | null
  }

  export type Inducks_personAvgAggregateOutputType = {
    numberofindexedissues: number | null
  }

  export type Inducks_personSumAggregateOutputType = {
    numberofindexedissues: number | null
  }

  export type Inducks_personMinAggregateOutputType = {
    personcode: string | null
    nationalitycountrycode: string | null
    fullname: string | null
    official: $Enums.inducks_person_official | null
    personcomment: string | null
    unknownstudiomember: $Enums.inducks_person_unknownstudiomember | null
    isfake: $Enums.inducks_person_isfake | null
    numberofindexedissues: number | null
    birthname: string | null
    borndate: string | null
    bornplace: string | null
    deceaseddate: string | null
    deceasedplace: string | null
    education: string | null
    moviestext: string | null
    comicstext: string | null
    othertext: string | null
    photofilename: string | null
    photocomment: string | null
    photosource: string | null
    personrefs: string | null
  }

  export type Inducks_personMaxAggregateOutputType = {
    personcode: string | null
    nationalitycountrycode: string | null
    fullname: string | null
    official: $Enums.inducks_person_official | null
    personcomment: string | null
    unknownstudiomember: $Enums.inducks_person_unknownstudiomember | null
    isfake: $Enums.inducks_person_isfake | null
    numberofindexedissues: number | null
    birthname: string | null
    borndate: string | null
    bornplace: string | null
    deceaseddate: string | null
    deceasedplace: string | null
    education: string | null
    moviestext: string | null
    comicstext: string | null
    othertext: string | null
    photofilename: string | null
    photocomment: string | null
    photosource: string | null
    personrefs: string | null
  }

  export type Inducks_personCountAggregateOutputType = {
    personcode: number
    nationalitycountrycode: number
    fullname: number
    official: number
    personcomment: number
    unknownstudiomember: number
    isfake: number
    numberofindexedissues: number
    birthname: number
    borndate: number
    bornplace: number
    deceaseddate: number
    deceasedplace: number
    education: number
    moviestext: number
    comicstext: number
    othertext: number
    photofilename: number
    photocomment: number
    photosource: number
    personrefs: number
    _all: number
  }


  export type Inducks_personAvgAggregateInputType = {
    numberofindexedissues?: true
  }

  export type Inducks_personSumAggregateInputType = {
    numberofindexedissues?: true
  }

  export type Inducks_personMinAggregateInputType = {
    personcode?: true
    nationalitycountrycode?: true
    fullname?: true
    official?: true
    personcomment?: true
    unknownstudiomember?: true
    isfake?: true
    numberofindexedissues?: true
    birthname?: true
    borndate?: true
    bornplace?: true
    deceaseddate?: true
    deceasedplace?: true
    education?: true
    moviestext?: true
    comicstext?: true
    othertext?: true
    photofilename?: true
    photocomment?: true
    photosource?: true
    personrefs?: true
  }

  export type Inducks_personMaxAggregateInputType = {
    personcode?: true
    nationalitycountrycode?: true
    fullname?: true
    official?: true
    personcomment?: true
    unknownstudiomember?: true
    isfake?: true
    numberofindexedissues?: true
    birthname?: true
    borndate?: true
    bornplace?: true
    deceaseddate?: true
    deceasedplace?: true
    education?: true
    moviestext?: true
    comicstext?: true
    othertext?: true
    photofilename?: true
    photocomment?: true
    photosource?: true
    personrefs?: true
  }

  export type Inducks_personCountAggregateInputType = {
    personcode?: true
    nationalitycountrycode?: true
    fullname?: true
    official?: true
    personcomment?: true
    unknownstudiomember?: true
    isfake?: true
    numberofindexedissues?: true
    birthname?: true
    borndate?: true
    bornplace?: true
    deceaseddate?: true
    deceasedplace?: true
    education?: true
    moviestext?: true
    comicstext?: true
    othertext?: true
    photofilename?: true
    photocomment?: true
    photosource?: true
    personrefs?: true
    _all?: true
  }

  export type Inducks_personAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_person to aggregate.
     */
    where?: inducks_personWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_people to fetch.
     */
    orderBy?: inducks_personOrderByWithRelationInput | inducks_personOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_personWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_people from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_people.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_people
    **/
    _count?: true | Inducks_personCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Inducks_personAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Inducks_personSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_personMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_personMaxAggregateInputType
  }

  export type GetInducks_personAggregateType<T extends Inducks_personAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_person]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_person[P]>
      : GetScalarType<T[P], AggregateInducks_person[P]>
  }




  export type inducks_personGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_personWhereInput
    orderBy?: inducks_personOrderByWithAggregationInput | inducks_personOrderByWithAggregationInput[]
    by: Inducks_personScalarFieldEnum[] | Inducks_personScalarFieldEnum
    having?: inducks_personScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_personCountAggregateInputType | true
    _avg?: Inducks_personAvgAggregateInputType
    _sum?: Inducks_personSumAggregateInputType
    _min?: Inducks_personMinAggregateInputType
    _max?: Inducks_personMaxAggregateInputType
  }

  export type Inducks_personGroupByOutputType = {
    personcode: string
    nationalitycountrycode: string | null
    fullname: string | null
    official: $Enums.inducks_person_official | null
    personcomment: string | null
    unknownstudiomember: $Enums.inducks_person_unknownstudiomember | null
    isfake: $Enums.inducks_person_isfake | null
    numberofindexedissues: number | null
    birthname: string | null
    borndate: string | null
    bornplace: string | null
    deceaseddate: string | null
    deceasedplace: string | null
    education: string | null
    moviestext: string | null
    comicstext: string | null
    othertext: string | null
    photofilename: string | null
    photocomment: string | null
    photosource: string | null
    personrefs: string | null
    _count: Inducks_personCountAggregateOutputType | null
    _avg: Inducks_personAvgAggregateOutputType | null
    _sum: Inducks_personSumAggregateOutputType | null
    _min: Inducks_personMinAggregateOutputType | null
    _max: Inducks_personMaxAggregateOutputType | null
  }

  type GetInducks_personGroupByPayload<T extends inducks_personGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_personGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_personGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_personGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_personGroupByOutputType[P]>
        }
      >
    >


  export type inducks_personSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    personcode?: boolean
    nationalitycountrycode?: boolean
    fullname?: boolean
    official?: boolean
    personcomment?: boolean
    unknownstudiomember?: boolean
    isfake?: boolean
    numberofindexedissues?: boolean
    birthname?: boolean
    borndate?: boolean
    bornplace?: boolean
    deceaseddate?: boolean
    deceasedplace?: boolean
    education?: boolean
    moviestext?: boolean
    comicstext?: boolean
    othertext?: boolean
    photofilename?: boolean
    photocomment?: boolean
    photosource?: boolean
    personrefs?: boolean
  }, ExtArgs["result"]["inducks_person"]>

  export type inducks_personSelectScalar = {
    personcode?: boolean
    nationalitycountrycode?: boolean
    fullname?: boolean
    official?: boolean
    personcomment?: boolean
    unknownstudiomember?: boolean
    isfake?: boolean
    numberofindexedissues?: boolean
    birthname?: boolean
    borndate?: boolean
    bornplace?: boolean
    deceaseddate?: boolean
    deceasedplace?: boolean
    education?: boolean
    moviestext?: boolean
    comicstext?: boolean
    othertext?: boolean
    photofilename?: boolean
    photocomment?: boolean
    photosource?: boolean
    personrefs?: boolean
  }


  export type $inducks_personPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_person"
    objects: {}
    scalars: $Extensions.GetResult<{
      personcode: string
      nationalitycountrycode: string | null
      fullname: string | null
      official: $Enums.inducks_person_official | null
      personcomment: string | null
      unknownstudiomember: $Enums.inducks_person_unknownstudiomember | null
      isfake: $Enums.inducks_person_isfake | null
      numberofindexedissues: number | null
      birthname: string | null
      borndate: string | null
      bornplace: string | null
      deceaseddate: string | null
      deceasedplace: string | null
      education: string | null
      moviestext: string | null
      comicstext: string | null
      othertext: string | null
      photofilename: string | null
      photocomment: string | null
      photosource: string | null
      personrefs: string | null
    }, ExtArgs["result"]["inducks_person"]>
    composites: {}
  }


  type inducks_personGetPayload<S extends boolean | null | undefined | inducks_personDefaultArgs> = $Result.GetResult<Prisma.$inducks_personPayload, S>

  type inducks_personCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_personFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_personCountAggregateInputType | true
    }

  export interface inducks_personDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_person'], meta: { name: 'inducks_person' } }
    /**
     * Find zero or one Inducks_person that matches the filter.
     * @param {inducks_personFindUniqueArgs} args - Arguments to find a Inducks_person
     * @example
     * // Get one Inducks_person
     * const inducks_person = await prisma.inducks_person.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_personFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_personFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_personClient<$Result.GetResult<Prisma.$inducks_personPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_person that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_personFindUniqueOrThrowArgs} args - Arguments to find a Inducks_person
     * @example
     * // Get one Inducks_person
     * const inducks_person = await prisma.inducks_person.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_personFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_personFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_personClient<$Result.GetResult<Prisma.$inducks_personPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_person that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_personFindFirstArgs} args - Arguments to find a Inducks_person
     * @example
     * // Get one Inducks_person
     * const inducks_person = await prisma.inducks_person.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_personFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_personFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_personClient<$Result.GetResult<Prisma.$inducks_personPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_person that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_personFindFirstOrThrowArgs} args - Arguments to find a Inducks_person
     * @example
     * // Get one Inducks_person
     * const inducks_person = await prisma.inducks_person.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_personFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_personFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_personClient<$Result.GetResult<Prisma.$inducks_personPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_people that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_personFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_people
     * const inducks_people = await prisma.inducks_person.findMany()
     * 
     * // Get first 10 Inducks_people
     * const inducks_people = await prisma.inducks_person.findMany({ take: 10 })
     * 
     * // Only select the `personcode`
     * const inducks_personWithPersoncodeOnly = await prisma.inducks_person.findMany({ select: { personcode: true } })
     * 
    **/
    findMany<T extends inducks_personFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_personFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_personPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_person.
     * @param {inducks_personCreateArgs} args - Arguments to create a Inducks_person.
     * @example
     * // Create one Inducks_person
     * const Inducks_person = await prisma.inducks_person.create({
     *   data: {
     *     // ... data to create a Inducks_person
     *   }
     * })
     * 
    **/
    create<T extends inducks_personCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_personCreateArgs<ExtArgs>>
    ): Prisma__inducks_personClient<$Result.GetResult<Prisma.$inducks_personPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_people.
     *     @param {inducks_personCreateManyArgs} args - Arguments to create many Inducks_people.
     *     @example
     *     // Create many Inducks_people
     *     const inducks_person = await prisma.inducks_person.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_personCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_personCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_person.
     * @param {inducks_personDeleteArgs} args - Arguments to delete one Inducks_person.
     * @example
     * // Delete one Inducks_person
     * const Inducks_person = await prisma.inducks_person.delete({
     *   where: {
     *     // ... filter to delete one Inducks_person
     *   }
     * })
     * 
    **/
    delete<T extends inducks_personDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_personDeleteArgs<ExtArgs>>
    ): Prisma__inducks_personClient<$Result.GetResult<Prisma.$inducks_personPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_person.
     * @param {inducks_personUpdateArgs} args - Arguments to update one Inducks_person.
     * @example
     * // Update one Inducks_person
     * const inducks_person = await prisma.inducks_person.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_personUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_personUpdateArgs<ExtArgs>>
    ): Prisma__inducks_personClient<$Result.GetResult<Prisma.$inducks_personPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_people.
     * @param {inducks_personDeleteManyArgs} args - Arguments to filter Inducks_people to delete.
     * @example
     * // Delete a few Inducks_people
     * const { count } = await prisma.inducks_person.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_personDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_personDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_people.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_personUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_people
     * const inducks_person = await prisma.inducks_person.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_personUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_personUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_person.
     * @param {inducks_personUpsertArgs} args - Arguments to update or create a Inducks_person.
     * @example
     * // Update or create a Inducks_person
     * const inducks_person = await prisma.inducks_person.upsert({
     *   create: {
     *     // ... data to create a Inducks_person
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_person we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_personUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_personUpsertArgs<ExtArgs>>
    ): Prisma__inducks_personClient<$Result.GetResult<Prisma.$inducks_personPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_people.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_personCountArgs} args - Arguments to filter Inducks_people to count.
     * @example
     * // Count the number of Inducks_people
     * const count = await prisma.inducks_person.count({
     *   where: {
     *     // ... the filter for the Inducks_people we want to count
     *   }
     * })
    **/
    count<T extends inducks_personCountArgs>(
      args?: Subset<T, inducks_personCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_personCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_person.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_personAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_personAggregateArgs>(args: Subset<T, Inducks_personAggregateArgs>): Prisma.PrismaPromise<GetInducks_personAggregateType<T>>

    /**
     * Group by Inducks_person.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_personGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_personGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_personGroupByArgs['orderBy'] }
        : { orderBy?: inducks_personGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_personGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_personGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_person model
   */
  readonly fields: inducks_personFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_person.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_personClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_person model
   */ 
  interface inducks_personFieldRefs {
    readonly personcode: FieldRef<"inducks_person", 'String'>
    readonly nationalitycountrycode: FieldRef<"inducks_person", 'String'>
    readonly fullname: FieldRef<"inducks_person", 'String'>
    readonly official: FieldRef<"inducks_person", 'inducks_person_official'>
    readonly personcomment: FieldRef<"inducks_person", 'String'>
    readonly unknownstudiomember: FieldRef<"inducks_person", 'inducks_person_unknownstudiomember'>
    readonly isfake: FieldRef<"inducks_person", 'inducks_person_isfake'>
    readonly numberofindexedissues: FieldRef<"inducks_person", 'Int'>
    readonly birthname: FieldRef<"inducks_person", 'String'>
    readonly borndate: FieldRef<"inducks_person", 'String'>
    readonly bornplace: FieldRef<"inducks_person", 'String'>
    readonly deceaseddate: FieldRef<"inducks_person", 'String'>
    readonly deceasedplace: FieldRef<"inducks_person", 'String'>
    readonly education: FieldRef<"inducks_person", 'String'>
    readonly moviestext: FieldRef<"inducks_person", 'String'>
    readonly comicstext: FieldRef<"inducks_person", 'String'>
    readonly othertext: FieldRef<"inducks_person", 'String'>
    readonly photofilename: FieldRef<"inducks_person", 'String'>
    readonly photocomment: FieldRef<"inducks_person", 'String'>
    readonly photosource: FieldRef<"inducks_person", 'String'>
    readonly personrefs: FieldRef<"inducks_person", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_person findUnique
   */
  export type inducks_personFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_person
     */
    select?: inducks_personSelect<ExtArgs> | null
    /**
     * Filter, which inducks_person to fetch.
     */
    where: inducks_personWhereUniqueInput
  }


  /**
   * inducks_person findUniqueOrThrow
   */
  export type inducks_personFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_person
     */
    select?: inducks_personSelect<ExtArgs> | null
    /**
     * Filter, which inducks_person to fetch.
     */
    where: inducks_personWhereUniqueInput
  }


  /**
   * inducks_person findFirst
   */
  export type inducks_personFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_person
     */
    select?: inducks_personSelect<ExtArgs> | null
    /**
     * Filter, which inducks_person to fetch.
     */
    where?: inducks_personWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_people to fetch.
     */
    orderBy?: inducks_personOrderByWithRelationInput | inducks_personOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_people.
     */
    cursor?: inducks_personWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_people from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_people.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_people.
     */
    distinct?: Inducks_personScalarFieldEnum | Inducks_personScalarFieldEnum[]
  }


  /**
   * inducks_person findFirstOrThrow
   */
  export type inducks_personFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_person
     */
    select?: inducks_personSelect<ExtArgs> | null
    /**
     * Filter, which inducks_person to fetch.
     */
    where?: inducks_personWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_people to fetch.
     */
    orderBy?: inducks_personOrderByWithRelationInput | inducks_personOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_people.
     */
    cursor?: inducks_personWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_people from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_people.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_people.
     */
    distinct?: Inducks_personScalarFieldEnum | Inducks_personScalarFieldEnum[]
  }


  /**
   * inducks_person findMany
   */
  export type inducks_personFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_person
     */
    select?: inducks_personSelect<ExtArgs> | null
    /**
     * Filter, which inducks_people to fetch.
     */
    where?: inducks_personWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_people to fetch.
     */
    orderBy?: inducks_personOrderByWithRelationInput | inducks_personOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_people.
     */
    cursor?: inducks_personWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_people from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_people.
     */
    skip?: number
    distinct?: Inducks_personScalarFieldEnum | Inducks_personScalarFieldEnum[]
  }


  /**
   * inducks_person create
   */
  export type inducks_personCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_person
     */
    select?: inducks_personSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_person.
     */
    data: XOR<inducks_personCreateInput, inducks_personUncheckedCreateInput>
  }


  /**
   * inducks_person createMany
   */
  export type inducks_personCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_people.
     */
    data: inducks_personCreateManyInput | inducks_personCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_person update
   */
  export type inducks_personUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_person
     */
    select?: inducks_personSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_person.
     */
    data: XOR<inducks_personUpdateInput, inducks_personUncheckedUpdateInput>
    /**
     * Choose, which inducks_person to update.
     */
    where: inducks_personWhereUniqueInput
  }


  /**
   * inducks_person updateMany
   */
  export type inducks_personUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_people.
     */
    data: XOR<inducks_personUpdateManyMutationInput, inducks_personUncheckedUpdateManyInput>
    /**
     * Filter which inducks_people to update
     */
    where?: inducks_personWhereInput
  }


  /**
   * inducks_person upsert
   */
  export type inducks_personUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_person
     */
    select?: inducks_personSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_person to update in case it exists.
     */
    where: inducks_personWhereUniqueInput
    /**
     * In case the inducks_person found by the `where` argument doesn't exist, create a new inducks_person with this data.
     */
    create: XOR<inducks_personCreateInput, inducks_personUncheckedCreateInput>
    /**
     * In case the inducks_person was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_personUpdateInput, inducks_personUncheckedUpdateInput>
  }


  /**
   * inducks_person delete
   */
  export type inducks_personDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_person
     */
    select?: inducks_personSelect<ExtArgs> | null
    /**
     * Filter which inducks_person to delete.
     */
    where: inducks_personWhereUniqueInput
  }


  /**
   * inducks_person deleteMany
   */
  export type inducks_personDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_people to delete
     */
    where?: inducks_personWhereInput
  }


  /**
   * inducks_person without action
   */
  export type inducks_personDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_person
     */
    select?: inducks_personSelect<ExtArgs> | null
  }



  /**
   * Model inducks_personurl
   */

  export type AggregateInducks_personurl = {
    _count: Inducks_personurlCountAggregateOutputType | null
    _min: Inducks_personurlMinAggregateOutputType | null
    _max: Inducks_personurlMaxAggregateOutputType | null
  }

  export type Inducks_personurlMinAggregateOutputType = {
    personcode: string | null
    sitecode: string | null
    url: string | null
  }

  export type Inducks_personurlMaxAggregateOutputType = {
    personcode: string | null
    sitecode: string | null
    url: string | null
  }

  export type Inducks_personurlCountAggregateOutputType = {
    personcode: number
    sitecode: number
    url: number
    _all: number
  }


  export type Inducks_personurlMinAggregateInputType = {
    personcode?: true
    sitecode?: true
    url?: true
  }

  export type Inducks_personurlMaxAggregateInputType = {
    personcode?: true
    sitecode?: true
    url?: true
  }

  export type Inducks_personurlCountAggregateInputType = {
    personcode?: true
    sitecode?: true
    url?: true
    _all?: true
  }

  export type Inducks_personurlAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_personurl to aggregate.
     */
    where?: inducks_personurlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_personurls to fetch.
     */
    orderBy?: inducks_personurlOrderByWithRelationInput | inducks_personurlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_personurlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_personurls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_personurls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_personurls
    **/
    _count?: true | Inducks_personurlCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_personurlMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_personurlMaxAggregateInputType
  }

  export type GetInducks_personurlAggregateType<T extends Inducks_personurlAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_personurl]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_personurl[P]>
      : GetScalarType<T[P], AggregateInducks_personurl[P]>
  }




  export type inducks_personurlGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_personurlWhereInput
    orderBy?: inducks_personurlOrderByWithAggregationInput | inducks_personurlOrderByWithAggregationInput[]
    by: Inducks_personurlScalarFieldEnum[] | Inducks_personurlScalarFieldEnum
    having?: inducks_personurlScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_personurlCountAggregateInputType | true
    _min?: Inducks_personurlMinAggregateInputType
    _max?: Inducks_personurlMaxAggregateInputType
  }

  export type Inducks_personurlGroupByOutputType = {
    personcode: string
    sitecode: string
    url: string | null
    _count: Inducks_personurlCountAggregateOutputType | null
    _min: Inducks_personurlMinAggregateOutputType | null
    _max: Inducks_personurlMaxAggregateOutputType | null
  }

  type GetInducks_personurlGroupByPayload<T extends inducks_personurlGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_personurlGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_personurlGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_personurlGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_personurlGroupByOutputType[P]>
        }
      >
    >


  export type inducks_personurlSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    personcode?: boolean
    sitecode?: boolean
    url?: boolean
  }, ExtArgs["result"]["inducks_personurl"]>

  export type inducks_personurlSelectScalar = {
    personcode?: boolean
    sitecode?: boolean
    url?: boolean
  }


  export type $inducks_personurlPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_personurl"
    objects: {}
    scalars: $Extensions.GetResult<{
      personcode: string
      sitecode: string
      url: string | null
    }, ExtArgs["result"]["inducks_personurl"]>
    composites: {}
  }


  type inducks_personurlGetPayload<S extends boolean | null | undefined | inducks_personurlDefaultArgs> = $Result.GetResult<Prisma.$inducks_personurlPayload, S>

  type inducks_personurlCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_personurlFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_personurlCountAggregateInputType | true
    }

  export interface inducks_personurlDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_personurl'], meta: { name: 'inducks_personurl' } }
    /**
     * Find zero or one Inducks_personurl that matches the filter.
     * @param {inducks_personurlFindUniqueArgs} args - Arguments to find a Inducks_personurl
     * @example
     * // Get one Inducks_personurl
     * const inducks_personurl = await prisma.inducks_personurl.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_personurlFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_personurlFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_personurlClient<$Result.GetResult<Prisma.$inducks_personurlPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_personurl that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_personurlFindUniqueOrThrowArgs} args - Arguments to find a Inducks_personurl
     * @example
     * // Get one Inducks_personurl
     * const inducks_personurl = await prisma.inducks_personurl.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_personurlFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_personurlFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_personurlClient<$Result.GetResult<Prisma.$inducks_personurlPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_personurl that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_personurlFindFirstArgs} args - Arguments to find a Inducks_personurl
     * @example
     * // Get one Inducks_personurl
     * const inducks_personurl = await prisma.inducks_personurl.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_personurlFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_personurlFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_personurlClient<$Result.GetResult<Prisma.$inducks_personurlPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_personurl that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_personurlFindFirstOrThrowArgs} args - Arguments to find a Inducks_personurl
     * @example
     * // Get one Inducks_personurl
     * const inducks_personurl = await prisma.inducks_personurl.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_personurlFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_personurlFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_personurlClient<$Result.GetResult<Prisma.$inducks_personurlPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_personurls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_personurlFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_personurls
     * const inducks_personurls = await prisma.inducks_personurl.findMany()
     * 
     * // Get first 10 Inducks_personurls
     * const inducks_personurls = await prisma.inducks_personurl.findMany({ take: 10 })
     * 
     * // Only select the `personcode`
     * const inducks_personurlWithPersoncodeOnly = await prisma.inducks_personurl.findMany({ select: { personcode: true } })
     * 
    **/
    findMany<T extends inducks_personurlFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_personurlFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_personurlPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_personurl.
     * @param {inducks_personurlCreateArgs} args - Arguments to create a Inducks_personurl.
     * @example
     * // Create one Inducks_personurl
     * const Inducks_personurl = await prisma.inducks_personurl.create({
     *   data: {
     *     // ... data to create a Inducks_personurl
     *   }
     * })
     * 
    **/
    create<T extends inducks_personurlCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_personurlCreateArgs<ExtArgs>>
    ): Prisma__inducks_personurlClient<$Result.GetResult<Prisma.$inducks_personurlPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_personurls.
     *     @param {inducks_personurlCreateManyArgs} args - Arguments to create many Inducks_personurls.
     *     @example
     *     // Create many Inducks_personurls
     *     const inducks_personurl = await prisma.inducks_personurl.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_personurlCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_personurlCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_personurl.
     * @param {inducks_personurlDeleteArgs} args - Arguments to delete one Inducks_personurl.
     * @example
     * // Delete one Inducks_personurl
     * const Inducks_personurl = await prisma.inducks_personurl.delete({
     *   where: {
     *     // ... filter to delete one Inducks_personurl
     *   }
     * })
     * 
    **/
    delete<T extends inducks_personurlDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_personurlDeleteArgs<ExtArgs>>
    ): Prisma__inducks_personurlClient<$Result.GetResult<Prisma.$inducks_personurlPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_personurl.
     * @param {inducks_personurlUpdateArgs} args - Arguments to update one Inducks_personurl.
     * @example
     * // Update one Inducks_personurl
     * const inducks_personurl = await prisma.inducks_personurl.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_personurlUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_personurlUpdateArgs<ExtArgs>>
    ): Prisma__inducks_personurlClient<$Result.GetResult<Prisma.$inducks_personurlPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_personurls.
     * @param {inducks_personurlDeleteManyArgs} args - Arguments to filter Inducks_personurls to delete.
     * @example
     * // Delete a few Inducks_personurls
     * const { count } = await prisma.inducks_personurl.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_personurlDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_personurlDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_personurls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_personurlUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_personurls
     * const inducks_personurl = await prisma.inducks_personurl.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_personurlUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_personurlUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_personurl.
     * @param {inducks_personurlUpsertArgs} args - Arguments to update or create a Inducks_personurl.
     * @example
     * // Update or create a Inducks_personurl
     * const inducks_personurl = await prisma.inducks_personurl.upsert({
     *   create: {
     *     // ... data to create a Inducks_personurl
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_personurl we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_personurlUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_personurlUpsertArgs<ExtArgs>>
    ): Prisma__inducks_personurlClient<$Result.GetResult<Prisma.$inducks_personurlPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_personurls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_personurlCountArgs} args - Arguments to filter Inducks_personurls to count.
     * @example
     * // Count the number of Inducks_personurls
     * const count = await prisma.inducks_personurl.count({
     *   where: {
     *     // ... the filter for the Inducks_personurls we want to count
     *   }
     * })
    **/
    count<T extends inducks_personurlCountArgs>(
      args?: Subset<T, inducks_personurlCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_personurlCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_personurl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_personurlAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_personurlAggregateArgs>(args: Subset<T, Inducks_personurlAggregateArgs>): Prisma.PrismaPromise<GetInducks_personurlAggregateType<T>>

    /**
     * Group by Inducks_personurl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_personurlGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_personurlGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_personurlGroupByArgs['orderBy'] }
        : { orderBy?: inducks_personurlGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_personurlGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_personurlGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_personurl model
   */
  readonly fields: inducks_personurlFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_personurl.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_personurlClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_personurl model
   */ 
  interface inducks_personurlFieldRefs {
    readonly personcode: FieldRef<"inducks_personurl", 'String'>
    readonly sitecode: FieldRef<"inducks_personurl", 'String'>
    readonly url: FieldRef<"inducks_personurl", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_personurl findUnique
   */
  export type inducks_personurlFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_personurl
     */
    select?: inducks_personurlSelect<ExtArgs> | null
    /**
     * Filter, which inducks_personurl to fetch.
     */
    where: inducks_personurlWhereUniqueInput
  }


  /**
   * inducks_personurl findUniqueOrThrow
   */
  export type inducks_personurlFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_personurl
     */
    select?: inducks_personurlSelect<ExtArgs> | null
    /**
     * Filter, which inducks_personurl to fetch.
     */
    where: inducks_personurlWhereUniqueInput
  }


  /**
   * inducks_personurl findFirst
   */
  export type inducks_personurlFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_personurl
     */
    select?: inducks_personurlSelect<ExtArgs> | null
    /**
     * Filter, which inducks_personurl to fetch.
     */
    where?: inducks_personurlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_personurls to fetch.
     */
    orderBy?: inducks_personurlOrderByWithRelationInput | inducks_personurlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_personurls.
     */
    cursor?: inducks_personurlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_personurls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_personurls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_personurls.
     */
    distinct?: Inducks_personurlScalarFieldEnum | Inducks_personurlScalarFieldEnum[]
  }


  /**
   * inducks_personurl findFirstOrThrow
   */
  export type inducks_personurlFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_personurl
     */
    select?: inducks_personurlSelect<ExtArgs> | null
    /**
     * Filter, which inducks_personurl to fetch.
     */
    where?: inducks_personurlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_personurls to fetch.
     */
    orderBy?: inducks_personurlOrderByWithRelationInput | inducks_personurlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_personurls.
     */
    cursor?: inducks_personurlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_personurls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_personurls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_personurls.
     */
    distinct?: Inducks_personurlScalarFieldEnum | Inducks_personurlScalarFieldEnum[]
  }


  /**
   * inducks_personurl findMany
   */
  export type inducks_personurlFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_personurl
     */
    select?: inducks_personurlSelect<ExtArgs> | null
    /**
     * Filter, which inducks_personurls to fetch.
     */
    where?: inducks_personurlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_personurls to fetch.
     */
    orderBy?: inducks_personurlOrderByWithRelationInput | inducks_personurlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_personurls.
     */
    cursor?: inducks_personurlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_personurls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_personurls.
     */
    skip?: number
    distinct?: Inducks_personurlScalarFieldEnum | Inducks_personurlScalarFieldEnum[]
  }


  /**
   * inducks_personurl create
   */
  export type inducks_personurlCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_personurl
     */
    select?: inducks_personurlSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_personurl.
     */
    data: XOR<inducks_personurlCreateInput, inducks_personurlUncheckedCreateInput>
  }


  /**
   * inducks_personurl createMany
   */
  export type inducks_personurlCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_personurls.
     */
    data: inducks_personurlCreateManyInput | inducks_personurlCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_personurl update
   */
  export type inducks_personurlUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_personurl
     */
    select?: inducks_personurlSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_personurl.
     */
    data: XOR<inducks_personurlUpdateInput, inducks_personurlUncheckedUpdateInput>
    /**
     * Choose, which inducks_personurl to update.
     */
    where: inducks_personurlWhereUniqueInput
  }


  /**
   * inducks_personurl updateMany
   */
  export type inducks_personurlUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_personurls.
     */
    data: XOR<inducks_personurlUpdateManyMutationInput, inducks_personurlUncheckedUpdateManyInput>
    /**
     * Filter which inducks_personurls to update
     */
    where?: inducks_personurlWhereInput
  }


  /**
   * inducks_personurl upsert
   */
  export type inducks_personurlUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_personurl
     */
    select?: inducks_personurlSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_personurl to update in case it exists.
     */
    where: inducks_personurlWhereUniqueInput
    /**
     * In case the inducks_personurl found by the `where` argument doesn't exist, create a new inducks_personurl with this data.
     */
    create: XOR<inducks_personurlCreateInput, inducks_personurlUncheckedCreateInput>
    /**
     * In case the inducks_personurl was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_personurlUpdateInput, inducks_personurlUncheckedUpdateInput>
  }


  /**
   * inducks_personurl delete
   */
  export type inducks_personurlDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_personurl
     */
    select?: inducks_personurlSelect<ExtArgs> | null
    /**
     * Filter which inducks_personurl to delete.
     */
    where: inducks_personurlWhereUniqueInput
  }


  /**
   * inducks_personurl deleteMany
   */
  export type inducks_personurlDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_personurls to delete
     */
    where?: inducks_personurlWhereInput
  }


  /**
   * inducks_personurl without action
   */
  export type inducks_personurlDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_personurl
     */
    select?: inducks_personurlSelect<ExtArgs> | null
  }



  /**
   * Model inducks_publication
   */

  export type AggregateInducks_publication = {
    _count: Inducks_publicationCountAggregateOutputType | null
    _avg: Inducks_publicationAvgAggregateOutputType | null
    _sum: Inducks_publicationSumAggregateOutputType | null
    _min: Inducks_publicationMinAggregateOutputType | null
    _max: Inducks_publicationMaxAggregateOutputType | null
  }

  export type Inducks_publicationAvgAggregateOutputType = {
    inputfilecode: number | null
  }

  export type Inducks_publicationSumAggregateOutputType = {
    inputfilecode: number | null
  }

  export type Inducks_publicationMinAggregateOutputType = {
    publicationcode: string | null
    countrycode: string | null
    languagecode: string | null
    title: string | null
    size: string | null
    publicationcomment: string | null
    circulation: string | null
    numbersarefake: $Enums.inducks_publication_numbersarefake | null
    error: $Enums.inducks_publication_error | null
    locked: $Enums.inducks_publication_locked | null
    inxforbidden: $Enums.inducks_publication_inxforbidden | null
    inputfilecode: number | null
    maintenanceteamcode: string | null
  }

  export type Inducks_publicationMaxAggregateOutputType = {
    publicationcode: string | null
    countrycode: string | null
    languagecode: string | null
    title: string | null
    size: string | null
    publicationcomment: string | null
    circulation: string | null
    numbersarefake: $Enums.inducks_publication_numbersarefake | null
    error: $Enums.inducks_publication_error | null
    locked: $Enums.inducks_publication_locked | null
    inxforbidden: $Enums.inducks_publication_inxforbidden | null
    inputfilecode: number | null
    maintenanceteamcode: string | null
  }

  export type Inducks_publicationCountAggregateOutputType = {
    publicationcode: number
    countrycode: number
    languagecode: number
    title: number
    size: number
    publicationcomment: number
    circulation: number
    numbersarefake: number
    error: number
    locked: number
    inxforbidden: number
    inputfilecode: number
    maintenanceteamcode: number
    _all: number
  }


  export type Inducks_publicationAvgAggregateInputType = {
    inputfilecode?: true
  }

  export type Inducks_publicationSumAggregateInputType = {
    inputfilecode?: true
  }

  export type Inducks_publicationMinAggregateInputType = {
    publicationcode?: true
    countrycode?: true
    languagecode?: true
    title?: true
    size?: true
    publicationcomment?: true
    circulation?: true
    numbersarefake?: true
    error?: true
    locked?: true
    inxforbidden?: true
    inputfilecode?: true
    maintenanceteamcode?: true
  }

  export type Inducks_publicationMaxAggregateInputType = {
    publicationcode?: true
    countrycode?: true
    languagecode?: true
    title?: true
    size?: true
    publicationcomment?: true
    circulation?: true
    numbersarefake?: true
    error?: true
    locked?: true
    inxforbidden?: true
    inputfilecode?: true
    maintenanceteamcode?: true
  }

  export type Inducks_publicationCountAggregateInputType = {
    publicationcode?: true
    countrycode?: true
    languagecode?: true
    title?: true
    size?: true
    publicationcomment?: true
    circulation?: true
    numbersarefake?: true
    error?: true
    locked?: true
    inxforbidden?: true
    inputfilecode?: true
    maintenanceteamcode?: true
    _all?: true
  }

  export type Inducks_publicationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_publication to aggregate.
     */
    where?: inducks_publicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_publications to fetch.
     */
    orderBy?: inducks_publicationOrderByWithRelationInput | inducks_publicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_publicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_publications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_publications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_publications
    **/
    _count?: true | Inducks_publicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Inducks_publicationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Inducks_publicationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_publicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_publicationMaxAggregateInputType
  }

  export type GetInducks_publicationAggregateType<T extends Inducks_publicationAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_publication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_publication[P]>
      : GetScalarType<T[P], AggregateInducks_publication[P]>
  }




  export type inducks_publicationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_publicationWhereInput
    orderBy?: inducks_publicationOrderByWithAggregationInput | inducks_publicationOrderByWithAggregationInput[]
    by: Inducks_publicationScalarFieldEnum[] | Inducks_publicationScalarFieldEnum
    having?: inducks_publicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_publicationCountAggregateInputType | true
    _avg?: Inducks_publicationAvgAggregateInputType
    _sum?: Inducks_publicationSumAggregateInputType
    _min?: Inducks_publicationMinAggregateInputType
    _max?: Inducks_publicationMaxAggregateInputType
  }

  export type Inducks_publicationGroupByOutputType = {
    publicationcode: string
    countrycode: string | null
    languagecode: string | null
    title: string | null
    size: string | null
    publicationcomment: string | null
    circulation: string | null
    numbersarefake: $Enums.inducks_publication_numbersarefake | null
    error: $Enums.inducks_publication_error | null
    locked: $Enums.inducks_publication_locked | null
    inxforbidden: $Enums.inducks_publication_inxforbidden | null
    inputfilecode: number | null
    maintenanceteamcode: string | null
    _count: Inducks_publicationCountAggregateOutputType | null
    _avg: Inducks_publicationAvgAggregateOutputType | null
    _sum: Inducks_publicationSumAggregateOutputType | null
    _min: Inducks_publicationMinAggregateOutputType | null
    _max: Inducks_publicationMaxAggregateOutputType | null
  }

  type GetInducks_publicationGroupByPayload<T extends inducks_publicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_publicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_publicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_publicationGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_publicationGroupByOutputType[P]>
        }
      >
    >


  export type inducks_publicationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    publicationcode?: boolean
    countrycode?: boolean
    languagecode?: boolean
    title?: boolean
    size?: boolean
    publicationcomment?: boolean
    circulation?: boolean
    numbersarefake?: boolean
    error?: boolean
    locked?: boolean
    inxforbidden?: boolean
    inputfilecode?: boolean
    maintenanceteamcode?: boolean
  }, ExtArgs["result"]["inducks_publication"]>

  export type inducks_publicationSelectScalar = {
    publicationcode?: boolean
    countrycode?: boolean
    languagecode?: boolean
    title?: boolean
    size?: boolean
    publicationcomment?: boolean
    circulation?: boolean
    numbersarefake?: boolean
    error?: boolean
    locked?: boolean
    inxforbidden?: boolean
    inputfilecode?: boolean
    maintenanceteamcode?: boolean
  }


  export type $inducks_publicationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_publication"
    objects: {}
    scalars: $Extensions.GetResult<{
      publicationcode: string
      countrycode: string | null
      languagecode: string | null
      title: string | null
      size: string | null
      publicationcomment: string | null
      circulation: string | null
      numbersarefake: $Enums.inducks_publication_numbersarefake | null
      error: $Enums.inducks_publication_error | null
      locked: $Enums.inducks_publication_locked | null
      inxforbidden: $Enums.inducks_publication_inxforbidden | null
      inputfilecode: number | null
      maintenanceteamcode: string | null
    }, ExtArgs["result"]["inducks_publication"]>
    composites: {}
  }


  type inducks_publicationGetPayload<S extends boolean | null | undefined | inducks_publicationDefaultArgs> = $Result.GetResult<Prisma.$inducks_publicationPayload, S>

  type inducks_publicationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_publicationFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_publicationCountAggregateInputType | true
    }

  export interface inducks_publicationDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_publication'], meta: { name: 'inducks_publication' } }
    /**
     * Find zero or one Inducks_publication that matches the filter.
     * @param {inducks_publicationFindUniqueArgs} args - Arguments to find a Inducks_publication
     * @example
     * // Get one Inducks_publication
     * const inducks_publication = await prisma.inducks_publication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_publicationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_publicationFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_publicationClient<$Result.GetResult<Prisma.$inducks_publicationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_publication that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_publicationFindUniqueOrThrowArgs} args - Arguments to find a Inducks_publication
     * @example
     * // Get one Inducks_publication
     * const inducks_publication = await prisma.inducks_publication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_publicationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_publicationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_publicationClient<$Result.GetResult<Prisma.$inducks_publicationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_publication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_publicationFindFirstArgs} args - Arguments to find a Inducks_publication
     * @example
     * // Get one Inducks_publication
     * const inducks_publication = await prisma.inducks_publication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_publicationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_publicationFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_publicationClient<$Result.GetResult<Prisma.$inducks_publicationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_publication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_publicationFindFirstOrThrowArgs} args - Arguments to find a Inducks_publication
     * @example
     * // Get one Inducks_publication
     * const inducks_publication = await prisma.inducks_publication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_publicationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_publicationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_publicationClient<$Result.GetResult<Prisma.$inducks_publicationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_publications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_publicationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_publications
     * const inducks_publications = await prisma.inducks_publication.findMany()
     * 
     * // Get first 10 Inducks_publications
     * const inducks_publications = await prisma.inducks_publication.findMany({ take: 10 })
     * 
     * // Only select the `publicationcode`
     * const inducks_publicationWithPublicationcodeOnly = await prisma.inducks_publication.findMany({ select: { publicationcode: true } })
     * 
    **/
    findMany<T extends inducks_publicationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_publicationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_publicationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_publication.
     * @param {inducks_publicationCreateArgs} args - Arguments to create a Inducks_publication.
     * @example
     * // Create one Inducks_publication
     * const Inducks_publication = await prisma.inducks_publication.create({
     *   data: {
     *     // ... data to create a Inducks_publication
     *   }
     * })
     * 
    **/
    create<T extends inducks_publicationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_publicationCreateArgs<ExtArgs>>
    ): Prisma__inducks_publicationClient<$Result.GetResult<Prisma.$inducks_publicationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_publications.
     *     @param {inducks_publicationCreateManyArgs} args - Arguments to create many Inducks_publications.
     *     @example
     *     // Create many Inducks_publications
     *     const inducks_publication = await prisma.inducks_publication.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_publicationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_publicationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_publication.
     * @param {inducks_publicationDeleteArgs} args - Arguments to delete one Inducks_publication.
     * @example
     * // Delete one Inducks_publication
     * const Inducks_publication = await prisma.inducks_publication.delete({
     *   where: {
     *     // ... filter to delete one Inducks_publication
     *   }
     * })
     * 
    **/
    delete<T extends inducks_publicationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_publicationDeleteArgs<ExtArgs>>
    ): Prisma__inducks_publicationClient<$Result.GetResult<Prisma.$inducks_publicationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_publication.
     * @param {inducks_publicationUpdateArgs} args - Arguments to update one Inducks_publication.
     * @example
     * // Update one Inducks_publication
     * const inducks_publication = await prisma.inducks_publication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_publicationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_publicationUpdateArgs<ExtArgs>>
    ): Prisma__inducks_publicationClient<$Result.GetResult<Prisma.$inducks_publicationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_publications.
     * @param {inducks_publicationDeleteManyArgs} args - Arguments to filter Inducks_publications to delete.
     * @example
     * // Delete a few Inducks_publications
     * const { count } = await prisma.inducks_publication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_publicationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_publicationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_publications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_publicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_publications
     * const inducks_publication = await prisma.inducks_publication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_publicationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_publicationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_publication.
     * @param {inducks_publicationUpsertArgs} args - Arguments to update or create a Inducks_publication.
     * @example
     * // Update or create a Inducks_publication
     * const inducks_publication = await prisma.inducks_publication.upsert({
     *   create: {
     *     // ... data to create a Inducks_publication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_publication we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_publicationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_publicationUpsertArgs<ExtArgs>>
    ): Prisma__inducks_publicationClient<$Result.GetResult<Prisma.$inducks_publicationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_publications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_publicationCountArgs} args - Arguments to filter Inducks_publications to count.
     * @example
     * // Count the number of Inducks_publications
     * const count = await prisma.inducks_publication.count({
     *   where: {
     *     // ... the filter for the Inducks_publications we want to count
     *   }
     * })
    **/
    count<T extends inducks_publicationCountArgs>(
      args?: Subset<T, inducks_publicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_publicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_publication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_publicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_publicationAggregateArgs>(args: Subset<T, Inducks_publicationAggregateArgs>): Prisma.PrismaPromise<GetInducks_publicationAggregateType<T>>

    /**
     * Group by Inducks_publication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_publicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_publicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_publicationGroupByArgs['orderBy'] }
        : { orderBy?: inducks_publicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_publicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_publicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_publication model
   */
  readonly fields: inducks_publicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_publication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_publicationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_publication model
   */ 
  interface inducks_publicationFieldRefs {
    readonly publicationcode: FieldRef<"inducks_publication", 'String'>
    readonly countrycode: FieldRef<"inducks_publication", 'String'>
    readonly languagecode: FieldRef<"inducks_publication", 'String'>
    readonly title: FieldRef<"inducks_publication", 'String'>
    readonly size: FieldRef<"inducks_publication", 'String'>
    readonly publicationcomment: FieldRef<"inducks_publication", 'String'>
    readonly circulation: FieldRef<"inducks_publication", 'String'>
    readonly numbersarefake: FieldRef<"inducks_publication", 'inducks_publication_numbersarefake'>
    readonly error: FieldRef<"inducks_publication", 'inducks_publication_error'>
    readonly locked: FieldRef<"inducks_publication", 'inducks_publication_locked'>
    readonly inxforbidden: FieldRef<"inducks_publication", 'inducks_publication_inxforbidden'>
    readonly inputfilecode: FieldRef<"inducks_publication", 'Int'>
    readonly maintenanceteamcode: FieldRef<"inducks_publication", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_publication findUnique
   */
  export type inducks_publicationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publication
     */
    select?: inducks_publicationSelect<ExtArgs> | null
    /**
     * Filter, which inducks_publication to fetch.
     */
    where: inducks_publicationWhereUniqueInput
  }


  /**
   * inducks_publication findUniqueOrThrow
   */
  export type inducks_publicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publication
     */
    select?: inducks_publicationSelect<ExtArgs> | null
    /**
     * Filter, which inducks_publication to fetch.
     */
    where: inducks_publicationWhereUniqueInput
  }


  /**
   * inducks_publication findFirst
   */
  export type inducks_publicationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publication
     */
    select?: inducks_publicationSelect<ExtArgs> | null
    /**
     * Filter, which inducks_publication to fetch.
     */
    where?: inducks_publicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_publications to fetch.
     */
    orderBy?: inducks_publicationOrderByWithRelationInput | inducks_publicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_publications.
     */
    cursor?: inducks_publicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_publications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_publications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_publications.
     */
    distinct?: Inducks_publicationScalarFieldEnum | Inducks_publicationScalarFieldEnum[]
  }


  /**
   * inducks_publication findFirstOrThrow
   */
  export type inducks_publicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publication
     */
    select?: inducks_publicationSelect<ExtArgs> | null
    /**
     * Filter, which inducks_publication to fetch.
     */
    where?: inducks_publicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_publications to fetch.
     */
    orderBy?: inducks_publicationOrderByWithRelationInput | inducks_publicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_publications.
     */
    cursor?: inducks_publicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_publications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_publications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_publications.
     */
    distinct?: Inducks_publicationScalarFieldEnum | Inducks_publicationScalarFieldEnum[]
  }


  /**
   * inducks_publication findMany
   */
  export type inducks_publicationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publication
     */
    select?: inducks_publicationSelect<ExtArgs> | null
    /**
     * Filter, which inducks_publications to fetch.
     */
    where?: inducks_publicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_publications to fetch.
     */
    orderBy?: inducks_publicationOrderByWithRelationInput | inducks_publicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_publications.
     */
    cursor?: inducks_publicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_publications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_publications.
     */
    skip?: number
    distinct?: Inducks_publicationScalarFieldEnum | Inducks_publicationScalarFieldEnum[]
  }


  /**
   * inducks_publication create
   */
  export type inducks_publicationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publication
     */
    select?: inducks_publicationSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_publication.
     */
    data: XOR<inducks_publicationCreateInput, inducks_publicationUncheckedCreateInput>
  }


  /**
   * inducks_publication createMany
   */
  export type inducks_publicationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_publications.
     */
    data: inducks_publicationCreateManyInput | inducks_publicationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_publication update
   */
  export type inducks_publicationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publication
     */
    select?: inducks_publicationSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_publication.
     */
    data: XOR<inducks_publicationUpdateInput, inducks_publicationUncheckedUpdateInput>
    /**
     * Choose, which inducks_publication to update.
     */
    where: inducks_publicationWhereUniqueInput
  }


  /**
   * inducks_publication updateMany
   */
  export type inducks_publicationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_publications.
     */
    data: XOR<inducks_publicationUpdateManyMutationInput, inducks_publicationUncheckedUpdateManyInput>
    /**
     * Filter which inducks_publications to update
     */
    where?: inducks_publicationWhereInput
  }


  /**
   * inducks_publication upsert
   */
  export type inducks_publicationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publication
     */
    select?: inducks_publicationSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_publication to update in case it exists.
     */
    where: inducks_publicationWhereUniqueInput
    /**
     * In case the inducks_publication found by the `where` argument doesn't exist, create a new inducks_publication with this data.
     */
    create: XOR<inducks_publicationCreateInput, inducks_publicationUncheckedCreateInput>
    /**
     * In case the inducks_publication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_publicationUpdateInput, inducks_publicationUncheckedUpdateInput>
  }


  /**
   * inducks_publication delete
   */
  export type inducks_publicationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publication
     */
    select?: inducks_publicationSelect<ExtArgs> | null
    /**
     * Filter which inducks_publication to delete.
     */
    where: inducks_publicationWhereUniqueInput
  }


  /**
   * inducks_publication deleteMany
   */
  export type inducks_publicationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_publications to delete
     */
    where?: inducks_publicationWhereInput
  }


  /**
   * inducks_publication without action
   */
  export type inducks_publicationDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publication
     */
    select?: inducks_publicationSelect<ExtArgs> | null
  }



  /**
   * Model inducks_publicationcategory
   */

  export type AggregateInducks_publicationcategory = {
    _count: Inducks_publicationcategoryCountAggregateOutputType | null
    _min: Inducks_publicationcategoryMinAggregateOutputType | null
    _max: Inducks_publicationcategoryMaxAggregateOutputType | null
  }

  export type Inducks_publicationcategoryMinAggregateOutputType = {
    publicationcode: string | null
    category: string | null
  }

  export type Inducks_publicationcategoryMaxAggregateOutputType = {
    publicationcode: string | null
    category: string | null
  }

  export type Inducks_publicationcategoryCountAggregateOutputType = {
    publicationcode: number
    category: number
    _all: number
  }


  export type Inducks_publicationcategoryMinAggregateInputType = {
    publicationcode?: true
    category?: true
  }

  export type Inducks_publicationcategoryMaxAggregateInputType = {
    publicationcode?: true
    category?: true
  }

  export type Inducks_publicationcategoryCountAggregateInputType = {
    publicationcode?: true
    category?: true
    _all?: true
  }

  export type Inducks_publicationcategoryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_publicationcategory to aggregate.
     */
    where?: inducks_publicationcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_publicationcategories to fetch.
     */
    orderBy?: inducks_publicationcategoryOrderByWithRelationInput | inducks_publicationcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_publicationcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_publicationcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_publicationcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_publicationcategories
    **/
    _count?: true | Inducks_publicationcategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_publicationcategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_publicationcategoryMaxAggregateInputType
  }

  export type GetInducks_publicationcategoryAggregateType<T extends Inducks_publicationcategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_publicationcategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_publicationcategory[P]>
      : GetScalarType<T[P], AggregateInducks_publicationcategory[P]>
  }




  export type inducks_publicationcategoryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_publicationcategoryWhereInput
    orderBy?: inducks_publicationcategoryOrderByWithAggregationInput | inducks_publicationcategoryOrderByWithAggregationInput[]
    by: Inducks_publicationcategoryScalarFieldEnum[] | Inducks_publicationcategoryScalarFieldEnum
    having?: inducks_publicationcategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_publicationcategoryCountAggregateInputType | true
    _min?: Inducks_publicationcategoryMinAggregateInputType
    _max?: Inducks_publicationcategoryMaxAggregateInputType
  }

  export type Inducks_publicationcategoryGroupByOutputType = {
    publicationcode: string
    category: string | null
    _count: Inducks_publicationcategoryCountAggregateOutputType | null
    _min: Inducks_publicationcategoryMinAggregateOutputType | null
    _max: Inducks_publicationcategoryMaxAggregateOutputType | null
  }

  type GetInducks_publicationcategoryGroupByPayload<T extends inducks_publicationcategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_publicationcategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_publicationcategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_publicationcategoryGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_publicationcategoryGroupByOutputType[P]>
        }
      >
    >


  export type inducks_publicationcategorySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    publicationcode?: boolean
    category?: boolean
  }, ExtArgs["result"]["inducks_publicationcategory"]>

  export type inducks_publicationcategorySelectScalar = {
    publicationcode?: boolean
    category?: boolean
  }


  export type $inducks_publicationcategoryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_publicationcategory"
    objects: {}
    scalars: $Extensions.GetResult<{
      publicationcode: string
      category: string | null
    }, ExtArgs["result"]["inducks_publicationcategory"]>
    composites: {}
  }


  type inducks_publicationcategoryGetPayload<S extends boolean | null | undefined | inducks_publicationcategoryDefaultArgs> = $Result.GetResult<Prisma.$inducks_publicationcategoryPayload, S>

  type inducks_publicationcategoryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_publicationcategoryFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_publicationcategoryCountAggregateInputType | true
    }

  export interface inducks_publicationcategoryDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_publicationcategory'], meta: { name: 'inducks_publicationcategory' } }
    /**
     * Find zero or one Inducks_publicationcategory that matches the filter.
     * @param {inducks_publicationcategoryFindUniqueArgs} args - Arguments to find a Inducks_publicationcategory
     * @example
     * // Get one Inducks_publicationcategory
     * const inducks_publicationcategory = await prisma.inducks_publicationcategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_publicationcategoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_publicationcategoryFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_publicationcategoryClient<$Result.GetResult<Prisma.$inducks_publicationcategoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_publicationcategory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_publicationcategoryFindUniqueOrThrowArgs} args - Arguments to find a Inducks_publicationcategory
     * @example
     * // Get one Inducks_publicationcategory
     * const inducks_publicationcategory = await prisma.inducks_publicationcategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_publicationcategoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_publicationcategoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_publicationcategoryClient<$Result.GetResult<Prisma.$inducks_publicationcategoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_publicationcategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_publicationcategoryFindFirstArgs} args - Arguments to find a Inducks_publicationcategory
     * @example
     * // Get one Inducks_publicationcategory
     * const inducks_publicationcategory = await prisma.inducks_publicationcategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_publicationcategoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_publicationcategoryFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_publicationcategoryClient<$Result.GetResult<Prisma.$inducks_publicationcategoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_publicationcategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_publicationcategoryFindFirstOrThrowArgs} args - Arguments to find a Inducks_publicationcategory
     * @example
     * // Get one Inducks_publicationcategory
     * const inducks_publicationcategory = await prisma.inducks_publicationcategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_publicationcategoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_publicationcategoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_publicationcategoryClient<$Result.GetResult<Prisma.$inducks_publicationcategoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_publicationcategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_publicationcategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_publicationcategories
     * const inducks_publicationcategories = await prisma.inducks_publicationcategory.findMany()
     * 
     * // Get first 10 Inducks_publicationcategories
     * const inducks_publicationcategories = await prisma.inducks_publicationcategory.findMany({ take: 10 })
     * 
     * // Only select the `publicationcode`
     * const inducks_publicationcategoryWithPublicationcodeOnly = await prisma.inducks_publicationcategory.findMany({ select: { publicationcode: true } })
     * 
    **/
    findMany<T extends inducks_publicationcategoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_publicationcategoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_publicationcategoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_publicationcategory.
     * @param {inducks_publicationcategoryCreateArgs} args - Arguments to create a Inducks_publicationcategory.
     * @example
     * // Create one Inducks_publicationcategory
     * const Inducks_publicationcategory = await prisma.inducks_publicationcategory.create({
     *   data: {
     *     // ... data to create a Inducks_publicationcategory
     *   }
     * })
     * 
    **/
    create<T extends inducks_publicationcategoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_publicationcategoryCreateArgs<ExtArgs>>
    ): Prisma__inducks_publicationcategoryClient<$Result.GetResult<Prisma.$inducks_publicationcategoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_publicationcategories.
     *     @param {inducks_publicationcategoryCreateManyArgs} args - Arguments to create many Inducks_publicationcategories.
     *     @example
     *     // Create many Inducks_publicationcategories
     *     const inducks_publicationcategory = await prisma.inducks_publicationcategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_publicationcategoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_publicationcategoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_publicationcategory.
     * @param {inducks_publicationcategoryDeleteArgs} args - Arguments to delete one Inducks_publicationcategory.
     * @example
     * // Delete one Inducks_publicationcategory
     * const Inducks_publicationcategory = await prisma.inducks_publicationcategory.delete({
     *   where: {
     *     // ... filter to delete one Inducks_publicationcategory
     *   }
     * })
     * 
    **/
    delete<T extends inducks_publicationcategoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_publicationcategoryDeleteArgs<ExtArgs>>
    ): Prisma__inducks_publicationcategoryClient<$Result.GetResult<Prisma.$inducks_publicationcategoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_publicationcategory.
     * @param {inducks_publicationcategoryUpdateArgs} args - Arguments to update one Inducks_publicationcategory.
     * @example
     * // Update one Inducks_publicationcategory
     * const inducks_publicationcategory = await prisma.inducks_publicationcategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_publicationcategoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_publicationcategoryUpdateArgs<ExtArgs>>
    ): Prisma__inducks_publicationcategoryClient<$Result.GetResult<Prisma.$inducks_publicationcategoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_publicationcategories.
     * @param {inducks_publicationcategoryDeleteManyArgs} args - Arguments to filter Inducks_publicationcategories to delete.
     * @example
     * // Delete a few Inducks_publicationcategories
     * const { count } = await prisma.inducks_publicationcategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_publicationcategoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_publicationcategoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_publicationcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_publicationcategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_publicationcategories
     * const inducks_publicationcategory = await prisma.inducks_publicationcategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_publicationcategoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_publicationcategoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_publicationcategory.
     * @param {inducks_publicationcategoryUpsertArgs} args - Arguments to update or create a Inducks_publicationcategory.
     * @example
     * // Update or create a Inducks_publicationcategory
     * const inducks_publicationcategory = await prisma.inducks_publicationcategory.upsert({
     *   create: {
     *     // ... data to create a Inducks_publicationcategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_publicationcategory we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_publicationcategoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_publicationcategoryUpsertArgs<ExtArgs>>
    ): Prisma__inducks_publicationcategoryClient<$Result.GetResult<Prisma.$inducks_publicationcategoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_publicationcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_publicationcategoryCountArgs} args - Arguments to filter Inducks_publicationcategories to count.
     * @example
     * // Count the number of Inducks_publicationcategories
     * const count = await prisma.inducks_publicationcategory.count({
     *   where: {
     *     // ... the filter for the Inducks_publicationcategories we want to count
     *   }
     * })
    **/
    count<T extends inducks_publicationcategoryCountArgs>(
      args?: Subset<T, inducks_publicationcategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_publicationcategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_publicationcategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_publicationcategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_publicationcategoryAggregateArgs>(args: Subset<T, Inducks_publicationcategoryAggregateArgs>): Prisma.PrismaPromise<GetInducks_publicationcategoryAggregateType<T>>

    /**
     * Group by Inducks_publicationcategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_publicationcategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_publicationcategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_publicationcategoryGroupByArgs['orderBy'] }
        : { orderBy?: inducks_publicationcategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_publicationcategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_publicationcategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_publicationcategory model
   */
  readonly fields: inducks_publicationcategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_publicationcategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_publicationcategoryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_publicationcategory model
   */ 
  interface inducks_publicationcategoryFieldRefs {
    readonly publicationcode: FieldRef<"inducks_publicationcategory", 'String'>
    readonly category: FieldRef<"inducks_publicationcategory", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_publicationcategory findUnique
   */
  export type inducks_publicationcategoryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publicationcategory
     */
    select?: inducks_publicationcategorySelect<ExtArgs> | null
    /**
     * Filter, which inducks_publicationcategory to fetch.
     */
    where: inducks_publicationcategoryWhereUniqueInput
  }


  /**
   * inducks_publicationcategory findUniqueOrThrow
   */
  export type inducks_publicationcategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publicationcategory
     */
    select?: inducks_publicationcategorySelect<ExtArgs> | null
    /**
     * Filter, which inducks_publicationcategory to fetch.
     */
    where: inducks_publicationcategoryWhereUniqueInput
  }


  /**
   * inducks_publicationcategory findFirst
   */
  export type inducks_publicationcategoryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publicationcategory
     */
    select?: inducks_publicationcategorySelect<ExtArgs> | null
    /**
     * Filter, which inducks_publicationcategory to fetch.
     */
    where?: inducks_publicationcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_publicationcategories to fetch.
     */
    orderBy?: inducks_publicationcategoryOrderByWithRelationInput | inducks_publicationcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_publicationcategories.
     */
    cursor?: inducks_publicationcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_publicationcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_publicationcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_publicationcategories.
     */
    distinct?: Inducks_publicationcategoryScalarFieldEnum | Inducks_publicationcategoryScalarFieldEnum[]
  }


  /**
   * inducks_publicationcategory findFirstOrThrow
   */
  export type inducks_publicationcategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publicationcategory
     */
    select?: inducks_publicationcategorySelect<ExtArgs> | null
    /**
     * Filter, which inducks_publicationcategory to fetch.
     */
    where?: inducks_publicationcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_publicationcategories to fetch.
     */
    orderBy?: inducks_publicationcategoryOrderByWithRelationInput | inducks_publicationcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_publicationcategories.
     */
    cursor?: inducks_publicationcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_publicationcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_publicationcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_publicationcategories.
     */
    distinct?: Inducks_publicationcategoryScalarFieldEnum | Inducks_publicationcategoryScalarFieldEnum[]
  }


  /**
   * inducks_publicationcategory findMany
   */
  export type inducks_publicationcategoryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publicationcategory
     */
    select?: inducks_publicationcategorySelect<ExtArgs> | null
    /**
     * Filter, which inducks_publicationcategories to fetch.
     */
    where?: inducks_publicationcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_publicationcategories to fetch.
     */
    orderBy?: inducks_publicationcategoryOrderByWithRelationInput | inducks_publicationcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_publicationcategories.
     */
    cursor?: inducks_publicationcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_publicationcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_publicationcategories.
     */
    skip?: number
    distinct?: Inducks_publicationcategoryScalarFieldEnum | Inducks_publicationcategoryScalarFieldEnum[]
  }


  /**
   * inducks_publicationcategory create
   */
  export type inducks_publicationcategoryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publicationcategory
     */
    select?: inducks_publicationcategorySelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_publicationcategory.
     */
    data: XOR<inducks_publicationcategoryCreateInput, inducks_publicationcategoryUncheckedCreateInput>
  }


  /**
   * inducks_publicationcategory createMany
   */
  export type inducks_publicationcategoryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_publicationcategories.
     */
    data: inducks_publicationcategoryCreateManyInput | inducks_publicationcategoryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_publicationcategory update
   */
  export type inducks_publicationcategoryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publicationcategory
     */
    select?: inducks_publicationcategorySelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_publicationcategory.
     */
    data: XOR<inducks_publicationcategoryUpdateInput, inducks_publicationcategoryUncheckedUpdateInput>
    /**
     * Choose, which inducks_publicationcategory to update.
     */
    where: inducks_publicationcategoryWhereUniqueInput
  }


  /**
   * inducks_publicationcategory updateMany
   */
  export type inducks_publicationcategoryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_publicationcategories.
     */
    data: XOR<inducks_publicationcategoryUpdateManyMutationInput, inducks_publicationcategoryUncheckedUpdateManyInput>
    /**
     * Filter which inducks_publicationcategories to update
     */
    where?: inducks_publicationcategoryWhereInput
  }


  /**
   * inducks_publicationcategory upsert
   */
  export type inducks_publicationcategoryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publicationcategory
     */
    select?: inducks_publicationcategorySelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_publicationcategory to update in case it exists.
     */
    where: inducks_publicationcategoryWhereUniqueInput
    /**
     * In case the inducks_publicationcategory found by the `where` argument doesn't exist, create a new inducks_publicationcategory with this data.
     */
    create: XOR<inducks_publicationcategoryCreateInput, inducks_publicationcategoryUncheckedCreateInput>
    /**
     * In case the inducks_publicationcategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_publicationcategoryUpdateInput, inducks_publicationcategoryUncheckedUpdateInput>
  }


  /**
   * inducks_publicationcategory delete
   */
  export type inducks_publicationcategoryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publicationcategory
     */
    select?: inducks_publicationcategorySelect<ExtArgs> | null
    /**
     * Filter which inducks_publicationcategory to delete.
     */
    where: inducks_publicationcategoryWhereUniqueInput
  }


  /**
   * inducks_publicationcategory deleteMany
   */
  export type inducks_publicationcategoryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_publicationcategories to delete
     */
    where?: inducks_publicationcategoryWhereInput
  }


  /**
   * inducks_publicationcategory without action
   */
  export type inducks_publicationcategoryDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publicationcategory
     */
    select?: inducks_publicationcategorySelect<ExtArgs> | null
  }



  /**
   * Model inducks_publicationname
   */

  export type AggregateInducks_publicationname = {
    _count: Inducks_publicationnameCountAggregateOutputType | null
    _min: Inducks_publicationnameMinAggregateOutputType | null
    _max: Inducks_publicationnameMaxAggregateOutputType | null
  }

  export type Inducks_publicationnameMinAggregateOutputType = {
    publicationcode: string | null
    publicationname: string | null
  }

  export type Inducks_publicationnameMaxAggregateOutputType = {
    publicationcode: string | null
    publicationname: string | null
  }

  export type Inducks_publicationnameCountAggregateOutputType = {
    publicationcode: number
    publicationname: number
    _all: number
  }


  export type Inducks_publicationnameMinAggregateInputType = {
    publicationcode?: true
    publicationname?: true
  }

  export type Inducks_publicationnameMaxAggregateInputType = {
    publicationcode?: true
    publicationname?: true
  }

  export type Inducks_publicationnameCountAggregateInputType = {
    publicationcode?: true
    publicationname?: true
    _all?: true
  }

  export type Inducks_publicationnameAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_publicationname to aggregate.
     */
    where?: inducks_publicationnameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_publicationnames to fetch.
     */
    orderBy?: inducks_publicationnameOrderByWithRelationInput | inducks_publicationnameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_publicationnameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_publicationnames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_publicationnames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_publicationnames
    **/
    _count?: true | Inducks_publicationnameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_publicationnameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_publicationnameMaxAggregateInputType
  }

  export type GetInducks_publicationnameAggregateType<T extends Inducks_publicationnameAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_publicationname]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_publicationname[P]>
      : GetScalarType<T[P], AggregateInducks_publicationname[P]>
  }




  export type inducks_publicationnameGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_publicationnameWhereInput
    orderBy?: inducks_publicationnameOrderByWithAggregationInput | inducks_publicationnameOrderByWithAggregationInput[]
    by: Inducks_publicationnameScalarFieldEnum[] | Inducks_publicationnameScalarFieldEnum
    having?: inducks_publicationnameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_publicationnameCountAggregateInputType | true
    _min?: Inducks_publicationnameMinAggregateInputType
    _max?: Inducks_publicationnameMaxAggregateInputType
  }

  export type Inducks_publicationnameGroupByOutputType = {
    publicationcode: string
    publicationname: string | null
    _count: Inducks_publicationnameCountAggregateOutputType | null
    _min: Inducks_publicationnameMinAggregateOutputType | null
    _max: Inducks_publicationnameMaxAggregateOutputType | null
  }

  type GetInducks_publicationnameGroupByPayload<T extends inducks_publicationnameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_publicationnameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_publicationnameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_publicationnameGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_publicationnameGroupByOutputType[P]>
        }
      >
    >


  export type inducks_publicationnameSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    publicationcode?: boolean
    publicationname?: boolean
  }, ExtArgs["result"]["inducks_publicationname"]>

  export type inducks_publicationnameSelectScalar = {
    publicationcode?: boolean
    publicationname?: boolean
  }


  export type $inducks_publicationnamePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_publicationname"
    objects: {}
    scalars: $Extensions.GetResult<{
      publicationcode: string
      publicationname: string | null
    }, ExtArgs["result"]["inducks_publicationname"]>
    composites: {}
  }


  type inducks_publicationnameGetPayload<S extends boolean | null | undefined | inducks_publicationnameDefaultArgs> = $Result.GetResult<Prisma.$inducks_publicationnamePayload, S>

  type inducks_publicationnameCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_publicationnameFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_publicationnameCountAggregateInputType | true
    }

  export interface inducks_publicationnameDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_publicationname'], meta: { name: 'inducks_publicationname' } }
    /**
     * Find zero or one Inducks_publicationname that matches the filter.
     * @param {inducks_publicationnameFindUniqueArgs} args - Arguments to find a Inducks_publicationname
     * @example
     * // Get one Inducks_publicationname
     * const inducks_publicationname = await prisma.inducks_publicationname.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_publicationnameFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_publicationnameFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_publicationnameClient<$Result.GetResult<Prisma.$inducks_publicationnamePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_publicationname that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_publicationnameFindUniqueOrThrowArgs} args - Arguments to find a Inducks_publicationname
     * @example
     * // Get one Inducks_publicationname
     * const inducks_publicationname = await prisma.inducks_publicationname.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_publicationnameFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_publicationnameFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_publicationnameClient<$Result.GetResult<Prisma.$inducks_publicationnamePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_publicationname that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_publicationnameFindFirstArgs} args - Arguments to find a Inducks_publicationname
     * @example
     * // Get one Inducks_publicationname
     * const inducks_publicationname = await prisma.inducks_publicationname.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_publicationnameFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_publicationnameFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_publicationnameClient<$Result.GetResult<Prisma.$inducks_publicationnamePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_publicationname that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_publicationnameFindFirstOrThrowArgs} args - Arguments to find a Inducks_publicationname
     * @example
     * // Get one Inducks_publicationname
     * const inducks_publicationname = await prisma.inducks_publicationname.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_publicationnameFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_publicationnameFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_publicationnameClient<$Result.GetResult<Prisma.$inducks_publicationnamePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_publicationnames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_publicationnameFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_publicationnames
     * const inducks_publicationnames = await prisma.inducks_publicationname.findMany()
     * 
     * // Get first 10 Inducks_publicationnames
     * const inducks_publicationnames = await prisma.inducks_publicationname.findMany({ take: 10 })
     * 
     * // Only select the `publicationcode`
     * const inducks_publicationnameWithPublicationcodeOnly = await prisma.inducks_publicationname.findMany({ select: { publicationcode: true } })
     * 
    **/
    findMany<T extends inducks_publicationnameFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_publicationnameFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_publicationnamePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_publicationname.
     * @param {inducks_publicationnameCreateArgs} args - Arguments to create a Inducks_publicationname.
     * @example
     * // Create one Inducks_publicationname
     * const Inducks_publicationname = await prisma.inducks_publicationname.create({
     *   data: {
     *     // ... data to create a Inducks_publicationname
     *   }
     * })
     * 
    **/
    create<T extends inducks_publicationnameCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_publicationnameCreateArgs<ExtArgs>>
    ): Prisma__inducks_publicationnameClient<$Result.GetResult<Prisma.$inducks_publicationnamePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_publicationnames.
     *     @param {inducks_publicationnameCreateManyArgs} args - Arguments to create many Inducks_publicationnames.
     *     @example
     *     // Create many Inducks_publicationnames
     *     const inducks_publicationname = await prisma.inducks_publicationname.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_publicationnameCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_publicationnameCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_publicationname.
     * @param {inducks_publicationnameDeleteArgs} args - Arguments to delete one Inducks_publicationname.
     * @example
     * // Delete one Inducks_publicationname
     * const Inducks_publicationname = await prisma.inducks_publicationname.delete({
     *   where: {
     *     // ... filter to delete one Inducks_publicationname
     *   }
     * })
     * 
    **/
    delete<T extends inducks_publicationnameDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_publicationnameDeleteArgs<ExtArgs>>
    ): Prisma__inducks_publicationnameClient<$Result.GetResult<Prisma.$inducks_publicationnamePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_publicationname.
     * @param {inducks_publicationnameUpdateArgs} args - Arguments to update one Inducks_publicationname.
     * @example
     * // Update one Inducks_publicationname
     * const inducks_publicationname = await prisma.inducks_publicationname.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_publicationnameUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_publicationnameUpdateArgs<ExtArgs>>
    ): Prisma__inducks_publicationnameClient<$Result.GetResult<Prisma.$inducks_publicationnamePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_publicationnames.
     * @param {inducks_publicationnameDeleteManyArgs} args - Arguments to filter Inducks_publicationnames to delete.
     * @example
     * // Delete a few Inducks_publicationnames
     * const { count } = await prisma.inducks_publicationname.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_publicationnameDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_publicationnameDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_publicationnames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_publicationnameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_publicationnames
     * const inducks_publicationname = await prisma.inducks_publicationname.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_publicationnameUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_publicationnameUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_publicationname.
     * @param {inducks_publicationnameUpsertArgs} args - Arguments to update or create a Inducks_publicationname.
     * @example
     * // Update or create a Inducks_publicationname
     * const inducks_publicationname = await prisma.inducks_publicationname.upsert({
     *   create: {
     *     // ... data to create a Inducks_publicationname
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_publicationname we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_publicationnameUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_publicationnameUpsertArgs<ExtArgs>>
    ): Prisma__inducks_publicationnameClient<$Result.GetResult<Prisma.$inducks_publicationnamePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_publicationnames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_publicationnameCountArgs} args - Arguments to filter Inducks_publicationnames to count.
     * @example
     * // Count the number of Inducks_publicationnames
     * const count = await prisma.inducks_publicationname.count({
     *   where: {
     *     // ... the filter for the Inducks_publicationnames we want to count
     *   }
     * })
    **/
    count<T extends inducks_publicationnameCountArgs>(
      args?: Subset<T, inducks_publicationnameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_publicationnameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_publicationname.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_publicationnameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_publicationnameAggregateArgs>(args: Subset<T, Inducks_publicationnameAggregateArgs>): Prisma.PrismaPromise<GetInducks_publicationnameAggregateType<T>>

    /**
     * Group by Inducks_publicationname.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_publicationnameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_publicationnameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_publicationnameGroupByArgs['orderBy'] }
        : { orderBy?: inducks_publicationnameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_publicationnameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_publicationnameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_publicationname model
   */
  readonly fields: inducks_publicationnameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_publicationname.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_publicationnameClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_publicationname model
   */ 
  interface inducks_publicationnameFieldRefs {
    readonly publicationcode: FieldRef<"inducks_publicationname", 'String'>
    readonly publicationname: FieldRef<"inducks_publicationname", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_publicationname findUnique
   */
  export type inducks_publicationnameFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publicationname
     */
    select?: inducks_publicationnameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_publicationname to fetch.
     */
    where: inducks_publicationnameWhereUniqueInput
  }


  /**
   * inducks_publicationname findUniqueOrThrow
   */
  export type inducks_publicationnameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publicationname
     */
    select?: inducks_publicationnameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_publicationname to fetch.
     */
    where: inducks_publicationnameWhereUniqueInput
  }


  /**
   * inducks_publicationname findFirst
   */
  export type inducks_publicationnameFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publicationname
     */
    select?: inducks_publicationnameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_publicationname to fetch.
     */
    where?: inducks_publicationnameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_publicationnames to fetch.
     */
    orderBy?: inducks_publicationnameOrderByWithRelationInput | inducks_publicationnameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_publicationnames.
     */
    cursor?: inducks_publicationnameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_publicationnames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_publicationnames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_publicationnames.
     */
    distinct?: Inducks_publicationnameScalarFieldEnum | Inducks_publicationnameScalarFieldEnum[]
  }


  /**
   * inducks_publicationname findFirstOrThrow
   */
  export type inducks_publicationnameFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publicationname
     */
    select?: inducks_publicationnameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_publicationname to fetch.
     */
    where?: inducks_publicationnameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_publicationnames to fetch.
     */
    orderBy?: inducks_publicationnameOrderByWithRelationInput | inducks_publicationnameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_publicationnames.
     */
    cursor?: inducks_publicationnameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_publicationnames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_publicationnames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_publicationnames.
     */
    distinct?: Inducks_publicationnameScalarFieldEnum | Inducks_publicationnameScalarFieldEnum[]
  }


  /**
   * inducks_publicationname findMany
   */
  export type inducks_publicationnameFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publicationname
     */
    select?: inducks_publicationnameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_publicationnames to fetch.
     */
    where?: inducks_publicationnameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_publicationnames to fetch.
     */
    orderBy?: inducks_publicationnameOrderByWithRelationInput | inducks_publicationnameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_publicationnames.
     */
    cursor?: inducks_publicationnameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_publicationnames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_publicationnames.
     */
    skip?: number
    distinct?: Inducks_publicationnameScalarFieldEnum | Inducks_publicationnameScalarFieldEnum[]
  }


  /**
   * inducks_publicationname create
   */
  export type inducks_publicationnameCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publicationname
     */
    select?: inducks_publicationnameSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_publicationname.
     */
    data: XOR<inducks_publicationnameCreateInput, inducks_publicationnameUncheckedCreateInput>
  }


  /**
   * inducks_publicationname createMany
   */
  export type inducks_publicationnameCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_publicationnames.
     */
    data: inducks_publicationnameCreateManyInput | inducks_publicationnameCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_publicationname update
   */
  export type inducks_publicationnameUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publicationname
     */
    select?: inducks_publicationnameSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_publicationname.
     */
    data: XOR<inducks_publicationnameUpdateInput, inducks_publicationnameUncheckedUpdateInput>
    /**
     * Choose, which inducks_publicationname to update.
     */
    where: inducks_publicationnameWhereUniqueInput
  }


  /**
   * inducks_publicationname updateMany
   */
  export type inducks_publicationnameUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_publicationnames.
     */
    data: XOR<inducks_publicationnameUpdateManyMutationInput, inducks_publicationnameUncheckedUpdateManyInput>
    /**
     * Filter which inducks_publicationnames to update
     */
    where?: inducks_publicationnameWhereInput
  }


  /**
   * inducks_publicationname upsert
   */
  export type inducks_publicationnameUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publicationname
     */
    select?: inducks_publicationnameSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_publicationname to update in case it exists.
     */
    where: inducks_publicationnameWhereUniqueInput
    /**
     * In case the inducks_publicationname found by the `where` argument doesn't exist, create a new inducks_publicationname with this data.
     */
    create: XOR<inducks_publicationnameCreateInput, inducks_publicationnameUncheckedCreateInput>
    /**
     * In case the inducks_publicationname was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_publicationnameUpdateInput, inducks_publicationnameUncheckedUpdateInput>
  }


  /**
   * inducks_publicationname delete
   */
  export type inducks_publicationnameDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publicationname
     */
    select?: inducks_publicationnameSelect<ExtArgs> | null
    /**
     * Filter which inducks_publicationname to delete.
     */
    where: inducks_publicationnameWhereUniqueInput
  }


  /**
   * inducks_publicationname deleteMany
   */
  export type inducks_publicationnameDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_publicationnames to delete
     */
    where?: inducks_publicationnameWhereInput
  }


  /**
   * inducks_publicationname without action
   */
  export type inducks_publicationnameDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publicationname
     */
    select?: inducks_publicationnameSelect<ExtArgs> | null
  }



  /**
   * Model inducks_publicationurl
   */

  export type AggregateInducks_publicationurl = {
    _count: Inducks_publicationurlCountAggregateOutputType | null
    _min: Inducks_publicationurlMinAggregateOutputType | null
    _max: Inducks_publicationurlMaxAggregateOutputType | null
  }

  export type Inducks_publicationurlMinAggregateOutputType = {
    publicationcode: string | null
    sitecode: string | null
    url: string | null
  }

  export type Inducks_publicationurlMaxAggregateOutputType = {
    publicationcode: string | null
    sitecode: string | null
    url: string | null
  }

  export type Inducks_publicationurlCountAggregateOutputType = {
    publicationcode: number
    sitecode: number
    url: number
    _all: number
  }


  export type Inducks_publicationurlMinAggregateInputType = {
    publicationcode?: true
    sitecode?: true
    url?: true
  }

  export type Inducks_publicationurlMaxAggregateInputType = {
    publicationcode?: true
    sitecode?: true
    url?: true
  }

  export type Inducks_publicationurlCountAggregateInputType = {
    publicationcode?: true
    sitecode?: true
    url?: true
    _all?: true
  }

  export type Inducks_publicationurlAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_publicationurl to aggregate.
     */
    where?: inducks_publicationurlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_publicationurls to fetch.
     */
    orderBy?: inducks_publicationurlOrderByWithRelationInput | inducks_publicationurlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_publicationurlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_publicationurls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_publicationurls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_publicationurls
    **/
    _count?: true | Inducks_publicationurlCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_publicationurlMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_publicationurlMaxAggregateInputType
  }

  export type GetInducks_publicationurlAggregateType<T extends Inducks_publicationurlAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_publicationurl]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_publicationurl[P]>
      : GetScalarType<T[P], AggregateInducks_publicationurl[P]>
  }




  export type inducks_publicationurlGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_publicationurlWhereInput
    orderBy?: inducks_publicationurlOrderByWithAggregationInput | inducks_publicationurlOrderByWithAggregationInput[]
    by: Inducks_publicationurlScalarFieldEnum[] | Inducks_publicationurlScalarFieldEnum
    having?: inducks_publicationurlScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_publicationurlCountAggregateInputType | true
    _min?: Inducks_publicationurlMinAggregateInputType
    _max?: Inducks_publicationurlMaxAggregateInputType
  }

  export type Inducks_publicationurlGroupByOutputType = {
    publicationcode: string
    sitecode: string
    url: string | null
    _count: Inducks_publicationurlCountAggregateOutputType | null
    _min: Inducks_publicationurlMinAggregateOutputType | null
    _max: Inducks_publicationurlMaxAggregateOutputType | null
  }

  type GetInducks_publicationurlGroupByPayload<T extends inducks_publicationurlGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_publicationurlGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_publicationurlGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_publicationurlGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_publicationurlGroupByOutputType[P]>
        }
      >
    >


  export type inducks_publicationurlSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    publicationcode?: boolean
    sitecode?: boolean
    url?: boolean
  }, ExtArgs["result"]["inducks_publicationurl"]>

  export type inducks_publicationurlSelectScalar = {
    publicationcode?: boolean
    sitecode?: boolean
    url?: boolean
  }


  export type $inducks_publicationurlPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_publicationurl"
    objects: {}
    scalars: $Extensions.GetResult<{
      publicationcode: string
      sitecode: string
      url: string | null
    }, ExtArgs["result"]["inducks_publicationurl"]>
    composites: {}
  }


  type inducks_publicationurlGetPayload<S extends boolean | null | undefined | inducks_publicationurlDefaultArgs> = $Result.GetResult<Prisma.$inducks_publicationurlPayload, S>

  type inducks_publicationurlCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_publicationurlFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_publicationurlCountAggregateInputType | true
    }

  export interface inducks_publicationurlDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_publicationurl'], meta: { name: 'inducks_publicationurl' } }
    /**
     * Find zero or one Inducks_publicationurl that matches the filter.
     * @param {inducks_publicationurlFindUniqueArgs} args - Arguments to find a Inducks_publicationurl
     * @example
     * // Get one Inducks_publicationurl
     * const inducks_publicationurl = await prisma.inducks_publicationurl.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_publicationurlFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_publicationurlFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_publicationurlClient<$Result.GetResult<Prisma.$inducks_publicationurlPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_publicationurl that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_publicationurlFindUniqueOrThrowArgs} args - Arguments to find a Inducks_publicationurl
     * @example
     * // Get one Inducks_publicationurl
     * const inducks_publicationurl = await prisma.inducks_publicationurl.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_publicationurlFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_publicationurlFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_publicationurlClient<$Result.GetResult<Prisma.$inducks_publicationurlPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_publicationurl that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_publicationurlFindFirstArgs} args - Arguments to find a Inducks_publicationurl
     * @example
     * // Get one Inducks_publicationurl
     * const inducks_publicationurl = await prisma.inducks_publicationurl.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_publicationurlFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_publicationurlFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_publicationurlClient<$Result.GetResult<Prisma.$inducks_publicationurlPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_publicationurl that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_publicationurlFindFirstOrThrowArgs} args - Arguments to find a Inducks_publicationurl
     * @example
     * // Get one Inducks_publicationurl
     * const inducks_publicationurl = await prisma.inducks_publicationurl.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_publicationurlFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_publicationurlFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_publicationurlClient<$Result.GetResult<Prisma.$inducks_publicationurlPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_publicationurls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_publicationurlFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_publicationurls
     * const inducks_publicationurls = await prisma.inducks_publicationurl.findMany()
     * 
     * // Get first 10 Inducks_publicationurls
     * const inducks_publicationurls = await prisma.inducks_publicationurl.findMany({ take: 10 })
     * 
     * // Only select the `publicationcode`
     * const inducks_publicationurlWithPublicationcodeOnly = await prisma.inducks_publicationurl.findMany({ select: { publicationcode: true } })
     * 
    **/
    findMany<T extends inducks_publicationurlFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_publicationurlFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_publicationurlPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_publicationurl.
     * @param {inducks_publicationurlCreateArgs} args - Arguments to create a Inducks_publicationurl.
     * @example
     * // Create one Inducks_publicationurl
     * const Inducks_publicationurl = await prisma.inducks_publicationurl.create({
     *   data: {
     *     // ... data to create a Inducks_publicationurl
     *   }
     * })
     * 
    **/
    create<T extends inducks_publicationurlCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_publicationurlCreateArgs<ExtArgs>>
    ): Prisma__inducks_publicationurlClient<$Result.GetResult<Prisma.$inducks_publicationurlPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_publicationurls.
     *     @param {inducks_publicationurlCreateManyArgs} args - Arguments to create many Inducks_publicationurls.
     *     @example
     *     // Create many Inducks_publicationurls
     *     const inducks_publicationurl = await prisma.inducks_publicationurl.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_publicationurlCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_publicationurlCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_publicationurl.
     * @param {inducks_publicationurlDeleteArgs} args - Arguments to delete one Inducks_publicationurl.
     * @example
     * // Delete one Inducks_publicationurl
     * const Inducks_publicationurl = await prisma.inducks_publicationurl.delete({
     *   where: {
     *     // ... filter to delete one Inducks_publicationurl
     *   }
     * })
     * 
    **/
    delete<T extends inducks_publicationurlDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_publicationurlDeleteArgs<ExtArgs>>
    ): Prisma__inducks_publicationurlClient<$Result.GetResult<Prisma.$inducks_publicationurlPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_publicationurl.
     * @param {inducks_publicationurlUpdateArgs} args - Arguments to update one Inducks_publicationurl.
     * @example
     * // Update one Inducks_publicationurl
     * const inducks_publicationurl = await prisma.inducks_publicationurl.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_publicationurlUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_publicationurlUpdateArgs<ExtArgs>>
    ): Prisma__inducks_publicationurlClient<$Result.GetResult<Prisma.$inducks_publicationurlPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_publicationurls.
     * @param {inducks_publicationurlDeleteManyArgs} args - Arguments to filter Inducks_publicationurls to delete.
     * @example
     * // Delete a few Inducks_publicationurls
     * const { count } = await prisma.inducks_publicationurl.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_publicationurlDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_publicationurlDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_publicationurls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_publicationurlUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_publicationurls
     * const inducks_publicationurl = await prisma.inducks_publicationurl.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_publicationurlUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_publicationurlUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_publicationurl.
     * @param {inducks_publicationurlUpsertArgs} args - Arguments to update or create a Inducks_publicationurl.
     * @example
     * // Update or create a Inducks_publicationurl
     * const inducks_publicationurl = await prisma.inducks_publicationurl.upsert({
     *   create: {
     *     // ... data to create a Inducks_publicationurl
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_publicationurl we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_publicationurlUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_publicationurlUpsertArgs<ExtArgs>>
    ): Prisma__inducks_publicationurlClient<$Result.GetResult<Prisma.$inducks_publicationurlPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_publicationurls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_publicationurlCountArgs} args - Arguments to filter Inducks_publicationurls to count.
     * @example
     * // Count the number of Inducks_publicationurls
     * const count = await prisma.inducks_publicationurl.count({
     *   where: {
     *     // ... the filter for the Inducks_publicationurls we want to count
     *   }
     * })
    **/
    count<T extends inducks_publicationurlCountArgs>(
      args?: Subset<T, inducks_publicationurlCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_publicationurlCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_publicationurl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_publicationurlAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_publicationurlAggregateArgs>(args: Subset<T, Inducks_publicationurlAggregateArgs>): Prisma.PrismaPromise<GetInducks_publicationurlAggregateType<T>>

    /**
     * Group by Inducks_publicationurl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_publicationurlGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_publicationurlGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_publicationurlGroupByArgs['orderBy'] }
        : { orderBy?: inducks_publicationurlGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_publicationurlGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_publicationurlGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_publicationurl model
   */
  readonly fields: inducks_publicationurlFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_publicationurl.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_publicationurlClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_publicationurl model
   */ 
  interface inducks_publicationurlFieldRefs {
    readonly publicationcode: FieldRef<"inducks_publicationurl", 'String'>
    readonly sitecode: FieldRef<"inducks_publicationurl", 'String'>
    readonly url: FieldRef<"inducks_publicationurl", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_publicationurl findUnique
   */
  export type inducks_publicationurlFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publicationurl
     */
    select?: inducks_publicationurlSelect<ExtArgs> | null
    /**
     * Filter, which inducks_publicationurl to fetch.
     */
    where: inducks_publicationurlWhereUniqueInput
  }


  /**
   * inducks_publicationurl findUniqueOrThrow
   */
  export type inducks_publicationurlFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publicationurl
     */
    select?: inducks_publicationurlSelect<ExtArgs> | null
    /**
     * Filter, which inducks_publicationurl to fetch.
     */
    where: inducks_publicationurlWhereUniqueInput
  }


  /**
   * inducks_publicationurl findFirst
   */
  export type inducks_publicationurlFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publicationurl
     */
    select?: inducks_publicationurlSelect<ExtArgs> | null
    /**
     * Filter, which inducks_publicationurl to fetch.
     */
    where?: inducks_publicationurlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_publicationurls to fetch.
     */
    orderBy?: inducks_publicationurlOrderByWithRelationInput | inducks_publicationurlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_publicationurls.
     */
    cursor?: inducks_publicationurlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_publicationurls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_publicationurls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_publicationurls.
     */
    distinct?: Inducks_publicationurlScalarFieldEnum | Inducks_publicationurlScalarFieldEnum[]
  }


  /**
   * inducks_publicationurl findFirstOrThrow
   */
  export type inducks_publicationurlFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publicationurl
     */
    select?: inducks_publicationurlSelect<ExtArgs> | null
    /**
     * Filter, which inducks_publicationurl to fetch.
     */
    where?: inducks_publicationurlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_publicationurls to fetch.
     */
    orderBy?: inducks_publicationurlOrderByWithRelationInput | inducks_publicationurlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_publicationurls.
     */
    cursor?: inducks_publicationurlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_publicationurls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_publicationurls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_publicationurls.
     */
    distinct?: Inducks_publicationurlScalarFieldEnum | Inducks_publicationurlScalarFieldEnum[]
  }


  /**
   * inducks_publicationurl findMany
   */
  export type inducks_publicationurlFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publicationurl
     */
    select?: inducks_publicationurlSelect<ExtArgs> | null
    /**
     * Filter, which inducks_publicationurls to fetch.
     */
    where?: inducks_publicationurlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_publicationurls to fetch.
     */
    orderBy?: inducks_publicationurlOrderByWithRelationInput | inducks_publicationurlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_publicationurls.
     */
    cursor?: inducks_publicationurlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_publicationurls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_publicationurls.
     */
    skip?: number
    distinct?: Inducks_publicationurlScalarFieldEnum | Inducks_publicationurlScalarFieldEnum[]
  }


  /**
   * inducks_publicationurl create
   */
  export type inducks_publicationurlCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publicationurl
     */
    select?: inducks_publicationurlSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_publicationurl.
     */
    data: XOR<inducks_publicationurlCreateInput, inducks_publicationurlUncheckedCreateInput>
  }


  /**
   * inducks_publicationurl createMany
   */
  export type inducks_publicationurlCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_publicationurls.
     */
    data: inducks_publicationurlCreateManyInput | inducks_publicationurlCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_publicationurl update
   */
  export type inducks_publicationurlUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publicationurl
     */
    select?: inducks_publicationurlSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_publicationurl.
     */
    data: XOR<inducks_publicationurlUpdateInput, inducks_publicationurlUncheckedUpdateInput>
    /**
     * Choose, which inducks_publicationurl to update.
     */
    where: inducks_publicationurlWhereUniqueInput
  }


  /**
   * inducks_publicationurl updateMany
   */
  export type inducks_publicationurlUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_publicationurls.
     */
    data: XOR<inducks_publicationurlUpdateManyMutationInput, inducks_publicationurlUncheckedUpdateManyInput>
    /**
     * Filter which inducks_publicationurls to update
     */
    where?: inducks_publicationurlWhereInput
  }


  /**
   * inducks_publicationurl upsert
   */
  export type inducks_publicationurlUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publicationurl
     */
    select?: inducks_publicationurlSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_publicationurl to update in case it exists.
     */
    where: inducks_publicationurlWhereUniqueInput
    /**
     * In case the inducks_publicationurl found by the `where` argument doesn't exist, create a new inducks_publicationurl with this data.
     */
    create: XOR<inducks_publicationurlCreateInput, inducks_publicationurlUncheckedCreateInput>
    /**
     * In case the inducks_publicationurl was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_publicationurlUpdateInput, inducks_publicationurlUncheckedUpdateInput>
  }


  /**
   * inducks_publicationurl delete
   */
  export type inducks_publicationurlDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publicationurl
     */
    select?: inducks_publicationurlSelect<ExtArgs> | null
    /**
     * Filter which inducks_publicationurl to delete.
     */
    where: inducks_publicationurlWhereUniqueInput
  }


  /**
   * inducks_publicationurl deleteMany
   */
  export type inducks_publicationurlDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_publicationurls to delete
     */
    where?: inducks_publicationurlWhereInput
  }


  /**
   * inducks_publicationurl without action
   */
  export type inducks_publicationurlDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publicationurl
     */
    select?: inducks_publicationurlSelect<ExtArgs> | null
  }



  /**
   * Model inducks_publisher
   */

  export type AggregateInducks_publisher = {
    _count: Inducks_publisherCountAggregateOutputType | null
    _min: Inducks_publisherMinAggregateOutputType | null
    _max: Inducks_publisherMaxAggregateOutputType | null
  }

  export type Inducks_publisherMinAggregateOutputType = {
    publisherid: string | null
    publishername: string | null
  }

  export type Inducks_publisherMaxAggregateOutputType = {
    publisherid: string | null
    publishername: string | null
  }

  export type Inducks_publisherCountAggregateOutputType = {
    publisherid: number
    publishername: number
    _all: number
  }


  export type Inducks_publisherMinAggregateInputType = {
    publisherid?: true
    publishername?: true
  }

  export type Inducks_publisherMaxAggregateInputType = {
    publisherid?: true
    publishername?: true
  }

  export type Inducks_publisherCountAggregateInputType = {
    publisherid?: true
    publishername?: true
    _all?: true
  }

  export type Inducks_publisherAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_publisher to aggregate.
     */
    where?: inducks_publisherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_publishers to fetch.
     */
    orderBy?: inducks_publisherOrderByWithRelationInput | inducks_publisherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_publisherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_publishers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_publishers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_publishers
    **/
    _count?: true | Inducks_publisherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_publisherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_publisherMaxAggregateInputType
  }

  export type GetInducks_publisherAggregateType<T extends Inducks_publisherAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_publisher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_publisher[P]>
      : GetScalarType<T[P], AggregateInducks_publisher[P]>
  }




  export type inducks_publisherGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_publisherWhereInput
    orderBy?: inducks_publisherOrderByWithAggregationInput | inducks_publisherOrderByWithAggregationInput[]
    by: Inducks_publisherScalarFieldEnum[] | Inducks_publisherScalarFieldEnum
    having?: inducks_publisherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_publisherCountAggregateInputType | true
    _min?: Inducks_publisherMinAggregateInputType
    _max?: Inducks_publisherMaxAggregateInputType
  }

  export type Inducks_publisherGroupByOutputType = {
    publisherid: string
    publishername: string | null
    _count: Inducks_publisherCountAggregateOutputType | null
    _min: Inducks_publisherMinAggregateOutputType | null
    _max: Inducks_publisherMaxAggregateOutputType | null
  }

  type GetInducks_publisherGroupByPayload<T extends inducks_publisherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_publisherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_publisherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_publisherGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_publisherGroupByOutputType[P]>
        }
      >
    >


  export type inducks_publisherSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    publisherid?: boolean
    publishername?: boolean
  }, ExtArgs["result"]["inducks_publisher"]>

  export type inducks_publisherSelectScalar = {
    publisherid?: boolean
    publishername?: boolean
  }


  export type $inducks_publisherPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_publisher"
    objects: {}
    scalars: $Extensions.GetResult<{
      publisherid: string
      publishername: string | null
    }, ExtArgs["result"]["inducks_publisher"]>
    composites: {}
  }


  type inducks_publisherGetPayload<S extends boolean | null | undefined | inducks_publisherDefaultArgs> = $Result.GetResult<Prisma.$inducks_publisherPayload, S>

  type inducks_publisherCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_publisherFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_publisherCountAggregateInputType | true
    }

  export interface inducks_publisherDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_publisher'], meta: { name: 'inducks_publisher' } }
    /**
     * Find zero or one Inducks_publisher that matches the filter.
     * @param {inducks_publisherFindUniqueArgs} args - Arguments to find a Inducks_publisher
     * @example
     * // Get one Inducks_publisher
     * const inducks_publisher = await prisma.inducks_publisher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_publisherFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_publisherFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_publisherClient<$Result.GetResult<Prisma.$inducks_publisherPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_publisher that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_publisherFindUniqueOrThrowArgs} args - Arguments to find a Inducks_publisher
     * @example
     * // Get one Inducks_publisher
     * const inducks_publisher = await prisma.inducks_publisher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_publisherFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_publisherFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_publisherClient<$Result.GetResult<Prisma.$inducks_publisherPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_publisher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_publisherFindFirstArgs} args - Arguments to find a Inducks_publisher
     * @example
     * // Get one Inducks_publisher
     * const inducks_publisher = await prisma.inducks_publisher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_publisherFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_publisherFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_publisherClient<$Result.GetResult<Prisma.$inducks_publisherPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_publisher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_publisherFindFirstOrThrowArgs} args - Arguments to find a Inducks_publisher
     * @example
     * // Get one Inducks_publisher
     * const inducks_publisher = await prisma.inducks_publisher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_publisherFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_publisherFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_publisherClient<$Result.GetResult<Prisma.$inducks_publisherPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_publishers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_publisherFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_publishers
     * const inducks_publishers = await prisma.inducks_publisher.findMany()
     * 
     * // Get first 10 Inducks_publishers
     * const inducks_publishers = await prisma.inducks_publisher.findMany({ take: 10 })
     * 
     * // Only select the `publisherid`
     * const inducks_publisherWithPublisheridOnly = await prisma.inducks_publisher.findMany({ select: { publisherid: true } })
     * 
    **/
    findMany<T extends inducks_publisherFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_publisherFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_publisherPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_publisher.
     * @param {inducks_publisherCreateArgs} args - Arguments to create a Inducks_publisher.
     * @example
     * // Create one Inducks_publisher
     * const Inducks_publisher = await prisma.inducks_publisher.create({
     *   data: {
     *     // ... data to create a Inducks_publisher
     *   }
     * })
     * 
    **/
    create<T extends inducks_publisherCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_publisherCreateArgs<ExtArgs>>
    ): Prisma__inducks_publisherClient<$Result.GetResult<Prisma.$inducks_publisherPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_publishers.
     *     @param {inducks_publisherCreateManyArgs} args - Arguments to create many Inducks_publishers.
     *     @example
     *     // Create many Inducks_publishers
     *     const inducks_publisher = await prisma.inducks_publisher.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_publisherCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_publisherCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_publisher.
     * @param {inducks_publisherDeleteArgs} args - Arguments to delete one Inducks_publisher.
     * @example
     * // Delete one Inducks_publisher
     * const Inducks_publisher = await prisma.inducks_publisher.delete({
     *   where: {
     *     // ... filter to delete one Inducks_publisher
     *   }
     * })
     * 
    **/
    delete<T extends inducks_publisherDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_publisherDeleteArgs<ExtArgs>>
    ): Prisma__inducks_publisherClient<$Result.GetResult<Prisma.$inducks_publisherPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_publisher.
     * @param {inducks_publisherUpdateArgs} args - Arguments to update one Inducks_publisher.
     * @example
     * // Update one Inducks_publisher
     * const inducks_publisher = await prisma.inducks_publisher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_publisherUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_publisherUpdateArgs<ExtArgs>>
    ): Prisma__inducks_publisherClient<$Result.GetResult<Prisma.$inducks_publisherPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_publishers.
     * @param {inducks_publisherDeleteManyArgs} args - Arguments to filter Inducks_publishers to delete.
     * @example
     * // Delete a few Inducks_publishers
     * const { count } = await prisma.inducks_publisher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_publisherDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_publisherDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_publishers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_publisherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_publishers
     * const inducks_publisher = await prisma.inducks_publisher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_publisherUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_publisherUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_publisher.
     * @param {inducks_publisherUpsertArgs} args - Arguments to update or create a Inducks_publisher.
     * @example
     * // Update or create a Inducks_publisher
     * const inducks_publisher = await prisma.inducks_publisher.upsert({
     *   create: {
     *     // ... data to create a Inducks_publisher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_publisher we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_publisherUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_publisherUpsertArgs<ExtArgs>>
    ): Prisma__inducks_publisherClient<$Result.GetResult<Prisma.$inducks_publisherPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_publishers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_publisherCountArgs} args - Arguments to filter Inducks_publishers to count.
     * @example
     * // Count the number of Inducks_publishers
     * const count = await prisma.inducks_publisher.count({
     *   where: {
     *     // ... the filter for the Inducks_publishers we want to count
     *   }
     * })
    **/
    count<T extends inducks_publisherCountArgs>(
      args?: Subset<T, inducks_publisherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_publisherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_publisher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_publisherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_publisherAggregateArgs>(args: Subset<T, Inducks_publisherAggregateArgs>): Prisma.PrismaPromise<GetInducks_publisherAggregateType<T>>

    /**
     * Group by Inducks_publisher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_publisherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_publisherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_publisherGroupByArgs['orderBy'] }
        : { orderBy?: inducks_publisherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_publisherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_publisherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_publisher model
   */
  readonly fields: inducks_publisherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_publisher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_publisherClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_publisher model
   */ 
  interface inducks_publisherFieldRefs {
    readonly publisherid: FieldRef<"inducks_publisher", 'String'>
    readonly publishername: FieldRef<"inducks_publisher", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_publisher findUnique
   */
  export type inducks_publisherFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publisher
     */
    select?: inducks_publisherSelect<ExtArgs> | null
    /**
     * Filter, which inducks_publisher to fetch.
     */
    where: inducks_publisherWhereUniqueInput
  }


  /**
   * inducks_publisher findUniqueOrThrow
   */
  export type inducks_publisherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publisher
     */
    select?: inducks_publisherSelect<ExtArgs> | null
    /**
     * Filter, which inducks_publisher to fetch.
     */
    where: inducks_publisherWhereUniqueInput
  }


  /**
   * inducks_publisher findFirst
   */
  export type inducks_publisherFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publisher
     */
    select?: inducks_publisherSelect<ExtArgs> | null
    /**
     * Filter, which inducks_publisher to fetch.
     */
    where?: inducks_publisherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_publishers to fetch.
     */
    orderBy?: inducks_publisherOrderByWithRelationInput | inducks_publisherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_publishers.
     */
    cursor?: inducks_publisherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_publishers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_publishers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_publishers.
     */
    distinct?: Inducks_publisherScalarFieldEnum | Inducks_publisherScalarFieldEnum[]
  }


  /**
   * inducks_publisher findFirstOrThrow
   */
  export type inducks_publisherFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publisher
     */
    select?: inducks_publisherSelect<ExtArgs> | null
    /**
     * Filter, which inducks_publisher to fetch.
     */
    where?: inducks_publisherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_publishers to fetch.
     */
    orderBy?: inducks_publisherOrderByWithRelationInput | inducks_publisherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_publishers.
     */
    cursor?: inducks_publisherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_publishers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_publishers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_publishers.
     */
    distinct?: Inducks_publisherScalarFieldEnum | Inducks_publisherScalarFieldEnum[]
  }


  /**
   * inducks_publisher findMany
   */
  export type inducks_publisherFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publisher
     */
    select?: inducks_publisherSelect<ExtArgs> | null
    /**
     * Filter, which inducks_publishers to fetch.
     */
    where?: inducks_publisherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_publishers to fetch.
     */
    orderBy?: inducks_publisherOrderByWithRelationInput | inducks_publisherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_publishers.
     */
    cursor?: inducks_publisherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_publishers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_publishers.
     */
    skip?: number
    distinct?: Inducks_publisherScalarFieldEnum | Inducks_publisherScalarFieldEnum[]
  }


  /**
   * inducks_publisher create
   */
  export type inducks_publisherCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publisher
     */
    select?: inducks_publisherSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_publisher.
     */
    data: XOR<inducks_publisherCreateInput, inducks_publisherUncheckedCreateInput>
  }


  /**
   * inducks_publisher createMany
   */
  export type inducks_publisherCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_publishers.
     */
    data: inducks_publisherCreateManyInput | inducks_publisherCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_publisher update
   */
  export type inducks_publisherUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publisher
     */
    select?: inducks_publisherSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_publisher.
     */
    data: XOR<inducks_publisherUpdateInput, inducks_publisherUncheckedUpdateInput>
    /**
     * Choose, which inducks_publisher to update.
     */
    where: inducks_publisherWhereUniqueInput
  }


  /**
   * inducks_publisher updateMany
   */
  export type inducks_publisherUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_publishers.
     */
    data: XOR<inducks_publisherUpdateManyMutationInput, inducks_publisherUncheckedUpdateManyInput>
    /**
     * Filter which inducks_publishers to update
     */
    where?: inducks_publisherWhereInput
  }


  /**
   * inducks_publisher upsert
   */
  export type inducks_publisherUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publisher
     */
    select?: inducks_publisherSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_publisher to update in case it exists.
     */
    where: inducks_publisherWhereUniqueInput
    /**
     * In case the inducks_publisher found by the `where` argument doesn't exist, create a new inducks_publisher with this data.
     */
    create: XOR<inducks_publisherCreateInput, inducks_publisherUncheckedCreateInput>
    /**
     * In case the inducks_publisher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_publisherUpdateInput, inducks_publisherUncheckedUpdateInput>
  }


  /**
   * inducks_publisher delete
   */
  export type inducks_publisherDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publisher
     */
    select?: inducks_publisherSelect<ExtArgs> | null
    /**
     * Filter which inducks_publisher to delete.
     */
    where: inducks_publisherWhereUniqueInput
  }


  /**
   * inducks_publisher deleteMany
   */
  export type inducks_publisherDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_publishers to delete
     */
    where?: inducks_publisherWhereInput
  }


  /**
   * inducks_publisher without action
   */
  export type inducks_publisherDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publisher
     */
    select?: inducks_publisherSelect<ExtArgs> | null
  }



  /**
   * Model inducks_publishingjob
   */

  export type AggregateInducks_publishingjob = {
    _count: Inducks_publishingjobCountAggregateOutputType | null
    _min: Inducks_publishingjobMinAggregateOutputType | null
    _max: Inducks_publishingjobMaxAggregateOutputType | null
  }

  export type Inducks_publishingjobMinAggregateOutputType = {
    publisherid: string | null
    issuecode: string | null
    publishingjobcomment: string | null
  }

  export type Inducks_publishingjobMaxAggregateOutputType = {
    publisherid: string | null
    issuecode: string | null
    publishingjobcomment: string | null
  }

  export type Inducks_publishingjobCountAggregateOutputType = {
    publisherid: number
    issuecode: number
    publishingjobcomment: number
    _all: number
  }


  export type Inducks_publishingjobMinAggregateInputType = {
    publisherid?: true
    issuecode?: true
    publishingjobcomment?: true
  }

  export type Inducks_publishingjobMaxAggregateInputType = {
    publisherid?: true
    issuecode?: true
    publishingjobcomment?: true
  }

  export type Inducks_publishingjobCountAggregateInputType = {
    publisherid?: true
    issuecode?: true
    publishingjobcomment?: true
    _all?: true
  }

  export type Inducks_publishingjobAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_publishingjob to aggregate.
     */
    where?: inducks_publishingjobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_publishingjobs to fetch.
     */
    orderBy?: inducks_publishingjobOrderByWithRelationInput | inducks_publishingjobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_publishingjobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_publishingjobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_publishingjobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_publishingjobs
    **/
    _count?: true | Inducks_publishingjobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_publishingjobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_publishingjobMaxAggregateInputType
  }

  export type GetInducks_publishingjobAggregateType<T extends Inducks_publishingjobAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_publishingjob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_publishingjob[P]>
      : GetScalarType<T[P], AggregateInducks_publishingjob[P]>
  }




  export type inducks_publishingjobGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_publishingjobWhereInput
    orderBy?: inducks_publishingjobOrderByWithAggregationInput | inducks_publishingjobOrderByWithAggregationInput[]
    by: Inducks_publishingjobScalarFieldEnum[] | Inducks_publishingjobScalarFieldEnum
    having?: inducks_publishingjobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_publishingjobCountAggregateInputType | true
    _min?: Inducks_publishingjobMinAggregateInputType
    _max?: Inducks_publishingjobMaxAggregateInputType
  }

  export type Inducks_publishingjobGroupByOutputType = {
    publisherid: string
    issuecode: string
    publishingjobcomment: string | null
    _count: Inducks_publishingjobCountAggregateOutputType | null
    _min: Inducks_publishingjobMinAggregateOutputType | null
    _max: Inducks_publishingjobMaxAggregateOutputType | null
  }

  type GetInducks_publishingjobGroupByPayload<T extends inducks_publishingjobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_publishingjobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_publishingjobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_publishingjobGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_publishingjobGroupByOutputType[P]>
        }
      >
    >


  export type inducks_publishingjobSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    publisherid?: boolean
    issuecode?: boolean
    publishingjobcomment?: boolean
  }, ExtArgs["result"]["inducks_publishingjob"]>

  export type inducks_publishingjobSelectScalar = {
    publisherid?: boolean
    issuecode?: boolean
    publishingjobcomment?: boolean
  }


  export type $inducks_publishingjobPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_publishingjob"
    objects: {}
    scalars: $Extensions.GetResult<{
      publisherid: string
      issuecode: string
      publishingjobcomment: string | null
    }, ExtArgs["result"]["inducks_publishingjob"]>
    composites: {}
  }


  type inducks_publishingjobGetPayload<S extends boolean | null | undefined | inducks_publishingjobDefaultArgs> = $Result.GetResult<Prisma.$inducks_publishingjobPayload, S>

  type inducks_publishingjobCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_publishingjobFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_publishingjobCountAggregateInputType | true
    }

  export interface inducks_publishingjobDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_publishingjob'], meta: { name: 'inducks_publishingjob' } }
    /**
     * Find zero or one Inducks_publishingjob that matches the filter.
     * @param {inducks_publishingjobFindUniqueArgs} args - Arguments to find a Inducks_publishingjob
     * @example
     * // Get one Inducks_publishingjob
     * const inducks_publishingjob = await prisma.inducks_publishingjob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_publishingjobFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_publishingjobFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_publishingjobClient<$Result.GetResult<Prisma.$inducks_publishingjobPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_publishingjob that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_publishingjobFindUniqueOrThrowArgs} args - Arguments to find a Inducks_publishingjob
     * @example
     * // Get one Inducks_publishingjob
     * const inducks_publishingjob = await prisma.inducks_publishingjob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_publishingjobFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_publishingjobFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_publishingjobClient<$Result.GetResult<Prisma.$inducks_publishingjobPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_publishingjob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_publishingjobFindFirstArgs} args - Arguments to find a Inducks_publishingjob
     * @example
     * // Get one Inducks_publishingjob
     * const inducks_publishingjob = await prisma.inducks_publishingjob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_publishingjobFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_publishingjobFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_publishingjobClient<$Result.GetResult<Prisma.$inducks_publishingjobPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_publishingjob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_publishingjobFindFirstOrThrowArgs} args - Arguments to find a Inducks_publishingjob
     * @example
     * // Get one Inducks_publishingjob
     * const inducks_publishingjob = await prisma.inducks_publishingjob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_publishingjobFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_publishingjobFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_publishingjobClient<$Result.GetResult<Prisma.$inducks_publishingjobPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_publishingjobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_publishingjobFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_publishingjobs
     * const inducks_publishingjobs = await prisma.inducks_publishingjob.findMany()
     * 
     * // Get first 10 Inducks_publishingjobs
     * const inducks_publishingjobs = await prisma.inducks_publishingjob.findMany({ take: 10 })
     * 
     * // Only select the `publisherid`
     * const inducks_publishingjobWithPublisheridOnly = await prisma.inducks_publishingjob.findMany({ select: { publisherid: true } })
     * 
    **/
    findMany<T extends inducks_publishingjobFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_publishingjobFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_publishingjobPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_publishingjob.
     * @param {inducks_publishingjobCreateArgs} args - Arguments to create a Inducks_publishingjob.
     * @example
     * // Create one Inducks_publishingjob
     * const Inducks_publishingjob = await prisma.inducks_publishingjob.create({
     *   data: {
     *     // ... data to create a Inducks_publishingjob
     *   }
     * })
     * 
    **/
    create<T extends inducks_publishingjobCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_publishingjobCreateArgs<ExtArgs>>
    ): Prisma__inducks_publishingjobClient<$Result.GetResult<Prisma.$inducks_publishingjobPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_publishingjobs.
     *     @param {inducks_publishingjobCreateManyArgs} args - Arguments to create many Inducks_publishingjobs.
     *     @example
     *     // Create many Inducks_publishingjobs
     *     const inducks_publishingjob = await prisma.inducks_publishingjob.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_publishingjobCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_publishingjobCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_publishingjob.
     * @param {inducks_publishingjobDeleteArgs} args - Arguments to delete one Inducks_publishingjob.
     * @example
     * // Delete one Inducks_publishingjob
     * const Inducks_publishingjob = await prisma.inducks_publishingjob.delete({
     *   where: {
     *     // ... filter to delete one Inducks_publishingjob
     *   }
     * })
     * 
    **/
    delete<T extends inducks_publishingjobDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_publishingjobDeleteArgs<ExtArgs>>
    ): Prisma__inducks_publishingjobClient<$Result.GetResult<Prisma.$inducks_publishingjobPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_publishingjob.
     * @param {inducks_publishingjobUpdateArgs} args - Arguments to update one Inducks_publishingjob.
     * @example
     * // Update one Inducks_publishingjob
     * const inducks_publishingjob = await prisma.inducks_publishingjob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_publishingjobUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_publishingjobUpdateArgs<ExtArgs>>
    ): Prisma__inducks_publishingjobClient<$Result.GetResult<Prisma.$inducks_publishingjobPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_publishingjobs.
     * @param {inducks_publishingjobDeleteManyArgs} args - Arguments to filter Inducks_publishingjobs to delete.
     * @example
     * // Delete a few Inducks_publishingjobs
     * const { count } = await prisma.inducks_publishingjob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_publishingjobDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_publishingjobDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_publishingjobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_publishingjobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_publishingjobs
     * const inducks_publishingjob = await prisma.inducks_publishingjob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_publishingjobUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_publishingjobUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_publishingjob.
     * @param {inducks_publishingjobUpsertArgs} args - Arguments to update or create a Inducks_publishingjob.
     * @example
     * // Update or create a Inducks_publishingjob
     * const inducks_publishingjob = await prisma.inducks_publishingjob.upsert({
     *   create: {
     *     // ... data to create a Inducks_publishingjob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_publishingjob we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_publishingjobUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_publishingjobUpsertArgs<ExtArgs>>
    ): Prisma__inducks_publishingjobClient<$Result.GetResult<Prisma.$inducks_publishingjobPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_publishingjobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_publishingjobCountArgs} args - Arguments to filter Inducks_publishingjobs to count.
     * @example
     * // Count the number of Inducks_publishingjobs
     * const count = await prisma.inducks_publishingjob.count({
     *   where: {
     *     // ... the filter for the Inducks_publishingjobs we want to count
     *   }
     * })
    **/
    count<T extends inducks_publishingjobCountArgs>(
      args?: Subset<T, inducks_publishingjobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_publishingjobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_publishingjob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_publishingjobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_publishingjobAggregateArgs>(args: Subset<T, Inducks_publishingjobAggregateArgs>): Prisma.PrismaPromise<GetInducks_publishingjobAggregateType<T>>

    /**
     * Group by Inducks_publishingjob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_publishingjobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_publishingjobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_publishingjobGroupByArgs['orderBy'] }
        : { orderBy?: inducks_publishingjobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_publishingjobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_publishingjobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_publishingjob model
   */
  readonly fields: inducks_publishingjobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_publishingjob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_publishingjobClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_publishingjob model
   */ 
  interface inducks_publishingjobFieldRefs {
    readonly publisherid: FieldRef<"inducks_publishingjob", 'String'>
    readonly issuecode: FieldRef<"inducks_publishingjob", 'String'>
    readonly publishingjobcomment: FieldRef<"inducks_publishingjob", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_publishingjob findUnique
   */
  export type inducks_publishingjobFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publishingjob
     */
    select?: inducks_publishingjobSelect<ExtArgs> | null
    /**
     * Filter, which inducks_publishingjob to fetch.
     */
    where: inducks_publishingjobWhereUniqueInput
  }


  /**
   * inducks_publishingjob findUniqueOrThrow
   */
  export type inducks_publishingjobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publishingjob
     */
    select?: inducks_publishingjobSelect<ExtArgs> | null
    /**
     * Filter, which inducks_publishingjob to fetch.
     */
    where: inducks_publishingjobWhereUniqueInput
  }


  /**
   * inducks_publishingjob findFirst
   */
  export type inducks_publishingjobFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publishingjob
     */
    select?: inducks_publishingjobSelect<ExtArgs> | null
    /**
     * Filter, which inducks_publishingjob to fetch.
     */
    where?: inducks_publishingjobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_publishingjobs to fetch.
     */
    orderBy?: inducks_publishingjobOrderByWithRelationInput | inducks_publishingjobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_publishingjobs.
     */
    cursor?: inducks_publishingjobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_publishingjobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_publishingjobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_publishingjobs.
     */
    distinct?: Inducks_publishingjobScalarFieldEnum | Inducks_publishingjobScalarFieldEnum[]
  }


  /**
   * inducks_publishingjob findFirstOrThrow
   */
  export type inducks_publishingjobFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publishingjob
     */
    select?: inducks_publishingjobSelect<ExtArgs> | null
    /**
     * Filter, which inducks_publishingjob to fetch.
     */
    where?: inducks_publishingjobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_publishingjobs to fetch.
     */
    orderBy?: inducks_publishingjobOrderByWithRelationInput | inducks_publishingjobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_publishingjobs.
     */
    cursor?: inducks_publishingjobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_publishingjobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_publishingjobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_publishingjobs.
     */
    distinct?: Inducks_publishingjobScalarFieldEnum | Inducks_publishingjobScalarFieldEnum[]
  }


  /**
   * inducks_publishingjob findMany
   */
  export type inducks_publishingjobFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publishingjob
     */
    select?: inducks_publishingjobSelect<ExtArgs> | null
    /**
     * Filter, which inducks_publishingjobs to fetch.
     */
    where?: inducks_publishingjobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_publishingjobs to fetch.
     */
    orderBy?: inducks_publishingjobOrderByWithRelationInput | inducks_publishingjobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_publishingjobs.
     */
    cursor?: inducks_publishingjobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_publishingjobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_publishingjobs.
     */
    skip?: number
    distinct?: Inducks_publishingjobScalarFieldEnum | Inducks_publishingjobScalarFieldEnum[]
  }


  /**
   * inducks_publishingjob create
   */
  export type inducks_publishingjobCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publishingjob
     */
    select?: inducks_publishingjobSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_publishingjob.
     */
    data: XOR<inducks_publishingjobCreateInput, inducks_publishingjobUncheckedCreateInput>
  }


  /**
   * inducks_publishingjob createMany
   */
  export type inducks_publishingjobCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_publishingjobs.
     */
    data: inducks_publishingjobCreateManyInput | inducks_publishingjobCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_publishingjob update
   */
  export type inducks_publishingjobUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publishingjob
     */
    select?: inducks_publishingjobSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_publishingjob.
     */
    data: XOR<inducks_publishingjobUpdateInput, inducks_publishingjobUncheckedUpdateInput>
    /**
     * Choose, which inducks_publishingjob to update.
     */
    where: inducks_publishingjobWhereUniqueInput
  }


  /**
   * inducks_publishingjob updateMany
   */
  export type inducks_publishingjobUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_publishingjobs.
     */
    data: XOR<inducks_publishingjobUpdateManyMutationInput, inducks_publishingjobUncheckedUpdateManyInput>
    /**
     * Filter which inducks_publishingjobs to update
     */
    where?: inducks_publishingjobWhereInput
  }


  /**
   * inducks_publishingjob upsert
   */
  export type inducks_publishingjobUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publishingjob
     */
    select?: inducks_publishingjobSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_publishingjob to update in case it exists.
     */
    where: inducks_publishingjobWhereUniqueInput
    /**
     * In case the inducks_publishingjob found by the `where` argument doesn't exist, create a new inducks_publishingjob with this data.
     */
    create: XOR<inducks_publishingjobCreateInput, inducks_publishingjobUncheckedCreateInput>
    /**
     * In case the inducks_publishingjob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_publishingjobUpdateInput, inducks_publishingjobUncheckedUpdateInput>
  }


  /**
   * inducks_publishingjob delete
   */
  export type inducks_publishingjobDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publishingjob
     */
    select?: inducks_publishingjobSelect<ExtArgs> | null
    /**
     * Filter which inducks_publishingjob to delete.
     */
    where: inducks_publishingjobWhereUniqueInput
  }


  /**
   * inducks_publishingjob deleteMany
   */
  export type inducks_publishingjobDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_publishingjobs to delete
     */
    where?: inducks_publishingjobWhereInput
  }


  /**
   * inducks_publishingjob without action
   */
  export type inducks_publishingjobDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_publishingjob
     */
    select?: inducks_publishingjobSelect<ExtArgs> | null
  }



  /**
   * Model inducks_referencereason
   */

  export type AggregateInducks_referencereason = {
    _count: Inducks_referencereasonCountAggregateOutputType | null
    _avg: Inducks_referencereasonAvgAggregateOutputType | null
    _sum: Inducks_referencereasonSumAggregateOutputType | null
    _min: Inducks_referencereasonMinAggregateOutputType | null
    _max: Inducks_referencereasonMaxAggregateOutputType | null
  }

  export type Inducks_referencereasonAvgAggregateOutputType = {
    referencereasonid: number | null
  }

  export type Inducks_referencereasonSumAggregateOutputType = {
    referencereasonid: number | null
  }

  export type Inducks_referencereasonMinAggregateOutputType = {
    referencereasonid: number | null
    referencereasontext: string | null
  }

  export type Inducks_referencereasonMaxAggregateOutputType = {
    referencereasonid: number | null
    referencereasontext: string | null
  }

  export type Inducks_referencereasonCountAggregateOutputType = {
    referencereasonid: number
    referencereasontext: number
    _all: number
  }


  export type Inducks_referencereasonAvgAggregateInputType = {
    referencereasonid?: true
  }

  export type Inducks_referencereasonSumAggregateInputType = {
    referencereasonid?: true
  }

  export type Inducks_referencereasonMinAggregateInputType = {
    referencereasonid?: true
    referencereasontext?: true
  }

  export type Inducks_referencereasonMaxAggregateInputType = {
    referencereasonid?: true
    referencereasontext?: true
  }

  export type Inducks_referencereasonCountAggregateInputType = {
    referencereasonid?: true
    referencereasontext?: true
    _all?: true
  }

  export type Inducks_referencereasonAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_referencereason to aggregate.
     */
    where?: inducks_referencereasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_referencereasons to fetch.
     */
    orderBy?: inducks_referencereasonOrderByWithRelationInput | inducks_referencereasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_referencereasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_referencereasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_referencereasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_referencereasons
    **/
    _count?: true | Inducks_referencereasonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Inducks_referencereasonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Inducks_referencereasonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_referencereasonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_referencereasonMaxAggregateInputType
  }

  export type GetInducks_referencereasonAggregateType<T extends Inducks_referencereasonAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_referencereason]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_referencereason[P]>
      : GetScalarType<T[P], AggregateInducks_referencereason[P]>
  }




  export type inducks_referencereasonGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_referencereasonWhereInput
    orderBy?: inducks_referencereasonOrderByWithAggregationInput | inducks_referencereasonOrderByWithAggregationInput[]
    by: Inducks_referencereasonScalarFieldEnum[] | Inducks_referencereasonScalarFieldEnum
    having?: inducks_referencereasonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_referencereasonCountAggregateInputType | true
    _avg?: Inducks_referencereasonAvgAggregateInputType
    _sum?: Inducks_referencereasonSumAggregateInputType
    _min?: Inducks_referencereasonMinAggregateInputType
    _max?: Inducks_referencereasonMaxAggregateInputType
  }

  export type Inducks_referencereasonGroupByOutputType = {
    referencereasonid: number
    referencereasontext: string | null
    _count: Inducks_referencereasonCountAggregateOutputType | null
    _avg: Inducks_referencereasonAvgAggregateOutputType | null
    _sum: Inducks_referencereasonSumAggregateOutputType | null
    _min: Inducks_referencereasonMinAggregateOutputType | null
    _max: Inducks_referencereasonMaxAggregateOutputType | null
  }

  type GetInducks_referencereasonGroupByPayload<T extends inducks_referencereasonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_referencereasonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_referencereasonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_referencereasonGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_referencereasonGroupByOutputType[P]>
        }
      >
    >


  export type inducks_referencereasonSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    referencereasonid?: boolean
    referencereasontext?: boolean
  }, ExtArgs["result"]["inducks_referencereason"]>

  export type inducks_referencereasonSelectScalar = {
    referencereasonid?: boolean
    referencereasontext?: boolean
  }


  export type $inducks_referencereasonPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_referencereason"
    objects: {}
    scalars: $Extensions.GetResult<{
      referencereasonid: number
      referencereasontext: string | null
    }, ExtArgs["result"]["inducks_referencereason"]>
    composites: {}
  }


  type inducks_referencereasonGetPayload<S extends boolean | null | undefined | inducks_referencereasonDefaultArgs> = $Result.GetResult<Prisma.$inducks_referencereasonPayload, S>

  type inducks_referencereasonCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_referencereasonFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_referencereasonCountAggregateInputType | true
    }

  export interface inducks_referencereasonDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_referencereason'], meta: { name: 'inducks_referencereason' } }
    /**
     * Find zero or one Inducks_referencereason that matches the filter.
     * @param {inducks_referencereasonFindUniqueArgs} args - Arguments to find a Inducks_referencereason
     * @example
     * // Get one Inducks_referencereason
     * const inducks_referencereason = await prisma.inducks_referencereason.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_referencereasonFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_referencereasonFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_referencereasonClient<$Result.GetResult<Prisma.$inducks_referencereasonPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_referencereason that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_referencereasonFindUniqueOrThrowArgs} args - Arguments to find a Inducks_referencereason
     * @example
     * // Get one Inducks_referencereason
     * const inducks_referencereason = await prisma.inducks_referencereason.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_referencereasonFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_referencereasonFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_referencereasonClient<$Result.GetResult<Prisma.$inducks_referencereasonPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_referencereason that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_referencereasonFindFirstArgs} args - Arguments to find a Inducks_referencereason
     * @example
     * // Get one Inducks_referencereason
     * const inducks_referencereason = await prisma.inducks_referencereason.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_referencereasonFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_referencereasonFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_referencereasonClient<$Result.GetResult<Prisma.$inducks_referencereasonPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_referencereason that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_referencereasonFindFirstOrThrowArgs} args - Arguments to find a Inducks_referencereason
     * @example
     * // Get one Inducks_referencereason
     * const inducks_referencereason = await prisma.inducks_referencereason.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_referencereasonFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_referencereasonFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_referencereasonClient<$Result.GetResult<Prisma.$inducks_referencereasonPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_referencereasons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_referencereasonFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_referencereasons
     * const inducks_referencereasons = await prisma.inducks_referencereason.findMany()
     * 
     * // Get first 10 Inducks_referencereasons
     * const inducks_referencereasons = await prisma.inducks_referencereason.findMany({ take: 10 })
     * 
     * // Only select the `referencereasonid`
     * const inducks_referencereasonWithReferencereasonidOnly = await prisma.inducks_referencereason.findMany({ select: { referencereasonid: true } })
     * 
    **/
    findMany<T extends inducks_referencereasonFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_referencereasonFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_referencereasonPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_referencereason.
     * @param {inducks_referencereasonCreateArgs} args - Arguments to create a Inducks_referencereason.
     * @example
     * // Create one Inducks_referencereason
     * const Inducks_referencereason = await prisma.inducks_referencereason.create({
     *   data: {
     *     // ... data to create a Inducks_referencereason
     *   }
     * })
     * 
    **/
    create<T extends inducks_referencereasonCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_referencereasonCreateArgs<ExtArgs>>
    ): Prisma__inducks_referencereasonClient<$Result.GetResult<Prisma.$inducks_referencereasonPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_referencereasons.
     *     @param {inducks_referencereasonCreateManyArgs} args - Arguments to create many Inducks_referencereasons.
     *     @example
     *     // Create many Inducks_referencereasons
     *     const inducks_referencereason = await prisma.inducks_referencereason.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_referencereasonCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_referencereasonCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_referencereason.
     * @param {inducks_referencereasonDeleteArgs} args - Arguments to delete one Inducks_referencereason.
     * @example
     * // Delete one Inducks_referencereason
     * const Inducks_referencereason = await prisma.inducks_referencereason.delete({
     *   where: {
     *     // ... filter to delete one Inducks_referencereason
     *   }
     * })
     * 
    **/
    delete<T extends inducks_referencereasonDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_referencereasonDeleteArgs<ExtArgs>>
    ): Prisma__inducks_referencereasonClient<$Result.GetResult<Prisma.$inducks_referencereasonPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_referencereason.
     * @param {inducks_referencereasonUpdateArgs} args - Arguments to update one Inducks_referencereason.
     * @example
     * // Update one Inducks_referencereason
     * const inducks_referencereason = await prisma.inducks_referencereason.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_referencereasonUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_referencereasonUpdateArgs<ExtArgs>>
    ): Prisma__inducks_referencereasonClient<$Result.GetResult<Prisma.$inducks_referencereasonPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_referencereasons.
     * @param {inducks_referencereasonDeleteManyArgs} args - Arguments to filter Inducks_referencereasons to delete.
     * @example
     * // Delete a few Inducks_referencereasons
     * const { count } = await prisma.inducks_referencereason.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_referencereasonDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_referencereasonDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_referencereasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_referencereasonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_referencereasons
     * const inducks_referencereason = await prisma.inducks_referencereason.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_referencereasonUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_referencereasonUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_referencereason.
     * @param {inducks_referencereasonUpsertArgs} args - Arguments to update or create a Inducks_referencereason.
     * @example
     * // Update or create a Inducks_referencereason
     * const inducks_referencereason = await prisma.inducks_referencereason.upsert({
     *   create: {
     *     // ... data to create a Inducks_referencereason
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_referencereason we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_referencereasonUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_referencereasonUpsertArgs<ExtArgs>>
    ): Prisma__inducks_referencereasonClient<$Result.GetResult<Prisma.$inducks_referencereasonPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_referencereasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_referencereasonCountArgs} args - Arguments to filter Inducks_referencereasons to count.
     * @example
     * // Count the number of Inducks_referencereasons
     * const count = await prisma.inducks_referencereason.count({
     *   where: {
     *     // ... the filter for the Inducks_referencereasons we want to count
     *   }
     * })
    **/
    count<T extends inducks_referencereasonCountArgs>(
      args?: Subset<T, inducks_referencereasonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_referencereasonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_referencereason.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_referencereasonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_referencereasonAggregateArgs>(args: Subset<T, Inducks_referencereasonAggregateArgs>): Prisma.PrismaPromise<GetInducks_referencereasonAggregateType<T>>

    /**
     * Group by Inducks_referencereason.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_referencereasonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_referencereasonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_referencereasonGroupByArgs['orderBy'] }
        : { orderBy?: inducks_referencereasonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_referencereasonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_referencereasonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_referencereason model
   */
  readonly fields: inducks_referencereasonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_referencereason.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_referencereasonClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_referencereason model
   */ 
  interface inducks_referencereasonFieldRefs {
    readonly referencereasonid: FieldRef<"inducks_referencereason", 'Int'>
    readonly referencereasontext: FieldRef<"inducks_referencereason", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_referencereason findUnique
   */
  export type inducks_referencereasonFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_referencereason
     */
    select?: inducks_referencereasonSelect<ExtArgs> | null
    /**
     * Filter, which inducks_referencereason to fetch.
     */
    where: inducks_referencereasonWhereUniqueInput
  }


  /**
   * inducks_referencereason findUniqueOrThrow
   */
  export type inducks_referencereasonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_referencereason
     */
    select?: inducks_referencereasonSelect<ExtArgs> | null
    /**
     * Filter, which inducks_referencereason to fetch.
     */
    where: inducks_referencereasonWhereUniqueInput
  }


  /**
   * inducks_referencereason findFirst
   */
  export type inducks_referencereasonFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_referencereason
     */
    select?: inducks_referencereasonSelect<ExtArgs> | null
    /**
     * Filter, which inducks_referencereason to fetch.
     */
    where?: inducks_referencereasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_referencereasons to fetch.
     */
    orderBy?: inducks_referencereasonOrderByWithRelationInput | inducks_referencereasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_referencereasons.
     */
    cursor?: inducks_referencereasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_referencereasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_referencereasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_referencereasons.
     */
    distinct?: Inducks_referencereasonScalarFieldEnum | Inducks_referencereasonScalarFieldEnum[]
  }


  /**
   * inducks_referencereason findFirstOrThrow
   */
  export type inducks_referencereasonFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_referencereason
     */
    select?: inducks_referencereasonSelect<ExtArgs> | null
    /**
     * Filter, which inducks_referencereason to fetch.
     */
    where?: inducks_referencereasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_referencereasons to fetch.
     */
    orderBy?: inducks_referencereasonOrderByWithRelationInput | inducks_referencereasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_referencereasons.
     */
    cursor?: inducks_referencereasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_referencereasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_referencereasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_referencereasons.
     */
    distinct?: Inducks_referencereasonScalarFieldEnum | Inducks_referencereasonScalarFieldEnum[]
  }


  /**
   * inducks_referencereason findMany
   */
  export type inducks_referencereasonFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_referencereason
     */
    select?: inducks_referencereasonSelect<ExtArgs> | null
    /**
     * Filter, which inducks_referencereasons to fetch.
     */
    where?: inducks_referencereasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_referencereasons to fetch.
     */
    orderBy?: inducks_referencereasonOrderByWithRelationInput | inducks_referencereasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_referencereasons.
     */
    cursor?: inducks_referencereasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_referencereasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_referencereasons.
     */
    skip?: number
    distinct?: Inducks_referencereasonScalarFieldEnum | Inducks_referencereasonScalarFieldEnum[]
  }


  /**
   * inducks_referencereason create
   */
  export type inducks_referencereasonCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_referencereason
     */
    select?: inducks_referencereasonSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_referencereason.
     */
    data: XOR<inducks_referencereasonCreateInput, inducks_referencereasonUncheckedCreateInput>
  }


  /**
   * inducks_referencereason createMany
   */
  export type inducks_referencereasonCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_referencereasons.
     */
    data: inducks_referencereasonCreateManyInput | inducks_referencereasonCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_referencereason update
   */
  export type inducks_referencereasonUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_referencereason
     */
    select?: inducks_referencereasonSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_referencereason.
     */
    data: XOR<inducks_referencereasonUpdateInput, inducks_referencereasonUncheckedUpdateInput>
    /**
     * Choose, which inducks_referencereason to update.
     */
    where: inducks_referencereasonWhereUniqueInput
  }


  /**
   * inducks_referencereason updateMany
   */
  export type inducks_referencereasonUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_referencereasons.
     */
    data: XOR<inducks_referencereasonUpdateManyMutationInput, inducks_referencereasonUncheckedUpdateManyInput>
    /**
     * Filter which inducks_referencereasons to update
     */
    where?: inducks_referencereasonWhereInput
  }


  /**
   * inducks_referencereason upsert
   */
  export type inducks_referencereasonUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_referencereason
     */
    select?: inducks_referencereasonSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_referencereason to update in case it exists.
     */
    where: inducks_referencereasonWhereUniqueInput
    /**
     * In case the inducks_referencereason found by the `where` argument doesn't exist, create a new inducks_referencereason with this data.
     */
    create: XOR<inducks_referencereasonCreateInput, inducks_referencereasonUncheckedCreateInput>
    /**
     * In case the inducks_referencereason was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_referencereasonUpdateInput, inducks_referencereasonUncheckedUpdateInput>
  }


  /**
   * inducks_referencereason delete
   */
  export type inducks_referencereasonDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_referencereason
     */
    select?: inducks_referencereasonSelect<ExtArgs> | null
    /**
     * Filter which inducks_referencereason to delete.
     */
    where: inducks_referencereasonWhereUniqueInput
  }


  /**
   * inducks_referencereason deleteMany
   */
  export type inducks_referencereasonDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_referencereasons to delete
     */
    where?: inducks_referencereasonWhereInput
  }


  /**
   * inducks_referencereason without action
   */
  export type inducks_referencereasonDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_referencereason
     */
    select?: inducks_referencereasonSelect<ExtArgs> | null
  }



  /**
   * Model inducks_referencereasonname
   */

  export type AggregateInducks_referencereasonname = {
    _count: Inducks_referencereasonnameCountAggregateOutputType | null
    _avg: Inducks_referencereasonnameAvgAggregateOutputType | null
    _sum: Inducks_referencereasonnameSumAggregateOutputType | null
    _min: Inducks_referencereasonnameMinAggregateOutputType | null
    _max: Inducks_referencereasonnameMaxAggregateOutputType | null
  }

  export type Inducks_referencereasonnameAvgAggregateOutputType = {
    referencereasonid: number | null
  }

  export type Inducks_referencereasonnameSumAggregateOutputType = {
    referencereasonid: number | null
  }

  export type Inducks_referencereasonnameMinAggregateOutputType = {
    referencereasonid: number | null
    languagecode: string | null
    referencereasontranslation: string | null
  }

  export type Inducks_referencereasonnameMaxAggregateOutputType = {
    referencereasonid: number | null
    languagecode: string | null
    referencereasontranslation: string | null
  }

  export type Inducks_referencereasonnameCountAggregateOutputType = {
    referencereasonid: number
    languagecode: number
    referencereasontranslation: number
    _all: number
  }


  export type Inducks_referencereasonnameAvgAggregateInputType = {
    referencereasonid?: true
  }

  export type Inducks_referencereasonnameSumAggregateInputType = {
    referencereasonid?: true
  }

  export type Inducks_referencereasonnameMinAggregateInputType = {
    referencereasonid?: true
    languagecode?: true
    referencereasontranslation?: true
  }

  export type Inducks_referencereasonnameMaxAggregateInputType = {
    referencereasonid?: true
    languagecode?: true
    referencereasontranslation?: true
  }

  export type Inducks_referencereasonnameCountAggregateInputType = {
    referencereasonid?: true
    languagecode?: true
    referencereasontranslation?: true
    _all?: true
  }

  export type Inducks_referencereasonnameAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_referencereasonname to aggregate.
     */
    where?: inducks_referencereasonnameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_referencereasonnames to fetch.
     */
    orderBy?: inducks_referencereasonnameOrderByWithRelationInput | inducks_referencereasonnameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_referencereasonnameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_referencereasonnames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_referencereasonnames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_referencereasonnames
    **/
    _count?: true | Inducks_referencereasonnameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Inducks_referencereasonnameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Inducks_referencereasonnameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_referencereasonnameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_referencereasonnameMaxAggregateInputType
  }

  export type GetInducks_referencereasonnameAggregateType<T extends Inducks_referencereasonnameAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_referencereasonname]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_referencereasonname[P]>
      : GetScalarType<T[P], AggregateInducks_referencereasonname[P]>
  }




  export type inducks_referencereasonnameGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_referencereasonnameWhereInput
    orderBy?: inducks_referencereasonnameOrderByWithAggregationInput | inducks_referencereasonnameOrderByWithAggregationInput[]
    by: Inducks_referencereasonnameScalarFieldEnum[] | Inducks_referencereasonnameScalarFieldEnum
    having?: inducks_referencereasonnameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_referencereasonnameCountAggregateInputType | true
    _avg?: Inducks_referencereasonnameAvgAggregateInputType
    _sum?: Inducks_referencereasonnameSumAggregateInputType
    _min?: Inducks_referencereasonnameMinAggregateInputType
    _max?: Inducks_referencereasonnameMaxAggregateInputType
  }

  export type Inducks_referencereasonnameGroupByOutputType = {
    referencereasonid: number
    languagecode: string
    referencereasontranslation: string | null
    _count: Inducks_referencereasonnameCountAggregateOutputType | null
    _avg: Inducks_referencereasonnameAvgAggregateOutputType | null
    _sum: Inducks_referencereasonnameSumAggregateOutputType | null
    _min: Inducks_referencereasonnameMinAggregateOutputType | null
    _max: Inducks_referencereasonnameMaxAggregateOutputType | null
  }

  type GetInducks_referencereasonnameGroupByPayload<T extends inducks_referencereasonnameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_referencereasonnameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_referencereasonnameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_referencereasonnameGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_referencereasonnameGroupByOutputType[P]>
        }
      >
    >


  export type inducks_referencereasonnameSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    referencereasonid?: boolean
    languagecode?: boolean
    referencereasontranslation?: boolean
  }, ExtArgs["result"]["inducks_referencereasonname"]>

  export type inducks_referencereasonnameSelectScalar = {
    referencereasonid?: boolean
    languagecode?: boolean
    referencereasontranslation?: boolean
  }


  export type $inducks_referencereasonnamePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_referencereasonname"
    objects: {}
    scalars: $Extensions.GetResult<{
      referencereasonid: number
      languagecode: string
      referencereasontranslation: string | null
    }, ExtArgs["result"]["inducks_referencereasonname"]>
    composites: {}
  }


  type inducks_referencereasonnameGetPayload<S extends boolean | null | undefined | inducks_referencereasonnameDefaultArgs> = $Result.GetResult<Prisma.$inducks_referencereasonnamePayload, S>

  type inducks_referencereasonnameCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_referencereasonnameFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_referencereasonnameCountAggregateInputType | true
    }

  export interface inducks_referencereasonnameDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_referencereasonname'], meta: { name: 'inducks_referencereasonname' } }
    /**
     * Find zero or one Inducks_referencereasonname that matches the filter.
     * @param {inducks_referencereasonnameFindUniqueArgs} args - Arguments to find a Inducks_referencereasonname
     * @example
     * // Get one Inducks_referencereasonname
     * const inducks_referencereasonname = await prisma.inducks_referencereasonname.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_referencereasonnameFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_referencereasonnameFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_referencereasonnameClient<$Result.GetResult<Prisma.$inducks_referencereasonnamePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_referencereasonname that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_referencereasonnameFindUniqueOrThrowArgs} args - Arguments to find a Inducks_referencereasonname
     * @example
     * // Get one Inducks_referencereasonname
     * const inducks_referencereasonname = await prisma.inducks_referencereasonname.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_referencereasonnameFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_referencereasonnameFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_referencereasonnameClient<$Result.GetResult<Prisma.$inducks_referencereasonnamePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_referencereasonname that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_referencereasonnameFindFirstArgs} args - Arguments to find a Inducks_referencereasonname
     * @example
     * // Get one Inducks_referencereasonname
     * const inducks_referencereasonname = await prisma.inducks_referencereasonname.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_referencereasonnameFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_referencereasonnameFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_referencereasonnameClient<$Result.GetResult<Prisma.$inducks_referencereasonnamePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_referencereasonname that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_referencereasonnameFindFirstOrThrowArgs} args - Arguments to find a Inducks_referencereasonname
     * @example
     * // Get one Inducks_referencereasonname
     * const inducks_referencereasonname = await prisma.inducks_referencereasonname.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_referencereasonnameFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_referencereasonnameFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_referencereasonnameClient<$Result.GetResult<Prisma.$inducks_referencereasonnamePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_referencereasonnames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_referencereasonnameFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_referencereasonnames
     * const inducks_referencereasonnames = await prisma.inducks_referencereasonname.findMany()
     * 
     * // Get first 10 Inducks_referencereasonnames
     * const inducks_referencereasonnames = await prisma.inducks_referencereasonname.findMany({ take: 10 })
     * 
     * // Only select the `referencereasonid`
     * const inducks_referencereasonnameWithReferencereasonidOnly = await prisma.inducks_referencereasonname.findMany({ select: { referencereasonid: true } })
     * 
    **/
    findMany<T extends inducks_referencereasonnameFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_referencereasonnameFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_referencereasonnamePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_referencereasonname.
     * @param {inducks_referencereasonnameCreateArgs} args - Arguments to create a Inducks_referencereasonname.
     * @example
     * // Create one Inducks_referencereasonname
     * const Inducks_referencereasonname = await prisma.inducks_referencereasonname.create({
     *   data: {
     *     // ... data to create a Inducks_referencereasonname
     *   }
     * })
     * 
    **/
    create<T extends inducks_referencereasonnameCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_referencereasonnameCreateArgs<ExtArgs>>
    ): Prisma__inducks_referencereasonnameClient<$Result.GetResult<Prisma.$inducks_referencereasonnamePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_referencereasonnames.
     *     @param {inducks_referencereasonnameCreateManyArgs} args - Arguments to create many Inducks_referencereasonnames.
     *     @example
     *     // Create many Inducks_referencereasonnames
     *     const inducks_referencereasonname = await prisma.inducks_referencereasonname.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_referencereasonnameCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_referencereasonnameCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_referencereasonname.
     * @param {inducks_referencereasonnameDeleteArgs} args - Arguments to delete one Inducks_referencereasonname.
     * @example
     * // Delete one Inducks_referencereasonname
     * const Inducks_referencereasonname = await prisma.inducks_referencereasonname.delete({
     *   where: {
     *     // ... filter to delete one Inducks_referencereasonname
     *   }
     * })
     * 
    **/
    delete<T extends inducks_referencereasonnameDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_referencereasonnameDeleteArgs<ExtArgs>>
    ): Prisma__inducks_referencereasonnameClient<$Result.GetResult<Prisma.$inducks_referencereasonnamePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_referencereasonname.
     * @param {inducks_referencereasonnameUpdateArgs} args - Arguments to update one Inducks_referencereasonname.
     * @example
     * // Update one Inducks_referencereasonname
     * const inducks_referencereasonname = await prisma.inducks_referencereasonname.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_referencereasonnameUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_referencereasonnameUpdateArgs<ExtArgs>>
    ): Prisma__inducks_referencereasonnameClient<$Result.GetResult<Prisma.$inducks_referencereasonnamePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_referencereasonnames.
     * @param {inducks_referencereasonnameDeleteManyArgs} args - Arguments to filter Inducks_referencereasonnames to delete.
     * @example
     * // Delete a few Inducks_referencereasonnames
     * const { count } = await prisma.inducks_referencereasonname.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_referencereasonnameDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_referencereasonnameDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_referencereasonnames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_referencereasonnameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_referencereasonnames
     * const inducks_referencereasonname = await prisma.inducks_referencereasonname.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_referencereasonnameUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_referencereasonnameUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_referencereasonname.
     * @param {inducks_referencereasonnameUpsertArgs} args - Arguments to update or create a Inducks_referencereasonname.
     * @example
     * // Update or create a Inducks_referencereasonname
     * const inducks_referencereasonname = await prisma.inducks_referencereasonname.upsert({
     *   create: {
     *     // ... data to create a Inducks_referencereasonname
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_referencereasonname we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_referencereasonnameUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_referencereasonnameUpsertArgs<ExtArgs>>
    ): Prisma__inducks_referencereasonnameClient<$Result.GetResult<Prisma.$inducks_referencereasonnamePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_referencereasonnames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_referencereasonnameCountArgs} args - Arguments to filter Inducks_referencereasonnames to count.
     * @example
     * // Count the number of Inducks_referencereasonnames
     * const count = await prisma.inducks_referencereasonname.count({
     *   where: {
     *     // ... the filter for the Inducks_referencereasonnames we want to count
     *   }
     * })
    **/
    count<T extends inducks_referencereasonnameCountArgs>(
      args?: Subset<T, inducks_referencereasonnameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_referencereasonnameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_referencereasonname.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_referencereasonnameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_referencereasonnameAggregateArgs>(args: Subset<T, Inducks_referencereasonnameAggregateArgs>): Prisma.PrismaPromise<GetInducks_referencereasonnameAggregateType<T>>

    /**
     * Group by Inducks_referencereasonname.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_referencereasonnameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_referencereasonnameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_referencereasonnameGroupByArgs['orderBy'] }
        : { orderBy?: inducks_referencereasonnameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_referencereasonnameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_referencereasonnameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_referencereasonname model
   */
  readonly fields: inducks_referencereasonnameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_referencereasonname.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_referencereasonnameClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_referencereasonname model
   */ 
  interface inducks_referencereasonnameFieldRefs {
    readonly referencereasonid: FieldRef<"inducks_referencereasonname", 'Int'>
    readonly languagecode: FieldRef<"inducks_referencereasonname", 'String'>
    readonly referencereasontranslation: FieldRef<"inducks_referencereasonname", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_referencereasonname findUnique
   */
  export type inducks_referencereasonnameFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_referencereasonname
     */
    select?: inducks_referencereasonnameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_referencereasonname to fetch.
     */
    where: inducks_referencereasonnameWhereUniqueInput
  }


  /**
   * inducks_referencereasonname findUniqueOrThrow
   */
  export type inducks_referencereasonnameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_referencereasonname
     */
    select?: inducks_referencereasonnameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_referencereasonname to fetch.
     */
    where: inducks_referencereasonnameWhereUniqueInput
  }


  /**
   * inducks_referencereasonname findFirst
   */
  export type inducks_referencereasonnameFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_referencereasonname
     */
    select?: inducks_referencereasonnameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_referencereasonname to fetch.
     */
    where?: inducks_referencereasonnameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_referencereasonnames to fetch.
     */
    orderBy?: inducks_referencereasonnameOrderByWithRelationInput | inducks_referencereasonnameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_referencereasonnames.
     */
    cursor?: inducks_referencereasonnameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_referencereasonnames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_referencereasonnames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_referencereasonnames.
     */
    distinct?: Inducks_referencereasonnameScalarFieldEnum | Inducks_referencereasonnameScalarFieldEnum[]
  }


  /**
   * inducks_referencereasonname findFirstOrThrow
   */
  export type inducks_referencereasonnameFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_referencereasonname
     */
    select?: inducks_referencereasonnameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_referencereasonname to fetch.
     */
    where?: inducks_referencereasonnameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_referencereasonnames to fetch.
     */
    orderBy?: inducks_referencereasonnameOrderByWithRelationInput | inducks_referencereasonnameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_referencereasonnames.
     */
    cursor?: inducks_referencereasonnameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_referencereasonnames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_referencereasonnames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_referencereasonnames.
     */
    distinct?: Inducks_referencereasonnameScalarFieldEnum | Inducks_referencereasonnameScalarFieldEnum[]
  }


  /**
   * inducks_referencereasonname findMany
   */
  export type inducks_referencereasonnameFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_referencereasonname
     */
    select?: inducks_referencereasonnameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_referencereasonnames to fetch.
     */
    where?: inducks_referencereasonnameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_referencereasonnames to fetch.
     */
    orderBy?: inducks_referencereasonnameOrderByWithRelationInput | inducks_referencereasonnameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_referencereasonnames.
     */
    cursor?: inducks_referencereasonnameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_referencereasonnames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_referencereasonnames.
     */
    skip?: number
    distinct?: Inducks_referencereasonnameScalarFieldEnum | Inducks_referencereasonnameScalarFieldEnum[]
  }


  /**
   * inducks_referencereasonname create
   */
  export type inducks_referencereasonnameCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_referencereasonname
     */
    select?: inducks_referencereasonnameSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_referencereasonname.
     */
    data: XOR<inducks_referencereasonnameCreateInput, inducks_referencereasonnameUncheckedCreateInput>
  }


  /**
   * inducks_referencereasonname createMany
   */
  export type inducks_referencereasonnameCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_referencereasonnames.
     */
    data: inducks_referencereasonnameCreateManyInput | inducks_referencereasonnameCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_referencereasonname update
   */
  export type inducks_referencereasonnameUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_referencereasonname
     */
    select?: inducks_referencereasonnameSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_referencereasonname.
     */
    data: XOR<inducks_referencereasonnameUpdateInput, inducks_referencereasonnameUncheckedUpdateInput>
    /**
     * Choose, which inducks_referencereasonname to update.
     */
    where: inducks_referencereasonnameWhereUniqueInput
  }


  /**
   * inducks_referencereasonname updateMany
   */
  export type inducks_referencereasonnameUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_referencereasonnames.
     */
    data: XOR<inducks_referencereasonnameUpdateManyMutationInput, inducks_referencereasonnameUncheckedUpdateManyInput>
    /**
     * Filter which inducks_referencereasonnames to update
     */
    where?: inducks_referencereasonnameWhereInput
  }


  /**
   * inducks_referencereasonname upsert
   */
  export type inducks_referencereasonnameUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_referencereasonname
     */
    select?: inducks_referencereasonnameSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_referencereasonname to update in case it exists.
     */
    where: inducks_referencereasonnameWhereUniqueInput
    /**
     * In case the inducks_referencereasonname found by the `where` argument doesn't exist, create a new inducks_referencereasonname with this data.
     */
    create: XOR<inducks_referencereasonnameCreateInput, inducks_referencereasonnameUncheckedCreateInput>
    /**
     * In case the inducks_referencereasonname was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_referencereasonnameUpdateInput, inducks_referencereasonnameUncheckedUpdateInput>
  }


  /**
   * inducks_referencereasonname delete
   */
  export type inducks_referencereasonnameDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_referencereasonname
     */
    select?: inducks_referencereasonnameSelect<ExtArgs> | null
    /**
     * Filter which inducks_referencereasonname to delete.
     */
    where: inducks_referencereasonnameWhereUniqueInput
  }


  /**
   * inducks_referencereasonname deleteMany
   */
  export type inducks_referencereasonnameDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_referencereasonnames to delete
     */
    where?: inducks_referencereasonnameWhereInput
  }


  /**
   * inducks_referencereasonname without action
   */
  export type inducks_referencereasonnameDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_referencereasonname
     */
    select?: inducks_referencereasonnameSelect<ExtArgs> | null
  }



  /**
   * Model inducks_site
   */

  export type AggregateInducks_site = {
    _count: Inducks_siteCountAggregateOutputType | null
    _min: Inducks_siteMinAggregateOutputType | null
    _max: Inducks_siteMaxAggregateOutputType | null
  }

  export type Inducks_siteMinAggregateOutputType = {
    sitecode: string | null
    urlbase: string | null
    images: $Enums.inducks_site_images | null
    sitename: string | null
    sitelogo: string | null
    properties: string | null
  }

  export type Inducks_siteMaxAggregateOutputType = {
    sitecode: string | null
    urlbase: string | null
    images: $Enums.inducks_site_images | null
    sitename: string | null
    sitelogo: string | null
    properties: string | null
  }

  export type Inducks_siteCountAggregateOutputType = {
    sitecode: number
    urlbase: number
    images: number
    sitename: number
    sitelogo: number
    properties: number
    _all: number
  }


  export type Inducks_siteMinAggregateInputType = {
    sitecode?: true
    urlbase?: true
    images?: true
    sitename?: true
    sitelogo?: true
    properties?: true
  }

  export type Inducks_siteMaxAggregateInputType = {
    sitecode?: true
    urlbase?: true
    images?: true
    sitename?: true
    sitelogo?: true
    properties?: true
  }

  export type Inducks_siteCountAggregateInputType = {
    sitecode?: true
    urlbase?: true
    images?: true
    sitename?: true
    sitelogo?: true
    properties?: true
    _all?: true
  }

  export type Inducks_siteAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_site to aggregate.
     */
    where?: inducks_siteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_sites to fetch.
     */
    orderBy?: inducks_siteOrderByWithRelationInput | inducks_siteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_siteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_sites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_sites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_sites
    **/
    _count?: true | Inducks_siteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_siteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_siteMaxAggregateInputType
  }

  export type GetInducks_siteAggregateType<T extends Inducks_siteAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_site]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_site[P]>
      : GetScalarType<T[P], AggregateInducks_site[P]>
  }




  export type inducks_siteGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_siteWhereInput
    orderBy?: inducks_siteOrderByWithAggregationInput | inducks_siteOrderByWithAggregationInput[]
    by: Inducks_siteScalarFieldEnum[] | Inducks_siteScalarFieldEnum
    having?: inducks_siteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_siteCountAggregateInputType | true
    _min?: Inducks_siteMinAggregateInputType
    _max?: Inducks_siteMaxAggregateInputType
  }

  export type Inducks_siteGroupByOutputType = {
    sitecode: string
    urlbase: string | null
    images: $Enums.inducks_site_images | null
    sitename: string | null
    sitelogo: string | null
    properties: string | null
    _count: Inducks_siteCountAggregateOutputType | null
    _min: Inducks_siteMinAggregateOutputType | null
    _max: Inducks_siteMaxAggregateOutputType | null
  }

  type GetInducks_siteGroupByPayload<T extends inducks_siteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_siteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_siteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_siteGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_siteGroupByOutputType[P]>
        }
      >
    >


  export type inducks_siteSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sitecode?: boolean
    urlbase?: boolean
    images?: boolean
    sitename?: boolean
    sitelogo?: boolean
    properties?: boolean
  }, ExtArgs["result"]["inducks_site"]>

  export type inducks_siteSelectScalar = {
    sitecode?: boolean
    urlbase?: boolean
    images?: boolean
    sitename?: boolean
    sitelogo?: boolean
    properties?: boolean
  }


  export type $inducks_sitePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_site"
    objects: {}
    scalars: $Extensions.GetResult<{
      sitecode: string
      urlbase: string | null
      images: $Enums.inducks_site_images | null
      sitename: string | null
      sitelogo: string | null
      properties: string | null
    }, ExtArgs["result"]["inducks_site"]>
    composites: {}
  }


  type inducks_siteGetPayload<S extends boolean | null | undefined | inducks_siteDefaultArgs> = $Result.GetResult<Prisma.$inducks_sitePayload, S>

  type inducks_siteCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_siteFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_siteCountAggregateInputType | true
    }

  export interface inducks_siteDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_site'], meta: { name: 'inducks_site' } }
    /**
     * Find zero or one Inducks_site that matches the filter.
     * @param {inducks_siteFindUniqueArgs} args - Arguments to find a Inducks_site
     * @example
     * // Get one Inducks_site
     * const inducks_site = await prisma.inducks_site.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_siteFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_siteFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_siteClient<$Result.GetResult<Prisma.$inducks_sitePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_site that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_siteFindUniqueOrThrowArgs} args - Arguments to find a Inducks_site
     * @example
     * // Get one Inducks_site
     * const inducks_site = await prisma.inducks_site.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_siteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_siteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_siteClient<$Result.GetResult<Prisma.$inducks_sitePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_site that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_siteFindFirstArgs} args - Arguments to find a Inducks_site
     * @example
     * // Get one Inducks_site
     * const inducks_site = await prisma.inducks_site.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_siteFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_siteFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_siteClient<$Result.GetResult<Prisma.$inducks_sitePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_site that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_siteFindFirstOrThrowArgs} args - Arguments to find a Inducks_site
     * @example
     * // Get one Inducks_site
     * const inducks_site = await prisma.inducks_site.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_siteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_siteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_siteClient<$Result.GetResult<Prisma.$inducks_sitePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_sites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_siteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_sites
     * const inducks_sites = await prisma.inducks_site.findMany()
     * 
     * // Get first 10 Inducks_sites
     * const inducks_sites = await prisma.inducks_site.findMany({ take: 10 })
     * 
     * // Only select the `sitecode`
     * const inducks_siteWithSitecodeOnly = await prisma.inducks_site.findMany({ select: { sitecode: true } })
     * 
    **/
    findMany<T extends inducks_siteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_siteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_sitePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_site.
     * @param {inducks_siteCreateArgs} args - Arguments to create a Inducks_site.
     * @example
     * // Create one Inducks_site
     * const Inducks_site = await prisma.inducks_site.create({
     *   data: {
     *     // ... data to create a Inducks_site
     *   }
     * })
     * 
    **/
    create<T extends inducks_siteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_siteCreateArgs<ExtArgs>>
    ): Prisma__inducks_siteClient<$Result.GetResult<Prisma.$inducks_sitePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_sites.
     *     @param {inducks_siteCreateManyArgs} args - Arguments to create many Inducks_sites.
     *     @example
     *     // Create many Inducks_sites
     *     const inducks_site = await prisma.inducks_site.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_siteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_siteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_site.
     * @param {inducks_siteDeleteArgs} args - Arguments to delete one Inducks_site.
     * @example
     * // Delete one Inducks_site
     * const Inducks_site = await prisma.inducks_site.delete({
     *   where: {
     *     // ... filter to delete one Inducks_site
     *   }
     * })
     * 
    **/
    delete<T extends inducks_siteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_siteDeleteArgs<ExtArgs>>
    ): Prisma__inducks_siteClient<$Result.GetResult<Prisma.$inducks_sitePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_site.
     * @param {inducks_siteUpdateArgs} args - Arguments to update one Inducks_site.
     * @example
     * // Update one Inducks_site
     * const inducks_site = await prisma.inducks_site.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_siteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_siteUpdateArgs<ExtArgs>>
    ): Prisma__inducks_siteClient<$Result.GetResult<Prisma.$inducks_sitePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_sites.
     * @param {inducks_siteDeleteManyArgs} args - Arguments to filter Inducks_sites to delete.
     * @example
     * // Delete a few Inducks_sites
     * const { count } = await prisma.inducks_site.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_siteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_siteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_sites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_siteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_sites
     * const inducks_site = await prisma.inducks_site.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_siteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_siteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_site.
     * @param {inducks_siteUpsertArgs} args - Arguments to update or create a Inducks_site.
     * @example
     * // Update or create a Inducks_site
     * const inducks_site = await prisma.inducks_site.upsert({
     *   create: {
     *     // ... data to create a Inducks_site
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_site we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_siteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_siteUpsertArgs<ExtArgs>>
    ): Prisma__inducks_siteClient<$Result.GetResult<Prisma.$inducks_sitePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_sites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_siteCountArgs} args - Arguments to filter Inducks_sites to count.
     * @example
     * // Count the number of Inducks_sites
     * const count = await prisma.inducks_site.count({
     *   where: {
     *     // ... the filter for the Inducks_sites we want to count
     *   }
     * })
    **/
    count<T extends inducks_siteCountArgs>(
      args?: Subset<T, inducks_siteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_siteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_site.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_siteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_siteAggregateArgs>(args: Subset<T, Inducks_siteAggregateArgs>): Prisma.PrismaPromise<GetInducks_siteAggregateType<T>>

    /**
     * Group by Inducks_site.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_siteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_siteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_siteGroupByArgs['orderBy'] }
        : { orderBy?: inducks_siteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_siteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_siteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_site model
   */
  readonly fields: inducks_siteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_site.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_siteClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_site model
   */ 
  interface inducks_siteFieldRefs {
    readonly sitecode: FieldRef<"inducks_site", 'String'>
    readonly urlbase: FieldRef<"inducks_site", 'String'>
    readonly images: FieldRef<"inducks_site", 'inducks_site_images'>
    readonly sitename: FieldRef<"inducks_site", 'String'>
    readonly sitelogo: FieldRef<"inducks_site", 'String'>
    readonly properties: FieldRef<"inducks_site", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_site findUnique
   */
  export type inducks_siteFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_site
     */
    select?: inducks_siteSelect<ExtArgs> | null
    /**
     * Filter, which inducks_site to fetch.
     */
    where: inducks_siteWhereUniqueInput
  }


  /**
   * inducks_site findUniqueOrThrow
   */
  export type inducks_siteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_site
     */
    select?: inducks_siteSelect<ExtArgs> | null
    /**
     * Filter, which inducks_site to fetch.
     */
    where: inducks_siteWhereUniqueInput
  }


  /**
   * inducks_site findFirst
   */
  export type inducks_siteFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_site
     */
    select?: inducks_siteSelect<ExtArgs> | null
    /**
     * Filter, which inducks_site to fetch.
     */
    where?: inducks_siteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_sites to fetch.
     */
    orderBy?: inducks_siteOrderByWithRelationInput | inducks_siteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_sites.
     */
    cursor?: inducks_siteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_sites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_sites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_sites.
     */
    distinct?: Inducks_siteScalarFieldEnum | Inducks_siteScalarFieldEnum[]
  }


  /**
   * inducks_site findFirstOrThrow
   */
  export type inducks_siteFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_site
     */
    select?: inducks_siteSelect<ExtArgs> | null
    /**
     * Filter, which inducks_site to fetch.
     */
    where?: inducks_siteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_sites to fetch.
     */
    orderBy?: inducks_siteOrderByWithRelationInput | inducks_siteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_sites.
     */
    cursor?: inducks_siteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_sites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_sites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_sites.
     */
    distinct?: Inducks_siteScalarFieldEnum | Inducks_siteScalarFieldEnum[]
  }


  /**
   * inducks_site findMany
   */
  export type inducks_siteFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_site
     */
    select?: inducks_siteSelect<ExtArgs> | null
    /**
     * Filter, which inducks_sites to fetch.
     */
    where?: inducks_siteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_sites to fetch.
     */
    orderBy?: inducks_siteOrderByWithRelationInput | inducks_siteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_sites.
     */
    cursor?: inducks_siteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_sites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_sites.
     */
    skip?: number
    distinct?: Inducks_siteScalarFieldEnum | Inducks_siteScalarFieldEnum[]
  }


  /**
   * inducks_site create
   */
  export type inducks_siteCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_site
     */
    select?: inducks_siteSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_site.
     */
    data: XOR<inducks_siteCreateInput, inducks_siteUncheckedCreateInput>
  }


  /**
   * inducks_site createMany
   */
  export type inducks_siteCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_sites.
     */
    data: inducks_siteCreateManyInput | inducks_siteCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_site update
   */
  export type inducks_siteUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_site
     */
    select?: inducks_siteSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_site.
     */
    data: XOR<inducks_siteUpdateInput, inducks_siteUncheckedUpdateInput>
    /**
     * Choose, which inducks_site to update.
     */
    where: inducks_siteWhereUniqueInput
  }


  /**
   * inducks_site updateMany
   */
  export type inducks_siteUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_sites.
     */
    data: XOR<inducks_siteUpdateManyMutationInput, inducks_siteUncheckedUpdateManyInput>
    /**
     * Filter which inducks_sites to update
     */
    where?: inducks_siteWhereInput
  }


  /**
   * inducks_site upsert
   */
  export type inducks_siteUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_site
     */
    select?: inducks_siteSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_site to update in case it exists.
     */
    where: inducks_siteWhereUniqueInput
    /**
     * In case the inducks_site found by the `where` argument doesn't exist, create a new inducks_site with this data.
     */
    create: XOR<inducks_siteCreateInput, inducks_siteUncheckedCreateInput>
    /**
     * In case the inducks_site was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_siteUpdateInput, inducks_siteUncheckedUpdateInput>
  }


  /**
   * inducks_site delete
   */
  export type inducks_siteDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_site
     */
    select?: inducks_siteSelect<ExtArgs> | null
    /**
     * Filter which inducks_site to delete.
     */
    where: inducks_siteWhereUniqueInput
  }


  /**
   * inducks_site deleteMany
   */
  export type inducks_siteDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_sites to delete
     */
    where?: inducks_siteWhereInput
  }


  /**
   * inducks_site without action
   */
  export type inducks_siteDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_site
     */
    select?: inducks_siteSelect<ExtArgs> | null
  }



  /**
   * Model inducks_statcharactercharacter
   */

  export type AggregateInducks_statcharactercharacter = {
    _count: Inducks_statcharactercharacterCountAggregateOutputType | null
    _avg: Inducks_statcharactercharacterAvgAggregateOutputType | null
    _sum: Inducks_statcharactercharacterSumAggregateOutputType | null
    _min: Inducks_statcharactercharacterMinAggregateOutputType | null
    _max: Inducks_statcharactercharacterMaxAggregateOutputType | null
  }

  export type Inducks_statcharactercharacterAvgAggregateOutputType = {
    total: number | null
  }

  export type Inducks_statcharactercharacterSumAggregateOutputType = {
    total: number | null
  }

  export type Inducks_statcharactercharacterMinAggregateOutputType = {
    charactercode: string | null
    cocharactercode: string | null
    total: number | null
    yearrange: string | null
  }

  export type Inducks_statcharactercharacterMaxAggregateOutputType = {
    charactercode: string | null
    cocharactercode: string | null
    total: number | null
    yearrange: string | null
  }

  export type Inducks_statcharactercharacterCountAggregateOutputType = {
    charactercode: number
    cocharactercode: number
    total: number
    yearrange: number
    _all: number
  }


  export type Inducks_statcharactercharacterAvgAggregateInputType = {
    total?: true
  }

  export type Inducks_statcharactercharacterSumAggregateInputType = {
    total?: true
  }

  export type Inducks_statcharactercharacterMinAggregateInputType = {
    charactercode?: true
    cocharactercode?: true
    total?: true
    yearrange?: true
  }

  export type Inducks_statcharactercharacterMaxAggregateInputType = {
    charactercode?: true
    cocharactercode?: true
    total?: true
    yearrange?: true
  }

  export type Inducks_statcharactercharacterCountAggregateInputType = {
    charactercode?: true
    cocharactercode?: true
    total?: true
    yearrange?: true
    _all?: true
  }

  export type Inducks_statcharactercharacterAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_statcharactercharacter to aggregate.
     */
    where?: inducks_statcharactercharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_statcharactercharacters to fetch.
     */
    orderBy?: inducks_statcharactercharacterOrderByWithRelationInput | inducks_statcharactercharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_statcharactercharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_statcharactercharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_statcharactercharacters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_statcharactercharacters
    **/
    _count?: true | Inducks_statcharactercharacterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Inducks_statcharactercharacterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Inducks_statcharactercharacterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_statcharactercharacterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_statcharactercharacterMaxAggregateInputType
  }

  export type GetInducks_statcharactercharacterAggregateType<T extends Inducks_statcharactercharacterAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_statcharactercharacter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_statcharactercharacter[P]>
      : GetScalarType<T[P], AggregateInducks_statcharactercharacter[P]>
  }




  export type inducks_statcharactercharacterGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_statcharactercharacterWhereInput
    orderBy?: inducks_statcharactercharacterOrderByWithAggregationInput | inducks_statcharactercharacterOrderByWithAggregationInput[]
    by: Inducks_statcharactercharacterScalarFieldEnum[] | Inducks_statcharactercharacterScalarFieldEnum
    having?: inducks_statcharactercharacterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_statcharactercharacterCountAggregateInputType | true
    _avg?: Inducks_statcharactercharacterAvgAggregateInputType
    _sum?: Inducks_statcharactercharacterSumAggregateInputType
    _min?: Inducks_statcharactercharacterMinAggregateInputType
    _max?: Inducks_statcharactercharacterMaxAggregateInputType
  }

  export type Inducks_statcharactercharacterGroupByOutputType = {
    charactercode: string
    cocharactercode: string | null
    total: number
    yearrange: string | null
    _count: Inducks_statcharactercharacterCountAggregateOutputType | null
    _avg: Inducks_statcharactercharacterAvgAggregateOutputType | null
    _sum: Inducks_statcharactercharacterSumAggregateOutputType | null
    _min: Inducks_statcharactercharacterMinAggregateOutputType | null
    _max: Inducks_statcharactercharacterMaxAggregateOutputType | null
  }

  type GetInducks_statcharactercharacterGroupByPayload<T extends inducks_statcharactercharacterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_statcharactercharacterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_statcharactercharacterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_statcharactercharacterGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_statcharactercharacterGroupByOutputType[P]>
        }
      >
    >


  export type inducks_statcharactercharacterSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    charactercode?: boolean
    cocharactercode?: boolean
    total?: boolean
    yearrange?: boolean
  }, ExtArgs["result"]["inducks_statcharactercharacter"]>

  export type inducks_statcharactercharacterSelectScalar = {
    charactercode?: boolean
    cocharactercode?: boolean
    total?: boolean
    yearrange?: boolean
  }


  export type $inducks_statcharactercharacterPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_statcharactercharacter"
    objects: {}
    scalars: $Extensions.GetResult<{
      charactercode: string
      cocharactercode: string | null
      total: number
      yearrange: string | null
    }, ExtArgs["result"]["inducks_statcharactercharacter"]>
    composites: {}
  }


  type inducks_statcharactercharacterGetPayload<S extends boolean | null | undefined | inducks_statcharactercharacterDefaultArgs> = $Result.GetResult<Prisma.$inducks_statcharactercharacterPayload, S>

  type inducks_statcharactercharacterCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_statcharactercharacterFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_statcharactercharacterCountAggregateInputType | true
    }

  export interface inducks_statcharactercharacterDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_statcharactercharacter'], meta: { name: 'inducks_statcharactercharacter' } }
    /**
     * Find zero or one Inducks_statcharactercharacter that matches the filter.
     * @param {inducks_statcharactercharacterFindUniqueArgs} args - Arguments to find a Inducks_statcharactercharacter
     * @example
     * // Get one Inducks_statcharactercharacter
     * const inducks_statcharactercharacter = await prisma.inducks_statcharactercharacter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_statcharactercharacterFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statcharactercharacterFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_statcharactercharacterClient<$Result.GetResult<Prisma.$inducks_statcharactercharacterPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_statcharactercharacter that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_statcharactercharacterFindUniqueOrThrowArgs} args - Arguments to find a Inducks_statcharactercharacter
     * @example
     * // Get one Inducks_statcharactercharacter
     * const inducks_statcharactercharacter = await prisma.inducks_statcharactercharacter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_statcharactercharacterFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statcharactercharacterFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_statcharactercharacterClient<$Result.GetResult<Prisma.$inducks_statcharactercharacterPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_statcharactercharacter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statcharactercharacterFindFirstArgs} args - Arguments to find a Inducks_statcharactercharacter
     * @example
     * // Get one Inducks_statcharactercharacter
     * const inducks_statcharactercharacter = await prisma.inducks_statcharactercharacter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_statcharactercharacterFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statcharactercharacterFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_statcharactercharacterClient<$Result.GetResult<Prisma.$inducks_statcharactercharacterPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_statcharactercharacter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statcharactercharacterFindFirstOrThrowArgs} args - Arguments to find a Inducks_statcharactercharacter
     * @example
     * // Get one Inducks_statcharactercharacter
     * const inducks_statcharactercharacter = await prisma.inducks_statcharactercharacter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_statcharactercharacterFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statcharactercharacterFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_statcharactercharacterClient<$Result.GetResult<Prisma.$inducks_statcharactercharacterPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_statcharactercharacters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statcharactercharacterFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_statcharactercharacters
     * const inducks_statcharactercharacters = await prisma.inducks_statcharactercharacter.findMany()
     * 
     * // Get first 10 Inducks_statcharactercharacters
     * const inducks_statcharactercharacters = await prisma.inducks_statcharactercharacter.findMany({ take: 10 })
     * 
     * // Only select the `charactercode`
     * const inducks_statcharactercharacterWithCharactercodeOnly = await prisma.inducks_statcharactercharacter.findMany({ select: { charactercode: true } })
     * 
    **/
    findMany<T extends inducks_statcharactercharacterFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statcharactercharacterFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_statcharactercharacterPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_statcharactercharacter.
     * @param {inducks_statcharactercharacterCreateArgs} args - Arguments to create a Inducks_statcharactercharacter.
     * @example
     * // Create one Inducks_statcharactercharacter
     * const Inducks_statcharactercharacter = await prisma.inducks_statcharactercharacter.create({
     *   data: {
     *     // ... data to create a Inducks_statcharactercharacter
     *   }
     * })
     * 
    **/
    create<T extends inducks_statcharactercharacterCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statcharactercharacterCreateArgs<ExtArgs>>
    ): Prisma__inducks_statcharactercharacterClient<$Result.GetResult<Prisma.$inducks_statcharactercharacterPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_statcharactercharacters.
     *     @param {inducks_statcharactercharacterCreateManyArgs} args - Arguments to create many Inducks_statcharactercharacters.
     *     @example
     *     // Create many Inducks_statcharactercharacters
     *     const inducks_statcharactercharacter = await prisma.inducks_statcharactercharacter.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_statcharactercharacterCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statcharactercharacterCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_statcharactercharacter.
     * @param {inducks_statcharactercharacterDeleteArgs} args - Arguments to delete one Inducks_statcharactercharacter.
     * @example
     * // Delete one Inducks_statcharactercharacter
     * const Inducks_statcharactercharacter = await prisma.inducks_statcharactercharacter.delete({
     *   where: {
     *     // ... filter to delete one Inducks_statcharactercharacter
     *   }
     * })
     * 
    **/
    delete<T extends inducks_statcharactercharacterDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statcharactercharacterDeleteArgs<ExtArgs>>
    ): Prisma__inducks_statcharactercharacterClient<$Result.GetResult<Prisma.$inducks_statcharactercharacterPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_statcharactercharacter.
     * @param {inducks_statcharactercharacterUpdateArgs} args - Arguments to update one Inducks_statcharactercharacter.
     * @example
     * // Update one Inducks_statcharactercharacter
     * const inducks_statcharactercharacter = await prisma.inducks_statcharactercharacter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_statcharactercharacterUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statcharactercharacterUpdateArgs<ExtArgs>>
    ): Prisma__inducks_statcharactercharacterClient<$Result.GetResult<Prisma.$inducks_statcharactercharacterPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_statcharactercharacters.
     * @param {inducks_statcharactercharacterDeleteManyArgs} args - Arguments to filter Inducks_statcharactercharacters to delete.
     * @example
     * // Delete a few Inducks_statcharactercharacters
     * const { count } = await prisma.inducks_statcharactercharacter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_statcharactercharacterDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statcharactercharacterDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_statcharactercharacters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statcharactercharacterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_statcharactercharacters
     * const inducks_statcharactercharacter = await prisma.inducks_statcharactercharacter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_statcharactercharacterUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statcharactercharacterUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_statcharactercharacter.
     * @param {inducks_statcharactercharacterUpsertArgs} args - Arguments to update or create a Inducks_statcharactercharacter.
     * @example
     * // Update or create a Inducks_statcharactercharacter
     * const inducks_statcharactercharacter = await prisma.inducks_statcharactercharacter.upsert({
     *   create: {
     *     // ... data to create a Inducks_statcharactercharacter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_statcharactercharacter we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_statcharactercharacterUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statcharactercharacterUpsertArgs<ExtArgs>>
    ): Prisma__inducks_statcharactercharacterClient<$Result.GetResult<Prisma.$inducks_statcharactercharacterPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_statcharactercharacters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statcharactercharacterCountArgs} args - Arguments to filter Inducks_statcharactercharacters to count.
     * @example
     * // Count the number of Inducks_statcharactercharacters
     * const count = await prisma.inducks_statcharactercharacter.count({
     *   where: {
     *     // ... the filter for the Inducks_statcharactercharacters we want to count
     *   }
     * })
    **/
    count<T extends inducks_statcharactercharacterCountArgs>(
      args?: Subset<T, inducks_statcharactercharacterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_statcharactercharacterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_statcharactercharacter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_statcharactercharacterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_statcharactercharacterAggregateArgs>(args: Subset<T, Inducks_statcharactercharacterAggregateArgs>): Prisma.PrismaPromise<GetInducks_statcharactercharacterAggregateType<T>>

    /**
     * Group by Inducks_statcharactercharacter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statcharactercharacterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_statcharactercharacterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_statcharactercharacterGroupByArgs['orderBy'] }
        : { orderBy?: inducks_statcharactercharacterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_statcharactercharacterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_statcharactercharacterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_statcharactercharacter model
   */
  readonly fields: inducks_statcharactercharacterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_statcharactercharacter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_statcharactercharacterClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_statcharactercharacter model
   */ 
  interface inducks_statcharactercharacterFieldRefs {
    readonly charactercode: FieldRef<"inducks_statcharactercharacter", 'String'>
    readonly cocharactercode: FieldRef<"inducks_statcharactercharacter", 'String'>
    readonly total: FieldRef<"inducks_statcharactercharacter", 'Int'>
    readonly yearrange: FieldRef<"inducks_statcharactercharacter", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_statcharactercharacter findUnique
   */
  export type inducks_statcharactercharacterFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statcharactercharacter
     */
    select?: inducks_statcharactercharacterSelect<ExtArgs> | null
    /**
     * Filter, which inducks_statcharactercharacter to fetch.
     */
    where: inducks_statcharactercharacterWhereUniqueInput
  }


  /**
   * inducks_statcharactercharacter findUniqueOrThrow
   */
  export type inducks_statcharactercharacterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statcharactercharacter
     */
    select?: inducks_statcharactercharacterSelect<ExtArgs> | null
    /**
     * Filter, which inducks_statcharactercharacter to fetch.
     */
    where: inducks_statcharactercharacterWhereUniqueInput
  }


  /**
   * inducks_statcharactercharacter findFirst
   */
  export type inducks_statcharactercharacterFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statcharactercharacter
     */
    select?: inducks_statcharactercharacterSelect<ExtArgs> | null
    /**
     * Filter, which inducks_statcharactercharacter to fetch.
     */
    where?: inducks_statcharactercharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_statcharactercharacters to fetch.
     */
    orderBy?: inducks_statcharactercharacterOrderByWithRelationInput | inducks_statcharactercharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_statcharactercharacters.
     */
    cursor?: inducks_statcharactercharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_statcharactercharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_statcharactercharacters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_statcharactercharacters.
     */
    distinct?: Inducks_statcharactercharacterScalarFieldEnum | Inducks_statcharactercharacterScalarFieldEnum[]
  }


  /**
   * inducks_statcharactercharacter findFirstOrThrow
   */
  export type inducks_statcharactercharacterFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statcharactercharacter
     */
    select?: inducks_statcharactercharacterSelect<ExtArgs> | null
    /**
     * Filter, which inducks_statcharactercharacter to fetch.
     */
    where?: inducks_statcharactercharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_statcharactercharacters to fetch.
     */
    orderBy?: inducks_statcharactercharacterOrderByWithRelationInput | inducks_statcharactercharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_statcharactercharacters.
     */
    cursor?: inducks_statcharactercharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_statcharactercharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_statcharactercharacters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_statcharactercharacters.
     */
    distinct?: Inducks_statcharactercharacterScalarFieldEnum | Inducks_statcharactercharacterScalarFieldEnum[]
  }


  /**
   * inducks_statcharactercharacter findMany
   */
  export type inducks_statcharactercharacterFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statcharactercharacter
     */
    select?: inducks_statcharactercharacterSelect<ExtArgs> | null
    /**
     * Filter, which inducks_statcharactercharacters to fetch.
     */
    where?: inducks_statcharactercharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_statcharactercharacters to fetch.
     */
    orderBy?: inducks_statcharactercharacterOrderByWithRelationInput | inducks_statcharactercharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_statcharactercharacters.
     */
    cursor?: inducks_statcharactercharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_statcharactercharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_statcharactercharacters.
     */
    skip?: number
    distinct?: Inducks_statcharactercharacterScalarFieldEnum | Inducks_statcharactercharacterScalarFieldEnum[]
  }


  /**
   * inducks_statcharactercharacter create
   */
  export type inducks_statcharactercharacterCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statcharactercharacter
     */
    select?: inducks_statcharactercharacterSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_statcharactercharacter.
     */
    data: XOR<inducks_statcharactercharacterCreateInput, inducks_statcharactercharacterUncheckedCreateInput>
  }


  /**
   * inducks_statcharactercharacter createMany
   */
  export type inducks_statcharactercharacterCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_statcharactercharacters.
     */
    data: inducks_statcharactercharacterCreateManyInput | inducks_statcharactercharacterCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_statcharactercharacter update
   */
  export type inducks_statcharactercharacterUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statcharactercharacter
     */
    select?: inducks_statcharactercharacterSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_statcharactercharacter.
     */
    data: XOR<inducks_statcharactercharacterUpdateInput, inducks_statcharactercharacterUncheckedUpdateInput>
    /**
     * Choose, which inducks_statcharactercharacter to update.
     */
    where: inducks_statcharactercharacterWhereUniqueInput
  }


  /**
   * inducks_statcharactercharacter updateMany
   */
  export type inducks_statcharactercharacterUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_statcharactercharacters.
     */
    data: XOR<inducks_statcharactercharacterUpdateManyMutationInput, inducks_statcharactercharacterUncheckedUpdateManyInput>
    /**
     * Filter which inducks_statcharactercharacters to update
     */
    where?: inducks_statcharactercharacterWhereInput
  }


  /**
   * inducks_statcharactercharacter upsert
   */
  export type inducks_statcharactercharacterUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statcharactercharacter
     */
    select?: inducks_statcharactercharacterSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_statcharactercharacter to update in case it exists.
     */
    where: inducks_statcharactercharacterWhereUniqueInput
    /**
     * In case the inducks_statcharactercharacter found by the `where` argument doesn't exist, create a new inducks_statcharactercharacter with this data.
     */
    create: XOR<inducks_statcharactercharacterCreateInput, inducks_statcharactercharacterUncheckedCreateInput>
    /**
     * In case the inducks_statcharactercharacter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_statcharactercharacterUpdateInput, inducks_statcharactercharacterUncheckedUpdateInput>
  }


  /**
   * inducks_statcharactercharacter delete
   */
  export type inducks_statcharactercharacterDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statcharactercharacter
     */
    select?: inducks_statcharactercharacterSelect<ExtArgs> | null
    /**
     * Filter which inducks_statcharactercharacter to delete.
     */
    where: inducks_statcharactercharacterWhereUniqueInput
  }


  /**
   * inducks_statcharactercharacter deleteMany
   */
  export type inducks_statcharactercharacterDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_statcharactercharacters to delete
     */
    where?: inducks_statcharactercharacterWhereInput
  }


  /**
   * inducks_statcharactercharacter without action
   */
  export type inducks_statcharactercharacterDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statcharactercharacter
     */
    select?: inducks_statcharactercharacterSelect<ExtArgs> | null
  }



  /**
   * Model inducks_statcharactercountry
   */

  export type AggregateInducks_statcharactercountry = {
    _count: Inducks_statcharactercountryCountAggregateOutputType | null
    _avg: Inducks_statcharactercountryAvgAggregateOutputType | null
    _sum: Inducks_statcharactercountrySumAggregateOutputType | null
    _min: Inducks_statcharactercountryMinAggregateOutputType | null
    _max: Inducks_statcharactercountryMaxAggregateOutputType | null
  }

  export type Inducks_statcharactercountryAvgAggregateOutputType = {
    total: number | null
  }

  export type Inducks_statcharactercountrySumAggregateOutputType = {
    total: number | null
  }

  export type Inducks_statcharactercountryMinAggregateOutputType = {
    charactercode: string | null
    countrycode: string | null
    total: number | null
  }

  export type Inducks_statcharactercountryMaxAggregateOutputType = {
    charactercode: string | null
    countrycode: string | null
    total: number | null
  }

  export type Inducks_statcharactercountryCountAggregateOutputType = {
    charactercode: number
    countrycode: number
    total: number
    _all: number
  }


  export type Inducks_statcharactercountryAvgAggregateInputType = {
    total?: true
  }

  export type Inducks_statcharactercountrySumAggregateInputType = {
    total?: true
  }

  export type Inducks_statcharactercountryMinAggregateInputType = {
    charactercode?: true
    countrycode?: true
    total?: true
  }

  export type Inducks_statcharactercountryMaxAggregateInputType = {
    charactercode?: true
    countrycode?: true
    total?: true
  }

  export type Inducks_statcharactercountryCountAggregateInputType = {
    charactercode?: true
    countrycode?: true
    total?: true
    _all?: true
  }

  export type Inducks_statcharactercountryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_statcharactercountry to aggregate.
     */
    where?: inducks_statcharactercountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_statcharactercountries to fetch.
     */
    orderBy?: inducks_statcharactercountryOrderByWithRelationInput | inducks_statcharactercountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_statcharactercountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_statcharactercountries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_statcharactercountries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_statcharactercountries
    **/
    _count?: true | Inducks_statcharactercountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Inducks_statcharactercountryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Inducks_statcharactercountrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_statcharactercountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_statcharactercountryMaxAggregateInputType
  }

  export type GetInducks_statcharactercountryAggregateType<T extends Inducks_statcharactercountryAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_statcharactercountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_statcharactercountry[P]>
      : GetScalarType<T[P], AggregateInducks_statcharactercountry[P]>
  }




  export type inducks_statcharactercountryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_statcharactercountryWhereInput
    orderBy?: inducks_statcharactercountryOrderByWithAggregationInput | inducks_statcharactercountryOrderByWithAggregationInput[]
    by: Inducks_statcharactercountryScalarFieldEnum[] | Inducks_statcharactercountryScalarFieldEnum
    having?: inducks_statcharactercountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_statcharactercountryCountAggregateInputType | true
    _avg?: Inducks_statcharactercountryAvgAggregateInputType
    _sum?: Inducks_statcharactercountrySumAggregateInputType
    _min?: Inducks_statcharactercountryMinAggregateInputType
    _max?: Inducks_statcharactercountryMaxAggregateInputType
  }

  export type Inducks_statcharactercountryGroupByOutputType = {
    charactercode: string
    countrycode: string
    total: number | null
    _count: Inducks_statcharactercountryCountAggregateOutputType | null
    _avg: Inducks_statcharactercountryAvgAggregateOutputType | null
    _sum: Inducks_statcharactercountrySumAggregateOutputType | null
    _min: Inducks_statcharactercountryMinAggregateOutputType | null
    _max: Inducks_statcharactercountryMaxAggregateOutputType | null
  }

  type GetInducks_statcharactercountryGroupByPayload<T extends inducks_statcharactercountryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_statcharactercountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_statcharactercountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_statcharactercountryGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_statcharactercountryGroupByOutputType[P]>
        }
      >
    >


  export type inducks_statcharactercountrySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    charactercode?: boolean
    countrycode?: boolean
    total?: boolean
  }, ExtArgs["result"]["inducks_statcharactercountry"]>

  export type inducks_statcharactercountrySelectScalar = {
    charactercode?: boolean
    countrycode?: boolean
    total?: boolean
  }


  export type $inducks_statcharactercountryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_statcharactercountry"
    objects: {}
    scalars: $Extensions.GetResult<{
      charactercode: string
      countrycode: string
      total: number | null
    }, ExtArgs["result"]["inducks_statcharactercountry"]>
    composites: {}
  }


  type inducks_statcharactercountryGetPayload<S extends boolean | null | undefined | inducks_statcharactercountryDefaultArgs> = $Result.GetResult<Prisma.$inducks_statcharactercountryPayload, S>

  type inducks_statcharactercountryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_statcharactercountryFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_statcharactercountryCountAggregateInputType | true
    }

  export interface inducks_statcharactercountryDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_statcharactercountry'], meta: { name: 'inducks_statcharactercountry' } }
    /**
     * Find zero or one Inducks_statcharactercountry that matches the filter.
     * @param {inducks_statcharactercountryFindUniqueArgs} args - Arguments to find a Inducks_statcharactercountry
     * @example
     * // Get one Inducks_statcharactercountry
     * const inducks_statcharactercountry = await prisma.inducks_statcharactercountry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_statcharactercountryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statcharactercountryFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_statcharactercountryClient<$Result.GetResult<Prisma.$inducks_statcharactercountryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_statcharactercountry that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_statcharactercountryFindUniqueOrThrowArgs} args - Arguments to find a Inducks_statcharactercountry
     * @example
     * // Get one Inducks_statcharactercountry
     * const inducks_statcharactercountry = await prisma.inducks_statcharactercountry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_statcharactercountryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statcharactercountryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_statcharactercountryClient<$Result.GetResult<Prisma.$inducks_statcharactercountryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_statcharactercountry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statcharactercountryFindFirstArgs} args - Arguments to find a Inducks_statcharactercountry
     * @example
     * // Get one Inducks_statcharactercountry
     * const inducks_statcharactercountry = await prisma.inducks_statcharactercountry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_statcharactercountryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statcharactercountryFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_statcharactercountryClient<$Result.GetResult<Prisma.$inducks_statcharactercountryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_statcharactercountry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statcharactercountryFindFirstOrThrowArgs} args - Arguments to find a Inducks_statcharactercountry
     * @example
     * // Get one Inducks_statcharactercountry
     * const inducks_statcharactercountry = await prisma.inducks_statcharactercountry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_statcharactercountryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statcharactercountryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_statcharactercountryClient<$Result.GetResult<Prisma.$inducks_statcharactercountryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_statcharactercountries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statcharactercountryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_statcharactercountries
     * const inducks_statcharactercountries = await prisma.inducks_statcharactercountry.findMany()
     * 
     * // Get first 10 Inducks_statcharactercountries
     * const inducks_statcharactercountries = await prisma.inducks_statcharactercountry.findMany({ take: 10 })
     * 
     * // Only select the `charactercode`
     * const inducks_statcharactercountryWithCharactercodeOnly = await prisma.inducks_statcharactercountry.findMany({ select: { charactercode: true } })
     * 
    **/
    findMany<T extends inducks_statcharactercountryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statcharactercountryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_statcharactercountryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_statcharactercountry.
     * @param {inducks_statcharactercountryCreateArgs} args - Arguments to create a Inducks_statcharactercountry.
     * @example
     * // Create one Inducks_statcharactercountry
     * const Inducks_statcharactercountry = await prisma.inducks_statcharactercountry.create({
     *   data: {
     *     // ... data to create a Inducks_statcharactercountry
     *   }
     * })
     * 
    **/
    create<T extends inducks_statcharactercountryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statcharactercountryCreateArgs<ExtArgs>>
    ): Prisma__inducks_statcharactercountryClient<$Result.GetResult<Prisma.$inducks_statcharactercountryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_statcharactercountries.
     *     @param {inducks_statcharactercountryCreateManyArgs} args - Arguments to create many Inducks_statcharactercountries.
     *     @example
     *     // Create many Inducks_statcharactercountries
     *     const inducks_statcharactercountry = await prisma.inducks_statcharactercountry.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_statcharactercountryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statcharactercountryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_statcharactercountry.
     * @param {inducks_statcharactercountryDeleteArgs} args - Arguments to delete one Inducks_statcharactercountry.
     * @example
     * // Delete one Inducks_statcharactercountry
     * const Inducks_statcharactercountry = await prisma.inducks_statcharactercountry.delete({
     *   where: {
     *     // ... filter to delete one Inducks_statcharactercountry
     *   }
     * })
     * 
    **/
    delete<T extends inducks_statcharactercountryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statcharactercountryDeleteArgs<ExtArgs>>
    ): Prisma__inducks_statcharactercountryClient<$Result.GetResult<Prisma.$inducks_statcharactercountryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_statcharactercountry.
     * @param {inducks_statcharactercountryUpdateArgs} args - Arguments to update one Inducks_statcharactercountry.
     * @example
     * // Update one Inducks_statcharactercountry
     * const inducks_statcharactercountry = await prisma.inducks_statcharactercountry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_statcharactercountryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statcharactercountryUpdateArgs<ExtArgs>>
    ): Prisma__inducks_statcharactercountryClient<$Result.GetResult<Prisma.$inducks_statcharactercountryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_statcharactercountries.
     * @param {inducks_statcharactercountryDeleteManyArgs} args - Arguments to filter Inducks_statcharactercountries to delete.
     * @example
     * // Delete a few Inducks_statcharactercountries
     * const { count } = await prisma.inducks_statcharactercountry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_statcharactercountryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statcharactercountryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_statcharactercountries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statcharactercountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_statcharactercountries
     * const inducks_statcharactercountry = await prisma.inducks_statcharactercountry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_statcharactercountryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statcharactercountryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_statcharactercountry.
     * @param {inducks_statcharactercountryUpsertArgs} args - Arguments to update or create a Inducks_statcharactercountry.
     * @example
     * // Update or create a Inducks_statcharactercountry
     * const inducks_statcharactercountry = await prisma.inducks_statcharactercountry.upsert({
     *   create: {
     *     // ... data to create a Inducks_statcharactercountry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_statcharactercountry we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_statcharactercountryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statcharactercountryUpsertArgs<ExtArgs>>
    ): Prisma__inducks_statcharactercountryClient<$Result.GetResult<Prisma.$inducks_statcharactercountryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_statcharactercountries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statcharactercountryCountArgs} args - Arguments to filter Inducks_statcharactercountries to count.
     * @example
     * // Count the number of Inducks_statcharactercountries
     * const count = await prisma.inducks_statcharactercountry.count({
     *   where: {
     *     // ... the filter for the Inducks_statcharactercountries we want to count
     *   }
     * })
    **/
    count<T extends inducks_statcharactercountryCountArgs>(
      args?: Subset<T, inducks_statcharactercountryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_statcharactercountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_statcharactercountry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_statcharactercountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_statcharactercountryAggregateArgs>(args: Subset<T, Inducks_statcharactercountryAggregateArgs>): Prisma.PrismaPromise<GetInducks_statcharactercountryAggregateType<T>>

    /**
     * Group by Inducks_statcharactercountry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statcharactercountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_statcharactercountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_statcharactercountryGroupByArgs['orderBy'] }
        : { orderBy?: inducks_statcharactercountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_statcharactercountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_statcharactercountryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_statcharactercountry model
   */
  readonly fields: inducks_statcharactercountryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_statcharactercountry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_statcharactercountryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_statcharactercountry model
   */ 
  interface inducks_statcharactercountryFieldRefs {
    readonly charactercode: FieldRef<"inducks_statcharactercountry", 'String'>
    readonly countrycode: FieldRef<"inducks_statcharactercountry", 'String'>
    readonly total: FieldRef<"inducks_statcharactercountry", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * inducks_statcharactercountry findUnique
   */
  export type inducks_statcharactercountryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statcharactercountry
     */
    select?: inducks_statcharactercountrySelect<ExtArgs> | null
    /**
     * Filter, which inducks_statcharactercountry to fetch.
     */
    where: inducks_statcharactercountryWhereUniqueInput
  }


  /**
   * inducks_statcharactercountry findUniqueOrThrow
   */
  export type inducks_statcharactercountryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statcharactercountry
     */
    select?: inducks_statcharactercountrySelect<ExtArgs> | null
    /**
     * Filter, which inducks_statcharactercountry to fetch.
     */
    where: inducks_statcharactercountryWhereUniqueInput
  }


  /**
   * inducks_statcharactercountry findFirst
   */
  export type inducks_statcharactercountryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statcharactercountry
     */
    select?: inducks_statcharactercountrySelect<ExtArgs> | null
    /**
     * Filter, which inducks_statcharactercountry to fetch.
     */
    where?: inducks_statcharactercountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_statcharactercountries to fetch.
     */
    orderBy?: inducks_statcharactercountryOrderByWithRelationInput | inducks_statcharactercountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_statcharactercountries.
     */
    cursor?: inducks_statcharactercountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_statcharactercountries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_statcharactercountries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_statcharactercountries.
     */
    distinct?: Inducks_statcharactercountryScalarFieldEnum | Inducks_statcharactercountryScalarFieldEnum[]
  }


  /**
   * inducks_statcharactercountry findFirstOrThrow
   */
  export type inducks_statcharactercountryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statcharactercountry
     */
    select?: inducks_statcharactercountrySelect<ExtArgs> | null
    /**
     * Filter, which inducks_statcharactercountry to fetch.
     */
    where?: inducks_statcharactercountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_statcharactercountries to fetch.
     */
    orderBy?: inducks_statcharactercountryOrderByWithRelationInput | inducks_statcharactercountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_statcharactercountries.
     */
    cursor?: inducks_statcharactercountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_statcharactercountries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_statcharactercountries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_statcharactercountries.
     */
    distinct?: Inducks_statcharactercountryScalarFieldEnum | Inducks_statcharactercountryScalarFieldEnum[]
  }


  /**
   * inducks_statcharactercountry findMany
   */
  export type inducks_statcharactercountryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statcharactercountry
     */
    select?: inducks_statcharactercountrySelect<ExtArgs> | null
    /**
     * Filter, which inducks_statcharactercountries to fetch.
     */
    where?: inducks_statcharactercountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_statcharactercountries to fetch.
     */
    orderBy?: inducks_statcharactercountryOrderByWithRelationInput | inducks_statcharactercountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_statcharactercountries.
     */
    cursor?: inducks_statcharactercountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_statcharactercountries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_statcharactercountries.
     */
    skip?: number
    distinct?: Inducks_statcharactercountryScalarFieldEnum | Inducks_statcharactercountryScalarFieldEnum[]
  }


  /**
   * inducks_statcharactercountry create
   */
  export type inducks_statcharactercountryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statcharactercountry
     */
    select?: inducks_statcharactercountrySelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_statcharactercountry.
     */
    data: XOR<inducks_statcharactercountryCreateInput, inducks_statcharactercountryUncheckedCreateInput>
  }


  /**
   * inducks_statcharactercountry createMany
   */
  export type inducks_statcharactercountryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_statcharactercountries.
     */
    data: inducks_statcharactercountryCreateManyInput | inducks_statcharactercountryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_statcharactercountry update
   */
  export type inducks_statcharactercountryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statcharactercountry
     */
    select?: inducks_statcharactercountrySelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_statcharactercountry.
     */
    data: XOR<inducks_statcharactercountryUpdateInput, inducks_statcharactercountryUncheckedUpdateInput>
    /**
     * Choose, which inducks_statcharactercountry to update.
     */
    where: inducks_statcharactercountryWhereUniqueInput
  }


  /**
   * inducks_statcharactercountry updateMany
   */
  export type inducks_statcharactercountryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_statcharactercountries.
     */
    data: XOR<inducks_statcharactercountryUpdateManyMutationInput, inducks_statcharactercountryUncheckedUpdateManyInput>
    /**
     * Filter which inducks_statcharactercountries to update
     */
    where?: inducks_statcharactercountryWhereInput
  }


  /**
   * inducks_statcharactercountry upsert
   */
  export type inducks_statcharactercountryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statcharactercountry
     */
    select?: inducks_statcharactercountrySelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_statcharactercountry to update in case it exists.
     */
    where: inducks_statcharactercountryWhereUniqueInput
    /**
     * In case the inducks_statcharactercountry found by the `where` argument doesn't exist, create a new inducks_statcharactercountry with this data.
     */
    create: XOR<inducks_statcharactercountryCreateInput, inducks_statcharactercountryUncheckedCreateInput>
    /**
     * In case the inducks_statcharactercountry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_statcharactercountryUpdateInput, inducks_statcharactercountryUncheckedUpdateInput>
  }


  /**
   * inducks_statcharactercountry delete
   */
  export type inducks_statcharactercountryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statcharactercountry
     */
    select?: inducks_statcharactercountrySelect<ExtArgs> | null
    /**
     * Filter which inducks_statcharactercountry to delete.
     */
    where: inducks_statcharactercountryWhereUniqueInput
  }


  /**
   * inducks_statcharactercountry deleteMany
   */
  export type inducks_statcharactercountryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_statcharactercountries to delete
     */
    where?: inducks_statcharactercountryWhereInput
  }


  /**
   * inducks_statcharactercountry without action
   */
  export type inducks_statcharactercountryDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statcharactercountry
     */
    select?: inducks_statcharactercountrySelect<ExtArgs> | null
  }



  /**
   * Model inducks_statcharacterstory
   */

  export type AggregateInducks_statcharacterstory = {
    _count: Inducks_statcharacterstoryCountAggregateOutputType | null
    _avg: Inducks_statcharacterstoryAvgAggregateOutputType | null
    _sum: Inducks_statcharacterstorySumAggregateOutputType | null
    _min: Inducks_statcharacterstoryMinAggregateOutputType | null
    _max: Inducks_statcharacterstoryMaxAggregateOutputType | null
  }

  export type Inducks_statcharacterstoryAvgAggregateOutputType = {
    total: number | null
  }

  export type Inducks_statcharacterstorySumAggregateOutputType = {
    total: number | null
  }

  export type Inducks_statcharacterstoryMinAggregateOutputType = {
    charactercode: string | null
    storyheadercode: string | null
    total: number | null
    yearrange: string | null
  }

  export type Inducks_statcharacterstoryMaxAggregateOutputType = {
    charactercode: string | null
    storyheadercode: string | null
    total: number | null
    yearrange: string | null
  }

  export type Inducks_statcharacterstoryCountAggregateOutputType = {
    charactercode: number
    storyheadercode: number
    total: number
    yearrange: number
    _all: number
  }


  export type Inducks_statcharacterstoryAvgAggregateInputType = {
    total?: true
  }

  export type Inducks_statcharacterstorySumAggregateInputType = {
    total?: true
  }

  export type Inducks_statcharacterstoryMinAggregateInputType = {
    charactercode?: true
    storyheadercode?: true
    total?: true
    yearrange?: true
  }

  export type Inducks_statcharacterstoryMaxAggregateInputType = {
    charactercode?: true
    storyheadercode?: true
    total?: true
    yearrange?: true
  }

  export type Inducks_statcharacterstoryCountAggregateInputType = {
    charactercode?: true
    storyheadercode?: true
    total?: true
    yearrange?: true
    _all?: true
  }

  export type Inducks_statcharacterstoryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_statcharacterstory to aggregate.
     */
    where?: inducks_statcharacterstoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_statcharacterstories to fetch.
     */
    orderBy?: inducks_statcharacterstoryOrderByWithRelationInput | inducks_statcharacterstoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_statcharacterstoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_statcharacterstories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_statcharacterstories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_statcharacterstories
    **/
    _count?: true | Inducks_statcharacterstoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Inducks_statcharacterstoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Inducks_statcharacterstorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_statcharacterstoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_statcharacterstoryMaxAggregateInputType
  }

  export type GetInducks_statcharacterstoryAggregateType<T extends Inducks_statcharacterstoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_statcharacterstory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_statcharacterstory[P]>
      : GetScalarType<T[P], AggregateInducks_statcharacterstory[P]>
  }




  export type inducks_statcharacterstoryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_statcharacterstoryWhereInput
    orderBy?: inducks_statcharacterstoryOrderByWithAggregationInput | inducks_statcharacterstoryOrderByWithAggregationInput[]
    by: Inducks_statcharacterstoryScalarFieldEnum[] | Inducks_statcharacterstoryScalarFieldEnum
    having?: inducks_statcharacterstoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_statcharacterstoryCountAggregateInputType | true
    _avg?: Inducks_statcharacterstoryAvgAggregateInputType
    _sum?: Inducks_statcharacterstorySumAggregateInputType
    _min?: Inducks_statcharacterstoryMinAggregateInputType
    _max?: Inducks_statcharacterstoryMaxAggregateInputType
  }

  export type Inducks_statcharacterstoryGroupByOutputType = {
    charactercode: string
    storyheadercode: string
    total: number | null
    yearrange: string | null
    _count: Inducks_statcharacterstoryCountAggregateOutputType | null
    _avg: Inducks_statcharacterstoryAvgAggregateOutputType | null
    _sum: Inducks_statcharacterstorySumAggregateOutputType | null
    _min: Inducks_statcharacterstoryMinAggregateOutputType | null
    _max: Inducks_statcharacterstoryMaxAggregateOutputType | null
  }

  type GetInducks_statcharacterstoryGroupByPayload<T extends inducks_statcharacterstoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_statcharacterstoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_statcharacterstoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_statcharacterstoryGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_statcharacterstoryGroupByOutputType[P]>
        }
      >
    >


  export type inducks_statcharacterstorySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    charactercode?: boolean
    storyheadercode?: boolean
    total?: boolean
    yearrange?: boolean
  }, ExtArgs["result"]["inducks_statcharacterstory"]>

  export type inducks_statcharacterstorySelectScalar = {
    charactercode?: boolean
    storyheadercode?: boolean
    total?: boolean
    yearrange?: boolean
  }


  export type $inducks_statcharacterstoryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_statcharacterstory"
    objects: {}
    scalars: $Extensions.GetResult<{
      charactercode: string
      storyheadercode: string
      total: number | null
      yearrange: string | null
    }, ExtArgs["result"]["inducks_statcharacterstory"]>
    composites: {}
  }


  type inducks_statcharacterstoryGetPayload<S extends boolean | null | undefined | inducks_statcharacterstoryDefaultArgs> = $Result.GetResult<Prisma.$inducks_statcharacterstoryPayload, S>

  type inducks_statcharacterstoryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_statcharacterstoryFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_statcharacterstoryCountAggregateInputType | true
    }

  export interface inducks_statcharacterstoryDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_statcharacterstory'], meta: { name: 'inducks_statcharacterstory' } }
    /**
     * Find zero or one Inducks_statcharacterstory that matches the filter.
     * @param {inducks_statcharacterstoryFindUniqueArgs} args - Arguments to find a Inducks_statcharacterstory
     * @example
     * // Get one Inducks_statcharacterstory
     * const inducks_statcharacterstory = await prisma.inducks_statcharacterstory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_statcharacterstoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statcharacterstoryFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_statcharacterstoryClient<$Result.GetResult<Prisma.$inducks_statcharacterstoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_statcharacterstory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_statcharacterstoryFindUniqueOrThrowArgs} args - Arguments to find a Inducks_statcharacterstory
     * @example
     * // Get one Inducks_statcharacterstory
     * const inducks_statcharacterstory = await prisma.inducks_statcharacterstory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_statcharacterstoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statcharacterstoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_statcharacterstoryClient<$Result.GetResult<Prisma.$inducks_statcharacterstoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_statcharacterstory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statcharacterstoryFindFirstArgs} args - Arguments to find a Inducks_statcharacterstory
     * @example
     * // Get one Inducks_statcharacterstory
     * const inducks_statcharacterstory = await prisma.inducks_statcharacterstory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_statcharacterstoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statcharacterstoryFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_statcharacterstoryClient<$Result.GetResult<Prisma.$inducks_statcharacterstoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_statcharacterstory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statcharacterstoryFindFirstOrThrowArgs} args - Arguments to find a Inducks_statcharacterstory
     * @example
     * // Get one Inducks_statcharacterstory
     * const inducks_statcharacterstory = await prisma.inducks_statcharacterstory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_statcharacterstoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statcharacterstoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_statcharacterstoryClient<$Result.GetResult<Prisma.$inducks_statcharacterstoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_statcharacterstories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statcharacterstoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_statcharacterstories
     * const inducks_statcharacterstories = await prisma.inducks_statcharacterstory.findMany()
     * 
     * // Get first 10 Inducks_statcharacterstories
     * const inducks_statcharacterstories = await prisma.inducks_statcharacterstory.findMany({ take: 10 })
     * 
     * // Only select the `charactercode`
     * const inducks_statcharacterstoryWithCharactercodeOnly = await prisma.inducks_statcharacterstory.findMany({ select: { charactercode: true } })
     * 
    **/
    findMany<T extends inducks_statcharacterstoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statcharacterstoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_statcharacterstoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_statcharacterstory.
     * @param {inducks_statcharacterstoryCreateArgs} args - Arguments to create a Inducks_statcharacterstory.
     * @example
     * // Create one Inducks_statcharacterstory
     * const Inducks_statcharacterstory = await prisma.inducks_statcharacterstory.create({
     *   data: {
     *     // ... data to create a Inducks_statcharacterstory
     *   }
     * })
     * 
    **/
    create<T extends inducks_statcharacterstoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statcharacterstoryCreateArgs<ExtArgs>>
    ): Prisma__inducks_statcharacterstoryClient<$Result.GetResult<Prisma.$inducks_statcharacterstoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_statcharacterstories.
     *     @param {inducks_statcharacterstoryCreateManyArgs} args - Arguments to create many Inducks_statcharacterstories.
     *     @example
     *     // Create many Inducks_statcharacterstories
     *     const inducks_statcharacterstory = await prisma.inducks_statcharacterstory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_statcharacterstoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statcharacterstoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_statcharacterstory.
     * @param {inducks_statcharacterstoryDeleteArgs} args - Arguments to delete one Inducks_statcharacterstory.
     * @example
     * // Delete one Inducks_statcharacterstory
     * const Inducks_statcharacterstory = await prisma.inducks_statcharacterstory.delete({
     *   where: {
     *     // ... filter to delete one Inducks_statcharacterstory
     *   }
     * })
     * 
    **/
    delete<T extends inducks_statcharacterstoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statcharacterstoryDeleteArgs<ExtArgs>>
    ): Prisma__inducks_statcharacterstoryClient<$Result.GetResult<Prisma.$inducks_statcharacterstoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_statcharacterstory.
     * @param {inducks_statcharacterstoryUpdateArgs} args - Arguments to update one Inducks_statcharacterstory.
     * @example
     * // Update one Inducks_statcharacterstory
     * const inducks_statcharacterstory = await prisma.inducks_statcharacterstory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_statcharacterstoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statcharacterstoryUpdateArgs<ExtArgs>>
    ): Prisma__inducks_statcharacterstoryClient<$Result.GetResult<Prisma.$inducks_statcharacterstoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_statcharacterstories.
     * @param {inducks_statcharacterstoryDeleteManyArgs} args - Arguments to filter Inducks_statcharacterstories to delete.
     * @example
     * // Delete a few Inducks_statcharacterstories
     * const { count } = await prisma.inducks_statcharacterstory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_statcharacterstoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statcharacterstoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_statcharacterstories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statcharacterstoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_statcharacterstories
     * const inducks_statcharacterstory = await prisma.inducks_statcharacterstory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_statcharacterstoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statcharacterstoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_statcharacterstory.
     * @param {inducks_statcharacterstoryUpsertArgs} args - Arguments to update or create a Inducks_statcharacterstory.
     * @example
     * // Update or create a Inducks_statcharacterstory
     * const inducks_statcharacterstory = await prisma.inducks_statcharacterstory.upsert({
     *   create: {
     *     // ... data to create a Inducks_statcharacterstory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_statcharacterstory we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_statcharacterstoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statcharacterstoryUpsertArgs<ExtArgs>>
    ): Prisma__inducks_statcharacterstoryClient<$Result.GetResult<Prisma.$inducks_statcharacterstoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_statcharacterstories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statcharacterstoryCountArgs} args - Arguments to filter Inducks_statcharacterstories to count.
     * @example
     * // Count the number of Inducks_statcharacterstories
     * const count = await prisma.inducks_statcharacterstory.count({
     *   where: {
     *     // ... the filter for the Inducks_statcharacterstories we want to count
     *   }
     * })
    **/
    count<T extends inducks_statcharacterstoryCountArgs>(
      args?: Subset<T, inducks_statcharacterstoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_statcharacterstoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_statcharacterstory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_statcharacterstoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_statcharacterstoryAggregateArgs>(args: Subset<T, Inducks_statcharacterstoryAggregateArgs>): Prisma.PrismaPromise<GetInducks_statcharacterstoryAggregateType<T>>

    /**
     * Group by Inducks_statcharacterstory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statcharacterstoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_statcharacterstoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_statcharacterstoryGroupByArgs['orderBy'] }
        : { orderBy?: inducks_statcharacterstoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_statcharacterstoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_statcharacterstoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_statcharacterstory model
   */
  readonly fields: inducks_statcharacterstoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_statcharacterstory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_statcharacterstoryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_statcharacterstory model
   */ 
  interface inducks_statcharacterstoryFieldRefs {
    readonly charactercode: FieldRef<"inducks_statcharacterstory", 'String'>
    readonly storyheadercode: FieldRef<"inducks_statcharacterstory", 'String'>
    readonly total: FieldRef<"inducks_statcharacterstory", 'Int'>
    readonly yearrange: FieldRef<"inducks_statcharacterstory", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_statcharacterstory findUnique
   */
  export type inducks_statcharacterstoryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statcharacterstory
     */
    select?: inducks_statcharacterstorySelect<ExtArgs> | null
    /**
     * Filter, which inducks_statcharacterstory to fetch.
     */
    where: inducks_statcharacterstoryWhereUniqueInput
  }


  /**
   * inducks_statcharacterstory findUniqueOrThrow
   */
  export type inducks_statcharacterstoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statcharacterstory
     */
    select?: inducks_statcharacterstorySelect<ExtArgs> | null
    /**
     * Filter, which inducks_statcharacterstory to fetch.
     */
    where: inducks_statcharacterstoryWhereUniqueInput
  }


  /**
   * inducks_statcharacterstory findFirst
   */
  export type inducks_statcharacterstoryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statcharacterstory
     */
    select?: inducks_statcharacterstorySelect<ExtArgs> | null
    /**
     * Filter, which inducks_statcharacterstory to fetch.
     */
    where?: inducks_statcharacterstoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_statcharacterstories to fetch.
     */
    orderBy?: inducks_statcharacterstoryOrderByWithRelationInput | inducks_statcharacterstoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_statcharacterstories.
     */
    cursor?: inducks_statcharacterstoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_statcharacterstories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_statcharacterstories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_statcharacterstories.
     */
    distinct?: Inducks_statcharacterstoryScalarFieldEnum | Inducks_statcharacterstoryScalarFieldEnum[]
  }


  /**
   * inducks_statcharacterstory findFirstOrThrow
   */
  export type inducks_statcharacterstoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statcharacterstory
     */
    select?: inducks_statcharacterstorySelect<ExtArgs> | null
    /**
     * Filter, which inducks_statcharacterstory to fetch.
     */
    where?: inducks_statcharacterstoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_statcharacterstories to fetch.
     */
    orderBy?: inducks_statcharacterstoryOrderByWithRelationInput | inducks_statcharacterstoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_statcharacterstories.
     */
    cursor?: inducks_statcharacterstoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_statcharacterstories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_statcharacterstories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_statcharacterstories.
     */
    distinct?: Inducks_statcharacterstoryScalarFieldEnum | Inducks_statcharacterstoryScalarFieldEnum[]
  }


  /**
   * inducks_statcharacterstory findMany
   */
  export type inducks_statcharacterstoryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statcharacterstory
     */
    select?: inducks_statcharacterstorySelect<ExtArgs> | null
    /**
     * Filter, which inducks_statcharacterstories to fetch.
     */
    where?: inducks_statcharacterstoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_statcharacterstories to fetch.
     */
    orderBy?: inducks_statcharacterstoryOrderByWithRelationInput | inducks_statcharacterstoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_statcharacterstories.
     */
    cursor?: inducks_statcharacterstoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_statcharacterstories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_statcharacterstories.
     */
    skip?: number
    distinct?: Inducks_statcharacterstoryScalarFieldEnum | Inducks_statcharacterstoryScalarFieldEnum[]
  }


  /**
   * inducks_statcharacterstory create
   */
  export type inducks_statcharacterstoryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statcharacterstory
     */
    select?: inducks_statcharacterstorySelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_statcharacterstory.
     */
    data: XOR<inducks_statcharacterstoryCreateInput, inducks_statcharacterstoryUncheckedCreateInput>
  }


  /**
   * inducks_statcharacterstory createMany
   */
  export type inducks_statcharacterstoryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_statcharacterstories.
     */
    data: inducks_statcharacterstoryCreateManyInput | inducks_statcharacterstoryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_statcharacterstory update
   */
  export type inducks_statcharacterstoryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statcharacterstory
     */
    select?: inducks_statcharacterstorySelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_statcharacterstory.
     */
    data: XOR<inducks_statcharacterstoryUpdateInput, inducks_statcharacterstoryUncheckedUpdateInput>
    /**
     * Choose, which inducks_statcharacterstory to update.
     */
    where: inducks_statcharacterstoryWhereUniqueInput
  }


  /**
   * inducks_statcharacterstory updateMany
   */
  export type inducks_statcharacterstoryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_statcharacterstories.
     */
    data: XOR<inducks_statcharacterstoryUpdateManyMutationInput, inducks_statcharacterstoryUncheckedUpdateManyInput>
    /**
     * Filter which inducks_statcharacterstories to update
     */
    where?: inducks_statcharacterstoryWhereInput
  }


  /**
   * inducks_statcharacterstory upsert
   */
  export type inducks_statcharacterstoryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statcharacterstory
     */
    select?: inducks_statcharacterstorySelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_statcharacterstory to update in case it exists.
     */
    where: inducks_statcharacterstoryWhereUniqueInput
    /**
     * In case the inducks_statcharacterstory found by the `where` argument doesn't exist, create a new inducks_statcharacterstory with this data.
     */
    create: XOR<inducks_statcharacterstoryCreateInput, inducks_statcharacterstoryUncheckedCreateInput>
    /**
     * In case the inducks_statcharacterstory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_statcharacterstoryUpdateInput, inducks_statcharacterstoryUncheckedUpdateInput>
  }


  /**
   * inducks_statcharacterstory delete
   */
  export type inducks_statcharacterstoryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statcharacterstory
     */
    select?: inducks_statcharacterstorySelect<ExtArgs> | null
    /**
     * Filter which inducks_statcharacterstory to delete.
     */
    where: inducks_statcharacterstoryWhereUniqueInput
  }


  /**
   * inducks_statcharacterstory deleteMany
   */
  export type inducks_statcharacterstoryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_statcharacterstories to delete
     */
    where?: inducks_statcharacterstoryWhereInput
  }


  /**
   * inducks_statcharacterstory without action
   */
  export type inducks_statcharacterstoryDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statcharacterstory
     */
    select?: inducks_statcharacterstorySelect<ExtArgs> | null
  }



  /**
   * Model inducks_statpersoncharacter
   */

  export type AggregateInducks_statpersoncharacter = {
    _count: Inducks_statpersoncharacterCountAggregateOutputType | null
    _avg: Inducks_statpersoncharacterAvgAggregateOutputType | null
    _sum: Inducks_statpersoncharacterSumAggregateOutputType | null
    _min: Inducks_statpersoncharacterMinAggregateOutputType | null
    _max: Inducks_statpersoncharacterMaxAggregateOutputType | null
  }

  export type Inducks_statpersoncharacterAvgAggregateOutputType = {
    total: number | null
  }

  export type Inducks_statpersoncharacterSumAggregateOutputType = {
    total: number | null
  }

  export type Inducks_statpersoncharacterMinAggregateOutputType = {
    personcode: string | null
    charactercode: string | null
    total: number | null
    yearrange: string | null
  }

  export type Inducks_statpersoncharacterMaxAggregateOutputType = {
    personcode: string | null
    charactercode: string | null
    total: number | null
    yearrange: string | null
  }

  export type Inducks_statpersoncharacterCountAggregateOutputType = {
    personcode: number
    charactercode: number
    total: number
    yearrange: number
    _all: number
  }


  export type Inducks_statpersoncharacterAvgAggregateInputType = {
    total?: true
  }

  export type Inducks_statpersoncharacterSumAggregateInputType = {
    total?: true
  }

  export type Inducks_statpersoncharacterMinAggregateInputType = {
    personcode?: true
    charactercode?: true
    total?: true
    yearrange?: true
  }

  export type Inducks_statpersoncharacterMaxAggregateInputType = {
    personcode?: true
    charactercode?: true
    total?: true
    yearrange?: true
  }

  export type Inducks_statpersoncharacterCountAggregateInputType = {
    personcode?: true
    charactercode?: true
    total?: true
    yearrange?: true
    _all?: true
  }

  export type Inducks_statpersoncharacterAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_statpersoncharacter to aggregate.
     */
    where?: inducks_statpersoncharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_statpersoncharacters to fetch.
     */
    orderBy?: inducks_statpersoncharacterOrderByWithRelationInput | inducks_statpersoncharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_statpersoncharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_statpersoncharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_statpersoncharacters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_statpersoncharacters
    **/
    _count?: true | Inducks_statpersoncharacterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Inducks_statpersoncharacterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Inducks_statpersoncharacterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_statpersoncharacterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_statpersoncharacterMaxAggregateInputType
  }

  export type GetInducks_statpersoncharacterAggregateType<T extends Inducks_statpersoncharacterAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_statpersoncharacter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_statpersoncharacter[P]>
      : GetScalarType<T[P], AggregateInducks_statpersoncharacter[P]>
  }




  export type inducks_statpersoncharacterGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_statpersoncharacterWhereInput
    orderBy?: inducks_statpersoncharacterOrderByWithAggregationInput | inducks_statpersoncharacterOrderByWithAggregationInput[]
    by: Inducks_statpersoncharacterScalarFieldEnum[] | Inducks_statpersoncharacterScalarFieldEnum
    having?: inducks_statpersoncharacterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_statpersoncharacterCountAggregateInputType | true
    _avg?: Inducks_statpersoncharacterAvgAggregateInputType
    _sum?: Inducks_statpersoncharacterSumAggregateInputType
    _min?: Inducks_statpersoncharacterMinAggregateInputType
    _max?: Inducks_statpersoncharacterMaxAggregateInputType
  }

  export type Inducks_statpersoncharacterGroupByOutputType = {
    personcode: string
    charactercode: string | null
    total: number
    yearrange: string | null
    _count: Inducks_statpersoncharacterCountAggregateOutputType | null
    _avg: Inducks_statpersoncharacterAvgAggregateOutputType | null
    _sum: Inducks_statpersoncharacterSumAggregateOutputType | null
    _min: Inducks_statpersoncharacterMinAggregateOutputType | null
    _max: Inducks_statpersoncharacterMaxAggregateOutputType | null
  }

  type GetInducks_statpersoncharacterGroupByPayload<T extends inducks_statpersoncharacterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_statpersoncharacterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_statpersoncharacterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_statpersoncharacterGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_statpersoncharacterGroupByOutputType[P]>
        }
      >
    >


  export type inducks_statpersoncharacterSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    personcode?: boolean
    charactercode?: boolean
    total?: boolean
    yearrange?: boolean
  }, ExtArgs["result"]["inducks_statpersoncharacter"]>

  export type inducks_statpersoncharacterSelectScalar = {
    personcode?: boolean
    charactercode?: boolean
    total?: boolean
    yearrange?: boolean
  }


  export type $inducks_statpersoncharacterPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_statpersoncharacter"
    objects: {}
    scalars: $Extensions.GetResult<{
      personcode: string
      charactercode: string | null
      total: number
      yearrange: string | null
    }, ExtArgs["result"]["inducks_statpersoncharacter"]>
    composites: {}
  }


  type inducks_statpersoncharacterGetPayload<S extends boolean | null | undefined | inducks_statpersoncharacterDefaultArgs> = $Result.GetResult<Prisma.$inducks_statpersoncharacterPayload, S>

  type inducks_statpersoncharacterCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_statpersoncharacterFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_statpersoncharacterCountAggregateInputType | true
    }

  export interface inducks_statpersoncharacterDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_statpersoncharacter'], meta: { name: 'inducks_statpersoncharacter' } }
    /**
     * Find zero or one Inducks_statpersoncharacter that matches the filter.
     * @param {inducks_statpersoncharacterFindUniqueArgs} args - Arguments to find a Inducks_statpersoncharacter
     * @example
     * // Get one Inducks_statpersoncharacter
     * const inducks_statpersoncharacter = await prisma.inducks_statpersoncharacter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_statpersoncharacterFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statpersoncharacterFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_statpersoncharacterClient<$Result.GetResult<Prisma.$inducks_statpersoncharacterPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_statpersoncharacter that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_statpersoncharacterFindUniqueOrThrowArgs} args - Arguments to find a Inducks_statpersoncharacter
     * @example
     * // Get one Inducks_statpersoncharacter
     * const inducks_statpersoncharacter = await prisma.inducks_statpersoncharacter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_statpersoncharacterFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statpersoncharacterFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_statpersoncharacterClient<$Result.GetResult<Prisma.$inducks_statpersoncharacterPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_statpersoncharacter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statpersoncharacterFindFirstArgs} args - Arguments to find a Inducks_statpersoncharacter
     * @example
     * // Get one Inducks_statpersoncharacter
     * const inducks_statpersoncharacter = await prisma.inducks_statpersoncharacter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_statpersoncharacterFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statpersoncharacterFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_statpersoncharacterClient<$Result.GetResult<Prisma.$inducks_statpersoncharacterPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_statpersoncharacter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statpersoncharacterFindFirstOrThrowArgs} args - Arguments to find a Inducks_statpersoncharacter
     * @example
     * // Get one Inducks_statpersoncharacter
     * const inducks_statpersoncharacter = await prisma.inducks_statpersoncharacter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_statpersoncharacterFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statpersoncharacterFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_statpersoncharacterClient<$Result.GetResult<Prisma.$inducks_statpersoncharacterPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_statpersoncharacters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statpersoncharacterFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_statpersoncharacters
     * const inducks_statpersoncharacters = await prisma.inducks_statpersoncharacter.findMany()
     * 
     * // Get first 10 Inducks_statpersoncharacters
     * const inducks_statpersoncharacters = await prisma.inducks_statpersoncharacter.findMany({ take: 10 })
     * 
     * // Only select the `personcode`
     * const inducks_statpersoncharacterWithPersoncodeOnly = await prisma.inducks_statpersoncharacter.findMany({ select: { personcode: true } })
     * 
    **/
    findMany<T extends inducks_statpersoncharacterFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statpersoncharacterFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_statpersoncharacterPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_statpersoncharacter.
     * @param {inducks_statpersoncharacterCreateArgs} args - Arguments to create a Inducks_statpersoncharacter.
     * @example
     * // Create one Inducks_statpersoncharacter
     * const Inducks_statpersoncharacter = await prisma.inducks_statpersoncharacter.create({
     *   data: {
     *     // ... data to create a Inducks_statpersoncharacter
     *   }
     * })
     * 
    **/
    create<T extends inducks_statpersoncharacterCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statpersoncharacterCreateArgs<ExtArgs>>
    ): Prisma__inducks_statpersoncharacterClient<$Result.GetResult<Prisma.$inducks_statpersoncharacterPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_statpersoncharacters.
     *     @param {inducks_statpersoncharacterCreateManyArgs} args - Arguments to create many Inducks_statpersoncharacters.
     *     @example
     *     // Create many Inducks_statpersoncharacters
     *     const inducks_statpersoncharacter = await prisma.inducks_statpersoncharacter.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_statpersoncharacterCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statpersoncharacterCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_statpersoncharacter.
     * @param {inducks_statpersoncharacterDeleteArgs} args - Arguments to delete one Inducks_statpersoncharacter.
     * @example
     * // Delete one Inducks_statpersoncharacter
     * const Inducks_statpersoncharacter = await prisma.inducks_statpersoncharacter.delete({
     *   where: {
     *     // ... filter to delete one Inducks_statpersoncharacter
     *   }
     * })
     * 
    **/
    delete<T extends inducks_statpersoncharacterDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statpersoncharacterDeleteArgs<ExtArgs>>
    ): Prisma__inducks_statpersoncharacterClient<$Result.GetResult<Prisma.$inducks_statpersoncharacterPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_statpersoncharacter.
     * @param {inducks_statpersoncharacterUpdateArgs} args - Arguments to update one Inducks_statpersoncharacter.
     * @example
     * // Update one Inducks_statpersoncharacter
     * const inducks_statpersoncharacter = await prisma.inducks_statpersoncharacter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_statpersoncharacterUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statpersoncharacterUpdateArgs<ExtArgs>>
    ): Prisma__inducks_statpersoncharacterClient<$Result.GetResult<Prisma.$inducks_statpersoncharacterPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_statpersoncharacters.
     * @param {inducks_statpersoncharacterDeleteManyArgs} args - Arguments to filter Inducks_statpersoncharacters to delete.
     * @example
     * // Delete a few Inducks_statpersoncharacters
     * const { count } = await prisma.inducks_statpersoncharacter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_statpersoncharacterDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statpersoncharacterDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_statpersoncharacters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statpersoncharacterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_statpersoncharacters
     * const inducks_statpersoncharacter = await prisma.inducks_statpersoncharacter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_statpersoncharacterUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statpersoncharacterUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_statpersoncharacter.
     * @param {inducks_statpersoncharacterUpsertArgs} args - Arguments to update or create a Inducks_statpersoncharacter.
     * @example
     * // Update or create a Inducks_statpersoncharacter
     * const inducks_statpersoncharacter = await prisma.inducks_statpersoncharacter.upsert({
     *   create: {
     *     // ... data to create a Inducks_statpersoncharacter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_statpersoncharacter we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_statpersoncharacterUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statpersoncharacterUpsertArgs<ExtArgs>>
    ): Prisma__inducks_statpersoncharacterClient<$Result.GetResult<Prisma.$inducks_statpersoncharacterPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_statpersoncharacters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statpersoncharacterCountArgs} args - Arguments to filter Inducks_statpersoncharacters to count.
     * @example
     * // Count the number of Inducks_statpersoncharacters
     * const count = await prisma.inducks_statpersoncharacter.count({
     *   where: {
     *     // ... the filter for the Inducks_statpersoncharacters we want to count
     *   }
     * })
    **/
    count<T extends inducks_statpersoncharacterCountArgs>(
      args?: Subset<T, inducks_statpersoncharacterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_statpersoncharacterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_statpersoncharacter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_statpersoncharacterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_statpersoncharacterAggregateArgs>(args: Subset<T, Inducks_statpersoncharacterAggregateArgs>): Prisma.PrismaPromise<GetInducks_statpersoncharacterAggregateType<T>>

    /**
     * Group by Inducks_statpersoncharacter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statpersoncharacterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_statpersoncharacterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_statpersoncharacterGroupByArgs['orderBy'] }
        : { orderBy?: inducks_statpersoncharacterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_statpersoncharacterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_statpersoncharacterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_statpersoncharacter model
   */
  readonly fields: inducks_statpersoncharacterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_statpersoncharacter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_statpersoncharacterClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_statpersoncharacter model
   */ 
  interface inducks_statpersoncharacterFieldRefs {
    readonly personcode: FieldRef<"inducks_statpersoncharacter", 'String'>
    readonly charactercode: FieldRef<"inducks_statpersoncharacter", 'String'>
    readonly total: FieldRef<"inducks_statpersoncharacter", 'Int'>
    readonly yearrange: FieldRef<"inducks_statpersoncharacter", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_statpersoncharacter findUnique
   */
  export type inducks_statpersoncharacterFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersoncharacter
     */
    select?: inducks_statpersoncharacterSelect<ExtArgs> | null
    /**
     * Filter, which inducks_statpersoncharacter to fetch.
     */
    where: inducks_statpersoncharacterWhereUniqueInput
  }


  /**
   * inducks_statpersoncharacter findUniqueOrThrow
   */
  export type inducks_statpersoncharacterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersoncharacter
     */
    select?: inducks_statpersoncharacterSelect<ExtArgs> | null
    /**
     * Filter, which inducks_statpersoncharacter to fetch.
     */
    where: inducks_statpersoncharacterWhereUniqueInput
  }


  /**
   * inducks_statpersoncharacter findFirst
   */
  export type inducks_statpersoncharacterFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersoncharacter
     */
    select?: inducks_statpersoncharacterSelect<ExtArgs> | null
    /**
     * Filter, which inducks_statpersoncharacter to fetch.
     */
    where?: inducks_statpersoncharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_statpersoncharacters to fetch.
     */
    orderBy?: inducks_statpersoncharacterOrderByWithRelationInput | inducks_statpersoncharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_statpersoncharacters.
     */
    cursor?: inducks_statpersoncharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_statpersoncharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_statpersoncharacters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_statpersoncharacters.
     */
    distinct?: Inducks_statpersoncharacterScalarFieldEnum | Inducks_statpersoncharacterScalarFieldEnum[]
  }


  /**
   * inducks_statpersoncharacter findFirstOrThrow
   */
  export type inducks_statpersoncharacterFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersoncharacter
     */
    select?: inducks_statpersoncharacterSelect<ExtArgs> | null
    /**
     * Filter, which inducks_statpersoncharacter to fetch.
     */
    where?: inducks_statpersoncharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_statpersoncharacters to fetch.
     */
    orderBy?: inducks_statpersoncharacterOrderByWithRelationInput | inducks_statpersoncharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_statpersoncharacters.
     */
    cursor?: inducks_statpersoncharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_statpersoncharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_statpersoncharacters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_statpersoncharacters.
     */
    distinct?: Inducks_statpersoncharacterScalarFieldEnum | Inducks_statpersoncharacterScalarFieldEnum[]
  }


  /**
   * inducks_statpersoncharacter findMany
   */
  export type inducks_statpersoncharacterFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersoncharacter
     */
    select?: inducks_statpersoncharacterSelect<ExtArgs> | null
    /**
     * Filter, which inducks_statpersoncharacters to fetch.
     */
    where?: inducks_statpersoncharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_statpersoncharacters to fetch.
     */
    orderBy?: inducks_statpersoncharacterOrderByWithRelationInput | inducks_statpersoncharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_statpersoncharacters.
     */
    cursor?: inducks_statpersoncharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_statpersoncharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_statpersoncharacters.
     */
    skip?: number
    distinct?: Inducks_statpersoncharacterScalarFieldEnum | Inducks_statpersoncharacterScalarFieldEnum[]
  }


  /**
   * inducks_statpersoncharacter create
   */
  export type inducks_statpersoncharacterCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersoncharacter
     */
    select?: inducks_statpersoncharacterSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_statpersoncharacter.
     */
    data: XOR<inducks_statpersoncharacterCreateInput, inducks_statpersoncharacterUncheckedCreateInput>
  }


  /**
   * inducks_statpersoncharacter createMany
   */
  export type inducks_statpersoncharacterCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_statpersoncharacters.
     */
    data: inducks_statpersoncharacterCreateManyInput | inducks_statpersoncharacterCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_statpersoncharacter update
   */
  export type inducks_statpersoncharacterUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersoncharacter
     */
    select?: inducks_statpersoncharacterSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_statpersoncharacter.
     */
    data: XOR<inducks_statpersoncharacterUpdateInput, inducks_statpersoncharacterUncheckedUpdateInput>
    /**
     * Choose, which inducks_statpersoncharacter to update.
     */
    where: inducks_statpersoncharacterWhereUniqueInput
  }


  /**
   * inducks_statpersoncharacter updateMany
   */
  export type inducks_statpersoncharacterUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_statpersoncharacters.
     */
    data: XOR<inducks_statpersoncharacterUpdateManyMutationInput, inducks_statpersoncharacterUncheckedUpdateManyInput>
    /**
     * Filter which inducks_statpersoncharacters to update
     */
    where?: inducks_statpersoncharacterWhereInput
  }


  /**
   * inducks_statpersoncharacter upsert
   */
  export type inducks_statpersoncharacterUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersoncharacter
     */
    select?: inducks_statpersoncharacterSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_statpersoncharacter to update in case it exists.
     */
    where: inducks_statpersoncharacterWhereUniqueInput
    /**
     * In case the inducks_statpersoncharacter found by the `where` argument doesn't exist, create a new inducks_statpersoncharacter with this data.
     */
    create: XOR<inducks_statpersoncharacterCreateInput, inducks_statpersoncharacterUncheckedCreateInput>
    /**
     * In case the inducks_statpersoncharacter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_statpersoncharacterUpdateInput, inducks_statpersoncharacterUncheckedUpdateInput>
  }


  /**
   * inducks_statpersoncharacter delete
   */
  export type inducks_statpersoncharacterDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersoncharacter
     */
    select?: inducks_statpersoncharacterSelect<ExtArgs> | null
    /**
     * Filter which inducks_statpersoncharacter to delete.
     */
    where: inducks_statpersoncharacterWhereUniqueInput
  }


  /**
   * inducks_statpersoncharacter deleteMany
   */
  export type inducks_statpersoncharacterDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_statpersoncharacters to delete
     */
    where?: inducks_statpersoncharacterWhereInput
  }


  /**
   * inducks_statpersoncharacter without action
   */
  export type inducks_statpersoncharacterDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersoncharacter
     */
    select?: inducks_statpersoncharacterSelect<ExtArgs> | null
  }



  /**
   * Model inducks_statpersoncountry
   */

  export type AggregateInducks_statpersoncountry = {
    _count: Inducks_statpersoncountryCountAggregateOutputType | null
    _avg: Inducks_statpersoncountryAvgAggregateOutputType | null
    _sum: Inducks_statpersoncountrySumAggregateOutputType | null
    _min: Inducks_statpersoncountryMinAggregateOutputType | null
    _max: Inducks_statpersoncountryMaxAggregateOutputType | null
  }

  export type Inducks_statpersoncountryAvgAggregateOutputType = {
    total: number | null
  }

  export type Inducks_statpersoncountrySumAggregateOutputType = {
    total: number | null
  }

  export type Inducks_statpersoncountryMinAggregateOutputType = {
    personcode: string | null
    countrycode: string | null
    total: number | null
  }

  export type Inducks_statpersoncountryMaxAggregateOutputType = {
    personcode: string | null
    countrycode: string | null
    total: number | null
  }

  export type Inducks_statpersoncountryCountAggregateOutputType = {
    personcode: number
    countrycode: number
    total: number
    _all: number
  }


  export type Inducks_statpersoncountryAvgAggregateInputType = {
    total?: true
  }

  export type Inducks_statpersoncountrySumAggregateInputType = {
    total?: true
  }

  export type Inducks_statpersoncountryMinAggregateInputType = {
    personcode?: true
    countrycode?: true
    total?: true
  }

  export type Inducks_statpersoncountryMaxAggregateInputType = {
    personcode?: true
    countrycode?: true
    total?: true
  }

  export type Inducks_statpersoncountryCountAggregateInputType = {
    personcode?: true
    countrycode?: true
    total?: true
    _all?: true
  }

  export type Inducks_statpersoncountryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_statpersoncountry to aggregate.
     */
    where?: inducks_statpersoncountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_statpersoncountries to fetch.
     */
    orderBy?: inducks_statpersoncountryOrderByWithRelationInput | inducks_statpersoncountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_statpersoncountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_statpersoncountries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_statpersoncountries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_statpersoncountries
    **/
    _count?: true | Inducks_statpersoncountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Inducks_statpersoncountryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Inducks_statpersoncountrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_statpersoncountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_statpersoncountryMaxAggregateInputType
  }

  export type GetInducks_statpersoncountryAggregateType<T extends Inducks_statpersoncountryAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_statpersoncountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_statpersoncountry[P]>
      : GetScalarType<T[P], AggregateInducks_statpersoncountry[P]>
  }




  export type inducks_statpersoncountryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_statpersoncountryWhereInput
    orderBy?: inducks_statpersoncountryOrderByWithAggregationInput | inducks_statpersoncountryOrderByWithAggregationInput[]
    by: Inducks_statpersoncountryScalarFieldEnum[] | Inducks_statpersoncountryScalarFieldEnum
    having?: inducks_statpersoncountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_statpersoncountryCountAggregateInputType | true
    _avg?: Inducks_statpersoncountryAvgAggregateInputType
    _sum?: Inducks_statpersoncountrySumAggregateInputType
    _min?: Inducks_statpersoncountryMinAggregateInputType
    _max?: Inducks_statpersoncountryMaxAggregateInputType
  }

  export type Inducks_statpersoncountryGroupByOutputType = {
    personcode: string
    countrycode: string
    total: number | null
    _count: Inducks_statpersoncountryCountAggregateOutputType | null
    _avg: Inducks_statpersoncountryAvgAggregateOutputType | null
    _sum: Inducks_statpersoncountrySumAggregateOutputType | null
    _min: Inducks_statpersoncountryMinAggregateOutputType | null
    _max: Inducks_statpersoncountryMaxAggregateOutputType | null
  }

  type GetInducks_statpersoncountryGroupByPayload<T extends inducks_statpersoncountryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_statpersoncountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_statpersoncountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_statpersoncountryGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_statpersoncountryGroupByOutputType[P]>
        }
      >
    >


  export type inducks_statpersoncountrySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    personcode?: boolean
    countrycode?: boolean
    total?: boolean
  }, ExtArgs["result"]["inducks_statpersoncountry"]>

  export type inducks_statpersoncountrySelectScalar = {
    personcode?: boolean
    countrycode?: boolean
    total?: boolean
  }


  export type $inducks_statpersoncountryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_statpersoncountry"
    objects: {}
    scalars: $Extensions.GetResult<{
      personcode: string
      countrycode: string
      total: number | null
    }, ExtArgs["result"]["inducks_statpersoncountry"]>
    composites: {}
  }


  type inducks_statpersoncountryGetPayload<S extends boolean | null | undefined | inducks_statpersoncountryDefaultArgs> = $Result.GetResult<Prisma.$inducks_statpersoncountryPayload, S>

  type inducks_statpersoncountryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_statpersoncountryFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_statpersoncountryCountAggregateInputType | true
    }

  export interface inducks_statpersoncountryDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_statpersoncountry'], meta: { name: 'inducks_statpersoncountry' } }
    /**
     * Find zero or one Inducks_statpersoncountry that matches the filter.
     * @param {inducks_statpersoncountryFindUniqueArgs} args - Arguments to find a Inducks_statpersoncountry
     * @example
     * // Get one Inducks_statpersoncountry
     * const inducks_statpersoncountry = await prisma.inducks_statpersoncountry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_statpersoncountryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statpersoncountryFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_statpersoncountryClient<$Result.GetResult<Prisma.$inducks_statpersoncountryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_statpersoncountry that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_statpersoncountryFindUniqueOrThrowArgs} args - Arguments to find a Inducks_statpersoncountry
     * @example
     * // Get one Inducks_statpersoncountry
     * const inducks_statpersoncountry = await prisma.inducks_statpersoncountry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_statpersoncountryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statpersoncountryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_statpersoncountryClient<$Result.GetResult<Prisma.$inducks_statpersoncountryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_statpersoncountry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statpersoncountryFindFirstArgs} args - Arguments to find a Inducks_statpersoncountry
     * @example
     * // Get one Inducks_statpersoncountry
     * const inducks_statpersoncountry = await prisma.inducks_statpersoncountry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_statpersoncountryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statpersoncountryFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_statpersoncountryClient<$Result.GetResult<Prisma.$inducks_statpersoncountryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_statpersoncountry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statpersoncountryFindFirstOrThrowArgs} args - Arguments to find a Inducks_statpersoncountry
     * @example
     * // Get one Inducks_statpersoncountry
     * const inducks_statpersoncountry = await prisma.inducks_statpersoncountry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_statpersoncountryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statpersoncountryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_statpersoncountryClient<$Result.GetResult<Prisma.$inducks_statpersoncountryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_statpersoncountries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statpersoncountryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_statpersoncountries
     * const inducks_statpersoncountries = await prisma.inducks_statpersoncountry.findMany()
     * 
     * // Get first 10 Inducks_statpersoncountries
     * const inducks_statpersoncountries = await prisma.inducks_statpersoncountry.findMany({ take: 10 })
     * 
     * // Only select the `personcode`
     * const inducks_statpersoncountryWithPersoncodeOnly = await prisma.inducks_statpersoncountry.findMany({ select: { personcode: true } })
     * 
    **/
    findMany<T extends inducks_statpersoncountryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statpersoncountryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_statpersoncountryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_statpersoncountry.
     * @param {inducks_statpersoncountryCreateArgs} args - Arguments to create a Inducks_statpersoncountry.
     * @example
     * // Create one Inducks_statpersoncountry
     * const Inducks_statpersoncountry = await prisma.inducks_statpersoncountry.create({
     *   data: {
     *     // ... data to create a Inducks_statpersoncountry
     *   }
     * })
     * 
    **/
    create<T extends inducks_statpersoncountryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statpersoncountryCreateArgs<ExtArgs>>
    ): Prisma__inducks_statpersoncountryClient<$Result.GetResult<Prisma.$inducks_statpersoncountryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_statpersoncountries.
     *     @param {inducks_statpersoncountryCreateManyArgs} args - Arguments to create many Inducks_statpersoncountries.
     *     @example
     *     // Create many Inducks_statpersoncountries
     *     const inducks_statpersoncountry = await prisma.inducks_statpersoncountry.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_statpersoncountryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statpersoncountryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_statpersoncountry.
     * @param {inducks_statpersoncountryDeleteArgs} args - Arguments to delete one Inducks_statpersoncountry.
     * @example
     * // Delete one Inducks_statpersoncountry
     * const Inducks_statpersoncountry = await prisma.inducks_statpersoncountry.delete({
     *   where: {
     *     // ... filter to delete one Inducks_statpersoncountry
     *   }
     * })
     * 
    **/
    delete<T extends inducks_statpersoncountryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statpersoncountryDeleteArgs<ExtArgs>>
    ): Prisma__inducks_statpersoncountryClient<$Result.GetResult<Prisma.$inducks_statpersoncountryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_statpersoncountry.
     * @param {inducks_statpersoncountryUpdateArgs} args - Arguments to update one Inducks_statpersoncountry.
     * @example
     * // Update one Inducks_statpersoncountry
     * const inducks_statpersoncountry = await prisma.inducks_statpersoncountry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_statpersoncountryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statpersoncountryUpdateArgs<ExtArgs>>
    ): Prisma__inducks_statpersoncountryClient<$Result.GetResult<Prisma.$inducks_statpersoncountryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_statpersoncountries.
     * @param {inducks_statpersoncountryDeleteManyArgs} args - Arguments to filter Inducks_statpersoncountries to delete.
     * @example
     * // Delete a few Inducks_statpersoncountries
     * const { count } = await prisma.inducks_statpersoncountry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_statpersoncountryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statpersoncountryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_statpersoncountries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statpersoncountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_statpersoncountries
     * const inducks_statpersoncountry = await prisma.inducks_statpersoncountry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_statpersoncountryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statpersoncountryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_statpersoncountry.
     * @param {inducks_statpersoncountryUpsertArgs} args - Arguments to update or create a Inducks_statpersoncountry.
     * @example
     * // Update or create a Inducks_statpersoncountry
     * const inducks_statpersoncountry = await prisma.inducks_statpersoncountry.upsert({
     *   create: {
     *     // ... data to create a Inducks_statpersoncountry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_statpersoncountry we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_statpersoncountryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statpersoncountryUpsertArgs<ExtArgs>>
    ): Prisma__inducks_statpersoncountryClient<$Result.GetResult<Prisma.$inducks_statpersoncountryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_statpersoncountries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statpersoncountryCountArgs} args - Arguments to filter Inducks_statpersoncountries to count.
     * @example
     * // Count the number of Inducks_statpersoncountries
     * const count = await prisma.inducks_statpersoncountry.count({
     *   where: {
     *     // ... the filter for the Inducks_statpersoncountries we want to count
     *   }
     * })
    **/
    count<T extends inducks_statpersoncountryCountArgs>(
      args?: Subset<T, inducks_statpersoncountryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_statpersoncountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_statpersoncountry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_statpersoncountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_statpersoncountryAggregateArgs>(args: Subset<T, Inducks_statpersoncountryAggregateArgs>): Prisma.PrismaPromise<GetInducks_statpersoncountryAggregateType<T>>

    /**
     * Group by Inducks_statpersoncountry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statpersoncountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_statpersoncountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_statpersoncountryGroupByArgs['orderBy'] }
        : { orderBy?: inducks_statpersoncountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_statpersoncountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_statpersoncountryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_statpersoncountry model
   */
  readonly fields: inducks_statpersoncountryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_statpersoncountry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_statpersoncountryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_statpersoncountry model
   */ 
  interface inducks_statpersoncountryFieldRefs {
    readonly personcode: FieldRef<"inducks_statpersoncountry", 'String'>
    readonly countrycode: FieldRef<"inducks_statpersoncountry", 'String'>
    readonly total: FieldRef<"inducks_statpersoncountry", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * inducks_statpersoncountry findUnique
   */
  export type inducks_statpersoncountryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersoncountry
     */
    select?: inducks_statpersoncountrySelect<ExtArgs> | null
    /**
     * Filter, which inducks_statpersoncountry to fetch.
     */
    where: inducks_statpersoncountryWhereUniqueInput
  }


  /**
   * inducks_statpersoncountry findUniqueOrThrow
   */
  export type inducks_statpersoncountryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersoncountry
     */
    select?: inducks_statpersoncountrySelect<ExtArgs> | null
    /**
     * Filter, which inducks_statpersoncountry to fetch.
     */
    where: inducks_statpersoncountryWhereUniqueInput
  }


  /**
   * inducks_statpersoncountry findFirst
   */
  export type inducks_statpersoncountryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersoncountry
     */
    select?: inducks_statpersoncountrySelect<ExtArgs> | null
    /**
     * Filter, which inducks_statpersoncountry to fetch.
     */
    where?: inducks_statpersoncountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_statpersoncountries to fetch.
     */
    orderBy?: inducks_statpersoncountryOrderByWithRelationInput | inducks_statpersoncountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_statpersoncountries.
     */
    cursor?: inducks_statpersoncountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_statpersoncountries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_statpersoncountries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_statpersoncountries.
     */
    distinct?: Inducks_statpersoncountryScalarFieldEnum | Inducks_statpersoncountryScalarFieldEnum[]
  }


  /**
   * inducks_statpersoncountry findFirstOrThrow
   */
  export type inducks_statpersoncountryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersoncountry
     */
    select?: inducks_statpersoncountrySelect<ExtArgs> | null
    /**
     * Filter, which inducks_statpersoncountry to fetch.
     */
    where?: inducks_statpersoncountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_statpersoncountries to fetch.
     */
    orderBy?: inducks_statpersoncountryOrderByWithRelationInput | inducks_statpersoncountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_statpersoncountries.
     */
    cursor?: inducks_statpersoncountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_statpersoncountries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_statpersoncountries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_statpersoncountries.
     */
    distinct?: Inducks_statpersoncountryScalarFieldEnum | Inducks_statpersoncountryScalarFieldEnum[]
  }


  /**
   * inducks_statpersoncountry findMany
   */
  export type inducks_statpersoncountryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersoncountry
     */
    select?: inducks_statpersoncountrySelect<ExtArgs> | null
    /**
     * Filter, which inducks_statpersoncountries to fetch.
     */
    where?: inducks_statpersoncountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_statpersoncountries to fetch.
     */
    orderBy?: inducks_statpersoncountryOrderByWithRelationInput | inducks_statpersoncountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_statpersoncountries.
     */
    cursor?: inducks_statpersoncountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_statpersoncountries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_statpersoncountries.
     */
    skip?: number
    distinct?: Inducks_statpersoncountryScalarFieldEnum | Inducks_statpersoncountryScalarFieldEnum[]
  }


  /**
   * inducks_statpersoncountry create
   */
  export type inducks_statpersoncountryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersoncountry
     */
    select?: inducks_statpersoncountrySelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_statpersoncountry.
     */
    data: XOR<inducks_statpersoncountryCreateInput, inducks_statpersoncountryUncheckedCreateInput>
  }


  /**
   * inducks_statpersoncountry createMany
   */
  export type inducks_statpersoncountryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_statpersoncountries.
     */
    data: inducks_statpersoncountryCreateManyInput | inducks_statpersoncountryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_statpersoncountry update
   */
  export type inducks_statpersoncountryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersoncountry
     */
    select?: inducks_statpersoncountrySelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_statpersoncountry.
     */
    data: XOR<inducks_statpersoncountryUpdateInput, inducks_statpersoncountryUncheckedUpdateInput>
    /**
     * Choose, which inducks_statpersoncountry to update.
     */
    where: inducks_statpersoncountryWhereUniqueInput
  }


  /**
   * inducks_statpersoncountry updateMany
   */
  export type inducks_statpersoncountryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_statpersoncountries.
     */
    data: XOR<inducks_statpersoncountryUpdateManyMutationInput, inducks_statpersoncountryUncheckedUpdateManyInput>
    /**
     * Filter which inducks_statpersoncountries to update
     */
    where?: inducks_statpersoncountryWhereInput
  }


  /**
   * inducks_statpersoncountry upsert
   */
  export type inducks_statpersoncountryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersoncountry
     */
    select?: inducks_statpersoncountrySelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_statpersoncountry to update in case it exists.
     */
    where: inducks_statpersoncountryWhereUniqueInput
    /**
     * In case the inducks_statpersoncountry found by the `where` argument doesn't exist, create a new inducks_statpersoncountry with this data.
     */
    create: XOR<inducks_statpersoncountryCreateInput, inducks_statpersoncountryUncheckedCreateInput>
    /**
     * In case the inducks_statpersoncountry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_statpersoncountryUpdateInput, inducks_statpersoncountryUncheckedUpdateInput>
  }


  /**
   * inducks_statpersoncountry delete
   */
  export type inducks_statpersoncountryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersoncountry
     */
    select?: inducks_statpersoncountrySelect<ExtArgs> | null
    /**
     * Filter which inducks_statpersoncountry to delete.
     */
    where: inducks_statpersoncountryWhereUniqueInput
  }


  /**
   * inducks_statpersoncountry deleteMany
   */
  export type inducks_statpersoncountryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_statpersoncountries to delete
     */
    where?: inducks_statpersoncountryWhereInput
  }


  /**
   * inducks_statpersoncountry without action
   */
  export type inducks_statpersoncountryDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersoncountry
     */
    select?: inducks_statpersoncountrySelect<ExtArgs> | null
  }



  /**
   * Model inducks_statpersonperson
   */

  export type AggregateInducks_statpersonperson = {
    _count: Inducks_statpersonpersonCountAggregateOutputType | null
    _avg: Inducks_statpersonpersonAvgAggregateOutputType | null
    _sum: Inducks_statpersonpersonSumAggregateOutputType | null
    _min: Inducks_statpersonpersonMinAggregateOutputType | null
    _max: Inducks_statpersonpersonMaxAggregateOutputType | null
  }

  export type Inducks_statpersonpersonAvgAggregateOutputType = {
    total: number | null
  }

  export type Inducks_statpersonpersonSumAggregateOutputType = {
    total: number | null
  }

  export type Inducks_statpersonpersonMinAggregateOutputType = {
    personcode: string | null
    copersoncode: string | null
    total: number | null
    yearrange: string | null
  }

  export type Inducks_statpersonpersonMaxAggregateOutputType = {
    personcode: string | null
    copersoncode: string | null
    total: number | null
    yearrange: string | null
  }

  export type Inducks_statpersonpersonCountAggregateOutputType = {
    personcode: number
    copersoncode: number
    total: number
    yearrange: number
    _all: number
  }


  export type Inducks_statpersonpersonAvgAggregateInputType = {
    total?: true
  }

  export type Inducks_statpersonpersonSumAggregateInputType = {
    total?: true
  }

  export type Inducks_statpersonpersonMinAggregateInputType = {
    personcode?: true
    copersoncode?: true
    total?: true
    yearrange?: true
  }

  export type Inducks_statpersonpersonMaxAggregateInputType = {
    personcode?: true
    copersoncode?: true
    total?: true
    yearrange?: true
  }

  export type Inducks_statpersonpersonCountAggregateInputType = {
    personcode?: true
    copersoncode?: true
    total?: true
    yearrange?: true
    _all?: true
  }

  export type Inducks_statpersonpersonAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_statpersonperson to aggregate.
     */
    where?: inducks_statpersonpersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_statpersonpeople to fetch.
     */
    orderBy?: inducks_statpersonpersonOrderByWithRelationInput | inducks_statpersonpersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_statpersonpersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_statpersonpeople from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_statpersonpeople.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_statpersonpeople
    **/
    _count?: true | Inducks_statpersonpersonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Inducks_statpersonpersonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Inducks_statpersonpersonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_statpersonpersonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_statpersonpersonMaxAggregateInputType
  }

  export type GetInducks_statpersonpersonAggregateType<T extends Inducks_statpersonpersonAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_statpersonperson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_statpersonperson[P]>
      : GetScalarType<T[P], AggregateInducks_statpersonperson[P]>
  }




  export type inducks_statpersonpersonGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_statpersonpersonWhereInput
    orderBy?: inducks_statpersonpersonOrderByWithAggregationInput | inducks_statpersonpersonOrderByWithAggregationInput[]
    by: Inducks_statpersonpersonScalarFieldEnum[] | Inducks_statpersonpersonScalarFieldEnum
    having?: inducks_statpersonpersonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_statpersonpersonCountAggregateInputType | true
    _avg?: Inducks_statpersonpersonAvgAggregateInputType
    _sum?: Inducks_statpersonpersonSumAggregateInputType
    _min?: Inducks_statpersonpersonMinAggregateInputType
    _max?: Inducks_statpersonpersonMaxAggregateInputType
  }

  export type Inducks_statpersonpersonGroupByOutputType = {
    personcode: string
    copersoncode: string | null
    total: number
    yearrange: string | null
    _count: Inducks_statpersonpersonCountAggregateOutputType | null
    _avg: Inducks_statpersonpersonAvgAggregateOutputType | null
    _sum: Inducks_statpersonpersonSumAggregateOutputType | null
    _min: Inducks_statpersonpersonMinAggregateOutputType | null
    _max: Inducks_statpersonpersonMaxAggregateOutputType | null
  }

  type GetInducks_statpersonpersonGroupByPayload<T extends inducks_statpersonpersonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_statpersonpersonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_statpersonpersonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_statpersonpersonGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_statpersonpersonGroupByOutputType[P]>
        }
      >
    >


  export type inducks_statpersonpersonSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    personcode?: boolean
    copersoncode?: boolean
    total?: boolean
    yearrange?: boolean
  }, ExtArgs["result"]["inducks_statpersonperson"]>

  export type inducks_statpersonpersonSelectScalar = {
    personcode?: boolean
    copersoncode?: boolean
    total?: boolean
    yearrange?: boolean
  }


  export type $inducks_statpersonpersonPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_statpersonperson"
    objects: {}
    scalars: $Extensions.GetResult<{
      personcode: string
      copersoncode: string | null
      total: number
      yearrange: string | null
    }, ExtArgs["result"]["inducks_statpersonperson"]>
    composites: {}
  }


  type inducks_statpersonpersonGetPayload<S extends boolean | null | undefined | inducks_statpersonpersonDefaultArgs> = $Result.GetResult<Prisma.$inducks_statpersonpersonPayload, S>

  type inducks_statpersonpersonCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_statpersonpersonFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_statpersonpersonCountAggregateInputType | true
    }

  export interface inducks_statpersonpersonDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_statpersonperson'], meta: { name: 'inducks_statpersonperson' } }
    /**
     * Find zero or one Inducks_statpersonperson that matches the filter.
     * @param {inducks_statpersonpersonFindUniqueArgs} args - Arguments to find a Inducks_statpersonperson
     * @example
     * // Get one Inducks_statpersonperson
     * const inducks_statpersonperson = await prisma.inducks_statpersonperson.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_statpersonpersonFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statpersonpersonFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_statpersonpersonClient<$Result.GetResult<Prisma.$inducks_statpersonpersonPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_statpersonperson that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_statpersonpersonFindUniqueOrThrowArgs} args - Arguments to find a Inducks_statpersonperson
     * @example
     * // Get one Inducks_statpersonperson
     * const inducks_statpersonperson = await prisma.inducks_statpersonperson.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_statpersonpersonFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statpersonpersonFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_statpersonpersonClient<$Result.GetResult<Prisma.$inducks_statpersonpersonPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_statpersonperson that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statpersonpersonFindFirstArgs} args - Arguments to find a Inducks_statpersonperson
     * @example
     * // Get one Inducks_statpersonperson
     * const inducks_statpersonperson = await prisma.inducks_statpersonperson.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_statpersonpersonFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statpersonpersonFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_statpersonpersonClient<$Result.GetResult<Prisma.$inducks_statpersonpersonPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_statpersonperson that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statpersonpersonFindFirstOrThrowArgs} args - Arguments to find a Inducks_statpersonperson
     * @example
     * // Get one Inducks_statpersonperson
     * const inducks_statpersonperson = await prisma.inducks_statpersonperson.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_statpersonpersonFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statpersonpersonFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_statpersonpersonClient<$Result.GetResult<Prisma.$inducks_statpersonpersonPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_statpersonpeople that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statpersonpersonFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_statpersonpeople
     * const inducks_statpersonpeople = await prisma.inducks_statpersonperson.findMany()
     * 
     * // Get first 10 Inducks_statpersonpeople
     * const inducks_statpersonpeople = await prisma.inducks_statpersonperson.findMany({ take: 10 })
     * 
     * // Only select the `personcode`
     * const inducks_statpersonpersonWithPersoncodeOnly = await prisma.inducks_statpersonperson.findMany({ select: { personcode: true } })
     * 
    **/
    findMany<T extends inducks_statpersonpersonFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statpersonpersonFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_statpersonpersonPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_statpersonperson.
     * @param {inducks_statpersonpersonCreateArgs} args - Arguments to create a Inducks_statpersonperson.
     * @example
     * // Create one Inducks_statpersonperson
     * const Inducks_statpersonperson = await prisma.inducks_statpersonperson.create({
     *   data: {
     *     // ... data to create a Inducks_statpersonperson
     *   }
     * })
     * 
    **/
    create<T extends inducks_statpersonpersonCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statpersonpersonCreateArgs<ExtArgs>>
    ): Prisma__inducks_statpersonpersonClient<$Result.GetResult<Prisma.$inducks_statpersonpersonPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_statpersonpeople.
     *     @param {inducks_statpersonpersonCreateManyArgs} args - Arguments to create many Inducks_statpersonpeople.
     *     @example
     *     // Create many Inducks_statpersonpeople
     *     const inducks_statpersonperson = await prisma.inducks_statpersonperson.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_statpersonpersonCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statpersonpersonCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_statpersonperson.
     * @param {inducks_statpersonpersonDeleteArgs} args - Arguments to delete one Inducks_statpersonperson.
     * @example
     * // Delete one Inducks_statpersonperson
     * const Inducks_statpersonperson = await prisma.inducks_statpersonperson.delete({
     *   where: {
     *     // ... filter to delete one Inducks_statpersonperson
     *   }
     * })
     * 
    **/
    delete<T extends inducks_statpersonpersonDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statpersonpersonDeleteArgs<ExtArgs>>
    ): Prisma__inducks_statpersonpersonClient<$Result.GetResult<Prisma.$inducks_statpersonpersonPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_statpersonperson.
     * @param {inducks_statpersonpersonUpdateArgs} args - Arguments to update one Inducks_statpersonperson.
     * @example
     * // Update one Inducks_statpersonperson
     * const inducks_statpersonperson = await prisma.inducks_statpersonperson.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_statpersonpersonUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statpersonpersonUpdateArgs<ExtArgs>>
    ): Prisma__inducks_statpersonpersonClient<$Result.GetResult<Prisma.$inducks_statpersonpersonPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_statpersonpeople.
     * @param {inducks_statpersonpersonDeleteManyArgs} args - Arguments to filter Inducks_statpersonpeople to delete.
     * @example
     * // Delete a few Inducks_statpersonpeople
     * const { count } = await prisma.inducks_statpersonperson.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_statpersonpersonDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statpersonpersonDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_statpersonpeople.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statpersonpersonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_statpersonpeople
     * const inducks_statpersonperson = await prisma.inducks_statpersonperson.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_statpersonpersonUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statpersonpersonUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_statpersonperson.
     * @param {inducks_statpersonpersonUpsertArgs} args - Arguments to update or create a Inducks_statpersonperson.
     * @example
     * // Update or create a Inducks_statpersonperson
     * const inducks_statpersonperson = await prisma.inducks_statpersonperson.upsert({
     *   create: {
     *     // ... data to create a Inducks_statpersonperson
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_statpersonperson we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_statpersonpersonUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statpersonpersonUpsertArgs<ExtArgs>>
    ): Prisma__inducks_statpersonpersonClient<$Result.GetResult<Prisma.$inducks_statpersonpersonPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_statpersonpeople.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statpersonpersonCountArgs} args - Arguments to filter Inducks_statpersonpeople to count.
     * @example
     * // Count the number of Inducks_statpersonpeople
     * const count = await prisma.inducks_statpersonperson.count({
     *   where: {
     *     // ... the filter for the Inducks_statpersonpeople we want to count
     *   }
     * })
    **/
    count<T extends inducks_statpersonpersonCountArgs>(
      args?: Subset<T, inducks_statpersonpersonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_statpersonpersonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_statpersonperson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_statpersonpersonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_statpersonpersonAggregateArgs>(args: Subset<T, Inducks_statpersonpersonAggregateArgs>): Prisma.PrismaPromise<GetInducks_statpersonpersonAggregateType<T>>

    /**
     * Group by Inducks_statpersonperson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statpersonpersonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_statpersonpersonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_statpersonpersonGroupByArgs['orderBy'] }
        : { orderBy?: inducks_statpersonpersonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_statpersonpersonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_statpersonpersonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_statpersonperson model
   */
  readonly fields: inducks_statpersonpersonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_statpersonperson.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_statpersonpersonClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_statpersonperson model
   */ 
  interface inducks_statpersonpersonFieldRefs {
    readonly personcode: FieldRef<"inducks_statpersonperson", 'String'>
    readonly copersoncode: FieldRef<"inducks_statpersonperson", 'String'>
    readonly total: FieldRef<"inducks_statpersonperson", 'Int'>
    readonly yearrange: FieldRef<"inducks_statpersonperson", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_statpersonperson findUnique
   */
  export type inducks_statpersonpersonFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersonperson
     */
    select?: inducks_statpersonpersonSelect<ExtArgs> | null
    /**
     * Filter, which inducks_statpersonperson to fetch.
     */
    where: inducks_statpersonpersonWhereUniqueInput
  }


  /**
   * inducks_statpersonperson findUniqueOrThrow
   */
  export type inducks_statpersonpersonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersonperson
     */
    select?: inducks_statpersonpersonSelect<ExtArgs> | null
    /**
     * Filter, which inducks_statpersonperson to fetch.
     */
    where: inducks_statpersonpersonWhereUniqueInput
  }


  /**
   * inducks_statpersonperson findFirst
   */
  export type inducks_statpersonpersonFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersonperson
     */
    select?: inducks_statpersonpersonSelect<ExtArgs> | null
    /**
     * Filter, which inducks_statpersonperson to fetch.
     */
    where?: inducks_statpersonpersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_statpersonpeople to fetch.
     */
    orderBy?: inducks_statpersonpersonOrderByWithRelationInput | inducks_statpersonpersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_statpersonpeople.
     */
    cursor?: inducks_statpersonpersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_statpersonpeople from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_statpersonpeople.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_statpersonpeople.
     */
    distinct?: Inducks_statpersonpersonScalarFieldEnum | Inducks_statpersonpersonScalarFieldEnum[]
  }


  /**
   * inducks_statpersonperson findFirstOrThrow
   */
  export type inducks_statpersonpersonFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersonperson
     */
    select?: inducks_statpersonpersonSelect<ExtArgs> | null
    /**
     * Filter, which inducks_statpersonperson to fetch.
     */
    where?: inducks_statpersonpersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_statpersonpeople to fetch.
     */
    orderBy?: inducks_statpersonpersonOrderByWithRelationInput | inducks_statpersonpersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_statpersonpeople.
     */
    cursor?: inducks_statpersonpersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_statpersonpeople from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_statpersonpeople.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_statpersonpeople.
     */
    distinct?: Inducks_statpersonpersonScalarFieldEnum | Inducks_statpersonpersonScalarFieldEnum[]
  }


  /**
   * inducks_statpersonperson findMany
   */
  export type inducks_statpersonpersonFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersonperson
     */
    select?: inducks_statpersonpersonSelect<ExtArgs> | null
    /**
     * Filter, which inducks_statpersonpeople to fetch.
     */
    where?: inducks_statpersonpersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_statpersonpeople to fetch.
     */
    orderBy?: inducks_statpersonpersonOrderByWithRelationInput | inducks_statpersonpersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_statpersonpeople.
     */
    cursor?: inducks_statpersonpersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_statpersonpeople from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_statpersonpeople.
     */
    skip?: number
    distinct?: Inducks_statpersonpersonScalarFieldEnum | Inducks_statpersonpersonScalarFieldEnum[]
  }


  /**
   * inducks_statpersonperson create
   */
  export type inducks_statpersonpersonCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersonperson
     */
    select?: inducks_statpersonpersonSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_statpersonperson.
     */
    data: XOR<inducks_statpersonpersonCreateInput, inducks_statpersonpersonUncheckedCreateInput>
  }


  /**
   * inducks_statpersonperson createMany
   */
  export type inducks_statpersonpersonCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_statpersonpeople.
     */
    data: inducks_statpersonpersonCreateManyInput | inducks_statpersonpersonCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_statpersonperson update
   */
  export type inducks_statpersonpersonUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersonperson
     */
    select?: inducks_statpersonpersonSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_statpersonperson.
     */
    data: XOR<inducks_statpersonpersonUpdateInput, inducks_statpersonpersonUncheckedUpdateInput>
    /**
     * Choose, which inducks_statpersonperson to update.
     */
    where: inducks_statpersonpersonWhereUniqueInput
  }


  /**
   * inducks_statpersonperson updateMany
   */
  export type inducks_statpersonpersonUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_statpersonpeople.
     */
    data: XOR<inducks_statpersonpersonUpdateManyMutationInput, inducks_statpersonpersonUncheckedUpdateManyInput>
    /**
     * Filter which inducks_statpersonpeople to update
     */
    where?: inducks_statpersonpersonWhereInput
  }


  /**
   * inducks_statpersonperson upsert
   */
  export type inducks_statpersonpersonUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersonperson
     */
    select?: inducks_statpersonpersonSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_statpersonperson to update in case it exists.
     */
    where: inducks_statpersonpersonWhereUniqueInput
    /**
     * In case the inducks_statpersonperson found by the `where` argument doesn't exist, create a new inducks_statpersonperson with this data.
     */
    create: XOR<inducks_statpersonpersonCreateInput, inducks_statpersonpersonUncheckedCreateInput>
    /**
     * In case the inducks_statpersonperson was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_statpersonpersonUpdateInput, inducks_statpersonpersonUncheckedUpdateInput>
  }


  /**
   * inducks_statpersonperson delete
   */
  export type inducks_statpersonpersonDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersonperson
     */
    select?: inducks_statpersonpersonSelect<ExtArgs> | null
    /**
     * Filter which inducks_statpersonperson to delete.
     */
    where: inducks_statpersonpersonWhereUniqueInput
  }


  /**
   * inducks_statpersonperson deleteMany
   */
  export type inducks_statpersonpersonDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_statpersonpeople to delete
     */
    where?: inducks_statpersonpersonWhereInput
  }


  /**
   * inducks_statpersonperson without action
   */
  export type inducks_statpersonpersonDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersonperson
     */
    select?: inducks_statpersonpersonSelect<ExtArgs> | null
  }



  /**
   * Model inducks_statpersonstory
   */

  export type AggregateInducks_statpersonstory = {
    _count: Inducks_statpersonstoryCountAggregateOutputType | null
    _avg: Inducks_statpersonstoryAvgAggregateOutputType | null
    _sum: Inducks_statpersonstorySumAggregateOutputType | null
    _min: Inducks_statpersonstoryMinAggregateOutputType | null
    _max: Inducks_statpersonstoryMaxAggregateOutputType | null
  }

  export type Inducks_statpersonstoryAvgAggregateOutputType = {
    total: number | null
  }

  export type Inducks_statpersonstorySumAggregateOutputType = {
    total: number | null
  }

  export type Inducks_statpersonstoryMinAggregateOutputType = {
    personcode: string | null
    storyheadercode: string | null
    total: number | null
    yearrange: string | null
  }

  export type Inducks_statpersonstoryMaxAggregateOutputType = {
    personcode: string | null
    storyheadercode: string | null
    total: number | null
    yearrange: string | null
  }

  export type Inducks_statpersonstoryCountAggregateOutputType = {
    personcode: number
    storyheadercode: number
    total: number
    yearrange: number
    _all: number
  }


  export type Inducks_statpersonstoryAvgAggregateInputType = {
    total?: true
  }

  export type Inducks_statpersonstorySumAggregateInputType = {
    total?: true
  }

  export type Inducks_statpersonstoryMinAggregateInputType = {
    personcode?: true
    storyheadercode?: true
    total?: true
    yearrange?: true
  }

  export type Inducks_statpersonstoryMaxAggregateInputType = {
    personcode?: true
    storyheadercode?: true
    total?: true
    yearrange?: true
  }

  export type Inducks_statpersonstoryCountAggregateInputType = {
    personcode?: true
    storyheadercode?: true
    total?: true
    yearrange?: true
    _all?: true
  }

  export type Inducks_statpersonstoryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_statpersonstory to aggregate.
     */
    where?: inducks_statpersonstoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_statpersonstories to fetch.
     */
    orderBy?: inducks_statpersonstoryOrderByWithRelationInput | inducks_statpersonstoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_statpersonstoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_statpersonstories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_statpersonstories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_statpersonstories
    **/
    _count?: true | Inducks_statpersonstoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Inducks_statpersonstoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Inducks_statpersonstorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_statpersonstoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_statpersonstoryMaxAggregateInputType
  }

  export type GetInducks_statpersonstoryAggregateType<T extends Inducks_statpersonstoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_statpersonstory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_statpersonstory[P]>
      : GetScalarType<T[P], AggregateInducks_statpersonstory[P]>
  }




  export type inducks_statpersonstoryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_statpersonstoryWhereInput
    orderBy?: inducks_statpersonstoryOrderByWithAggregationInput | inducks_statpersonstoryOrderByWithAggregationInput[]
    by: Inducks_statpersonstoryScalarFieldEnum[] | Inducks_statpersonstoryScalarFieldEnum
    having?: inducks_statpersonstoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_statpersonstoryCountAggregateInputType | true
    _avg?: Inducks_statpersonstoryAvgAggregateInputType
    _sum?: Inducks_statpersonstorySumAggregateInputType
    _min?: Inducks_statpersonstoryMinAggregateInputType
    _max?: Inducks_statpersonstoryMaxAggregateInputType
  }

  export type Inducks_statpersonstoryGroupByOutputType = {
    personcode: string
    storyheadercode: string
    total: number | null
    yearrange: string | null
    _count: Inducks_statpersonstoryCountAggregateOutputType | null
    _avg: Inducks_statpersonstoryAvgAggregateOutputType | null
    _sum: Inducks_statpersonstorySumAggregateOutputType | null
    _min: Inducks_statpersonstoryMinAggregateOutputType | null
    _max: Inducks_statpersonstoryMaxAggregateOutputType | null
  }

  type GetInducks_statpersonstoryGroupByPayload<T extends inducks_statpersonstoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_statpersonstoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_statpersonstoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_statpersonstoryGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_statpersonstoryGroupByOutputType[P]>
        }
      >
    >


  export type inducks_statpersonstorySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    personcode?: boolean
    storyheadercode?: boolean
    total?: boolean
    yearrange?: boolean
  }, ExtArgs["result"]["inducks_statpersonstory"]>

  export type inducks_statpersonstorySelectScalar = {
    personcode?: boolean
    storyheadercode?: boolean
    total?: boolean
    yearrange?: boolean
  }


  export type $inducks_statpersonstoryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_statpersonstory"
    objects: {}
    scalars: $Extensions.GetResult<{
      personcode: string
      storyheadercode: string
      total: number | null
      yearrange: string | null
    }, ExtArgs["result"]["inducks_statpersonstory"]>
    composites: {}
  }


  type inducks_statpersonstoryGetPayload<S extends boolean | null | undefined | inducks_statpersonstoryDefaultArgs> = $Result.GetResult<Prisma.$inducks_statpersonstoryPayload, S>

  type inducks_statpersonstoryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_statpersonstoryFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_statpersonstoryCountAggregateInputType | true
    }

  export interface inducks_statpersonstoryDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_statpersonstory'], meta: { name: 'inducks_statpersonstory' } }
    /**
     * Find zero or one Inducks_statpersonstory that matches the filter.
     * @param {inducks_statpersonstoryFindUniqueArgs} args - Arguments to find a Inducks_statpersonstory
     * @example
     * // Get one Inducks_statpersonstory
     * const inducks_statpersonstory = await prisma.inducks_statpersonstory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_statpersonstoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statpersonstoryFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_statpersonstoryClient<$Result.GetResult<Prisma.$inducks_statpersonstoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_statpersonstory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_statpersonstoryFindUniqueOrThrowArgs} args - Arguments to find a Inducks_statpersonstory
     * @example
     * // Get one Inducks_statpersonstory
     * const inducks_statpersonstory = await prisma.inducks_statpersonstory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_statpersonstoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statpersonstoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_statpersonstoryClient<$Result.GetResult<Prisma.$inducks_statpersonstoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_statpersonstory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statpersonstoryFindFirstArgs} args - Arguments to find a Inducks_statpersonstory
     * @example
     * // Get one Inducks_statpersonstory
     * const inducks_statpersonstory = await prisma.inducks_statpersonstory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_statpersonstoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statpersonstoryFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_statpersonstoryClient<$Result.GetResult<Prisma.$inducks_statpersonstoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_statpersonstory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statpersonstoryFindFirstOrThrowArgs} args - Arguments to find a Inducks_statpersonstory
     * @example
     * // Get one Inducks_statpersonstory
     * const inducks_statpersonstory = await prisma.inducks_statpersonstory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_statpersonstoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statpersonstoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_statpersonstoryClient<$Result.GetResult<Prisma.$inducks_statpersonstoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_statpersonstories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statpersonstoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_statpersonstories
     * const inducks_statpersonstories = await prisma.inducks_statpersonstory.findMany()
     * 
     * // Get first 10 Inducks_statpersonstories
     * const inducks_statpersonstories = await prisma.inducks_statpersonstory.findMany({ take: 10 })
     * 
     * // Only select the `personcode`
     * const inducks_statpersonstoryWithPersoncodeOnly = await prisma.inducks_statpersonstory.findMany({ select: { personcode: true } })
     * 
    **/
    findMany<T extends inducks_statpersonstoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statpersonstoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_statpersonstoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_statpersonstory.
     * @param {inducks_statpersonstoryCreateArgs} args - Arguments to create a Inducks_statpersonstory.
     * @example
     * // Create one Inducks_statpersonstory
     * const Inducks_statpersonstory = await prisma.inducks_statpersonstory.create({
     *   data: {
     *     // ... data to create a Inducks_statpersonstory
     *   }
     * })
     * 
    **/
    create<T extends inducks_statpersonstoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statpersonstoryCreateArgs<ExtArgs>>
    ): Prisma__inducks_statpersonstoryClient<$Result.GetResult<Prisma.$inducks_statpersonstoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_statpersonstories.
     *     @param {inducks_statpersonstoryCreateManyArgs} args - Arguments to create many Inducks_statpersonstories.
     *     @example
     *     // Create many Inducks_statpersonstories
     *     const inducks_statpersonstory = await prisma.inducks_statpersonstory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_statpersonstoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statpersonstoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_statpersonstory.
     * @param {inducks_statpersonstoryDeleteArgs} args - Arguments to delete one Inducks_statpersonstory.
     * @example
     * // Delete one Inducks_statpersonstory
     * const Inducks_statpersonstory = await prisma.inducks_statpersonstory.delete({
     *   where: {
     *     // ... filter to delete one Inducks_statpersonstory
     *   }
     * })
     * 
    **/
    delete<T extends inducks_statpersonstoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statpersonstoryDeleteArgs<ExtArgs>>
    ): Prisma__inducks_statpersonstoryClient<$Result.GetResult<Prisma.$inducks_statpersonstoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_statpersonstory.
     * @param {inducks_statpersonstoryUpdateArgs} args - Arguments to update one Inducks_statpersonstory.
     * @example
     * // Update one Inducks_statpersonstory
     * const inducks_statpersonstory = await prisma.inducks_statpersonstory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_statpersonstoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statpersonstoryUpdateArgs<ExtArgs>>
    ): Prisma__inducks_statpersonstoryClient<$Result.GetResult<Prisma.$inducks_statpersonstoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_statpersonstories.
     * @param {inducks_statpersonstoryDeleteManyArgs} args - Arguments to filter Inducks_statpersonstories to delete.
     * @example
     * // Delete a few Inducks_statpersonstories
     * const { count } = await prisma.inducks_statpersonstory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_statpersonstoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_statpersonstoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_statpersonstories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statpersonstoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_statpersonstories
     * const inducks_statpersonstory = await prisma.inducks_statpersonstory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_statpersonstoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statpersonstoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_statpersonstory.
     * @param {inducks_statpersonstoryUpsertArgs} args - Arguments to update or create a Inducks_statpersonstory.
     * @example
     * // Update or create a Inducks_statpersonstory
     * const inducks_statpersonstory = await prisma.inducks_statpersonstory.upsert({
     *   create: {
     *     // ... data to create a Inducks_statpersonstory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_statpersonstory we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_statpersonstoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_statpersonstoryUpsertArgs<ExtArgs>>
    ): Prisma__inducks_statpersonstoryClient<$Result.GetResult<Prisma.$inducks_statpersonstoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_statpersonstories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statpersonstoryCountArgs} args - Arguments to filter Inducks_statpersonstories to count.
     * @example
     * // Count the number of Inducks_statpersonstories
     * const count = await prisma.inducks_statpersonstory.count({
     *   where: {
     *     // ... the filter for the Inducks_statpersonstories we want to count
     *   }
     * })
    **/
    count<T extends inducks_statpersonstoryCountArgs>(
      args?: Subset<T, inducks_statpersonstoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_statpersonstoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_statpersonstory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_statpersonstoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_statpersonstoryAggregateArgs>(args: Subset<T, Inducks_statpersonstoryAggregateArgs>): Prisma.PrismaPromise<GetInducks_statpersonstoryAggregateType<T>>

    /**
     * Group by Inducks_statpersonstory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_statpersonstoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_statpersonstoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_statpersonstoryGroupByArgs['orderBy'] }
        : { orderBy?: inducks_statpersonstoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_statpersonstoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_statpersonstoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_statpersonstory model
   */
  readonly fields: inducks_statpersonstoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_statpersonstory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_statpersonstoryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_statpersonstory model
   */ 
  interface inducks_statpersonstoryFieldRefs {
    readonly personcode: FieldRef<"inducks_statpersonstory", 'String'>
    readonly storyheadercode: FieldRef<"inducks_statpersonstory", 'String'>
    readonly total: FieldRef<"inducks_statpersonstory", 'Int'>
    readonly yearrange: FieldRef<"inducks_statpersonstory", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_statpersonstory findUnique
   */
  export type inducks_statpersonstoryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersonstory
     */
    select?: inducks_statpersonstorySelect<ExtArgs> | null
    /**
     * Filter, which inducks_statpersonstory to fetch.
     */
    where: inducks_statpersonstoryWhereUniqueInput
  }


  /**
   * inducks_statpersonstory findUniqueOrThrow
   */
  export type inducks_statpersonstoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersonstory
     */
    select?: inducks_statpersonstorySelect<ExtArgs> | null
    /**
     * Filter, which inducks_statpersonstory to fetch.
     */
    where: inducks_statpersonstoryWhereUniqueInput
  }


  /**
   * inducks_statpersonstory findFirst
   */
  export type inducks_statpersonstoryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersonstory
     */
    select?: inducks_statpersonstorySelect<ExtArgs> | null
    /**
     * Filter, which inducks_statpersonstory to fetch.
     */
    where?: inducks_statpersonstoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_statpersonstories to fetch.
     */
    orderBy?: inducks_statpersonstoryOrderByWithRelationInput | inducks_statpersonstoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_statpersonstories.
     */
    cursor?: inducks_statpersonstoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_statpersonstories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_statpersonstories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_statpersonstories.
     */
    distinct?: Inducks_statpersonstoryScalarFieldEnum | Inducks_statpersonstoryScalarFieldEnum[]
  }


  /**
   * inducks_statpersonstory findFirstOrThrow
   */
  export type inducks_statpersonstoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersonstory
     */
    select?: inducks_statpersonstorySelect<ExtArgs> | null
    /**
     * Filter, which inducks_statpersonstory to fetch.
     */
    where?: inducks_statpersonstoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_statpersonstories to fetch.
     */
    orderBy?: inducks_statpersonstoryOrderByWithRelationInput | inducks_statpersonstoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_statpersonstories.
     */
    cursor?: inducks_statpersonstoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_statpersonstories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_statpersonstories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_statpersonstories.
     */
    distinct?: Inducks_statpersonstoryScalarFieldEnum | Inducks_statpersonstoryScalarFieldEnum[]
  }


  /**
   * inducks_statpersonstory findMany
   */
  export type inducks_statpersonstoryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersonstory
     */
    select?: inducks_statpersonstorySelect<ExtArgs> | null
    /**
     * Filter, which inducks_statpersonstories to fetch.
     */
    where?: inducks_statpersonstoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_statpersonstories to fetch.
     */
    orderBy?: inducks_statpersonstoryOrderByWithRelationInput | inducks_statpersonstoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_statpersonstories.
     */
    cursor?: inducks_statpersonstoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_statpersonstories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_statpersonstories.
     */
    skip?: number
    distinct?: Inducks_statpersonstoryScalarFieldEnum | Inducks_statpersonstoryScalarFieldEnum[]
  }


  /**
   * inducks_statpersonstory create
   */
  export type inducks_statpersonstoryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersonstory
     */
    select?: inducks_statpersonstorySelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_statpersonstory.
     */
    data: XOR<inducks_statpersonstoryCreateInput, inducks_statpersonstoryUncheckedCreateInput>
  }


  /**
   * inducks_statpersonstory createMany
   */
  export type inducks_statpersonstoryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_statpersonstories.
     */
    data: inducks_statpersonstoryCreateManyInput | inducks_statpersonstoryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_statpersonstory update
   */
  export type inducks_statpersonstoryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersonstory
     */
    select?: inducks_statpersonstorySelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_statpersonstory.
     */
    data: XOR<inducks_statpersonstoryUpdateInput, inducks_statpersonstoryUncheckedUpdateInput>
    /**
     * Choose, which inducks_statpersonstory to update.
     */
    where: inducks_statpersonstoryWhereUniqueInput
  }


  /**
   * inducks_statpersonstory updateMany
   */
  export type inducks_statpersonstoryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_statpersonstories.
     */
    data: XOR<inducks_statpersonstoryUpdateManyMutationInput, inducks_statpersonstoryUncheckedUpdateManyInput>
    /**
     * Filter which inducks_statpersonstories to update
     */
    where?: inducks_statpersonstoryWhereInput
  }


  /**
   * inducks_statpersonstory upsert
   */
  export type inducks_statpersonstoryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersonstory
     */
    select?: inducks_statpersonstorySelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_statpersonstory to update in case it exists.
     */
    where: inducks_statpersonstoryWhereUniqueInput
    /**
     * In case the inducks_statpersonstory found by the `where` argument doesn't exist, create a new inducks_statpersonstory with this data.
     */
    create: XOR<inducks_statpersonstoryCreateInput, inducks_statpersonstoryUncheckedCreateInput>
    /**
     * In case the inducks_statpersonstory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_statpersonstoryUpdateInput, inducks_statpersonstoryUncheckedUpdateInput>
  }


  /**
   * inducks_statpersonstory delete
   */
  export type inducks_statpersonstoryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersonstory
     */
    select?: inducks_statpersonstorySelect<ExtArgs> | null
    /**
     * Filter which inducks_statpersonstory to delete.
     */
    where: inducks_statpersonstoryWhereUniqueInput
  }


  /**
   * inducks_statpersonstory deleteMany
   */
  export type inducks_statpersonstoryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_statpersonstories to delete
     */
    where?: inducks_statpersonstoryWhereInput
  }


  /**
   * inducks_statpersonstory without action
   */
  export type inducks_statpersonstoryDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_statpersonstory
     */
    select?: inducks_statpersonstorySelect<ExtArgs> | null
  }



  /**
   * Model inducks_story
   */

  export type AggregateInducks_story = {
    _count: Inducks_storyCountAggregateOutputType | null
    _avg: Inducks_storyAvgAggregateOutputType | null
    _sum: Inducks_storySumAggregateOutputType | null
    _min: Inducks_storyMinAggregateOutputType | null
    _max: Inducks_storyMaxAggregateOutputType | null
  }

  export type Inducks_storyAvgAggregateOutputType = {
    storyparts: number | null
    inputfilecode: number | null
  }

  export type Inducks_storySumAggregateOutputType = {
    storyparts: number | null
    inputfilecode: number | null
  }

  export type Inducks_storyMinAggregateOutputType = {
    storycode: string | null
    originalstoryversioncode: string | null
    creationdate: string | null
    firstpublicationdate: string | null
    endpublicationdate: string | null
    title: string | null
    usedifferentcode: string | null
    storycomment: string | null
    error: $Enums.inducks_story_error | null
    repcountrysummary: string | null
    storyparts: number | null
    locked: $Enums.inducks_story_locked | null
    inputfilecode: number | null
    issuecodeofstoryitem: string | null
    maintenanceteamcode: string | null
    storyheadercode: string | null
  }

  export type Inducks_storyMaxAggregateOutputType = {
    storycode: string | null
    originalstoryversioncode: string | null
    creationdate: string | null
    firstpublicationdate: string | null
    endpublicationdate: string | null
    title: string | null
    usedifferentcode: string | null
    storycomment: string | null
    error: $Enums.inducks_story_error | null
    repcountrysummary: string | null
    storyparts: number | null
    locked: $Enums.inducks_story_locked | null
    inputfilecode: number | null
    issuecodeofstoryitem: string | null
    maintenanceteamcode: string | null
    storyheadercode: string | null
  }

  export type Inducks_storyCountAggregateOutputType = {
    storycode: number
    originalstoryversioncode: number
    creationdate: number
    firstpublicationdate: number
    endpublicationdate: number
    title: number
    usedifferentcode: number
    storycomment: number
    error: number
    repcountrysummary: number
    storyparts: number
    locked: number
    inputfilecode: number
    issuecodeofstoryitem: number
    maintenanceteamcode: number
    storyheadercode: number
    _all: number
  }


  export type Inducks_storyAvgAggregateInputType = {
    storyparts?: true
    inputfilecode?: true
  }

  export type Inducks_storySumAggregateInputType = {
    storyparts?: true
    inputfilecode?: true
  }

  export type Inducks_storyMinAggregateInputType = {
    storycode?: true
    originalstoryversioncode?: true
    creationdate?: true
    firstpublicationdate?: true
    endpublicationdate?: true
    title?: true
    usedifferentcode?: true
    storycomment?: true
    error?: true
    repcountrysummary?: true
    storyparts?: true
    locked?: true
    inputfilecode?: true
    issuecodeofstoryitem?: true
    maintenanceteamcode?: true
    storyheadercode?: true
  }

  export type Inducks_storyMaxAggregateInputType = {
    storycode?: true
    originalstoryversioncode?: true
    creationdate?: true
    firstpublicationdate?: true
    endpublicationdate?: true
    title?: true
    usedifferentcode?: true
    storycomment?: true
    error?: true
    repcountrysummary?: true
    storyparts?: true
    locked?: true
    inputfilecode?: true
    issuecodeofstoryitem?: true
    maintenanceteamcode?: true
    storyheadercode?: true
  }

  export type Inducks_storyCountAggregateInputType = {
    storycode?: true
    originalstoryversioncode?: true
    creationdate?: true
    firstpublicationdate?: true
    endpublicationdate?: true
    title?: true
    usedifferentcode?: true
    storycomment?: true
    error?: true
    repcountrysummary?: true
    storyparts?: true
    locked?: true
    inputfilecode?: true
    issuecodeofstoryitem?: true
    maintenanceteamcode?: true
    storyheadercode?: true
    _all?: true
  }

  export type Inducks_storyAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_story to aggregate.
     */
    where?: inducks_storyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_stories to fetch.
     */
    orderBy?: inducks_storyOrderByWithRelationInput | inducks_storyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_storyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_stories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_stories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_stories
    **/
    _count?: true | Inducks_storyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Inducks_storyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Inducks_storySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_storyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_storyMaxAggregateInputType
  }

  export type GetInducks_storyAggregateType<T extends Inducks_storyAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_story]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_story[P]>
      : GetScalarType<T[P], AggregateInducks_story[P]>
  }




  export type inducks_storyGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_storyWhereInput
    orderBy?: inducks_storyOrderByWithAggregationInput | inducks_storyOrderByWithAggregationInput[]
    by: Inducks_storyScalarFieldEnum[] | Inducks_storyScalarFieldEnum
    having?: inducks_storyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_storyCountAggregateInputType | true
    _avg?: Inducks_storyAvgAggregateInputType
    _sum?: Inducks_storySumAggregateInputType
    _min?: Inducks_storyMinAggregateInputType
    _max?: Inducks_storyMaxAggregateInputType
  }

  export type Inducks_storyGroupByOutputType = {
    storycode: string
    originalstoryversioncode: string | null
    creationdate: string | null
    firstpublicationdate: string | null
    endpublicationdate: string | null
    title: string | null
    usedifferentcode: string | null
    storycomment: string | null
    error: $Enums.inducks_story_error | null
    repcountrysummary: string | null
    storyparts: number | null
    locked: $Enums.inducks_story_locked | null
    inputfilecode: number | null
    issuecodeofstoryitem: string | null
    maintenanceteamcode: string | null
    storyheadercode: string | null
    _count: Inducks_storyCountAggregateOutputType | null
    _avg: Inducks_storyAvgAggregateOutputType | null
    _sum: Inducks_storySumAggregateOutputType | null
    _min: Inducks_storyMinAggregateOutputType | null
    _max: Inducks_storyMaxAggregateOutputType | null
  }

  type GetInducks_storyGroupByPayload<T extends inducks_storyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_storyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_storyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_storyGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_storyGroupByOutputType[P]>
        }
      >
    >


  export type inducks_storySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    storycode?: boolean
    originalstoryversioncode?: boolean
    creationdate?: boolean
    firstpublicationdate?: boolean
    endpublicationdate?: boolean
    title?: boolean
    usedifferentcode?: boolean
    storycomment?: boolean
    error?: boolean
    repcountrysummary?: boolean
    storyparts?: boolean
    locked?: boolean
    inputfilecode?: boolean
    issuecodeofstoryitem?: boolean
    maintenanceteamcode?: boolean
    storyheadercode?: boolean
  }, ExtArgs["result"]["inducks_story"]>

  export type inducks_storySelectScalar = {
    storycode?: boolean
    originalstoryversioncode?: boolean
    creationdate?: boolean
    firstpublicationdate?: boolean
    endpublicationdate?: boolean
    title?: boolean
    usedifferentcode?: boolean
    storycomment?: boolean
    error?: boolean
    repcountrysummary?: boolean
    storyparts?: boolean
    locked?: boolean
    inputfilecode?: boolean
    issuecodeofstoryitem?: boolean
    maintenanceteamcode?: boolean
    storyheadercode?: boolean
  }


  export type $inducks_storyPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_story"
    objects: {}
    scalars: $Extensions.GetResult<{
      storycode: string
      originalstoryversioncode: string | null
      creationdate: string | null
      firstpublicationdate: string | null
      endpublicationdate: string | null
      title: string | null
      usedifferentcode: string | null
      storycomment: string | null
      error: $Enums.inducks_story_error | null
      repcountrysummary: string | null
      storyparts: number | null
      locked: $Enums.inducks_story_locked | null
      inputfilecode: number | null
      issuecodeofstoryitem: string | null
      maintenanceteamcode: string | null
      storyheadercode: string | null
    }, ExtArgs["result"]["inducks_story"]>
    composites: {}
  }


  type inducks_storyGetPayload<S extends boolean | null | undefined | inducks_storyDefaultArgs> = $Result.GetResult<Prisma.$inducks_storyPayload, S>

  type inducks_storyCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_storyFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_storyCountAggregateInputType | true
    }

  export interface inducks_storyDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_story'], meta: { name: 'inducks_story' } }
    /**
     * Find zero or one Inducks_story that matches the filter.
     * @param {inducks_storyFindUniqueArgs} args - Arguments to find a Inducks_story
     * @example
     * // Get one Inducks_story
     * const inducks_story = await prisma.inducks_story.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_storyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_storyClient<$Result.GetResult<Prisma.$inducks_storyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_story that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_storyFindUniqueOrThrowArgs} args - Arguments to find a Inducks_story
     * @example
     * // Get one Inducks_story
     * const inducks_story = await prisma.inducks_story.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_storyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_storyClient<$Result.GetResult<Prisma.$inducks_storyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_story that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyFindFirstArgs} args - Arguments to find a Inducks_story
     * @example
     * // Get one Inducks_story
     * const inducks_story = await prisma.inducks_story.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_storyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_storyClient<$Result.GetResult<Prisma.$inducks_storyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_story that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyFindFirstOrThrowArgs} args - Arguments to find a Inducks_story
     * @example
     * // Get one Inducks_story
     * const inducks_story = await prisma.inducks_story.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_storyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_storyClient<$Result.GetResult<Prisma.$inducks_storyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_stories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_stories
     * const inducks_stories = await prisma.inducks_story.findMany()
     * 
     * // Get first 10 Inducks_stories
     * const inducks_stories = await prisma.inducks_story.findMany({ take: 10 })
     * 
     * // Only select the `storycode`
     * const inducks_storyWithStorycodeOnly = await prisma.inducks_story.findMany({ select: { storycode: true } })
     * 
    **/
    findMany<T extends inducks_storyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_storyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_story.
     * @param {inducks_storyCreateArgs} args - Arguments to create a Inducks_story.
     * @example
     * // Create one Inducks_story
     * const Inducks_story = await prisma.inducks_story.create({
     *   data: {
     *     // ... data to create a Inducks_story
     *   }
     * })
     * 
    **/
    create<T extends inducks_storyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyCreateArgs<ExtArgs>>
    ): Prisma__inducks_storyClient<$Result.GetResult<Prisma.$inducks_storyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_stories.
     *     @param {inducks_storyCreateManyArgs} args - Arguments to create many Inducks_stories.
     *     @example
     *     // Create many Inducks_stories
     *     const inducks_story = await prisma.inducks_story.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_storyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_story.
     * @param {inducks_storyDeleteArgs} args - Arguments to delete one Inducks_story.
     * @example
     * // Delete one Inducks_story
     * const Inducks_story = await prisma.inducks_story.delete({
     *   where: {
     *     // ... filter to delete one Inducks_story
     *   }
     * })
     * 
    **/
    delete<T extends inducks_storyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyDeleteArgs<ExtArgs>>
    ): Prisma__inducks_storyClient<$Result.GetResult<Prisma.$inducks_storyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_story.
     * @param {inducks_storyUpdateArgs} args - Arguments to update one Inducks_story.
     * @example
     * // Update one Inducks_story
     * const inducks_story = await prisma.inducks_story.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_storyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyUpdateArgs<ExtArgs>>
    ): Prisma__inducks_storyClient<$Result.GetResult<Prisma.$inducks_storyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_stories.
     * @param {inducks_storyDeleteManyArgs} args - Arguments to filter Inducks_stories to delete.
     * @example
     * // Delete a few Inducks_stories
     * const { count } = await prisma.inducks_story.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_storyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_stories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_stories
     * const inducks_story = await prisma.inducks_story.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_storyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_story.
     * @param {inducks_storyUpsertArgs} args - Arguments to update or create a Inducks_story.
     * @example
     * // Update or create a Inducks_story
     * const inducks_story = await prisma.inducks_story.upsert({
     *   create: {
     *     // ... data to create a Inducks_story
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_story we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_storyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyUpsertArgs<ExtArgs>>
    ): Prisma__inducks_storyClient<$Result.GetResult<Prisma.$inducks_storyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_stories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyCountArgs} args - Arguments to filter Inducks_stories to count.
     * @example
     * // Count the number of Inducks_stories
     * const count = await prisma.inducks_story.count({
     *   where: {
     *     // ... the filter for the Inducks_stories we want to count
     *   }
     * })
    **/
    count<T extends inducks_storyCountArgs>(
      args?: Subset<T, inducks_storyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_storyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_story.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_storyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_storyAggregateArgs>(args: Subset<T, Inducks_storyAggregateArgs>): Prisma.PrismaPromise<GetInducks_storyAggregateType<T>>

    /**
     * Group by Inducks_story.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_storyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_storyGroupByArgs['orderBy'] }
        : { orderBy?: inducks_storyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_storyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_storyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_story model
   */
  readonly fields: inducks_storyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_story.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_storyClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_story model
   */ 
  interface inducks_storyFieldRefs {
    readonly storycode: FieldRef<"inducks_story", 'String'>
    readonly originalstoryversioncode: FieldRef<"inducks_story", 'String'>
    readonly creationdate: FieldRef<"inducks_story", 'String'>
    readonly firstpublicationdate: FieldRef<"inducks_story", 'String'>
    readonly endpublicationdate: FieldRef<"inducks_story", 'String'>
    readonly title: FieldRef<"inducks_story", 'String'>
    readonly usedifferentcode: FieldRef<"inducks_story", 'String'>
    readonly storycomment: FieldRef<"inducks_story", 'String'>
    readonly error: FieldRef<"inducks_story", 'inducks_story_error'>
    readonly repcountrysummary: FieldRef<"inducks_story", 'String'>
    readonly storyparts: FieldRef<"inducks_story", 'Int'>
    readonly locked: FieldRef<"inducks_story", 'inducks_story_locked'>
    readonly inputfilecode: FieldRef<"inducks_story", 'Int'>
    readonly issuecodeofstoryitem: FieldRef<"inducks_story", 'String'>
    readonly maintenanceteamcode: FieldRef<"inducks_story", 'String'>
    readonly storyheadercode: FieldRef<"inducks_story", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_story findUnique
   */
  export type inducks_storyFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_story
     */
    select?: inducks_storySelect<ExtArgs> | null
    /**
     * Filter, which inducks_story to fetch.
     */
    where: inducks_storyWhereUniqueInput
  }


  /**
   * inducks_story findUniqueOrThrow
   */
  export type inducks_storyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_story
     */
    select?: inducks_storySelect<ExtArgs> | null
    /**
     * Filter, which inducks_story to fetch.
     */
    where: inducks_storyWhereUniqueInput
  }


  /**
   * inducks_story findFirst
   */
  export type inducks_storyFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_story
     */
    select?: inducks_storySelect<ExtArgs> | null
    /**
     * Filter, which inducks_story to fetch.
     */
    where?: inducks_storyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_stories to fetch.
     */
    orderBy?: inducks_storyOrderByWithRelationInput | inducks_storyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_stories.
     */
    cursor?: inducks_storyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_stories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_stories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_stories.
     */
    distinct?: Inducks_storyScalarFieldEnum | Inducks_storyScalarFieldEnum[]
  }


  /**
   * inducks_story findFirstOrThrow
   */
  export type inducks_storyFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_story
     */
    select?: inducks_storySelect<ExtArgs> | null
    /**
     * Filter, which inducks_story to fetch.
     */
    where?: inducks_storyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_stories to fetch.
     */
    orderBy?: inducks_storyOrderByWithRelationInput | inducks_storyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_stories.
     */
    cursor?: inducks_storyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_stories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_stories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_stories.
     */
    distinct?: Inducks_storyScalarFieldEnum | Inducks_storyScalarFieldEnum[]
  }


  /**
   * inducks_story findMany
   */
  export type inducks_storyFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_story
     */
    select?: inducks_storySelect<ExtArgs> | null
    /**
     * Filter, which inducks_stories to fetch.
     */
    where?: inducks_storyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_stories to fetch.
     */
    orderBy?: inducks_storyOrderByWithRelationInput | inducks_storyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_stories.
     */
    cursor?: inducks_storyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_stories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_stories.
     */
    skip?: number
    distinct?: Inducks_storyScalarFieldEnum | Inducks_storyScalarFieldEnum[]
  }


  /**
   * inducks_story create
   */
  export type inducks_storyCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_story
     */
    select?: inducks_storySelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_story.
     */
    data: XOR<inducks_storyCreateInput, inducks_storyUncheckedCreateInput>
  }


  /**
   * inducks_story createMany
   */
  export type inducks_storyCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_stories.
     */
    data: inducks_storyCreateManyInput | inducks_storyCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_story update
   */
  export type inducks_storyUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_story
     */
    select?: inducks_storySelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_story.
     */
    data: XOR<inducks_storyUpdateInput, inducks_storyUncheckedUpdateInput>
    /**
     * Choose, which inducks_story to update.
     */
    where: inducks_storyWhereUniqueInput
  }


  /**
   * inducks_story updateMany
   */
  export type inducks_storyUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_stories.
     */
    data: XOR<inducks_storyUpdateManyMutationInput, inducks_storyUncheckedUpdateManyInput>
    /**
     * Filter which inducks_stories to update
     */
    where?: inducks_storyWhereInput
  }


  /**
   * inducks_story upsert
   */
  export type inducks_storyUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_story
     */
    select?: inducks_storySelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_story to update in case it exists.
     */
    where: inducks_storyWhereUniqueInput
    /**
     * In case the inducks_story found by the `where` argument doesn't exist, create a new inducks_story with this data.
     */
    create: XOR<inducks_storyCreateInput, inducks_storyUncheckedCreateInput>
    /**
     * In case the inducks_story was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_storyUpdateInput, inducks_storyUncheckedUpdateInput>
  }


  /**
   * inducks_story delete
   */
  export type inducks_storyDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_story
     */
    select?: inducks_storySelect<ExtArgs> | null
    /**
     * Filter which inducks_story to delete.
     */
    where: inducks_storyWhereUniqueInput
  }


  /**
   * inducks_story deleteMany
   */
  export type inducks_storyDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_stories to delete
     */
    where?: inducks_storyWhereInput
  }


  /**
   * inducks_story without action
   */
  export type inducks_storyDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_story
     */
    select?: inducks_storySelect<ExtArgs> | null
  }



  /**
   * Model inducks_storycodes
   */

  export type AggregateInducks_storycodes = {
    _count: Inducks_storycodesCountAggregateOutputType | null
    _min: Inducks_storycodesMinAggregateOutputType | null
    _max: Inducks_storycodesMaxAggregateOutputType | null
  }

  export type Inducks_storycodesMinAggregateOutputType = {
    storycode: string | null
    alternativecode: string | null
    unpackedcode: string | null
    codecomment: string | null
  }

  export type Inducks_storycodesMaxAggregateOutputType = {
    storycode: string | null
    alternativecode: string | null
    unpackedcode: string | null
    codecomment: string | null
  }

  export type Inducks_storycodesCountAggregateOutputType = {
    storycode: number
    alternativecode: number
    unpackedcode: number
    codecomment: number
    _all: number
  }


  export type Inducks_storycodesMinAggregateInputType = {
    storycode?: true
    alternativecode?: true
    unpackedcode?: true
    codecomment?: true
  }

  export type Inducks_storycodesMaxAggregateInputType = {
    storycode?: true
    alternativecode?: true
    unpackedcode?: true
    codecomment?: true
  }

  export type Inducks_storycodesCountAggregateInputType = {
    storycode?: true
    alternativecode?: true
    unpackedcode?: true
    codecomment?: true
    _all?: true
  }

  export type Inducks_storycodesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_storycodes to aggregate.
     */
    where?: inducks_storycodesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_storycodes to fetch.
     */
    orderBy?: inducks_storycodesOrderByWithRelationInput | inducks_storycodesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_storycodesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_storycodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_storycodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_storycodes
    **/
    _count?: true | Inducks_storycodesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_storycodesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_storycodesMaxAggregateInputType
  }

  export type GetInducks_storycodesAggregateType<T extends Inducks_storycodesAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_storycodes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_storycodes[P]>
      : GetScalarType<T[P], AggregateInducks_storycodes[P]>
  }




  export type inducks_storycodesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_storycodesWhereInput
    orderBy?: inducks_storycodesOrderByWithAggregationInput | inducks_storycodesOrderByWithAggregationInput[]
    by: Inducks_storycodesScalarFieldEnum[] | Inducks_storycodesScalarFieldEnum
    having?: inducks_storycodesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_storycodesCountAggregateInputType | true
    _min?: Inducks_storycodesMinAggregateInputType
    _max?: Inducks_storycodesMaxAggregateInputType
  }

  export type Inducks_storycodesGroupByOutputType = {
    storycode: string
    alternativecode: string
    unpackedcode: string | null
    codecomment: string | null
    _count: Inducks_storycodesCountAggregateOutputType | null
    _min: Inducks_storycodesMinAggregateOutputType | null
    _max: Inducks_storycodesMaxAggregateOutputType | null
  }

  type GetInducks_storycodesGroupByPayload<T extends inducks_storycodesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_storycodesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_storycodesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_storycodesGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_storycodesGroupByOutputType[P]>
        }
      >
    >


  export type inducks_storycodesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    storycode?: boolean
    alternativecode?: boolean
    unpackedcode?: boolean
    codecomment?: boolean
  }, ExtArgs["result"]["inducks_storycodes"]>

  export type inducks_storycodesSelectScalar = {
    storycode?: boolean
    alternativecode?: boolean
    unpackedcode?: boolean
    codecomment?: boolean
  }


  export type $inducks_storycodesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_storycodes"
    objects: {}
    scalars: $Extensions.GetResult<{
      storycode: string
      alternativecode: string
      unpackedcode: string | null
      codecomment: string | null
    }, ExtArgs["result"]["inducks_storycodes"]>
    composites: {}
  }


  type inducks_storycodesGetPayload<S extends boolean | null | undefined | inducks_storycodesDefaultArgs> = $Result.GetResult<Prisma.$inducks_storycodesPayload, S>

  type inducks_storycodesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_storycodesFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_storycodesCountAggregateInputType | true
    }

  export interface inducks_storycodesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_storycodes'], meta: { name: 'inducks_storycodes' } }
    /**
     * Find zero or one Inducks_storycodes that matches the filter.
     * @param {inducks_storycodesFindUniqueArgs} args - Arguments to find a Inducks_storycodes
     * @example
     * // Get one Inducks_storycodes
     * const inducks_storycodes = await prisma.inducks_storycodes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_storycodesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storycodesFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_storycodesClient<$Result.GetResult<Prisma.$inducks_storycodesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_storycodes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_storycodesFindUniqueOrThrowArgs} args - Arguments to find a Inducks_storycodes
     * @example
     * // Get one Inducks_storycodes
     * const inducks_storycodes = await prisma.inducks_storycodes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_storycodesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storycodesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_storycodesClient<$Result.GetResult<Prisma.$inducks_storycodesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_storycodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storycodesFindFirstArgs} args - Arguments to find a Inducks_storycodes
     * @example
     * // Get one Inducks_storycodes
     * const inducks_storycodes = await prisma.inducks_storycodes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_storycodesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storycodesFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_storycodesClient<$Result.GetResult<Prisma.$inducks_storycodesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_storycodes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storycodesFindFirstOrThrowArgs} args - Arguments to find a Inducks_storycodes
     * @example
     * // Get one Inducks_storycodes
     * const inducks_storycodes = await prisma.inducks_storycodes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_storycodesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storycodesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_storycodesClient<$Result.GetResult<Prisma.$inducks_storycodesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_storycodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storycodesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_storycodes
     * const inducks_storycodes = await prisma.inducks_storycodes.findMany()
     * 
     * // Get first 10 Inducks_storycodes
     * const inducks_storycodes = await prisma.inducks_storycodes.findMany({ take: 10 })
     * 
     * // Only select the `storycode`
     * const inducks_storycodesWithStorycodeOnly = await prisma.inducks_storycodes.findMany({ select: { storycode: true } })
     * 
    **/
    findMany<T extends inducks_storycodesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storycodesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_storycodesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_storycodes.
     * @param {inducks_storycodesCreateArgs} args - Arguments to create a Inducks_storycodes.
     * @example
     * // Create one Inducks_storycodes
     * const Inducks_storycodes = await prisma.inducks_storycodes.create({
     *   data: {
     *     // ... data to create a Inducks_storycodes
     *   }
     * })
     * 
    **/
    create<T extends inducks_storycodesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storycodesCreateArgs<ExtArgs>>
    ): Prisma__inducks_storycodesClient<$Result.GetResult<Prisma.$inducks_storycodesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_storycodes.
     *     @param {inducks_storycodesCreateManyArgs} args - Arguments to create many Inducks_storycodes.
     *     @example
     *     // Create many Inducks_storycodes
     *     const inducks_storycodes = await prisma.inducks_storycodes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_storycodesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storycodesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_storycodes.
     * @param {inducks_storycodesDeleteArgs} args - Arguments to delete one Inducks_storycodes.
     * @example
     * // Delete one Inducks_storycodes
     * const Inducks_storycodes = await prisma.inducks_storycodes.delete({
     *   where: {
     *     // ... filter to delete one Inducks_storycodes
     *   }
     * })
     * 
    **/
    delete<T extends inducks_storycodesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storycodesDeleteArgs<ExtArgs>>
    ): Prisma__inducks_storycodesClient<$Result.GetResult<Prisma.$inducks_storycodesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_storycodes.
     * @param {inducks_storycodesUpdateArgs} args - Arguments to update one Inducks_storycodes.
     * @example
     * // Update one Inducks_storycodes
     * const inducks_storycodes = await prisma.inducks_storycodes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_storycodesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storycodesUpdateArgs<ExtArgs>>
    ): Prisma__inducks_storycodesClient<$Result.GetResult<Prisma.$inducks_storycodesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_storycodes.
     * @param {inducks_storycodesDeleteManyArgs} args - Arguments to filter Inducks_storycodes to delete.
     * @example
     * // Delete a few Inducks_storycodes
     * const { count } = await prisma.inducks_storycodes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_storycodesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storycodesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_storycodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storycodesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_storycodes
     * const inducks_storycodes = await prisma.inducks_storycodes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_storycodesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storycodesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_storycodes.
     * @param {inducks_storycodesUpsertArgs} args - Arguments to update or create a Inducks_storycodes.
     * @example
     * // Update or create a Inducks_storycodes
     * const inducks_storycodes = await prisma.inducks_storycodes.upsert({
     *   create: {
     *     // ... data to create a Inducks_storycodes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_storycodes we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_storycodesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storycodesUpsertArgs<ExtArgs>>
    ): Prisma__inducks_storycodesClient<$Result.GetResult<Prisma.$inducks_storycodesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_storycodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storycodesCountArgs} args - Arguments to filter Inducks_storycodes to count.
     * @example
     * // Count the number of Inducks_storycodes
     * const count = await prisma.inducks_storycodes.count({
     *   where: {
     *     // ... the filter for the Inducks_storycodes we want to count
     *   }
     * })
    **/
    count<T extends inducks_storycodesCountArgs>(
      args?: Subset<T, inducks_storycodesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_storycodesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_storycodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_storycodesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_storycodesAggregateArgs>(args: Subset<T, Inducks_storycodesAggregateArgs>): Prisma.PrismaPromise<GetInducks_storycodesAggregateType<T>>

    /**
     * Group by Inducks_storycodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storycodesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_storycodesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_storycodesGroupByArgs['orderBy'] }
        : { orderBy?: inducks_storycodesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_storycodesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_storycodesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_storycodes model
   */
  readonly fields: inducks_storycodesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_storycodes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_storycodesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_storycodes model
   */ 
  interface inducks_storycodesFieldRefs {
    readonly storycode: FieldRef<"inducks_storycodes", 'String'>
    readonly alternativecode: FieldRef<"inducks_storycodes", 'String'>
    readonly unpackedcode: FieldRef<"inducks_storycodes", 'String'>
    readonly codecomment: FieldRef<"inducks_storycodes", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_storycodes findUnique
   */
  export type inducks_storycodesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storycodes
     */
    select?: inducks_storycodesSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storycodes to fetch.
     */
    where: inducks_storycodesWhereUniqueInput
  }


  /**
   * inducks_storycodes findUniqueOrThrow
   */
  export type inducks_storycodesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storycodes
     */
    select?: inducks_storycodesSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storycodes to fetch.
     */
    where: inducks_storycodesWhereUniqueInput
  }


  /**
   * inducks_storycodes findFirst
   */
  export type inducks_storycodesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storycodes
     */
    select?: inducks_storycodesSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storycodes to fetch.
     */
    where?: inducks_storycodesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_storycodes to fetch.
     */
    orderBy?: inducks_storycodesOrderByWithRelationInput | inducks_storycodesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_storycodes.
     */
    cursor?: inducks_storycodesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_storycodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_storycodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_storycodes.
     */
    distinct?: Inducks_storycodesScalarFieldEnum | Inducks_storycodesScalarFieldEnum[]
  }


  /**
   * inducks_storycodes findFirstOrThrow
   */
  export type inducks_storycodesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storycodes
     */
    select?: inducks_storycodesSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storycodes to fetch.
     */
    where?: inducks_storycodesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_storycodes to fetch.
     */
    orderBy?: inducks_storycodesOrderByWithRelationInput | inducks_storycodesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_storycodes.
     */
    cursor?: inducks_storycodesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_storycodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_storycodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_storycodes.
     */
    distinct?: Inducks_storycodesScalarFieldEnum | Inducks_storycodesScalarFieldEnum[]
  }


  /**
   * inducks_storycodes findMany
   */
  export type inducks_storycodesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storycodes
     */
    select?: inducks_storycodesSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storycodes to fetch.
     */
    where?: inducks_storycodesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_storycodes to fetch.
     */
    orderBy?: inducks_storycodesOrderByWithRelationInput | inducks_storycodesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_storycodes.
     */
    cursor?: inducks_storycodesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_storycodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_storycodes.
     */
    skip?: number
    distinct?: Inducks_storycodesScalarFieldEnum | Inducks_storycodesScalarFieldEnum[]
  }


  /**
   * inducks_storycodes create
   */
  export type inducks_storycodesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storycodes
     */
    select?: inducks_storycodesSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_storycodes.
     */
    data: XOR<inducks_storycodesCreateInput, inducks_storycodesUncheckedCreateInput>
  }


  /**
   * inducks_storycodes createMany
   */
  export type inducks_storycodesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_storycodes.
     */
    data: inducks_storycodesCreateManyInput | inducks_storycodesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_storycodes update
   */
  export type inducks_storycodesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storycodes
     */
    select?: inducks_storycodesSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_storycodes.
     */
    data: XOR<inducks_storycodesUpdateInput, inducks_storycodesUncheckedUpdateInput>
    /**
     * Choose, which inducks_storycodes to update.
     */
    where: inducks_storycodesWhereUniqueInput
  }


  /**
   * inducks_storycodes updateMany
   */
  export type inducks_storycodesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_storycodes.
     */
    data: XOR<inducks_storycodesUpdateManyMutationInput, inducks_storycodesUncheckedUpdateManyInput>
    /**
     * Filter which inducks_storycodes to update
     */
    where?: inducks_storycodesWhereInput
  }


  /**
   * inducks_storycodes upsert
   */
  export type inducks_storycodesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storycodes
     */
    select?: inducks_storycodesSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_storycodes to update in case it exists.
     */
    where: inducks_storycodesWhereUniqueInput
    /**
     * In case the inducks_storycodes found by the `where` argument doesn't exist, create a new inducks_storycodes with this data.
     */
    create: XOR<inducks_storycodesCreateInput, inducks_storycodesUncheckedCreateInput>
    /**
     * In case the inducks_storycodes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_storycodesUpdateInput, inducks_storycodesUncheckedUpdateInput>
  }


  /**
   * inducks_storycodes delete
   */
  export type inducks_storycodesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storycodes
     */
    select?: inducks_storycodesSelect<ExtArgs> | null
    /**
     * Filter which inducks_storycodes to delete.
     */
    where: inducks_storycodesWhereUniqueInput
  }


  /**
   * inducks_storycodes deleteMany
   */
  export type inducks_storycodesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_storycodes to delete
     */
    where?: inducks_storycodesWhereInput
  }


  /**
   * inducks_storycodes without action
   */
  export type inducks_storycodesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storycodes
     */
    select?: inducks_storycodesSelect<ExtArgs> | null
  }



  /**
   * Model inducks_storydescription
   */

  export type AggregateInducks_storydescription = {
    _count: Inducks_storydescriptionCountAggregateOutputType | null
    _min: Inducks_storydescriptionMinAggregateOutputType | null
    _max: Inducks_storydescriptionMaxAggregateOutputType | null
  }

  export type Inducks_storydescriptionMinAggregateOutputType = {
    storyversioncode: string | null
    languagecode: string | null
    desctext: string | null
  }

  export type Inducks_storydescriptionMaxAggregateOutputType = {
    storyversioncode: string | null
    languagecode: string | null
    desctext: string | null
  }

  export type Inducks_storydescriptionCountAggregateOutputType = {
    storyversioncode: number
    languagecode: number
    desctext: number
    _all: number
  }


  export type Inducks_storydescriptionMinAggregateInputType = {
    storyversioncode?: true
    languagecode?: true
    desctext?: true
  }

  export type Inducks_storydescriptionMaxAggregateInputType = {
    storyversioncode?: true
    languagecode?: true
    desctext?: true
  }

  export type Inducks_storydescriptionCountAggregateInputType = {
    storyversioncode?: true
    languagecode?: true
    desctext?: true
    _all?: true
  }

  export type Inducks_storydescriptionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_storydescription to aggregate.
     */
    where?: inducks_storydescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_storydescriptions to fetch.
     */
    orderBy?: inducks_storydescriptionOrderByWithRelationInput | inducks_storydescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_storydescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_storydescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_storydescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_storydescriptions
    **/
    _count?: true | Inducks_storydescriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_storydescriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_storydescriptionMaxAggregateInputType
  }

  export type GetInducks_storydescriptionAggregateType<T extends Inducks_storydescriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_storydescription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_storydescription[P]>
      : GetScalarType<T[P], AggregateInducks_storydescription[P]>
  }




  export type inducks_storydescriptionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_storydescriptionWhereInput
    orderBy?: inducks_storydescriptionOrderByWithAggregationInput | inducks_storydescriptionOrderByWithAggregationInput[]
    by: Inducks_storydescriptionScalarFieldEnum[] | Inducks_storydescriptionScalarFieldEnum
    having?: inducks_storydescriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_storydescriptionCountAggregateInputType | true
    _min?: Inducks_storydescriptionMinAggregateInputType
    _max?: Inducks_storydescriptionMaxAggregateInputType
  }

  export type Inducks_storydescriptionGroupByOutputType = {
    storyversioncode: string
    languagecode: string
    desctext: string | null
    _count: Inducks_storydescriptionCountAggregateOutputType | null
    _min: Inducks_storydescriptionMinAggregateOutputType | null
    _max: Inducks_storydescriptionMaxAggregateOutputType | null
  }

  type GetInducks_storydescriptionGroupByPayload<T extends inducks_storydescriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_storydescriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_storydescriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_storydescriptionGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_storydescriptionGroupByOutputType[P]>
        }
      >
    >


  export type inducks_storydescriptionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    storyversioncode?: boolean
    languagecode?: boolean
    desctext?: boolean
  }, ExtArgs["result"]["inducks_storydescription"]>

  export type inducks_storydescriptionSelectScalar = {
    storyversioncode?: boolean
    languagecode?: boolean
    desctext?: boolean
  }


  export type $inducks_storydescriptionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_storydescription"
    objects: {}
    scalars: $Extensions.GetResult<{
      storyversioncode: string
      languagecode: string
      desctext: string | null
    }, ExtArgs["result"]["inducks_storydescription"]>
    composites: {}
  }


  type inducks_storydescriptionGetPayload<S extends boolean | null | undefined | inducks_storydescriptionDefaultArgs> = $Result.GetResult<Prisma.$inducks_storydescriptionPayload, S>

  type inducks_storydescriptionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_storydescriptionFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_storydescriptionCountAggregateInputType | true
    }

  export interface inducks_storydescriptionDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_storydescription'], meta: { name: 'inducks_storydescription' } }
    /**
     * Find zero or one Inducks_storydescription that matches the filter.
     * @param {inducks_storydescriptionFindUniqueArgs} args - Arguments to find a Inducks_storydescription
     * @example
     * // Get one Inducks_storydescription
     * const inducks_storydescription = await prisma.inducks_storydescription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_storydescriptionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storydescriptionFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_storydescriptionClient<$Result.GetResult<Prisma.$inducks_storydescriptionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_storydescription that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_storydescriptionFindUniqueOrThrowArgs} args - Arguments to find a Inducks_storydescription
     * @example
     * // Get one Inducks_storydescription
     * const inducks_storydescription = await prisma.inducks_storydescription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_storydescriptionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storydescriptionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_storydescriptionClient<$Result.GetResult<Prisma.$inducks_storydescriptionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_storydescription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storydescriptionFindFirstArgs} args - Arguments to find a Inducks_storydescription
     * @example
     * // Get one Inducks_storydescription
     * const inducks_storydescription = await prisma.inducks_storydescription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_storydescriptionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storydescriptionFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_storydescriptionClient<$Result.GetResult<Prisma.$inducks_storydescriptionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_storydescription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storydescriptionFindFirstOrThrowArgs} args - Arguments to find a Inducks_storydescription
     * @example
     * // Get one Inducks_storydescription
     * const inducks_storydescription = await prisma.inducks_storydescription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_storydescriptionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storydescriptionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_storydescriptionClient<$Result.GetResult<Prisma.$inducks_storydescriptionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_storydescriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storydescriptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_storydescriptions
     * const inducks_storydescriptions = await prisma.inducks_storydescription.findMany()
     * 
     * // Get first 10 Inducks_storydescriptions
     * const inducks_storydescriptions = await prisma.inducks_storydescription.findMany({ take: 10 })
     * 
     * // Only select the `storyversioncode`
     * const inducks_storydescriptionWithStoryversioncodeOnly = await prisma.inducks_storydescription.findMany({ select: { storyversioncode: true } })
     * 
    **/
    findMany<T extends inducks_storydescriptionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storydescriptionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_storydescriptionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_storydescription.
     * @param {inducks_storydescriptionCreateArgs} args - Arguments to create a Inducks_storydescription.
     * @example
     * // Create one Inducks_storydescription
     * const Inducks_storydescription = await prisma.inducks_storydescription.create({
     *   data: {
     *     // ... data to create a Inducks_storydescription
     *   }
     * })
     * 
    **/
    create<T extends inducks_storydescriptionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storydescriptionCreateArgs<ExtArgs>>
    ): Prisma__inducks_storydescriptionClient<$Result.GetResult<Prisma.$inducks_storydescriptionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_storydescriptions.
     *     @param {inducks_storydescriptionCreateManyArgs} args - Arguments to create many Inducks_storydescriptions.
     *     @example
     *     // Create many Inducks_storydescriptions
     *     const inducks_storydescription = await prisma.inducks_storydescription.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_storydescriptionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storydescriptionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_storydescription.
     * @param {inducks_storydescriptionDeleteArgs} args - Arguments to delete one Inducks_storydescription.
     * @example
     * // Delete one Inducks_storydescription
     * const Inducks_storydescription = await prisma.inducks_storydescription.delete({
     *   where: {
     *     // ... filter to delete one Inducks_storydescription
     *   }
     * })
     * 
    **/
    delete<T extends inducks_storydescriptionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storydescriptionDeleteArgs<ExtArgs>>
    ): Prisma__inducks_storydescriptionClient<$Result.GetResult<Prisma.$inducks_storydescriptionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_storydescription.
     * @param {inducks_storydescriptionUpdateArgs} args - Arguments to update one Inducks_storydescription.
     * @example
     * // Update one Inducks_storydescription
     * const inducks_storydescription = await prisma.inducks_storydescription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_storydescriptionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storydescriptionUpdateArgs<ExtArgs>>
    ): Prisma__inducks_storydescriptionClient<$Result.GetResult<Prisma.$inducks_storydescriptionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_storydescriptions.
     * @param {inducks_storydescriptionDeleteManyArgs} args - Arguments to filter Inducks_storydescriptions to delete.
     * @example
     * // Delete a few Inducks_storydescriptions
     * const { count } = await prisma.inducks_storydescription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_storydescriptionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storydescriptionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_storydescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storydescriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_storydescriptions
     * const inducks_storydescription = await prisma.inducks_storydescription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_storydescriptionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storydescriptionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_storydescription.
     * @param {inducks_storydescriptionUpsertArgs} args - Arguments to update or create a Inducks_storydescription.
     * @example
     * // Update or create a Inducks_storydescription
     * const inducks_storydescription = await prisma.inducks_storydescription.upsert({
     *   create: {
     *     // ... data to create a Inducks_storydescription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_storydescription we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_storydescriptionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storydescriptionUpsertArgs<ExtArgs>>
    ): Prisma__inducks_storydescriptionClient<$Result.GetResult<Prisma.$inducks_storydescriptionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_storydescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storydescriptionCountArgs} args - Arguments to filter Inducks_storydescriptions to count.
     * @example
     * // Count the number of Inducks_storydescriptions
     * const count = await prisma.inducks_storydescription.count({
     *   where: {
     *     // ... the filter for the Inducks_storydescriptions we want to count
     *   }
     * })
    **/
    count<T extends inducks_storydescriptionCountArgs>(
      args?: Subset<T, inducks_storydescriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_storydescriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_storydescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_storydescriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_storydescriptionAggregateArgs>(args: Subset<T, Inducks_storydescriptionAggregateArgs>): Prisma.PrismaPromise<GetInducks_storydescriptionAggregateType<T>>

    /**
     * Group by Inducks_storydescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storydescriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_storydescriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_storydescriptionGroupByArgs['orderBy'] }
        : { orderBy?: inducks_storydescriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_storydescriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_storydescriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_storydescription model
   */
  readonly fields: inducks_storydescriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_storydescription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_storydescriptionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_storydescription model
   */ 
  interface inducks_storydescriptionFieldRefs {
    readonly storyversioncode: FieldRef<"inducks_storydescription", 'String'>
    readonly languagecode: FieldRef<"inducks_storydescription", 'String'>
    readonly desctext: FieldRef<"inducks_storydescription", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_storydescription findUnique
   */
  export type inducks_storydescriptionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storydescription
     */
    select?: inducks_storydescriptionSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storydescription to fetch.
     */
    where: inducks_storydescriptionWhereUniqueInput
  }


  /**
   * inducks_storydescription findUniqueOrThrow
   */
  export type inducks_storydescriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storydescription
     */
    select?: inducks_storydescriptionSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storydescription to fetch.
     */
    where: inducks_storydescriptionWhereUniqueInput
  }


  /**
   * inducks_storydescription findFirst
   */
  export type inducks_storydescriptionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storydescription
     */
    select?: inducks_storydescriptionSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storydescription to fetch.
     */
    where?: inducks_storydescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_storydescriptions to fetch.
     */
    orderBy?: inducks_storydescriptionOrderByWithRelationInput | inducks_storydescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_storydescriptions.
     */
    cursor?: inducks_storydescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_storydescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_storydescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_storydescriptions.
     */
    distinct?: Inducks_storydescriptionScalarFieldEnum | Inducks_storydescriptionScalarFieldEnum[]
  }


  /**
   * inducks_storydescription findFirstOrThrow
   */
  export type inducks_storydescriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storydescription
     */
    select?: inducks_storydescriptionSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storydescription to fetch.
     */
    where?: inducks_storydescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_storydescriptions to fetch.
     */
    orderBy?: inducks_storydescriptionOrderByWithRelationInput | inducks_storydescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_storydescriptions.
     */
    cursor?: inducks_storydescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_storydescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_storydescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_storydescriptions.
     */
    distinct?: Inducks_storydescriptionScalarFieldEnum | Inducks_storydescriptionScalarFieldEnum[]
  }


  /**
   * inducks_storydescription findMany
   */
  export type inducks_storydescriptionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storydescription
     */
    select?: inducks_storydescriptionSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storydescriptions to fetch.
     */
    where?: inducks_storydescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_storydescriptions to fetch.
     */
    orderBy?: inducks_storydescriptionOrderByWithRelationInput | inducks_storydescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_storydescriptions.
     */
    cursor?: inducks_storydescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_storydescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_storydescriptions.
     */
    skip?: number
    distinct?: Inducks_storydescriptionScalarFieldEnum | Inducks_storydescriptionScalarFieldEnum[]
  }


  /**
   * inducks_storydescription create
   */
  export type inducks_storydescriptionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storydescription
     */
    select?: inducks_storydescriptionSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_storydescription.
     */
    data: XOR<inducks_storydescriptionCreateInput, inducks_storydescriptionUncheckedCreateInput>
  }


  /**
   * inducks_storydescription createMany
   */
  export type inducks_storydescriptionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_storydescriptions.
     */
    data: inducks_storydescriptionCreateManyInput | inducks_storydescriptionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_storydescription update
   */
  export type inducks_storydescriptionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storydescription
     */
    select?: inducks_storydescriptionSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_storydescription.
     */
    data: XOR<inducks_storydescriptionUpdateInput, inducks_storydescriptionUncheckedUpdateInput>
    /**
     * Choose, which inducks_storydescription to update.
     */
    where: inducks_storydescriptionWhereUniqueInput
  }


  /**
   * inducks_storydescription updateMany
   */
  export type inducks_storydescriptionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_storydescriptions.
     */
    data: XOR<inducks_storydescriptionUpdateManyMutationInput, inducks_storydescriptionUncheckedUpdateManyInput>
    /**
     * Filter which inducks_storydescriptions to update
     */
    where?: inducks_storydescriptionWhereInput
  }


  /**
   * inducks_storydescription upsert
   */
  export type inducks_storydescriptionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storydescription
     */
    select?: inducks_storydescriptionSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_storydescription to update in case it exists.
     */
    where: inducks_storydescriptionWhereUniqueInput
    /**
     * In case the inducks_storydescription found by the `where` argument doesn't exist, create a new inducks_storydescription with this data.
     */
    create: XOR<inducks_storydescriptionCreateInput, inducks_storydescriptionUncheckedCreateInput>
    /**
     * In case the inducks_storydescription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_storydescriptionUpdateInput, inducks_storydescriptionUncheckedUpdateInput>
  }


  /**
   * inducks_storydescription delete
   */
  export type inducks_storydescriptionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storydescription
     */
    select?: inducks_storydescriptionSelect<ExtArgs> | null
    /**
     * Filter which inducks_storydescription to delete.
     */
    where: inducks_storydescriptionWhereUniqueInput
  }


  /**
   * inducks_storydescription deleteMany
   */
  export type inducks_storydescriptionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_storydescriptions to delete
     */
    where?: inducks_storydescriptionWhereInput
  }


  /**
   * inducks_storydescription without action
   */
  export type inducks_storydescriptionDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storydescription
     */
    select?: inducks_storydescriptionSelect<ExtArgs> | null
  }



  /**
   * Model inducks_storyheader
   */

  export type AggregateInducks_storyheader = {
    _count: Inducks_storyheaderCountAggregateOutputType | null
    _min: Inducks_storyheaderMinAggregateOutputType | null
    _max: Inducks_storyheaderMaxAggregateOutputType | null
  }

  export type Inducks_storyheaderMinAggregateOutputType = {
    storyheadercode: string | null
    level: string | null
    title: string | null
    storyheadercomment: string | null
    countrycode: string | null
  }

  export type Inducks_storyheaderMaxAggregateOutputType = {
    storyheadercode: string | null
    level: string | null
    title: string | null
    storyheadercomment: string | null
    countrycode: string | null
  }

  export type Inducks_storyheaderCountAggregateOutputType = {
    storyheadercode: number
    level: number
    title: number
    storyheadercomment: number
    countrycode: number
    _all: number
  }


  export type Inducks_storyheaderMinAggregateInputType = {
    storyheadercode?: true
    level?: true
    title?: true
    storyheadercomment?: true
    countrycode?: true
  }

  export type Inducks_storyheaderMaxAggregateInputType = {
    storyheadercode?: true
    level?: true
    title?: true
    storyheadercomment?: true
    countrycode?: true
  }

  export type Inducks_storyheaderCountAggregateInputType = {
    storyheadercode?: true
    level?: true
    title?: true
    storyheadercomment?: true
    countrycode?: true
    _all?: true
  }

  export type Inducks_storyheaderAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_storyheader to aggregate.
     */
    where?: inducks_storyheaderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_storyheaders to fetch.
     */
    orderBy?: inducks_storyheaderOrderByWithRelationInput | inducks_storyheaderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_storyheaderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_storyheaders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_storyheaders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_storyheaders
    **/
    _count?: true | Inducks_storyheaderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_storyheaderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_storyheaderMaxAggregateInputType
  }

  export type GetInducks_storyheaderAggregateType<T extends Inducks_storyheaderAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_storyheader]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_storyheader[P]>
      : GetScalarType<T[P], AggregateInducks_storyheader[P]>
  }




  export type inducks_storyheaderGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_storyheaderWhereInput
    orderBy?: inducks_storyheaderOrderByWithAggregationInput | inducks_storyheaderOrderByWithAggregationInput[]
    by: Inducks_storyheaderScalarFieldEnum[] | Inducks_storyheaderScalarFieldEnum
    having?: inducks_storyheaderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_storyheaderCountAggregateInputType | true
    _min?: Inducks_storyheaderMinAggregateInputType
    _max?: Inducks_storyheaderMaxAggregateInputType
  }

  export type Inducks_storyheaderGroupByOutputType = {
    storyheadercode: string
    level: string
    title: string | null
    storyheadercomment: string | null
    countrycode: string | null
    _count: Inducks_storyheaderCountAggregateOutputType | null
    _min: Inducks_storyheaderMinAggregateOutputType | null
    _max: Inducks_storyheaderMaxAggregateOutputType | null
  }

  type GetInducks_storyheaderGroupByPayload<T extends inducks_storyheaderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_storyheaderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_storyheaderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_storyheaderGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_storyheaderGroupByOutputType[P]>
        }
      >
    >


  export type inducks_storyheaderSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    storyheadercode?: boolean
    level?: boolean
    title?: boolean
    storyheadercomment?: boolean
    countrycode?: boolean
  }, ExtArgs["result"]["inducks_storyheader"]>

  export type inducks_storyheaderSelectScalar = {
    storyheadercode?: boolean
    level?: boolean
    title?: boolean
    storyheadercomment?: boolean
    countrycode?: boolean
  }


  export type $inducks_storyheaderPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_storyheader"
    objects: {}
    scalars: $Extensions.GetResult<{
      storyheadercode: string
      level: string
      title: string | null
      storyheadercomment: string | null
      countrycode: string | null
    }, ExtArgs["result"]["inducks_storyheader"]>
    composites: {}
  }


  type inducks_storyheaderGetPayload<S extends boolean | null | undefined | inducks_storyheaderDefaultArgs> = $Result.GetResult<Prisma.$inducks_storyheaderPayload, S>

  type inducks_storyheaderCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_storyheaderFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_storyheaderCountAggregateInputType | true
    }

  export interface inducks_storyheaderDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_storyheader'], meta: { name: 'inducks_storyheader' } }
    /**
     * Find zero or one Inducks_storyheader that matches the filter.
     * @param {inducks_storyheaderFindUniqueArgs} args - Arguments to find a Inducks_storyheader
     * @example
     * // Get one Inducks_storyheader
     * const inducks_storyheader = await prisma.inducks_storyheader.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_storyheaderFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyheaderFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_storyheaderClient<$Result.GetResult<Prisma.$inducks_storyheaderPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_storyheader that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_storyheaderFindUniqueOrThrowArgs} args - Arguments to find a Inducks_storyheader
     * @example
     * // Get one Inducks_storyheader
     * const inducks_storyheader = await prisma.inducks_storyheader.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_storyheaderFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyheaderFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_storyheaderClient<$Result.GetResult<Prisma.$inducks_storyheaderPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_storyheader that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyheaderFindFirstArgs} args - Arguments to find a Inducks_storyheader
     * @example
     * // Get one Inducks_storyheader
     * const inducks_storyheader = await prisma.inducks_storyheader.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_storyheaderFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyheaderFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_storyheaderClient<$Result.GetResult<Prisma.$inducks_storyheaderPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_storyheader that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyheaderFindFirstOrThrowArgs} args - Arguments to find a Inducks_storyheader
     * @example
     * // Get one Inducks_storyheader
     * const inducks_storyheader = await prisma.inducks_storyheader.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_storyheaderFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyheaderFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_storyheaderClient<$Result.GetResult<Prisma.$inducks_storyheaderPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_storyheaders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyheaderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_storyheaders
     * const inducks_storyheaders = await prisma.inducks_storyheader.findMany()
     * 
     * // Get first 10 Inducks_storyheaders
     * const inducks_storyheaders = await prisma.inducks_storyheader.findMany({ take: 10 })
     * 
     * // Only select the `storyheadercode`
     * const inducks_storyheaderWithStoryheadercodeOnly = await prisma.inducks_storyheader.findMany({ select: { storyheadercode: true } })
     * 
    **/
    findMany<T extends inducks_storyheaderFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyheaderFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_storyheaderPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_storyheader.
     * @param {inducks_storyheaderCreateArgs} args - Arguments to create a Inducks_storyheader.
     * @example
     * // Create one Inducks_storyheader
     * const Inducks_storyheader = await prisma.inducks_storyheader.create({
     *   data: {
     *     // ... data to create a Inducks_storyheader
     *   }
     * })
     * 
    **/
    create<T extends inducks_storyheaderCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyheaderCreateArgs<ExtArgs>>
    ): Prisma__inducks_storyheaderClient<$Result.GetResult<Prisma.$inducks_storyheaderPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_storyheaders.
     *     @param {inducks_storyheaderCreateManyArgs} args - Arguments to create many Inducks_storyheaders.
     *     @example
     *     // Create many Inducks_storyheaders
     *     const inducks_storyheader = await prisma.inducks_storyheader.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_storyheaderCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyheaderCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_storyheader.
     * @param {inducks_storyheaderDeleteArgs} args - Arguments to delete one Inducks_storyheader.
     * @example
     * // Delete one Inducks_storyheader
     * const Inducks_storyheader = await prisma.inducks_storyheader.delete({
     *   where: {
     *     // ... filter to delete one Inducks_storyheader
     *   }
     * })
     * 
    **/
    delete<T extends inducks_storyheaderDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyheaderDeleteArgs<ExtArgs>>
    ): Prisma__inducks_storyheaderClient<$Result.GetResult<Prisma.$inducks_storyheaderPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_storyheader.
     * @param {inducks_storyheaderUpdateArgs} args - Arguments to update one Inducks_storyheader.
     * @example
     * // Update one Inducks_storyheader
     * const inducks_storyheader = await prisma.inducks_storyheader.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_storyheaderUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyheaderUpdateArgs<ExtArgs>>
    ): Prisma__inducks_storyheaderClient<$Result.GetResult<Prisma.$inducks_storyheaderPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_storyheaders.
     * @param {inducks_storyheaderDeleteManyArgs} args - Arguments to filter Inducks_storyheaders to delete.
     * @example
     * // Delete a few Inducks_storyheaders
     * const { count } = await prisma.inducks_storyheader.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_storyheaderDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyheaderDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_storyheaders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyheaderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_storyheaders
     * const inducks_storyheader = await prisma.inducks_storyheader.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_storyheaderUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyheaderUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_storyheader.
     * @param {inducks_storyheaderUpsertArgs} args - Arguments to update or create a Inducks_storyheader.
     * @example
     * // Update or create a Inducks_storyheader
     * const inducks_storyheader = await prisma.inducks_storyheader.upsert({
     *   create: {
     *     // ... data to create a Inducks_storyheader
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_storyheader we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_storyheaderUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyheaderUpsertArgs<ExtArgs>>
    ): Prisma__inducks_storyheaderClient<$Result.GetResult<Prisma.$inducks_storyheaderPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_storyheaders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyheaderCountArgs} args - Arguments to filter Inducks_storyheaders to count.
     * @example
     * // Count the number of Inducks_storyheaders
     * const count = await prisma.inducks_storyheader.count({
     *   where: {
     *     // ... the filter for the Inducks_storyheaders we want to count
     *   }
     * })
    **/
    count<T extends inducks_storyheaderCountArgs>(
      args?: Subset<T, inducks_storyheaderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_storyheaderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_storyheader.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_storyheaderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_storyheaderAggregateArgs>(args: Subset<T, Inducks_storyheaderAggregateArgs>): Prisma.PrismaPromise<GetInducks_storyheaderAggregateType<T>>

    /**
     * Group by Inducks_storyheader.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyheaderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_storyheaderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_storyheaderGroupByArgs['orderBy'] }
        : { orderBy?: inducks_storyheaderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_storyheaderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_storyheaderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_storyheader model
   */
  readonly fields: inducks_storyheaderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_storyheader.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_storyheaderClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_storyheader model
   */ 
  interface inducks_storyheaderFieldRefs {
    readonly storyheadercode: FieldRef<"inducks_storyheader", 'String'>
    readonly level: FieldRef<"inducks_storyheader", 'String'>
    readonly title: FieldRef<"inducks_storyheader", 'String'>
    readonly storyheadercomment: FieldRef<"inducks_storyheader", 'String'>
    readonly countrycode: FieldRef<"inducks_storyheader", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_storyheader findUnique
   */
  export type inducks_storyheaderFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyheader
     */
    select?: inducks_storyheaderSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storyheader to fetch.
     */
    where: inducks_storyheaderWhereUniqueInput
  }


  /**
   * inducks_storyheader findUniqueOrThrow
   */
  export type inducks_storyheaderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyheader
     */
    select?: inducks_storyheaderSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storyheader to fetch.
     */
    where: inducks_storyheaderWhereUniqueInput
  }


  /**
   * inducks_storyheader findFirst
   */
  export type inducks_storyheaderFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyheader
     */
    select?: inducks_storyheaderSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storyheader to fetch.
     */
    where?: inducks_storyheaderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_storyheaders to fetch.
     */
    orderBy?: inducks_storyheaderOrderByWithRelationInput | inducks_storyheaderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_storyheaders.
     */
    cursor?: inducks_storyheaderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_storyheaders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_storyheaders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_storyheaders.
     */
    distinct?: Inducks_storyheaderScalarFieldEnum | Inducks_storyheaderScalarFieldEnum[]
  }


  /**
   * inducks_storyheader findFirstOrThrow
   */
  export type inducks_storyheaderFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyheader
     */
    select?: inducks_storyheaderSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storyheader to fetch.
     */
    where?: inducks_storyheaderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_storyheaders to fetch.
     */
    orderBy?: inducks_storyheaderOrderByWithRelationInput | inducks_storyheaderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_storyheaders.
     */
    cursor?: inducks_storyheaderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_storyheaders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_storyheaders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_storyheaders.
     */
    distinct?: Inducks_storyheaderScalarFieldEnum | Inducks_storyheaderScalarFieldEnum[]
  }


  /**
   * inducks_storyheader findMany
   */
  export type inducks_storyheaderFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyheader
     */
    select?: inducks_storyheaderSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storyheaders to fetch.
     */
    where?: inducks_storyheaderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_storyheaders to fetch.
     */
    orderBy?: inducks_storyheaderOrderByWithRelationInput | inducks_storyheaderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_storyheaders.
     */
    cursor?: inducks_storyheaderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_storyheaders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_storyheaders.
     */
    skip?: number
    distinct?: Inducks_storyheaderScalarFieldEnum | Inducks_storyheaderScalarFieldEnum[]
  }


  /**
   * inducks_storyheader create
   */
  export type inducks_storyheaderCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyheader
     */
    select?: inducks_storyheaderSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_storyheader.
     */
    data: XOR<inducks_storyheaderCreateInput, inducks_storyheaderUncheckedCreateInput>
  }


  /**
   * inducks_storyheader createMany
   */
  export type inducks_storyheaderCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_storyheaders.
     */
    data: inducks_storyheaderCreateManyInput | inducks_storyheaderCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_storyheader update
   */
  export type inducks_storyheaderUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyheader
     */
    select?: inducks_storyheaderSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_storyheader.
     */
    data: XOR<inducks_storyheaderUpdateInput, inducks_storyheaderUncheckedUpdateInput>
    /**
     * Choose, which inducks_storyheader to update.
     */
    where: inducks_storyheaderWhereUniqueInput
  }


  /**
   * inducks_storyheader updateMany
   */
  export type inducks_storyheaderUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_storyheaders.
     */
    data: XOR<inducks_storyheaderUpdateManyMutationInput, inducks_storyheaderUncheckedUpdateManyInput>
    /**
     * Filter which inducks_storyheaders to update
     */
    where?: inducks_storyheaderWhereInput
  }


  /**
   * inducks_storyheader upsert
   */
  export type inducks_storyheaderUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyheader
     */
    select?: inducks_storyheaderSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_storyheader to update in case it exists.
     */
    where: inducks_storyheaderWhereUniqueInput
    /**
     * In case the inducks_storyheader found by the `where` argument doesn't exist, create a new inducks_storyheader with this data.
     */
    create: XOR<inducks_storyheaderCreateInput, inducks_storyheaderUncheckedCreateInput>
    /**
     * In case the inducks_storyheader was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_storyheaderUpdateInput, inducks_storyheaderUncheckedUpdateInput>
  }


  /**
   * inducks_storyheader delete
   */
  export type inducks_storyheaderDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyheader
     */
    select?: inducks_storyheaderSelect<ExtArgs> | null
    /**
     * Filter which inducks_storyheader to delete.
     */
    where: inducks_storyheaderWhereUniqueInput
  }


  /**
   * inducks_storyheader deleteMany
   */
  export type inducks_storyheaderDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_storyheaders to delete
     */
    where?: inducks_storyheaderWhereInput
  }


  /**
   * inducks_storyheader without action
   */
  export type inducks_storyheaderDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyheader
     */
    select?: inducks_storyheaderSelect<ExtArgs> | null
  }



  /**
   * Model inducks_storyjob
   */

  export type AggregateInducks_storyjob = {
    _count: Inducks_storyjobCountAggregateOutputType | null
    _min: Inducks_storyjobMinAggregateOutputType | null
    _max: Inducks_storyjobMaxAggregateOutputType | null
  }

  export type Inducks_storyjobMinAggregateOutputType = {
    storyversioncode: string | null
    personcode: string | null
    plotwritartink: string | null
    storyjobcomment: string | null
    indirect: $Enums.inducks_storyjob_indirect | null
    doubt: $Enums.inducks_storyjob_doubt | null
  }

  export type Inducks_storyjobMaxAggregateOutputType = {
    storyversioncode: string | null
    personcode: string | null
    plotwritartink: string | null
    storyjobcomment: string | null
    indirect: $Enums.inducks_storyjob_indirect | null
    doubt: $Enums.inducks_storyjob_doubt | null
  }

  export type Inducks_storyjobCountAggregateOutputType = {
    storyversioncode: number
    personcode: number
    plotwritartink: number
    storyjobcomment: number
    indirect: number
    doubt: number
    _all: number
  }


  export type Inducks_storyjobMinAggregateInputType = {
    storyversioncode?: true
    personcode?: true
    plotwritartink?: true
    storyjobcomment?: true
    indirect?: true
    doubt?: true
  }

  export type Inducks_storyjobMaxAggregateInputType = {
    storyversioncode?: true
    personcode?: true
    plotwritartink?: true
    storyjobcomment?: true
    indirect?: true
    doubt?: true
  }

  export type Inducks_storyjobCountAggregateInputType = {
    storyversioncode?: true
    personcode?: true
    plotwritartink?: true
    storyjobcomment?: true
    indirect?: true
    doubt?: true
    _all?: true
  }

  export type Inducks_storyjobAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_storyjob to aggregate.
     */
    where?: inducks_storyjobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_storyjobs to fetch.
     */
    orderBy?: inducks_storyjobOrderByWithRelationInput | inducks_storyjobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_storyjobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_storyjobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_storyjobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_storyjobs
    **/
    _count?: true | Inducks_storyjobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_storyjobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_storyjobMaxAggregateInputType
  }

  export type GetInducks_storyjobAggregateType<T extends Inducks_storyjobAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_storyjob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_storyjob[P]>
      : GetScalarType<T[P], AggregateInducks_storyjob[P]>
  }




  export type inducks_storyjobGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_storyjobWhereInput
    orderBy?: inducks_storyjobOrderByWithAggregationInput | inducks_storyjobOrderByWithAggregationInput[]
    by: Inducks_storyjobScalarFieldEnum[] | Inducks_storyjobScalarFieldEnum
    having?: inducks_storyjobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_storyjobCountAggregateInputType | true
    _min?: Inducks_storyjobMinAggregateInputType
    _max?: Inducks_storyjobMaxAggregateInputType
  }

  export type Inducks_storyjobGroupByOutputType = {
    storyversioncode: string
    personcode: string
    plotwritartink: string
    storyjobcomment: string | null
    indirect: $Enums.inducks_storyjob_indirect | null
    doubt: $Enums.inducks_storyjob_doubt | null
    _count: Inducks_storyjobCountAggregateOutputType | null
    _min: Inducks_storyjobMinAggregateOutputType | null
    _max: Inducks_storyjobMaxAggregateOutputType | null
  }

  type GetInducks_storyjobGroupByPayload<T extends inducks_storyjobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_storyjobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_storyjobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_storyjobGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_storyjobGroupByOutputType[P]>
        }
      >
    >


  export type inducks_storyjobSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    storyversioncode?: boolean
    personcode?: boolean
    plotwritartink?: boolean
    storyjobcomment?: boolean
    indirect?: boolean
    doubt?: boolean
  }, ExtArgs["result"]["inducks_storyjob"]>

  export type inducks_storyjobSelectScalar = {
    storyversioncode?: boolean
    personcode?: boolean
    plotwritartink?: boolean
    storyjobcomment?: boolean
    indirect?: boolean
    doubt?: boolean
  }


  export type $inducks_storyjobPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_storyjob"
    objects: {}
    scalars: $Extensions.GetResult<{
      storyversioncode: string
      personcode: string
      plotwritartink: string
      storyjobcomment: string | null
      indirect: $Enums.inducks_storyjob_indirect | null
      doubt: $Enums.inducks_storyjob_doubt | null
    }, ExtArgs["result"]["inducks_storyjob"]>
    composites: {}
  }


  type inducks_storyjobGetPayload<S extends boolean | null | undefined | inducks_storyjobDefaultArgs> = $Result.GetResult<Prisma.$inducks_storyjobPayload, S>

  type inducks_storyjobCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_storyjobFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_storyjobCountAggregateInputType | true
    }

  export interface inducks_storyjobDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_storyjob'], meta: { name: 'inducks_storyjob' } }
    /**
     * Find zero or one Inducks_storyjob that matches the filter.
     * @param {inducks_storyjobFindUniqueArgs} args - Arguments to find a Inducks_storyjob
     * @example
     * // Get one Inducks_storyjob
     * const inducks_storyjob = await prisma.inducks_storyjob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_storyjobFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyjobFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_storyjobClient<$Result.GetResult<Prisma.$inducks_storyjobPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_storyjob that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_storyjobFindUniqueOrThrowArgs} args - Arguments to find a Inducks_storyjob
     * @example
     * // Get one Inducks_storyjob
     * const inducks_storyjob = await prisma.inducks_storyjob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_storyjobFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyjobFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_storyjobClient<$Result.GetResult<Prisma.$inducks_storyjobPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_storyjob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyjobFindFirstArgs} args - Arguments to find a Inducks_storyjob
     * @example
     * // Get one Inducks_storyjob
     * const inducks_storyjob = await prisma.inducks_storyjob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_storyjobFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyjobFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_storyjobClient<$Result.GetResult<Prisma.$inducks_storyjobPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_storyjob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyjobFindFirstOrThrowArgs} args - Arguments to find a Inducks_storyjob
     * @example
     * // Get one Inducks_storyjob
     * const inducks_storyjob = await prisma.inducks_storyjob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_storyjobFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyjobFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_storyjobClient<$Result.GetResult<Prisma.$inducks_storyjobPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_storyjobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyjobFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_storyjobs
     * const inducks_storyjobs = await prisma.inducks_storyjob.findMany()
     * 
     * // Get first 10 Inducks_storyjobs
     * const inducks_storyjobs = await prisma.inducks_storyjob.findMany({ take: 10 })
     * 
     * // Only select the `storyversioncode`
     * const inducks_storyjobWithStoryversioncodeOnly = await prisma.inducks_storyjob.findMany({ select: { storyversioncode: true } })
     * 
    **/
    findMany<T extends inducks_storyjobFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyjobFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_storyjobPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_storyjob.
     * @param {inducks_storyjobCreateArgs} args - Arguments to create a Inducks_storyjob.
     * @example
     * // Create one Inducks_storyjob
     * const Inducks_storyjob = await prisma.inducks_storyjob.create({
     *   data: {
     *     // ... data to create a Inducks_storyjob
     *   }
     * })
     * 
    **/
    create<T extends inducks_storyjobCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyjobCreateArgs<ExtArgs>>
    ): Prisma__inducks_storyjobClient<$Result.GetResult<Prisma.$inducks_storyjobPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_storyjobs.
     *     @param {inducks_storyjobCreateManyArgs} args - Arguments to create many Inducks_storyjobs.
     *     @example
     *     // Create many Inducks_storyjobs
     *     const inducks_storyjob = await prisma.inducks_storyjob.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_storyjobCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyjobCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_storyjob.
     * @param {inducks_storyjobDeleteArgs} args - Arguments to delete one Inducks_storyjob.
     * @example
     * // Delete one Inducks_storyjob
     * const Inducks_storyjob = await prisma.inducks_storyjob.delete({
     *   where: {
     *     // ... filter to delete one Inducks_storyjob
     *   }
     * })
     * 
    **/
    delete<T extends inducks_storyjobDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyjobDeleteArgs<ExtArgs>>
    ): Prisma__inducks_storyjobClient<$Result.GetResult<Prisma.$inducks_storyjobPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_storyjob.
     * @param {inducks_storyjobUpdateArgs} args - Arguments to update one Inducks_storyjob.
     * @example
     * // Update one Inducks_storyjob
     * const inducks_storyjob = await prisma.inducks_storyjob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_storyjobUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyjobUpdateArgs<ExtArgs>>
    ): Prisma__inducks_storyjobClient<$Result.GetResult<Prisma.$inducks_storyjobPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_storyjobs.
     * @param {inducks_storyjobDeleteManyArgs} args - Arguments to filter Inducks_storyjobs to delete.
     * @example
     * // Delete a few Inducks_storyjobs
     * const { count } = await prisma.inducks_storyjob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_storyjobDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyjobDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_storyjobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyjobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_storyjobs
     * const inducks_storyjob = await prisma.inducks_storyjob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_storyjobUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyjobUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_storyjob.
     * @param {inducks_storyjobUpsertArgs} args - Arguments to update or create a Inducks_storyjob.
     * @example
     * // Update or create a Inducks_storyjob
     * const inducks_storyjob = await prisma.inducks_storyjob.upsert({
     *   create: {
     *     // ... data to create a Inducks_storyjob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_storyjob we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_storyjobUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyjobUpsertArgs<ExtArgs>>
    ): Prisma__inducks_storyjobClient<$Result.GetResult<Prisma.$inducks_storyjobPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_storyjobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyjobCountArgs} args - Arguments to filter Inducks_storyjobs to count.
     * @example
     * // Count the number of Inducks_storyjobs
     * const count = await prisma.inducks_storyjob.count({
     *   where: {
     *     // ... the filter for the Inducks_storyjobs we want to count
     *   }
     * })
    **/
    count<T extends inducks_storyjobCountArgs>(
      args?: Subset<T, inducks_storyjobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_storyjobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_storyjob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_storyjobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_storyjobAggregateArgs>(args: Subset<T, Inducks_storyjobAggregateArgs>): Prisma.PrismaPromise<GetInducks_storyjobAggregateType<T>>

    /**
     * Group by Inducks_storyjob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyjobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_storyjobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_storyjobGroupByArgs['orderBy'] }
        : { orderBy?: inducks_storyjobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_storyjobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_storyjobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_storyjob model
   */
  readonly fields: inducks_storyjobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_storyjob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_storyjobClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_storyjob model
   */ 
  interface inducks_storyjobFieldRefs {
    readonly storyversioncode: FieldRef<"inducks_storyjob", 'String'>
    readonly personcode: FieldRef<"inducks_storyjob", 'String'>
    readonly plotwritartink: FieldRef<"inducks_storyjob", 'String'>
    readonly storyjobcomment: FieldRef<"inducks_storyjob", 'String'>
    readonly indirect: FieldRef<"inducks_storyjob", 'inducks_storyjob_indirect'>
    readonly doubt: FieldRef<"inducks_storyjob", 'inducks_storyjob_doubt'>
  }
    

  // Custom InputTypes

  /**
   * inducks_storyjob findUnique
   */
  export type inducks_storyjobFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyjob
     */
    select?: inducks_storyjobSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storyjob to fetch.
     */
    where: inducks_storyjobWhereUniqueInput
  }


  /**
   * inducks_storyjob findUniqueOrThrow
   */
  export type inducks_storyjobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyjob
     */
    select?: inducks_storyjobSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storyjob to fetch.
     */
    where: inducks_storyjobWhereUniqueInput
  }


  /**
   * inducks_storyjob findFirst
   */
  export type inducks_storyjobFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyjob
     */
    select?: inducks_storyjobSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storyjob to fetch.
     */
    where?: inducks_storyjobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_storyjobs to fetch.
     */
    orderBy?: inducks_storyjobOrderByWithRelationInput | inducks_storyjobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_storyjobs.
     */
    cursor?: inducks_storyjobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_storyjobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_storyjobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_storyjobs.
     */
    distinct?: Inducks_storyjobScalarFieldEnum | Inducks_storyjobScalarFieldEnum[]
  }


  /**
   * inducks_storyjob findFirstOrThrow
   */
  export type inducks_storyjobFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyjob
     */
    select?: inducks_storyjobSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storyjob to fetch.
     */
    where?: inducks_storyjobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_storyjobs to fetch.
     */
    orderBy?: inducks_storyjobOrderByWithRelationInput | inducks_storyjobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_storyjobs.
     */
    cursor?: inducks_storyjobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_storyjobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_storyjobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_storyjobs.
     */
    distinct?: Inducks_storyjobScalarFieldEnum | Inducks_storyjobScalarFieldEnum[]
  }


  /**
   * inducks_storyjob findMany
   */
  export type inducks_storyjobFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyjob
     */
    select?: inducks_storyjobSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storyjobs to fetch.
     */
    where?: inducks_storyjobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_storyjobs to fetch.
     */
    orderBy?: inducks_storyjobOrderByWithRelationInput | inducks_storyjobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_storyjobs.
     */
    cursor?: inducks_storyjobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_storyjobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_storyjobs.
     */
    skip?: number
    distinct?: Inducks_storyjobScalarFieldEnum | Inducks_storyjobScalarFieldEnum[]
  }


  /**
   * inducks_storyjob create
   */
  export type inducks_storyjobCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyjob
     */
    select?: inducks_storyjobSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_storyjob.
     */
    data: XOR<inducks_storyjobCreateInput, inducks_storyjobUncheckedCreateInput>
  }


  /**
   * inducks_storyjob createMany
   */
  export type inducks_storyjobCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_storyjobs.
     */
    data: inducks_storyjobCreateManyInput | inducks_storyjobCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_storyjob update
   */
  export type inducks_storyjobUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyjob
     */
    select?: inducks_storyjobSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_storyjob.
     */
    data: XOR<inducks_storyjobUpdateInput, inducks_storyjobUncheckedUpdateInput>
    /**
     * Choose, which inducks_storyjob to update.
     */
    where: inducks_storyjobWhereUniqueInput
  }


  /**
   * inducks_storyjob updateMany
   */
  export type inducks_storyjobUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_storyjobs.
     */
    data: XOR<inducks_storyjobUpdateManyMutationInput, inducks_storyjobUncheckedUpdateManyInput>
    /**
     * Filter which inducks_storyjobs to update
     */
    where?: inducks_storyjobWhereInput
  }


  /**
   * inducks_storyjob upsert
   */
  export type inducks_storyjobUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyjob
     */
    select?: inducks_storyjobSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_storyjob to update in case it exists.
     */
    where: inducks_storyjobWhereUniqueInput
    /**
     * In case the inducks_storyjob found by the `where` argument doesn't exist, create a new inducks_storyjob with this data.
     */
    create: XOR<inducks_storyjobCreateInput, inducks_storyjobUncheckedCreateInput>
    /**
     * In case the inducks_storyjob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_storyjobUpdateInput, inducks_storyjobUncheckedUpdateInput>
  }


  /**
   * inducks_storyjob delete
   */
  export type inducks_storyjobDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyjob
     */
    select?: inducks_storyjobSelect<ExtArgs> | null
    /**
     * Filter which inducks_storyjob to delete.
     */
    where: inducks_storyjobWhereUniqueInput
  }


  /**
   * inducks_storyjob deleteMany
   */
  export type inducks_storyjobDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_storyjobs to delete
     */
    where?: inducks_storyjobWhereInput
  }


  /**
   * inducks_storyjob without action
   */
  export type inducks_storyjobDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyjob
     */
    select?: inducks_storyjobSelect<ExtArgs> | null
  }



  /**
   * Model inducks_storyreference
   */

  export type AggregateInducks_storyreference = {
    _count: Inducks_storyreferenceCountAggregateOutputType | null
    _avg: Inducks_storyreferenceAvgAggregateOutputType | null
    _sum: Inducks_storyreferenceSumAggregateOutputType | null
    _min: Inducks_storyreferenceMinAggregateOutputType | null
    _max: Inducks_storyreferenceMaxAggregateOutputType | null
  }

  export type Inducks_storyreferenceAvgAggregateOutputType = {
    referencereasonid: number | null
  }

  export type Inducks_storyreferenceSumAggregateOutputType = {
    referencereasonid: number | null
  }

  export type Inducks_storyreferenceMinAggregateOutputType = {
    fromstorycode: string | null
    tostorycode: string | null
    referencereasonid: number | null
  }

  export type Inducks_storyreferenceMaxAggregateOutputType = {
    fromstorycode: string | null
    tostorycode: string | null
    referencereasonid: number | null
  }

  export type Inducks_storyreferenceCountAggregateOutputType = {
    fromstorycode: number
    tostorycode: number
    referencereasonid: number
    _all: number
  }


  export type Inducks_storyreferenceAvgAggregateInputType = {
    referencereasonid?: true
  }

  export type Inducks_storyreferenceSumAggregateInputType = {
    referencereasonid?: true
  }

  export type Inducks_storyreferenceMinAggregateInputType = {
    fromstorycode?: true
    tostorycode?: true
    referencereasonid?: true
  }

  export type Inducks_storyreferenceMaxAggregateInputType = {
    fromstorycode?: true
    tostorycode?: true
    referencereasonid?: true
  }

  export type Inducks_storyreferenceCountAggregateInputType = {
    fromstorycode?: true
    tostorycode?: true
    referencereasonid?: true
    _all?: true
  }

  export type Inducks_storyreferenceAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_storyreference to aggregate.
     */
    where?: inducks_storyreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_storyreferences to fetch.
     */
    orderBy?: inducks_storyreferenceOrderByWithRelationInput | inducks_storyreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_storyreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_storyreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_storyreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_storyreferences
    **/
    _count?: true | Inducks_storyreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Inducks_storyreferenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Inducks_storyreferenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_storyreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_storyreferenceMaxAggregateInputType
  }

  export type GetInducks_storyreferenceAggregateType<T extends Inducks_storyreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_storyreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_storyreference[P]>
      : GetScalarType<T[P], AggregateInducks_storyreference[P]>
  }




  export type inducks_storyreferenceGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_storyreferenceWhereInput
    orderBy?: inducks_storyreferenceOrderByWithAggregationInput | inducks_storyreferenceOrderByWithAggregationInput[]
    by: Inducks_storyreferenceScalarFieldEnum[] | Inducks_storyreferenceScalarFieldEnum
    having?: inducks_storyreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_storyreferenceCountAggregateInputType | true
    _avg?: Inducks_storyreferenceAvgAggregateInputType
    _sum?: Inducks_storyreferenceSumAggregateInputType
    _min?: Inducks_storyreferenceMinAggregateInputType
    _max?: Inducks_storyreferenceMaxAggregateInputType
  }

  export type Inducks_storyreferenceGroupByOutputType = {
    fromstorycode: string
    tostorycode: string
    referencereasonid: number | null
    _count: Inducks_storyreferenceCountAggregateOutputType | null
    _avg: Inducks_storyreferenceAvgAggregateOutputType | null
    _sum: Inducks_storyreferenceSumAggregateOutputType | null
    _min: Inducks_storyreferenceMinAggregateOutputType | null
    _max: Inducks_storyreferenceMaxAggregateOutputType | null
  }

  type GetInducks_storyreferenceGroupByPayload<T extends inducks_storyreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_storyreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_storyreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_storyreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_storyreferenceGroupByOutputType[P]>
        }
      >
    >


  export type inducks_storyreferenceSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    fromstorycode?: boolean
    tostorycode?: boolean
    referencereasonid?: boolean
  }, ExtArgs["result"]["inducks_storyreference"]>

  export type inducks_storyreferenceSelectScalar = {
    fromstorycode?: boolean
    tostorycode?: boolean
    referencereasonid?: boolean
  }


  export type $inducks_storyreferencePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_storyreference"
    objects: {}
    scalars: $Extensions.GetResult<{
      fromstorycode: string
      tostorycode: string
      referencereasonid: number | null
    }, ExtArgs["result"]["inducks_storyreference"]>
    composites: {}
  }


  type inducks_storyreferenceGetPayload<S extends boolean | null | undefined | inducks_storyreferenceDefaultArgs> = $Result.GetResult<Prisma.$inducks_storyreferencePayload, S>

  type inducks_storyreferenceCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_storyreferenceFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_storyreferenceCountAggregateInputType | true
    }

  export interface inducks_storyreferenceDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_storyreference'], meta: { name: 'inducks_storyreference' } }
    /**
     * Find zero or one Inducks_storyreference that matches the filter.
     * @param {inducks_storyreferenceFindUniqueArgs} args - Arguments to find a Inducks_storyreference
     * @example
     * // Get one Inducks_storyreference
     * const inducks_storyreference = await prisma.inducks_storyreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_storyreferenceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyreferenceFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_storyreferenceClient<$Result.GetResult<Prisma.$inducks_storyreferencePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_storyreference that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_storyreferenceFindUniqueOrThrowArgs} args - Arguments to find a Inducks_storyreference
     * @example
     * // Get one Inducks_storyreference
     * const inducks_storyreference = await prisma.inducks_storyreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_storyreferenceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyreferenceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_storyreferenceClient<$Result.GetResult<Prisma.$inducks_storyreferencePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_storyreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyreferenceFindFirstArgs} args - Arguments to find a Inducks_storyreference
     * @example
     * // Get one Inducks_storyreference
     * const inducks_storyreference = await prisma.inducks_storyreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_storyreferenceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyreferenceFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_storyreferenceClient<$Result.GetResult<Prisma.$inducks_storyreferencePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_storyreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyreferenceFindFirstOrThrowArgs} args - Arguments to find a Inducks_storyreference
     * @example
     * // Get one Inducks_storyreference
     * const inducks_storyreference = await prisma.inducks_storyreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_storyreferenceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyreferenceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_storyreferenceClient<$Result.GetResult<Prisma.$inducks_storyreferencePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_storyreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyreferenceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_storyreferences
     * const inducks_storyreferences = await prisma.inducks_storyreference.findMany()
     * 
     * // Get first 10 Inducks_storyreferences
     * const inducks_storyreferences = await prisma.inducks_storyreference.findMany({ take: 10 })
     * 
     * // Only select the `fromstorycode`
     * const inducks_storyreferenceWithFromstorycodeOnly = await prisma.inducks_storyreference.findMany({ select: { fromstorycode: true } })
     * 
    **/
    findMany<T extends inducks_storyreferenceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyreferenceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_storyreferencePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_storyreference.
     * @param {inducks_storyreferenceCreateArgs} args - Arguments to create a Inducks_storyreference.
     * @example
     * // Create one Inducks_storyreference
     * const Inducks_storyreference = await prisma.inducks_storyreference.create({
     *   data: {
     *     // ... data to create a Inducks_storyreference
     *   }
     * })
     * 
    **/
    create<T extends inducks_storyreferenceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyreferenceCreateArgs<ExtArgs>>
    ): Prisma__inducks_storyreferenceClient<$Result.GetResult<Prisma.$inducks_storyreferencePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_storyreferences.
     *     @param {inducks_storyreferenceCreateManyArgs} args - Arguments to create many Inducks_storyreferences.
     *     @example
     *     // Create many Inducks_storyreferences
     *     const inducks_storyreference = await prisma.inducks_storyreference.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_storyreferenceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyreferenceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_storyreference.
     * @param {inducks_storyreferenceDeleteArgs} args - Arguments to delete one Inducks_storyreference.
     * @example
     * // Delete one Inducks_storyreference
     * const Inducks_storyreference = await prisma.inducks_storyreference.delete({
     *   where: {
     *     // ... filter to delete one Inducks_storyreference
     *   }
     * })
     * 
    **/
    delete<T extends inducks_storyreferenceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyreferenceDeleteArgs<ExtArgs>>
    ): Prisma__inducks_storyreferenceClient<$Result.GetResult<Prisma.$inducks_storyreferencePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_storyreference.
     * @param {inducks_storyreferenceUpdateArgs} args - Arguments to update one Inducks_storyreference.
     * @example
     * // Update one Inducks_storyreference
     * const inducks_storyreference = await prisma.inducks_storyreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_storyreferenceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyreferenceUpdateArgs<ExtArgs>>
    ): Prisma__inducks_storyreferenceClient<$Result.GetResult<Prisma.$inducks_storyreferencePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_storyreferences.
     * @param {inducks_storyreferenceDeleteManyArgs} args - Arguments to filter Inducks_storyreferences to delete.
     * @example
     * // Delete a few Inducks_storyreferences
     * const { count } = await prisma.inducks_storyreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_storyreferenceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyreferenceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_storyreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_storyreferences
     * const inducks_storyreference = await prisma.inducks_storyreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_storyreferenceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyreferenceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_storyreference.
     * @param {inducks_storyreferenceUpsertArgs} args - Arguments to update or create a Inducks_storyreference.
     * @example
     * // Update or create a Inducks_storyreference
     * const inducks_storyreference = await prisma.inducks_storyreference.upsert({
     *   create: {
     *     // ... data to create a Inducks_storyreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_storyreference we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_storyreferenceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyreferenceUpsertArgs<ExtArgs>>
    ): Prisma__inducks_storyreferenceClient<$Result.GetResult<Prisma.$inducks_storyreferencePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_storyreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyreferenceCountArgs} args - Arguments to filter Inducks_storyreferences to count.
     * @example
     * // Count the number of Inducks_storyreferences
     * const count = await prisma.inducks_storyreference.count({
     *   where: {
     *     // ... the filter for the Inducks_storyreferences we want to count
     *   }
     * })
    **/
    count<T extends inducks_storyreferenceCountArgs>(
      args?: Subset<T, inducks_storyreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_storyreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_storyreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_storyreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_storyreferenceAggregateArgs>(args: Subset<T, Inducks_storyreferenceAggregateArgs>): Prisma.PrismaPromise<GetInducks_storyreferenceAggregateType<T>>

    /**
     * Group by Inducks_storyreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_storyreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_storyreferenceGroupByArgs['orderBy'] }
        : { orderBy?: inducks_storyreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_storyreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_storyreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_storyreference model
   */
  readonly fields: inducks_storyreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_storyreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_storyreferenceClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_storyreference model
   */ 
  interface inducks_storyreferenceFieldRefs {
    readonly fromstorycode: FieldRef<"inducks_storyreference", 'String'>
    readonly tostorycode: FieldRef<"inducks_storyreference", 'String'>
    readonly referencereasonid: FieldRef<"inducks_storyreference", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * inducks_storyreference findUnique
   */
  export type inducks_storyreferenceFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyreference
     */
    select?: inducks_storyreferenceSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storyreference to fetch.
     */
    where: inducks_storyreferenceWhereUniqueInput
  }


  /**
   * inducks_storyreference findUniqueOrThrow
   */
  export type inducks_storyreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyreference
     */
    select?: inducks_storyreferenceSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storyreference to fetch.
     */
    where: inducks_storyreferenceWhereUniqueInput
  }


  /**
   * inducks_storyreference findFirst
   */
  export type inducks_storyreferenceFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyreference
     */
    select?: inducks_storyreferenceSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storyreference to fetch.
     */
    where?: inducks_storyreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_storyreferences to fetch.
     */
    orderBy?: inducks_storyreferenceOrderByWithRelationInput | inducks_storyreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_storyreferences.
     */
    cursor?: inducks_storyreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_storyreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_storyreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_storyreferences.
     */
    distinct?: Inducks_storyreferenceScalarFieldEnum | Inducks_storyreferenceScalarFieldEnum[]
  }


  /**
   * inducks_storyreference findFirstOrThrow
   */
  export type inducks_storyreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyreference
     */
    select?: inducks_storyreferenceSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storyreference to fetch.
     */
    where?: inducks_storyreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_storyreferences to fetch.
     */
    orderBy?: inducks_storyreferenceOrderByWithRelationInput | inducks_storyreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_storyreferences.
     */
    cursor?: inducks_storyreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_storyreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_storyreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_storyreferences.
     */
    distinct?: Inducks_storyreferenceScalarFieldEnum | Inducks_storyreferenceScalarFieldEnum[]
  }


  /**
   * inducks_storyreference findMany
   */
  export type inducks_storyreferenceFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyreference
     */
    select?: inducks_storyreferenceSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storyreferences to fetch.
     */
    where?: inducks_storyreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_storyreferences to fetch.
     */
    orderBy?: inducks_storyreferenceOrderByWithRelationInput | inducks_storyreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_storyreferences.
     */
    cursor?: inducks_storyreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_storyreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_storyreferences.
     */
    skip?: number
    distinct?: Inducks_storyreferenceScalarFieldEnum | Inducks_storyreferenceScalarFieldEnum[]
  }


  /**
   * inducks_storyreference create
   */
  export type inducks_storyreferenceCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyreference
     */
    select?: inducks_storyreferenceSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_storyreference.
     */
    data: XOR<inducks_storyreferenceCreateInput, inducks_storyreferenceUncheckedCreateInput>
  }


  /**
   * inducks_storyreference createMany
   */
  export type inducks_storyreferenceCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_storyreferences.
     */
    data: inducks_storyreferenceCreateManyInput | inducks_storyreferenceCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_storyreference update
   */
  export type inducks_storyreferenceUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyreference
     */
    select?: inducks_storyreferenceSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_storyreference.
     */
    data: XOR<inducks_storyreferenceUpdateInput, inducks_storyreferenceUncheckedUpdateInput>
    /**
     * Choose, which inducks_storyreference to update.
     */
    where: inducks_storyreferenceWhereUniqueInput
  }


  /**
   * inducks_storyreference updateMany
   */
  export type inducks_storyreferenceUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_storyreferences.
     */
    data: XOR<inducks_storyreferenceUpdateManyMutationInput, inducks_storyreferenceUncheckedUpdateManyInput>
    /**
     * Filter which inducks_storyreferences to update
     */
    where?: inducks_storyreferenceWhereInput
  }


  /**
   * inducks_storyreference upsert
   */
  export type inducks_storyreferenceUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyreference
     */
    select?: inducks_storyreferenceSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_storyreference to update in case it exists.
     */
    where: inducks_storyreferenceWhereUniqueInput
    /**
     * In case the inducks_storyreference found by the `where` argument doesn't exist, create a new inducks_storyreference with this data.
     */
    create: XOR<inducks_storyreferenceCreateInput, inducks_storyreferenceUncheckedCreateInput>
    /**
     * In case the inducks_storyreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_storyreferenceUpdateInput, inducks_storyreferenceUncheckedUpdateInput>
  }


  /**
   * inducks_storyreference delete
   */
  export type inducks_storyreferenceDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyreference
     */
    select?: inducks_storyreferenceSelect<ExtArgs> | null
    /**
     * Filter which inducks_storyreference to delete.
     */
    where: inducks_storyreferenceWhereUniqueInput
  }


  /**
   * inducks_storyreference deleteMany
   */
  export type inducks_storyreferenceDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_storyreferences to delete
     */
    where?: inducks_storyreferenceWhereInput
  }


  /**
   * inducks_storyreference without action
   */
  export type inducks_storyreferenceDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyreference
     */
    select?: inducks_storyreferenceSelect<ExtArgs> | null
  }



  /**
   * Model inducks_storysubseries
   */

  export type AggregateInducks_storysubseries = {
    _count: Inducks_storysubseriesCountAggregateOutputType | null
    _min: Inducks_storysubseriesMinAggregateOutputType | null
    _max: Inducks_storysubseriesMaxAggregateOutputType | null
  }

  export type Inducks_storysubseriesMinAggregateOutputType = {
    storycode: string | null
    subseriescode: string | null
    storysubseriescomment: string | null
  }

  export type Inducks_storysubseriesMaxAggregateOutputType = {
    storycode: string | null
    subseriescode: string | null
    storysubseriescomment: string | null
  }

  export type Inducks_storysubseriesCountAggregateOutputType = {
    storycode: number
    subseriescode: number
    storysubseriescomment: number
    _all: number
  }


  export type Inducks_storysubseriesMinAggregateInputType = {
    storycode?: true
    subseriescode?: true
    storysubseriescomment?: true
  }

  export type Inducks_storysubseriesMaxAggregateInputType = {
    storycode?: true
    subseriescode?: true
    storysubseriescomment?: true
  }

  export type Inducks_storysubseriesCountAggregateInputType = {
    storycode?: true
    subseriescode?: true
    storysubseriescomment?: true
    _all?: true
  }

  export type Inducks_storysubseriesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_storysubseries to aggregate.
     */
    where?: inducks_storysubseriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_storysubseries to fetch.
     */
    orderBy?: inducks_storysubseriesOrderByWithRelationInput | inducks_storysubseriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_storysubseriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_storysubseries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_storysubseries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_storysubseries
    **/
    _count?: true | Inducks_storysubseriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_storysubseriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_storysubseriesMaxAggregateInputType
  }

  export type GetInducks_storysubseriesAggregateType<T extends Inducks_storysubseriesAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_storysubseries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_storysubseries[P]>
      : GetScalarType<T[P], AggregateInducks_storysubseries[P]>
  }




  export type inducks_storysubseriesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_storysubseriesWhereInput
    orderBy?: inducks_storysubseriesOrderByWithAggregationInput | inducks_storysubseriesOrderByWithAggregationInput[]
    by: Inducks_storysubseriesScalarFieldEnum[] | Inducks_storysubseriesScalarFieldEnum
    having?: inducks_storysubseriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_storysubseriesCountAggregateInputType | true
    _min?: Inducks_storysubseriesMinAggregateInputType
    _max?: Inducks_storysubseriesMaxAggregateInputType
  }

  export type Inducks_storysubseriesGroupByOutputType = {
    storycode: string
    subseriescode: string
    storysubseriescomment: string | null
    _count: Inducks_storysubseriesCountAggregateOutputType | null
    _min: Inducks_storysubseriesMinAggregateOutputType | null
    _max: Inducks_storysubseriesMaxAggregateOutputType | null
  }

  type GetInducks_storysubseriesGroupByPayload<T extends inducks_storysubseriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_storysubseriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_storysubseriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_storysubseriesGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_storysubseriesGroupByOutputType[P]>
        }
      >
    >


  export type inducks_storysubseriesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    storycode?: boolean
    subseriescode?: boolean
    storysubseriescomment?: boolean
  }, ExtArgs["result"]["inducks_storysubseries"]>

  export type inducks_storysubseriesSelectScalar = {
    storycode?: boolean
    subseriescode?: boolean
    storysubseriescomment?: boolean
  }


  export type $inducks_storysubseriesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_storysubseries"
    objects: {}
    scalars: $Extensions.GetResult<{
      storycode: string
      subseriescode: string
      storysubseriescomment: string | null
    }, ExtArgs["result"]["inducks_storysubseries"]>
    composites: {}
  }


  type inducks_storysubseriesGetPayload<S extends boolean | null | undefined | inducks_storysubseriesDefaultArgs> = $Result.GetResult<Prisma.$inducks_storysubseriesPayload, S>

  type inducks_storysubseriesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_storysubseriesFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_storysubseriesCountAggregateInputType | true
    }

  export interface inducks_storysubseriesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_storysubseries'], meta: { name: 'inducks_storysubseries' } }
    /**
     * Find zero or one Inducks_storysubseries that matches the filter.
     * @param {inducks_storysubseriesFindUniqueArgs} args - Arguments to find a Inducks_storysubseries
     * @example
     * // Get one Inducks_storysubseries
     * const inducks_storysubseries = await prisma.inducks_storysubseries.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_storysubseriesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storysubseriesFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_storysubseriesClient<$Result.GetResult<Prisma.$inducks_storysubseriesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_storysubseries that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_storysubseriesFindUniqueOrThrowArgs} args - Arguments to find a Inducks_storysubseries
     * @example
     * // Get one Inducks_storysubseries
     * const inducks_storysubseries = await prisma.inducks_storysubseries.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_storysubseriesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storysubseriesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_storysubseriesClient<$Result.GetResult<Prisma.$inducks_storysubseriesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_storysubseries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storysubseriesFindFirstArgs} args - Arguments to find a Inducks_storysubseries
     * @example
     * // Get one Inducks_storysubseries
     * const inducks_storysubseries = await prisma.inducks_storysubseries.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_storysubseriesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storysubseriesFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_storysubseriesClient<$Result.GetResult<Prisma.$inducks_storysubseriesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_storysubseries that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storysubseriesFindFirstOrThrowArgs} args - Arguments to find a Inducks_storysubseries
     * @example
     * // Get one Inducks_storysubseries
     * const inducks_storysubseries = await prisma.inducks_storysubseries.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_storysubseriesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storysubseriesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_storysubseriesClient<$Result.GetResult<Prisma.$inducks_storysubseriesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_storysubseries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storysubseriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_storysubseries
     * const inducks_storysubseries = await prisma.inducks_storysubseries.findMany()
     * 
     * // Get first 10 Inducks_storysubseries
     * const inducks_storysubseries = await prisma.inducks_storysubseries.findMany({ take: 10 })
     * 
     * // Only select the `storycode`
     * const inducks_storysubseriesWithStorycodeOnly = await prisma.inducks_storysubseries.findMany({ select: { storycode: true } })
     * 
    **/
    findMany<T extends inducks_storysubseriesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storysubseriesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_storysubseriesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_storysubseries.
     * @param {inducks_storysubseriesCreateArgs} args - Arguments to create a Inducks_storysubseries.
     * @example
     * // Create one Inducks_storysubseries
     * const Inducks_storysubseries = await prisma.inducks_storysubseries.create({
     *   data: {
     *     // ... data to create a Inducks_storysubseries
     *   }
     * })
     * 
    **/
    create<T extends inducks_storysubseriesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storysubseriesCreateArgs<ExtArgs>>
    ): Prisma__inducks_storysubseriesClient<$Result.GetResult<Prisma.$inducks_storysubseriesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_storysubseries.
     *     @param {inducks_storysubseriesCreateManyArgs} args - Arguments to create many Inducks_storysubseries.
     *     @example
     *     // Create many Inducks_storysubseries
     *     const inducks_storysubseries = await prisma.inducks_storysubseries.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_storysubseriesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storysubseriesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_storysubseries.
     * @param {inducks_storysubseriesDeleteArgs} args - Arguments to delete one Inducks_storysubseries.
     * @example
     * // Delete one Inducks_storysubseries
     * const Inducks_storysubseries = await prisma.inducks_storysubseries.delete({
     *   where: {
     *     // ... filter to delete one Inducks_storysubseries
     *   }
     * })
     * 
    **/
    delete<T extends inducks_storysubseriesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storysubseriesDeleteArgs<ExtArgs>>
    ): Prisma__inducks_storysubseriesClient<$Result.GetResult<Prisma.$inducks_storysubseriesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_storysubseries.
     * @param {inducks_storysubseriesUpdateArgs} args - Arguments to update one Inducks_storysubseries.
     * @example
     * // Update one Inducks_storysubseries
     * const inducks_storysubseries = await prisma.inducks_storysubseries.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_storysubseriesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storysubseriesUpdateArgs<ExtArgs>>
    ): Prisma__inducks_storysubseriesClient<$Result.GetResult<Prisma.$inducks_storysubseriesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_storysubseries.
     * @param {inducks_storysubseriesDeleteManyArgs} args - Arguments to filter Inducks_storysubseries to delete.
     * @example
     * // Delete a few Inducks_storysubseries
     * const { count } = await prisma.inducks_storysubseries.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_storysubseriesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storysubseriesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_storysubseries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storysubseriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_storysubseries
     * const inducks_storysubseries = await prisma.inducks_storysubseries.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_storysubseriesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storysubseriesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_storysubseries.
     * @param {inducks_storysubseriesUpsertArgs} args - Arguments to update or create a Inducks_storysubseries.
     * @example
     * // Update or create a Inducks_storysubseries
     * const inducks_storysubseries = await prisma.inducks_storysubseries.upsert({
     *   create: {
     *     // ... data to create a Inducks_storysubseries
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_storysubseries we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_storysubseriesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storysubseriesUpsertArgs<ExtArgs>>
    ): Prisma__inducks_storysubseriesClient<$Result.GetResult<Prisma.$inducks_storysubseriesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_storysubseries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storysubseriesCountArgs} args - Arguments to filter Inducks_storysubseries to count.
     * @example
     * // Count the number of Inducks_storysubseries
     * const count = await prisma.inducks_storysubseries.count({
     *   where: {
     *     // ... the filter for the Inducks_storysubseries we want to count
     *   }
     * })
    **/
    count<T extends inducks_storysubseriesCountArgs>(
      args?: Subset<T, inducks_storysubseriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_storysubseriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_storysubseries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_storysubseriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_storysubseriesAggregateArgs>(args: Subset<T, Inducks_storysubseriesAggregateArgs>): Prisma.PrismaPromise<GetInducks_storysubseriesAggregateType<T>>

    /**
     * Group by Inducks_storysubseries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storysubseriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_storysubseriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_storysubseriesGroupByArgs['orderBy'] }
        : { orderBy?: inducks_storysubseriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_storysubseriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_storysubseriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_storysubseries model
   */
  readonly fields: inducks_storysubseriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_storysubseries.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_storysubseriesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_storysubseries model
   */ 
  interface inducks_storysubseriesFieldRefs {
    readonly storycode: FieldRef<"inducks_storysubseries", 'String'>
    readonly subseriescode: FieldRef<"inducks_storysubseries", 'String'>
    readonly storysubseriescomment: FieldRef<"inducks_storysubseries", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_storysubseries findUnique
   */
  export type inducks_storysubseriesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storysubseries
     */
    select?: inducks_storysubseriesSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storysubseries to fetch.
     */
    where: inducks_storysubseriesWhereUniqueInput
  }


  /**
   * inducks_storysubseries findUniqueOrThrow
   */
  export type inducks_storysubseriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storysubseries
     */
    select?: inducks_storysubseriesSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storysubseries to fetch.
     */
    where: inducks_storysubseriesWhereUniqueInput
  }


  /**
   * inducks_storysubseries findFirst
   */
  export type inducks_storysubseriesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storysubseries
     */
    select?: inducks_storysubseriesSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storysubseries to fetch.
     */
    where?: inducks_storysubseriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_storysubseries to fetch.
     */
    orderBy?: inducks_storysubseriesOrderByWithRelationInput | inducks_storysubseriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_storysubseries.
     */
    cursor?: inducks_storysubseriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_storysubseries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_storysubseries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_storysubseries.
     */
    distinct?: Inducks_storysubseriesScalarFieldEnum | Inducks_storysubseriesScalarFieldEnum[]
  }


  /**
   * inducks_storysubseries findFirstOrThrow
   */
  export type inducks_storysubseriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storysubseries
     */
    select?: inducks_storysubseriesSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storysubseries to fetch.
     */
    where?: inducks_storysubseriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_storysubseries to fetch.
     */
    orderBy?: inducks_storysubseriesOrderByWithRelationInput | inducks_storysubseriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_storysubseries.
     */
    cursor?: inducks_storysubseriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_storysubseries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_storysubseries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_storysubseries.
     */
    distinct?: Inducks_storysubseriesScalarFieldEnum | Inducks_storysubseriesScalarFieldEnum[]
  }


  /**
   * inducks_storysubseries findMany
   */
  export type inducks_storysubseriesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storysubseries
     */
    select?: inducks_storysubseriesSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storysubseries to fetch.
     */
    where?: inducks_storysubseriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_storysubseries to fetch.
     */
    orderBy?: inducks_storysubseriesOrderByWithRelationInput | inducks_storysubseriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_storysubseries.
     */
    cursor?: inducks_storysubseriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_storysubseries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_storysubseries.
     */
    skip?: number
    distinct?: Inducks_storysubseriesScalarFieldEnum | Inducks_storysubseriesScalarFieldEnum[]
  }


  /**
   * inducks_storysubseries create
   */
  export type inducks_storysubseriesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storysubseries
     */
    select?: inducks_storysubseriesSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_storysubseries.
     */
    data: XOR<inducks_storysubseriesCreateInput, inducks_storysubseriesUncheckedCreateInput>
  }


  /**
   * inducks_storysubseries createMany
   */
  export type inducks_storysubseriesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_storysubseries.
     */
    data: inducks_storysubseriesCreateManyInput | inducks_storysubseriesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_storysubseries update
   */
  export type inducks_storysubseriesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storysubseries
     */
    select?: inducks_storysubseriesSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_storysubseries.
     */
    data: XOR<inducks_storysubseriesUpdateInput, inducks_storysubseriesUncheckedUpdateInput>
    /**
     * Choose, which inducks_storysubseries to update.
     */
    where: inducks_storysubseriesWhereUniqueInput
  }


  /**
   * inducks_storysubseries updateMany
   */
  export type inducks_storysubseriesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_storysubseries.
     */
    data: XOR<inducks_storysubseriesUpdateManyMutationInput, inducks_storysubseriesUncheckedUpdateManyInput>
    /**
     * Filter which inducks_storysubseries to update
     */
    where?: inducks_storysubseriesWhereInput
  }


  /**
   * inducks_storysubseries upsert
   */
  export type inducks_storysubseriesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storysubseries
     */
    select?: inducks_storysubseriesSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_storysubseries to update in case it exists.
     */
    where: inducks_storysubseriesWhereUniqueInput
    /**
     * In case the inducks_storysubseries found by the `where` argument doesn't exist, create a new inducks_storysubseries with this data.
     */
    create: XOR<inducks_storysubseriesCreateInput, inducks_storysubseriesUncheckedCreateInput>
    /**
     * In case the inducks_storysubseries was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_storysubseriesUpdateInput, inducks_storysubseriesUncheckedUpdateInput>
  }


  /**
   * inducks_storysubseries delete
   */
  export type inducks_storysubseriesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storysubseries
     */
    select?: inducks_storysubseriesSelect<ExtArgs> | null
    /**
     * Filter which inducks_storysubseries to delete.
     */
    where: inducks_storysubseriesWhereUniqueInput
  }


  /**
   * inducks_storysubseries deleteMany
   */
  export type inducks_storysubseriesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_storysubseries to delete
     */
    where?: inducks_storysubseriesWhereInput
  }


  /**
   * inducks_storysubseries without action
   */
  export type inducks_storysubseriesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storysubseries
     */
    select?: inducks_storysubseriesSelect<ExtArgs> | null
  }



  /**
   * Model inducks_storyurl
   */

  export type AggregateInducks_storyurl = {
    _count: Inducks_storyurlCountAggregateOutputType | null
    _min: Inducks_storyurlMinAggregateOutputType | null
    _max: Inducks_storyurlMaxAggregateOutputType | null
  }

  export type Inducks_storyurlMinAggregateOutputType = {
    storycode: string | null
    sitecode: string | null
    url: string | null
  }

  export type Inducks_storyurlMaxAggregateOutputType = {
    storycode: string | null
    sitecode: string | null
    url: string | null
  }

  export type Inducks_storyurlCountAggregateOutputType = {
    storycode: number
    sitecode: number
    url: number
    _all: number
  }


  export type Inducks_storyurlMinAggregateInputType = {
    storycode?: true
    sitecode?: true
    url?: true
  }

  export type Inducks_storyurlMaxAggregateInputType = {
    storycode?: true
    sitecode?: true
    url?: true
  }

  export type Inducks_storyurlCountAggregateInputType = {
    storycode?: true
    sitecode?: true
    url?: true
    _all?: true
  }

  export type Inducks_storyurlAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_storyurl to aggregate.
     */
    where?: inducks_storyurlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_storyurls to fetch.
     */
    orderBy?: inducks_storyurlOrderByWithRelationInput | inducks_storyurlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_storyurlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_storyurls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_storyurls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_storyurls
    **/
    _count?: true | Inducks_storyurlCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_storyurlMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_storyurlMaxAggregateInputType
  }

  export type GetInducks_storyurlAggregateType<T extends Inducks_storyurlAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_storyurl]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_storyurl[P]>
      : GetScalarType<T[P], AggregateInducks_storyurl[P]>
  }




  export type inducks_storyurlGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_storyurlWhereInput
    orderBy?: inducks_storyurlOrderByWithAggregationInput | inducks_storyurlOrderByWithAggregationInput[]
    by: Inducks_storyurlScalarFieldEnum[] | Inducks_storyurlScalarFieldEnum
    having?: inducks_storyurlScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_storyurlCountAggregateInputType | true
    _min?: Inducks_storyurlMinAggregateInputType
    _max?: Inducks_storyurlMaxAggregateInputType
  }

  export type Inducks_storyurlGroupByOutputType = {
    storycode: string
    sitecode: string
    url: string | null
    _count: Inducks_storyurlCountAggregateOutputType | null
    _min: Inducks_storyurlMinAggregateOutputType | null
    _max: Inducks_storyurlMaxAggregateOutputType | null
  }

  type GetInducks_storyurlGroupByPayload<T extends inducks_storyurlGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_storyurlGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_storyurlGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_storyurlGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_storyurlGroupByOutputType[P]>
        }
      >
    >


  export type inducks_storyurlSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    storycode?: boolean
    sitecode?: boolean
    url?: boolean
  }, ExtArgs["result"]["inducks_storyurl"]>

  export type inducks_storyurlSelectScalar = {
    storycode?: boolean
    sitecode?: boolean
    url?: boolean
  }


  export type $inducks_storyurlPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_storyurl"
    objects: {}
    scalars: $Extensions.GetResult<{
      storycode: string
      sitecode: string
      url: string | null
    }, ExtArgs["result"]["inducks_storyurl"]>
    composites: {}
  }


  type inducks_storyurlGetPayload<S extends boolean | null | undefined | inducks_storyurlDefaultArgs> = $Result.GetResult<Prisma.$inducks_storyurlPayload, S>

  type inducks_storyurlCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_storyurlFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_storyurlCountAggregateInputType | true
    }

  export interface inducks_storyurlDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_storyurl'], meta: { name: 'inducks_storyurl' } }
    /**
     * Find zero or one Inducks_storyurl that matches the filter.
     * @param {inducks_storyurlFindUniqueArgs} args - Arguments to find a Inducks_storyurl
     * @example
     * // Get one Inducks_storyurl
     * const inducks_storyurl = await prisma.inducks_storyurl.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_storyurlFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyurlFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_storyurlClient<$Result.GetResult<Prisma.$inducks_storyurlPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_storyurl that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_storyurlFindUniqueOrThrowArgs} args - Arguments to find a Inducks_storyurl
     * @example
     * // Get one Inducks_storyurl
     * const inducks_storyurl = await prisma.inducks_storyurl.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_storyurlFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyurlFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_storyurlClient<$Result.GetResult<Prisma.$inducks_storyurlPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_storyurl that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyurlFindFirstArgs} args - Arguments to find a Inducks_storyurl
     * @example
     * // Get one Inducks_storyurl
     * const inducks_storyurl = await prisma.inducks_storyurl.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_storyurlFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyurlFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_storyurlClient<$Result.GetResult<Prisma.$inducks_storyurlPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_storyurl that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyurlFindFirstOrThrowArgs} args - Arguments to find a Inducks_storyurl
     * @example
     * // Get one Inducks_storyurl
     * const inducks_storyurl = await prisma.inducks_storyurl.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_storyurlFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyurlFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_storyurlClient<$Result.GetResult<Prisma.$inducks_storyurlPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_storyurls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyurlFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_storyurls
     * const inducks_storyurls = await prisma.inducks_storyurl.findMany()
     * 
     * // Get first 10 Inducks_storyurls
     * const inducks_storyurls = await prisma.inducks_storyurl.findMany({ take: 10 })
     * 
     * // Only select the `storycode`
     * const inducks_storyurlWithStorycodeOnly = await prisma.inducks_storyurl.findMany({ select: { storycode: true } })
     * 
    **/
    findMany<T extends inducks_storyurlFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyurlFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_storyurlPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_storyurl.
     * @param {inducks_storyurlCreateArgs} args - Arguments to create a Inducks_storyurl.
     * @example
     * // Create one Inducks_storyurl
     * const Inducks_storyurl = await prisma.inducks_storyurl.create({
     *   data: {
     *     // ... data to create a Inducks_storyurl
     *   }
     * })
     * 
    **/
    create<T extends inducks_storyurlCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyurlCreateArgs<ExtArgs>>
    ): Prisma__inducks_storyurlClient<$Result.GetResult<Prisma.$inducks_storyurlPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_storyurls.
     *     @param {inducks_storyurlCreateManyArgs} args - Arguments to create many Inducks_storyurls.
     *     @example
     *     // Create many Inducks_storyurls
     *     const inducks_storyurl = await prisma.inducks_storyurl.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_storyurlCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyurlCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_storyurl.
     * @param {inducks_storyurlDeleteArgs} args - Arguments to delete one Inducks_storyurl.
     * @example
     * // Delete one Inducks_storyurl
     * const Inducks_storyurl = await prisma.inducks_storyurl.delete({
     *   where: {
     *     // ... filter to delete one Inducks_storyurl
     *   }
     * })
     * 
    **/
    delete<T extends inducks_storyurlDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyurlDeleteArgs<ExtArgs>>
    ): Prisma__inducks_storyurlClient<$Result.GetResult<Prisma.$inducks_storyurlPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_storyurl.
     * @param {inducks_storyurlUpdateArgs} args - Arguments to update one Inducks_storyurl.
     * @example
     * // Update one Inducks_storyurl
     * const inducks_storyurl = await prisma.inducks_storyurl.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_storyurlUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyurlUpdateArgs<ExtArgs>>
    ): Prisma__inducks_storyurlClient<$Result.GetResult<Prisma.$inducks_storyurlPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_storyurls.
     * @param {inducks_storyurlDeleteManyArgs} args - Arguments to filter Inducks_storyurls to delete.
     * @example
     * // Delete a few Inducks_storyurls
     * const { count } = await prisma.inducks_storyurl.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_storyurlDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyurlDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_storyurls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyurlUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_storyurls
     * const inducks_storyurl = await prisma.inducks_storyurl.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_storyurlUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyurlUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_storyurl.
     * @param {inducks_storyurlUpsertArgs} args - Arguments to update or create a Inducks_storyurl.
     * @example
     * // Update or create a Inducks_storyurl
     * const inducks_storyurl = await prisma.inducks_storyurl.upsert({
     *   create: {
     *     // ... data to create a Inducks_storyurl
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_storyurl we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_storyurlUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyurlUpsertArgs<ExtArgs>>
    ): Prisma__inducks_storyurlClient<$Result.GetResult<Prisma.$inducks_storyurlPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_storyurls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyurlCountArgs} args - Arguments to filter Inducks_storyurls to count.
     * @example
     * // Count the number of Inducks_storyurls
     * const count = await prisma.inducks_storyurl.count({
     *   where: {
     *     // ... the filter for the Inducks_storyurls we want to count
     *   }
     * })
    **/
    count<T extends inducks_storyurlCountArgs>(
      args?: Subset<T, inducks_storyurlCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_storyurlCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_storyurl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_storyurlAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_storyurlAggregateArgs>(args: Subset<T, Inducks_storyurlAggregateArgs>): Prisma.PrismaPromise<GetInducks_storyurlAggregateType<T>>

    /**
     * Group by Inducks_storyurl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyurlGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_storyurlGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_storyurlGroupByArgs['orderBy'] }
        : { orderBy?: inducks_storyurlGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_storyurlGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_storyurlGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_storyurl model
   */
  readonly fields: inducks_storyurlFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_storyurl.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_storyurlClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_storyurl model
   */ 
  interface inducks_storyurlFieldRefs {
    readonly storycode: FieldRef<"inducks_storyurl", 'String'>
    readonly sitecode: FieldRef<"inducks_storyurl", 'String'>
    readonly url: FieldRef<"inducks_storyurl", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_storyurl findUnique
   */
  export type inducks_storyurlFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyurl
     */
    select?: inducks_storyurlSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storyurl to fetch.
     */
    where: inducks_storyurlWhereUniqueInput
  }


  /**
   * inducks_storyurl findUniqueOrThrow
   */
  export type inducks_storyurlFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyurl
     */
    select?: inducks_storyurlSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storyurl to fetch.
     */
    where: inducks_storyurlWhereUniqueInput
  }


  /**
   * inducks_storyurl findFirst
   */
  export type inducks_storyurlFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyurl
     */
    select?: inducks_storyurlSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storyurl to fetch.
     */
    where?: inducks_storyurlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_storyurls to fetch.
     */
    orderBy?: inducks_storyurlOrderByWithRelationInput | inducks_storyurlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_storyurls.
     */
    cursor?: inducks_storyurlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_storyurls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_storyurls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_storyurls.
     */
    distinct?: Inducks_storyurlScalarFieldEnum | Inducks_storyurlScalarFieldEnum[]
  }


  /**
   * inducks_storyurl findFirstOrThrow
   */
  export type inducks_storyurlFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyurl
     */
    select?: inducks_storyurlSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storyurl to fetch.
     */
    where?: inducks_storyurlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_storyurls to fetch.
     */
    orderBy?: inducks_storyurlOrderByWithRelationInput | inducks_storyurlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_storyurls.
     */
    cursor?: inducks_storyurlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_storyurls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_storyurls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_storyurls.
     */
    distinct?: Inducks_storyurlScalarFieldEnum | Inducks_storyurlScalarFieldEnum[]
  }


  /**
   * inducks_storyurl findMany
   */
  export type inducks_storyurlFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyurl
     */
    select?: inducks_storyurlSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storyurls to fetch.
     */
    where?: inducks_storyurlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_storyurls to fetch.
     */
    orderBy?: inducks_storyurlOrderByWithRelationInput | inducks_storyurlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_storyurls.
     */
    cursor?: inducks_storyurlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_storyurls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_storyurls.
     */
    skip?: number
    distinct?: Inducks_storyurlScalarFieldEnum | Inducks_storyurlScalarFieldEnum[]
  }


  /**
   * inducks_storyurl create
   */
  export type inducks_storyurlCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyurl
     */
    select?: inducks_storyurlSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_storyurl.
     */
    data: XOR<inducks_storyurlCreateInput, inducks_storyurlUncheckedCreateInput>
  }


  /**
   * inducks_storyurl createMany
   */
  export type inducks_storyurlCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_storyurls.
     */
    data: inducks_storyurlCreateManyInput | inducks_storyurlCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_storyurl update
   */
  export type inducks_storyurlUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyurl
     */
    select?: inducks_storyurlSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_storyurl.
     */
    data: XOR<inducks_storyurlUpdateInput, inducks_storyurlUncheckedUpdateInput>
    /**
     * Choose, which inducks_storyurl to update.
     */
    where: inducks_storyurlWhereUniqueInput
  }


  /**
   * inducks_storyurl updateMany
   */
  export type inducks_storyurlUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_storyurls.
     */
    data: XOR<inducks_storyurlUpdateManyMutationInput, inducks_storyurlUncheckedUpdateManyInput>
    /**
     * Filter which inducks_storyurls to update
     */
    where?: inducks_storyurlWhereInput
  }


  /**
   * inducks_storyurl upsert
   */
  export type inducks_storyurlUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyurl
     */
    select?: inducks_storyurlSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_storyurl to update in case it exists.
     */
    where: inducks_storyurlWhereUniqueInput
    /**
     * In case the inducks_storyurl found by the `where` argument doesn't exist, create a new inducks_storyurl with this data.
     */
    create: XOR<inducks_storyurlCreateInput, inducks_storyurlUncheckedCreateInput>
    /**
     * In case the inducks_storyurl was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_storyurlUpdateInput, inducks_storyurlUncheckedUpdateInput>
  }


  /**
   * inducks_storyurl delete
   */
  export type inducks_storyurlDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyurl
     */
    select?: inducks_storyurlSelect<ExtArgs> | null
    /**
     * Filter which inducks_storyurl to delete.
     */
    where: inducks_storyurlWhereUniqueInput
  }


  /**
   * inducks_storyurl deleteMany
   */
  export type inducks_storyurlDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_storyurls to delete
     */
    where?: inducks_storyurlWhereInput
  }


  /**
   * inducks_storyurl without action
   */
  export type inducks_storyurlDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyurl
     */
    select?: inducks_storyurlSelect<ExtArgs> | null
  }



  /**
   * Model inducks_storyversion
   */

  export type AggregateInducks_storyversion = {
    _count: Inducks_storyversionCountAggregateOutputType | null
    _avg: Inducks_storyversionAvgAggregateOutputType | null
    _sum: Inducks_storyversionSumAggregateOutputType | null
    _min: Inducks_storyversionMinAggregateOutputType | null
    _max: Inducks_storyversionMaxAggregateOutputType | null
  }

  export type Inducks_storyversionAvgAggregateOutputType = {
    entirepages: number | null
    brokenpagenumerator: number | null
    brokenpagedenominator: number | null
    rowsperpage: number | null
    columnsperpage: number | null
    estimatedpanels: number | null
  }

  export type Inducks_storyversionSumAggregateOutputType = {
    entirepages: number | null
    brokenpagenumerator: number | null
    brokenpagedenominator: number | null
    rowsperpage: number | null
    columnsperpage: number | null
    estimatedpanels: number | null
  }

  export type Inducks_storyversionMinAggregateOutputType = {
    storyversioncode: string | null
    storycode: string | null
    entirepages: number | null
    brokenpagenumerator: number | null
    brokenpagedenominator: number | null
    brokenpageunspecified: $Enums.inducks_storyversion_brokenpageunspecified | null
    kind: string | null
    rowsperpage: number | null
    columnsperpage: number | null
    appisxapp: $Enums.inducks_storyversion_appisxapp | null
    what: string | null
    appsummary: string | null
    plotsummary: string | null
    writsummary: string | null
    artsummary: string | null
    inksummary: string | null
    creatorrefsummary: string | null
    keywordsummary: string | null
    estimatedpanels: number | null
  }

  export type Inducks_storyversionMaxAggregateOutputType = {
    storyversioncode: string | null
    storycode: string | null
    entirepages: number | null
    brokenpagenumerator: number | null
    brokenpagedenominator: number | null
    brokenpageunspecified: $Enums.inducks_storyversion_brokenpageunspecified | null
    kind: string | null
    rowsperpage: number | null
    columnsperpage: number | null
    appisxapp: $Enums.inducks_storyversion_appisxapp | null
    what: string | null
    appsummary: string | null
    plotsummary: string | null
    writsummary: string | null
    artsummary: string | null
    inksummary: string | null
    creatorrefsummary: string | null
    keywordsummary: string | null
    estimatedpanels: number | null
  }

  export type Inducks_storyversionCountAggregateOutputType = {
    storyversioncode: number
    storycode: number
    entirepages: number
    brokenpagenumerator: number
    brokenpagedenominator: number
    brokenpageunspecified: number
    kind: number
    rowsperpage: number
    columnsperpage: number
    appisxapp: number
    what: number
    appsummary: number
    plotsummary: number
    writsummary: number
    artsummary: number
    inksummary: number
    creatorrefsummary: number
    keywordsummary: number
    estimatedpanels: number
    _all: number
  }


  export type Inducks_storyversionAvgAggregateInputType = {
    entirepages?: true
    brokenpagenumerator?: true
    brokenpagedenominator?: true
    rowsperpage?: true
    columnsperpage?: true
    estimatedpanels?: true
  }

  export type Inducks_storyversionSumAggregateInputType = {
    entirepages?: true
    brokenpagenumerator?: true
    brokenpagedenominator?: true
    rowsperpage?: true
    columnsperpage?: true
    estimatedpanels?: true
  }

  export type Inducks_storyversionMinAggregateInputType = {
    storyversioncode?: true
    storycode?: true
    entirepages?: true
    brokenpagenumerator?: true
    brokenpagedenominator?: true
    brokenpageunspecified?: true
    kind?: true
    rowsperpage?: true
    columnsperpage?: true
    appisxapp?: true
    what?: true
    appsummary?: true
    plotsummary?: true
    writsummary?: true
    artsummary?: true
    inksummary?: true
    creatorrefsummary?: true
    keywordsummary?: true
    estimatedpanels?: true
  }

  export type Inducks_storyversionMaxAggregateInputType = {
    storyversioncode?: true
    storycode?: true
    entirepages?: true
    brokenpagenumerator?: true
    brokenpagedenominator?: true
    brokenpageunspecified?: true
    kind?: true
    rowsperpage?: true
    columnsperpage?: true
    appisxapp?: true
    what?: true
    appsummary?: true
    plotsummary?: true
    writsummary?: true
    artsummary?: true
    inksummary?: true
    creatorrefsummary?: true
    keywordsummary?: true
    estimatedpanels?: true
  }

  export type Inducks_storyversionCountAggregateInputType = {
    storyversioncode?: true
    storycode?: true
    entirepages?: true
    brokenpagenumerator?: true
    brokenpagedenominator?: true
    brokenpageunspecified?: true
    kind?: true
    rowsperpage?: true
    columnsperpage?: true
    appisxapp?: true
    what?: true
    appsummary?: true
    plotsummary?: true
    writsummary?: true
    artsummary?: true
    inksummary?: true
    creatorrefsummary?: true
    keywordsummary?: true
    estimatedpanels?: true
    _all?: true
  }

  export type Inducks_storyversionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_storyversion to aggregate.
     */
    where?: inducks_storyversionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_storyversions to fetch.
     */
    orderBy?: inducks_storyversionOrderByWithRelationInput | inducks_storyversionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_storyversionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_storyversions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_storyversions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_storyversions
    **/
    _count?: true | Inducks_storyversionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Inducks_storyversionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Inducks_storyversionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_storyversionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_storyversionMaxAggregateInputType
  }

  export type GetInducks_storyversionAggregateType<T extends Inducks_storyversionAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_storyversion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_storyversion[P]>
      : GetScalarType<T[P], AggregateInducks_storyversion[P]>
  }




  export type inducks_storyversionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_storyversionWhereInput
    orderBy?: inducks_storyversionOrderByWithAggregationInput | inducks_storyversionOrderByWithAggregationInput[]
    by: Inducks_storyversionScalarFieldEnum[] | Inducks_storyversionScalarFieldEnum
    having?: inducks_storyversionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_storyversionCountAggregateInputType | true
    _avg?: Inducks_storyversionAvgAggregateInputType
    _sum?: Inducks_storyversionSumAggregateInputType
    _min?: Inducks_storyversionMinAggregateInputType
    _max?: Inducks_storyversionMaxAggregateInputType
  }

  export type Inducks_storyversionGroupByOutputType = {
    storyversioncode: string
    storycode: string | null
    entirepages: number | null
    brokenpagenumerator: number | null
    brokenpagedenominator: number | null
    brokenpageunspecified: $Enums.inducks_storyversion_brokenpageunspecified | null
    kind: string | null
    rowsperpage: number | null
    columnsperpage: number | null
    appisxapp: $Enums.inducks_storyversion_appisxapp | null
    what: string | null
    appsummary: string | null
    plotsummary: string | null
    writsummary: string | null
    artsummary: string | null
    inksummary: string | null
    creatorrefsummary: string | null
    keywordsummary: string | null
    estimatedpanels: number | null
    _count: Inducks_storyversionCountAggregateOutputType | null
    _avg: Inducks_storyversionAvgAggregateOutputType | null
    _sum: Inducks_storyversionSumAggregateOutputType | null
    _min: Inducks_storyversionMinAggregateOutputType | null
    _max: Inducks_storyversionMaxAggregateOutputType | null
  }

  type GetInducks_storyversionGroupByPayload<T extends inducks_storyversionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_storyversionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_storyversionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_storyversionGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_storyversionGroupByOutputType[P]>
        }
      >
    >


  export type inducks_storyversionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    storyversioncode?: boolean
    storycode?: boolean
    entirepages?: boolean
    brokenpagenumerator?: boolean
    brokenpagedenominator?: boolean
    brokenpageunspecified?: boolean
    kind?: boolean
    rowsperpage?: boolean
    columnsperpage?: boolean
    appisxapp?: boolean
    what?: boolean
    appsummary?: boolean
    plotsummary?: boolean
    writsummary?: boolean
    artsummary?: boolean
    inksummary?: boolean
    creatorrefsummary?: boolean
    keywordsummary?: boolean
    estimatedpanels?: boolean
  }, ExtArgs["result"]["inducks_storyversion"]>

  export type inducks_storyversionSelectScalar = {
    storyversioncode?: boolean
    storycode?: boolean
    entirepages?: boolean
    brokenpagenumerator?: boolean
    brokenpagedenominator?: boolean
    brokenpageunspecified?: boolean
    kind?: boolean
    rowsperpage?: boolean
    columnsperpage?: boolean
    appisxapp?: boolean
    what?: boolean
    appsummary?: boolean
    plotsummary?: boolean
    writsummary?: boolean
    artsummary?: boolean
    inksummary?: boolean
    creatorrefsummary?: boolean
    keywordsummary?: boolean
    estimatedpanels?: boolean
  }


  export type $inducks_storyversionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_storyversion"
    objects: {}
    scalars: $Extensions.GetResult<{
      storyversioncode: string
      storycode: string | null
      entirepages: number | null
      brokenpagenumerator: number | null
      brokenpagedenominator: number | null
      brokenpageunspecified: $Enums.inducks_storyversion_brokenpageunspecified | null
      kind: string | null
      rowsperpage: number | null
      columnsperpage: number | null
      appisxapp: $Enums.inducks_storyversion_appisxapp | null
      what: string | null
      appsummary: string | null
      plotsummary: string | null
      writsummary: string | null
      artsummary: string | null
      inksummary: string | null
      creatorrefsummary: string | null
      keywordsummary: string | null
      estimatedpanels: number | null
    }, ExtArgs["result"]["inducks_storyversion"]>
    composites: {}
  }


  type inducks_storyversionGetPayload<S extends boolean | null | undefined | inducks_storyversionDefaultArgs> = $Result.GetResult<Prisma.$inducks_storyversionPayload, S>

  type inducks_storyversionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_storyversionFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_storyversionCountAggregateInputType | true
    }

  export interface inducks_storyversionDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_storyversion'], meta: { name: 'inducks_storyversion' } }
    /**
     * Find zero or one Inducks_storyversion that matches the filter.
     * @param {inducks_storyversionFindUniqueArgs} args - Arguments to find a Inducks_storyversion
     * @example
     * // Get one Inducks_storyversion
     * const inducks_storyversion = await prisma.inducks_storyversion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_storyversionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyversionFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_storyversionClient<$Result.GetResult<Prisma.$inducks_storyversionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_storyversion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_storyversionFindUniqueOrThrowArgs} args - Arguments to find a Inducks_storyversion
     * @example
     * // Get one Inducks_storyversion
     * const inducks_storyversion = await prisma.inducks_storyversion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_storyversionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyversionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_storyversionClient<$Result.GetResult<Prisma.$inducks_storyversionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_storyversion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyversionFindFirstArgs} args - Arguments to find a Inducks_storyversion
     * @example
     * // Get one Inducks_storyversion
     * const inducks_storyversion = await prisma.inducks_storyversion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_storyversionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyversionFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_storyversionClient<$Result.GetResult<Prisma.$inducks_storyversionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_storyversion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyversionFindFirstOrThrowArgs} args - Arguments to find a Inducks_storyversion
     * @example
     * // Get one Inducks_storyversion
     * const inducks_storyversion = await prisma.inducks_storyversion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_storyversionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyversionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_storyversionClient<$Result.GetResult<Prisma.$inducks_storyversionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_storyversions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyversionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_storyversions
     * const inducks_storyversions = await prisma.inducks_storyversion.findMany()
     * 
     * // Get first 10 Inducks_storyversions
     * const inducks_storyversions = await prisma.inducks_storyversion.findMany({ take: 10 })
     * 
     * // Only select the `storyversioncode`
     * const inducks_storyversionWithStoryversioncodeOnly = await prisma.inducks_storyversion.findMany({ select: { storyversioncode: true } })
     * 
    **/
    findMany<T extends inducks_storyversionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyversionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_storyversionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_storyversion.
     * @param {inducks_storyversionCreateArgs} args - Arguments to create a Inducks_storyversion.
     * @example
     * // Create one Inducks_storyversion
     * const Inducks_storyversion = await prisma.inducks_storyversion.create({
     *   data: {
     *     // ... data to create a Inducks_storyversion
     *   }
     * })
     * 
    **/
    create<T extends inducks_storyversionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyversionCreateArgs<ExtArgs>>
    ): Prisma__inducks_storyversionClient<$Result.GetResult<Prisma.$inducks_storyversionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_storyversions.
     *     @param {inducks_storyversionCreateManyArgs} args - Arguments to create many Inducks_storyversions.
     *     @example
     *     // Create many Inducks_storyversions
     *     const inducks_storyversion = await prisma.inducks_storyversion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_storyversionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyversionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_storyversion.
     * @param {inducks_storyversionDeleteArgs} args - Arguments to delete one Inducks_storyversion.
     * @example
     * // Delete one Inducks_storyversion
     * const Inducks_storyversion = await prisma.inducks_storyversion.delete({
     *   where: {
     *     // ... filter to delete one Inducks_storyversion
     *   }
     * })
     * 
    **/
    delete<T extends inducks_storyversionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyversionDeleteArgs<ExtArgs>>
    ): Prisma__inducks_storyversionClient<$Result.GetResult<Prisma.$inducks_storyversionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_storyversion.
     * @param {inducks_storyversionUpdateArgs} args - Arguments to update one Inducks_storyversion.
     * @example
     * // Update one Inducks_storyversion
     * const inducks_storyversion = await prisma.inducks_storyversion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_storyversionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyversionUpdateArgs<ExtArgs>>
    ): Prisma__inducks_storyversionClient<$Result.GetResult<Prisma.$inducks_storyversionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_storyversions.
     * @param {inducks_storyversionDeleteManyArgs} args - Arguments to filter Inducks_storyversions to delete.
     * @example
     * // Delete a few Inducks_storyversions
     * const { count } = await prisma.inducks_storyversion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_storyversionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyversionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_storyversions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyversionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_storyversions
     * const inducks_storyversion = await prisma.inducks_storyversion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_storyversionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyversionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_storyversion.
     * @param {inducks_storyversionUpsertArgs} args - Arguments to update or create a Inducks_storyversion.
     * @example
     * // Update or create a Inducks_storyversion
     * const inducks_storyversion = await prisma.inducks_storyversion.upsert({
     *   create: {
     *     // ... data to create a Inducks_storyversion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_storyversion we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_storyversionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyversionUpsertArgs<ExtArgs>>
    ): Prisma__inducks_storyversionClient<$Result.GetResult<Prisma.$inducks_storyversionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_storyversions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyversionCountArgs} args - Arguments to filter Inducks_storyversions to count.
     * @example
     * // Count the number of Inducks_storyversions
     * const count = await prisma.inducks_storyversion.count({
     *   where: {
     *     // ... the filter for the Inducks_storyversions we want to count
     *   }
     * })
    **/
    count<T extends inducks_storyversionCountArgs>(
      args?: Subset<T, inducks_storyversionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_storyversionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_storyversion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_storyversionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_storyversionAggregateArgs>(args: Subset<T, Inducks_storyversionAggregateArgs>): Prisma.PrismaPromise<GetInducks_storyversionAggregateType<T>>

    /**
     * Group by Inducks_storyversion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyversionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_storyversionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_storyversionGroupByArgs['orderBy'] }
        : { orderBy?: inducks_storyversionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_storyversionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_storyversionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_storyversion model
   */
  readonly fields: inducks_storyversionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_storyversion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_storyversionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_storyversion model
   */ 
  interface inducks_storyversionFieldRefs {
    readonly storyversioncode: FieldRef<"inducks_storyversion", 'String'>
    readonly storycode: FieldRef<"inducks_storyversion", 'String'>
    readonly entirepages: FieldRef<"inducks_storyversion", 'Int'>
    readonly brokenpagenumerator: FieldRef<"inducks_storyversion", 'Int'>
    readonly brokenpagedenominator: FieldRef<"inducks_storyversion", 'Int'>
    readonly brokenpageunspecified: FieldRef<"inducks_storyversion", 'inducks_storyversion_brokenpageunspecified'>
    readonly kind: FieldRef<"inducks_storyversion", 'String'>
    readonly rowsperpage: FieldRef<"inducks_storyversion", 'Int'>
    readonly columnsperpage: FieldRef<"inducks_storyversion", 'Int'>
    readonly appisxapp: FieldRef<"inducks_storyversion", 'inducks_storyversion_appisxapp'>
    readonly what: FieldRef<"inducks_storyversion", 'String'>
    readonly appsummary: FieldRef<"inducks_storyversion", 'String'>
    readonly plotsummary: FieldRef<"inducks_storyversion", 'String'>
    readonly writsummary: FieldRef<"inducks_storyversion", 'String'>
    readonly artsummary: FieldRef<"inducks_storyversion", 'String'>
    readonly inksummary: FieldRef<"inducks_storyversion", 'String'>
    readonly creatorrefsummary: FieldRef<"inducks_storyversion", 'String'>
    readonly keywordsummary: FieldRef<"inducks_storyversion", 'String'>
    readonly estimatedpanels: FieldRef<"inducks_storyversion", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * inducks_storyversion findUnique
   */
  export type inducks_storyversionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyversion
     */
    select?: inducks_storyversionSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storyversion to fetch.
     */
    where: inducks_storyversionWhereUniqueInput
  }


  /**
   * inducks_storyversion findUniqueOrThrow
   */
  export type inducks_storyversionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyversion
     */
    select?: inducks_storyversionSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storyversion to fetch.
     */
    where: inducks_storyversionWhereUniqueInput
  }


  /**
   * inducks_storyversion findFirst
   */
  export type inducks_storyversionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyversion
     */
    select?: inducks_storyversionSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storyversion to fetch.
     */
    where?: inducks_storyversionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_storyversions to fetch.
     */
    orderBy?: inducks_storyversionOrderByWithRelationInput | inducks_storyversionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_storyversions.
     */
    cursor?: inducks_storyversionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_storyversions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_storyversions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_storyversions.
     */
    distinct?: Inducks_storyversionScalarFieldEnum | Inducks_storyversionScalarFieldEnum[]
  }


  /**
   * inducks_storyversion findFirstOrThrow
   */
  export type inducks_storyversionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyversion
     */
    select?: inducks_storyversionSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storyversion to fetch.
     */
    where?: inducks_storyversionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_storyversions to fetch.
     */
    orderBy?: inducks_storyversionOrderByWithRelationInput | inducks_storyversionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_storyversions.
     */
    cursor?: inducks_storyversionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_storyversions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_storyversions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_storyversions.
     */
    distinct?: Inducks_storyversionScalarFieldEnum | Inducks_storyversionScalarFieldEnum[]
  }


  /**
   * inducks_storyversion findMany
   */
  export type inducks_storyversionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyversion
     */
    select?: inducks_storyversionSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storyversions to fetch.
     */
    where?: inducks_storyversionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_storyversions to fetch.
     */
    orderBy?: inducks_storyversionOrderByWithRelationInput | inducks_storyversionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_storyversions.
     */
    cursor?: inducks_storyversionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_storyversions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_storyversions.
     */
    skip?: number
    distinct?: Inducks_storyversionScalarFieldEnum | Inducks_storyversionScalarFieldEnum[]
  }


  /**
   * inducks_storyversion create
   */
  export type inducks_storyversionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyversion
     */
    select?: inducks_storyversionSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_storyversion.
     */
    data: XOR<inducks_storyversionCreateInput, inducks_storyversionUncheckedCreateInput>
  }


  /**
   * inducks_storyversion createMany
   */
  export type inducks_storyversionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_storyversions.
     */
    data: inducks_storyversionCreateManyInput | inducks_storyversionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_storyversion update
   */
  export type inducks_storyversionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyversion
     */
    select?: inducks_storyversionSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_storyversion.
     */
    data: XOR<inducks_storyversionUpdateInput, inducks_storyversionUncheckedUpdateInput>
    /**
     * Choose, which inducks_storyversion to update.
     */
    where: inducks_storyversionWhereUniqueInput
  }


  /**
   * inducks_storyversion updateMany
   */
  export type inducks_storyversionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_storyversions.
     */
    data: XOR<inducks_storyversionUpdateManyMutationInput, inducks_storyversionUncheckedUpdateManyInput>
    /**
     * Filter which inducks_storyversions to update
     */
    where?: inducks_storyversionWhereInput
  }


  /**
   * inducks_storyversion upsert
   */
  export type inducks_storyversionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyversion
     */
    select?: inducks_storyversionSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_storyversion to update in case it exists.
     */
    where: inducks_storyversionWhereUniqueInput
    /**
     * In case the inducks_storyversion found by the `where` argument doesn't exist, create a new inducks_storyversion with this data.
     */
    create: XOR<inducks_storyversionCreateInput, inducks_storyversionUncheckedCreateInput>
    /**
     * In case the inducks_storyversion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_storyversionUpdateInput, inducks_storyversionUncheckedUpdateInput>
  }


  /**
   * inducks_storyversion delete
   */
  export type inducks_storyversionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyversion
     */
    select?: inducks_storyversionSelect<ExtArgs> | null
    /**
     * Filter which inducks_storyversion to delete.
     */
    where: inducks_storyversionWhereUniqueInput
  }


  /**
   * inducks_storyversion deleteMany
   */
  export type inducks_storyversionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_storyversions to delete
     */
    where?: inducks_storyversionWhereInput
  }


  /**
   * inducks_storyversion without action
   */
  export type inducks_storyversionDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyversion
     */
    select?: inducks_storyversionSelect<ExtArgs> | null
  }



  /**
   * Model inducks_storyversion_nofulltext
   */

  export type AggregateInducks_storyversion_nofulltext = {
    _count: Inducks_storyversion_nofulltextCountAggregateOutputType | null
    _avg: Inducks_storyversion_nofulltextAvgAggregateOutputType | null
    _sum: Inducks_storyversion_nofulltextSumAggregateOutputType | null
    _min: Inducks_storyversion_nofulltextMinAggregateOutputType | null
    _max: Inducks_storyversion_nofulltextMaxAggregateOutputType | null
  }

  export type Inducks_storyversion_nofulltextAvgAggregateOutputType = {
    entirepages: number | null
    brokenpagenumerator: number | null
    brokenpagedenominator: number | null
    rowsperpage: number | null
    columnsperpage: number | null
    estimatedpanels: number | null
  }

  export type Inducks_storyversion_nofulltextSumAggregateOutputType = {
    entirepages: number | null
    brokenpagenumerator: number | null
    brokenpagedenominator: number | null
    rowsperpage: number | null
    columnsperpage: number | null
    estimatedpanels: number | null
  }

  export type Inducks_storyversion_nofulltextMinAggregateOutputType = {
    storyversioncode: string | null
    storycode: string | null
    entirepages: number | null
    brokenpagenumerator: number | null
    brokenpagedenominator: number | null
    brokenpageunspecified: $Enums.inducks_storyversion_nofulltext_brokenpageunspecified | null
    kind: string | null
    rowsperpage: number | null
    columnsperpage: number | null
    appisxapp: $Enums.inducks_storyversion_nofulltext_appisxapp | null
    what: string | null
    appsummary: string | null
    plotsummary: string | null
    writsummary: string | null
    artsummary: string | null
    inksummary: string | null
    creatorrefsummary: string | null
    keywordsummary: string | null
    estimatedpanels: number | null
  }

  export type Inducks_storyversion_nofulltextMaxAggregateOutputType = {
    storyversioncode: string | null
    storycode: string | null
    entirepages: number | null
    brokenpagenumerator: number | null
    brokenpagedenominator: number | null
    brokenpageunspecified: $Enums.inducks_storyversion_nofulltext_brokenpageunspecified | null
    kind: string | null
    rowsperpage: number | null
    columnsperpage: number | null
    appisxapp: $Enums.inducks_storyversion_nofulltext_appisxapp | null
    what: string | null
    appsummary: string | null
    plotsummary: string | null
    writsummary: string | null
    artsummary: string | null
    inksummary: string | null
    creatorrefsummary: string | null
    keywordsummary: string | null
    estimatedpanels: number | null
  }

  export type Inducks_storyversion_nofulltextCountAggregateOutputType = {
    storyversioncode: number
    storycode: number
    entirepages: number
    brokenpagenumerator: number
    brokenpagedenominator: number
    brokenpageunspecified: number
    kind: number
    rowsperpage: number
    columnsperpage: number
    appisxapp: number
    what: number
    appsummary: number
    plotsummary: number
    writsummary: number
    artsummary: number
    inksummary: number
    creatorrefsummary: number
    keywordsummary: number
    estimatedpanels: number
    _all: number
  }


  export type Inducks_storyversion_nofulltextAvgAggregateInputType = {
    entirepages?: true
    brokenpagenumerator?: true
    brokenpagedenominator?: true
    rowsperpage?: true
    columnsperpage?: true
    estimatedpanels?: true
  }

  export type Inducks_storyversion_nofulltextSumAggregateInputType = {
    entirepages?: true
    brokenpagenumerator?: true
    brokenpagedenominator?: true
    rowsperpage?: true
    columnsperpage?: true
    estimatedpanels?: true
  }

  export type Inducks_storyversion_nofulltextMinAggregateInputType = {
    storyversioncode?: true
    storycode?: true
    entirepages?: true
    brokenpagenumerator?: true
    brokenpagedenominator?: true
    brokenpageunspecified?: true
    kind?: true
    rowsperpage?: true
    columnsperpage?: true
    appisxapp?: true
    what?: true
    appsummary?: true
    plotsummary?: true
    writsummary?: true
    artsummary?: true
    inksummary?: true
    creatorrefsummary?: true
    keywordsummary?: true
    estimatedpanels?: true
  }

  export type Inducks_storyversion_nofulltextMaxAggregateInputType = {
    storyversioncode?: true
    storycode?: true
    entirepages?: true
    brokenpagenumerator?: true
    brokenpagedenominator?: true
    brokenpageunspecified?: true
    kind?: true
    rowsperpage?: true
    columnsperpage?: true
    appisxapp?: true
    what?: true
    appsummary?: true
    plotsummary?: true
    writsummary?: true
    artsummary?: true
    inksummary?: true
    creatorrefsummary?: true
    keywordsummary?: true
    estimatedpanels?: true
  }

  export type Inducks_storyversion_nofulltextCountAggregateInputType = {
    storyversioncode?: true
    storycode?: true
    entirepages?: true
    brokenpagenumerator?: true
    brokenpagedenominator?: true
    brokenpageunspecified?: true
    kind?: true
    rowsperpage?: true
    columnsperpage?: true
    appisxapp?: true
    what?: true
    appsummary?: true
    plotsummary?: true
    writsummary?: true
    artsummary?: true
    inksummary?: true
    creatorrefsummary?: true
    keywordsummary?: true
    estimatedpanels?: true
    _all?: true
  }

  export type Inducks_storyversion_nofulltextAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_storyversion_nofulltext to aggregate.
     */
    where?: inducks_storyversion_nofulltextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_storyversion_nofulltexts to fetch.
     */
    orderBy?: inducks_storyversion_nofulltextOrderByWithRelationInput | inducks_storyversion_nofulltextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_storyversion_nofulltextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_storyversion_nofulltexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_storyversion_nofulltexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_storyversion_nofulltexts
    **/
    _count?: true | Inducks_storyversion_nofulltextCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Inducks_storyversion_nofulltextAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Inducks_storyversion_nofulltextSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_storyversion_nofulltextMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_storyversion_nofulltextMaxAggregateInputType
  }

  export type GetInducks_storyversion_nofulltextAggregateType<T extends Inducks_storyversion_nofulltextAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_storyversion_nofulltext]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_storyversion_nofulltext[P]>
      : GetScalarType<T[P], AggregateInducks_storyversion_nofulltext[P]>
  }




  export type inducks_storyversion_nofulltextGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_storyversion_nofulltextWhereInput
    orderBy?: inducks_storyversion_nofulltextOrderByWithAggregationInput | inducks_storyversion_nofulltextOrderByWithAggregationInput[]
    by: Inducks_storyversion_nofulltextScalarFieldEnum[] | Inducks_storyversion_nofulltextScalarFieldEnum
    having?: inducks_storyversion_nofulltextScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_storyversion_nofulltextCountAggregateInputType | true
    _avg?: Inducks_storyversion_nofulltextAvgAggregateInputType
    _sum?: Inducks_storyversion_nofulltextSumAggregateInputType
    _min?: Inducks_storyversion_nofulltextMinAggregateInputType
    _max?: Inducks_storyversion_nofulltextMaxAggregateInputType
  }

  export type Inducks_storyversion_nofulltextGroupByOutputType = {
    storyversioncode: string
    storycode: string | null
    entirepages: number | null
    brokenpagenumerator: number | null
    brokenpagedenominator: number | null
    brokenpageunspecified: $Enums.inducks_storyversion_nofulltext_brokenpageunspecified | null
    kind: string | null
    rowsperpage: number | null
    columnsperpage: number | null
    appisxapp: $Enums.inducks_storyversion_nofulltext_appisxapp | null
    what: string | null
    appsummary: string | null
    plotsummary: string | null
    writsummary: string | null
    artsummary: string | null
    inksummary: string | null
    creatorrefsummary: string | null
    keywordsummary: string | null
    estimatedpanels: number | null
    _count: Inducks_storyversion_nofulltextCountAggregateOutputType | null
    _avg: Inducks_storyversion_nofulltextAvgAggregateOutputType | null
    _sum: Inducks_storyversion_nofulltextSumAggregateOutputType | null
    _min: Inducks_storyversion_nofulltextMinAggregateOutputType | null
    _max: Inducks_storyversion_nofulltextMaxAggregateOutputType | null
  }

  type GetInducks_storyversion_nofulltextGroupByPayload<T extends inducks_storyversion_nofulltextGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_storyversion_nofulltextGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_storyversion_nofulltextGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_storyversion_nofulltextGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_storyversion_nofulltextGroupByOutputType[P]>
        }
      >
    >


  export type inducks_storyversion_nofulltextSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    storyversioncode?: boolean
    storycode?: boolean
    entirepages?: boolean
    brokenpagenumerator?: boolean
    brokenpagedenominator?: boolean
    brokenpageunspecified?: boolean
    kind?: boolean
    rowsperpage?: boolean
    columnsperpage?: boolean
    appisxapp?: boolean
    what?: boolean
    appsummary?: boolean
    plotsummary?: boolean
    writsummary?: boolean
    artsummary?: boolean
    inksummary?: boolean
    creatorrefsummary?: boolean
    keywordsummary?: boolean
    estimatedpanels?: boolean
  }, ExtArgs["result"]["inducks_storyversion_nofulltext"]>

  export type inducks_storyversion_nofulltextSelectScalar = {
    storyversioncode?: boolean
    storycode?: boolean
    entirepages?: boolean
    brokenpagenumerator?: boolean
    brokenpagedenominator?: boolean
    brokenpageunspecified?: boolean
    kind?: boolean
    rowsperpage?: boolean
    columnsperpage?: boolean
    appisxapp?: boolean
    what?: boolean
    appsummary?: boolean
    plotsummary?: boolean
    writsummary?: boolean
    artsummary?: boolean
    inksummary?: boolean
    creatorrefsummary?: boolean
    keywordsummary?: boolean
    estimatedpanels?: boolean
  }


  export type $inducks_storyversion_nofulltextPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_storyversion_nofulltext"
    objects: {}
    scalars: $Extensions.GetResult<{
      storyversioncode: string
      storycode: string | null
      entirepages: number | null
      brokenpagenumerator: number | null
      brokenpagedenominator: number | null
      brokenpageunspecified: $Enums.inducks_storyversion_nofulltext_brokenpageunspecified | null
      kind: string | null
      rowsperpage: number | null
      columnsperpage: number | null
      appisxapp: $Enums.inducks_storyversion_nofulltext_appisxapp | null
      what: string | null
      appsummary: string | null
      plotsummary: string | null
      writsummary: string | null
      artsummary: string | null
      inksummary: string | null
      creatorrefsummary: string | null
      keywordsummary: string | null
      estimatedpanels: number | null
    }, ExtArgs["result"]["inducks_storyversion_nofulltext"]>
    composites: {}
  }


  type inducks_storyversion_nofulltextGetPayload<S extends boolean | null | undefined | inducks_storyversion_nofulltextDefaultArgs> = $Result.GetResult<Prisma.$inducks_storyversion_nofulltextPayload, S>

  type inducks_storyversion_nofulltextCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_storyversion_nofulltextFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_storyversion_nofulltextCountAggregateInputType | true
    }

  export interface inducks_storyversion_nofulltextDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_storyversion_nofulltext'], meta: { name: 'inducks_storyversion_nofulltext' } }
    /**
     * Find zero or one Inducks_storyversion_nofulltext that matches the filter.
     * @param {inducks_storyversion_nofulltextFindUniqueArgs} args - Arguments to find a Inducks_storyversion_nofulltext
     * @example
     * // Get one Inducks_storyversion_nofulltext
     * const inducks_storyversion_nofulltext = await prisma.inducks_storyversion_nofulltext.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_storyversion_nofulltextFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyversion_nofulltextFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_storyversion_nofulltextClient<$Result.GetResult<Prisma.$inducks_storyversion_nofulltextPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_storyversion_nofulltext that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_storyversion_nofulltextFindUniqueOrThrowArgs} args - Arguments to find a Inducks_storyversion_nofulltext
     * @example
     * // Get one Inducks_storyversion_nofulltext
     * const inducks_storyversion_nofulltext = await prisma.inducks_storyversion_nofulltext.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_storyversion_nofulltextFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyversion_nofulltextFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_storyversion_nofulltextClient<$Result.GetResult<Prisma.$inducks_storyversion_nofulltextPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_storyversion_nofulltext that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyversion_nofulltextFindFirstArgs} args - Arguments to find a Inducks_storyversion_nofulltext
     * @example
     * // Get one Inducks_storyversion_nofulltext
     * const inducks_storyversion_nofulltext = await prisma.inducks_storyversion_nofulltext.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_storyversion_nofulltextFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyversion_nofulltextFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_storyversion_nofulltextClient<$Result.GetResult<Prisma.$inducks_storyversion_nofulltextPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_storyversion_nofulltext that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyversion_nofulltextFindFirstOrThrowArgs} args - Arguments to find a Inducks_storyversion_nofulltext
     * @example
     * // Get one Inducks_storyversion_nofulltext
     * const inducks_storyversion_nofulltext = await prisma.inducks_storyversion_nofulltext.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_storyversion_nofulltextFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyversion_nofulltextFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_storyversion_nofulltextClient<$Result.GetResult<Prisma.$inducks_storyversion_nofulltextPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_storyversion_nofulltexts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyversion_nofulltextFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_storyversion_nofulltexts
     * const inducks_storyversion_nofulltexts = await prisma.inducks_storyversion_nofulltext.findMany()
     * 
     * // Get first 10 Inducks_storyversion_nofulltexts
     * const inducks_storyversion_nofulltexts = await prisma.inducks_storyversion_nofulltext.findMany({ take: 10 })
     * 
     * // Only select the `storyversioncode`
     * const inducks_storyversion_nofulltextWithStoryversioncodeOnly = await prisma.inducks_storyversion_nofulltext.findMany({ select: { storyversioncode: true } })
     * 
    **/
    findMany<T extends inducks_storyversion_nofulltextFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyversion_nofulltextFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_storyversion_nofulltextPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_storyversion_nofulltext.
     * @param {inducks_storyversion_nofulltextCreateArgs} args - Arguments to create a Inducks_storyversion_nofulltext.
     * @example
     * // Create one Inducks_storyversion_nofulltext
     * const Inducks_storyversion_nofulltext = await prisma.inducks_storyversion_nofulltext.create({
     *   data: {
     *     // ... data to create a Inducks_storyversion_nofulltext
     *   }
     * })
     * 
    **/
    create<T extends inducks_storyversion_nofulltextCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyversion_nofulltextCreateArgs<ExtArgs>>
    ): Prisma__inducks_storyversion_nofulltextClient<$Result.GetResult<Prisma.$inducks_storyversion_nofulltextPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_storyversion_nofulltexts.
     *     @param {inducks_storyversion_nofulltextCreateManyArgs} args - Arguments to create many Inducks_storyversion_nofulltexts.
     *     @example
     *     // Create many Inducks_storyversion_nofulltexts
     *     const inducks_storyversion_nofulltext = await prisma.inducks_storyversion_nofulltext.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_storyversion_nofulltextCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyversion_nofulltextCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_storyversion_nofulltext.
     * @param {inducks_storyversion_nofulltextDeleteArgs} args - Arguments to delete one Inducks_storyversion_nofulltext.
     * @example
     * // Delete one Inducks_storyversion_nofulltext
     * const Inducks_storyversion_nofulltext = await prisma.inducks_storyversion_nofulltext.delete({
     *   where: {
     *     // ... filter to delete one Inducks_storyversion_nofulltext
     *   }
     * })
     * 
    **/
    delete<T extends inducks_storyversion_nofulltextDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyversion_nofulltextDeleteArgs<ExtArgs>>
    ): Prisma__inducks_storyversion_nofulltextClient<$Result.GetResult<Prisma.$inducks_storyversion_nofulltextPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_storyversion_nofulltext.
     * @param {inducks_storyversion_nofulltextUpdateArgs} args - Arguments to update one Inducks_storyversion_nofulltext.
     * @example
     * // Update one Inducks_storyversion_nofulltext
     * const inducks_storyversion_nofulltext = await prisma.inducks_storyversion_nofulltext.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_storyversion_nofulltextUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyversion_nofulltextUpdateArgs<ExtArgs>>
    ): Prisma__inducks_storyversion_nofulltextClient<$Result.GetResult<Prisma.$inducks_storyversion_nofulltextPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_storyversion_nofulltexts.
     * @param {inducks_storyversion_nofulltextDeleteManyArgs} args - Arguments to filter Inducks_storyversion_nofulltexts to delete.
     * @example
     * // Delete a few Inducks_storyversion_nofulltexts
     * const { count } = await prisma.inducks_storyversion_nofulltext.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_storyversion_nofulltextDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_storyversion_nofulltextDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_storyversion_nofulltexts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyversion_nofulltextUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_storyversion_nofulltexts
     * const inducks_storyversion_nofulltext = await prisma.inducks_storyversion_nofulltext.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_storyversion_nofulltextUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyversion_nofulltextUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_storyversion_nofulltext.
     * @param {inducks_storyversion_nofulltextUpsertArgs} args - Arguments to update or create a Inducks_storyversion_nofulltext.
     * @example
     * // Update or create a Inducks_storyversion_nofulltext
     * const inducks_storyversion_nofulltext = await prisma.inducks_storyversion_nofulltext.upsert({
     *   create: {
     *     // ... data to create a Inducks_storyversion_nofulltext
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_storyversion_nofulltext we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_storyversion_nofulltextUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_storyversion_nofulltextUpsertArgs<ExtArgs>>
    ): Prisma__inducks_storyversion_nofulltextClient<$Result.GetResult<Prisma.$inducks_storyversion_nofulltextPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_storyversion_nofulltexts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyversion_nofulltextCountArgs} args - Arguments to filter Inducks_storyversion_nofulltexts to count.
     * @example
     * // Count the number of Inducks_storyversion_nofulltexts
     * const count = await prisma.inducks_storyversion_nofulltext.count({
     *   where: {
     *     // ... the filter for the Inducks_storyversion_nofulltexts we want to count
     *   }
     * })
    **/
    count<T extends inducks_storyversion_nofulltextCountArgs>(
      args?: Subset<T, inducks_storyversion_nofulltextCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_storyversion_nofulltextCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_storyversion_nofulltext.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_storyversion_nofulltextAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_storyversion_nofulltextAggregateArgs>(args: Subset<T, Inducks_storyversion_nofulltextAggregateArgs>): Prisma.PrismaPromise<GetInducks_storyversion_nofulltextAggregateType<T>>

    /**
     * Group by Inducks_storyversion_nofulltext.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_storyversion_nofulltextGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_storyversion_nofulltextGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_storyversion_nofulltextGroupByArgs['orderBy'] }
        : { orderBy?: inducks_storyversion_nofulltextGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_storyversion_nofulltextGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_storyversion_nofulltextGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_storyversion_nofulltext model
   */
  readonly fields: inducks_storyversion_nofulltextFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_storyversion_nofulltext.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_storyversion_nofulltextClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_storyversion_nofulltext model
   */ 
  interface inducks_storyversion_nofulltextFieldRefs {
    readonly storyversioncode: FieldRef<"inducks_storyversion_nofulltext", 'String'>
    readonly storycode: FieldRef<"inducks_storyversion_nofulltext", 'String'>
    readonly entirepages: FieldRef<"inducks_storyversion_nofulltext", 'Int'>
    readonly brokenpagenumerator: FieldRef<"inducks_storyversion_nofulltext", 'Int'>
    readonly brokenpagedenominator: FieldRef<"inducks_storyversion_nofulltext", 'Int'>
    readonly brokenpageunspecified: FieldRef<"inducks_storyversion_nofulltext", 'inducks_storyversion_nofulltext_brokenpageunspecified'>
    readonly kind: FieldRef<"inducks_storyversion_nofulltext", 'String'>
    readonly rowsperpage: FieldRef<"inducks_storyversion_nofulltext", 'Int'>
    readonly columnsperpage: FieldRef<"inducks_storyversion_nofulltext", 'Int'>
    readonly appisxapp: FieldRef<"inducks_storyversion_nofulltext", 'inducks_storyversion_nofulltext_appisxapp'>
    readonly what: FieldRef<"inducks_storyversion_nofulltext", 'String'>
    readonly appsummary: FieldRef<"inducks_storyversion_nofulltext", 'String'>
    readonly plotsummary: FieldRef<"inducks_storyversion_nofulltext", 'String'>
    readonly writsummary: FieldRef<"inducks_storyversion_nofulltext", 'String'>
    readonly artsummary: FieldRef<"inducks_storyversion_nofulltext", 'String'>
    readonly inksummary: FieldRef<"inducks_storyversion_nofulltext", 'String'>
    readonly creatorrefsummary: FieldRef<"inducks_storyversion_nofulltext", 'String'>
    readonly keywordsummary: FieldRef<"inducks_storyversion_nofulltext", 'String'>
    readonly estimatedpanels: FieldRef<"inducks_storyversion_nofulltext", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * inducks_storyversion_nofulltext findUnique
   */
  export type inducks_storyversion_nofulltextFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyversion_nofulltext
     */
    select?: inducks_storyversion_nofulltextSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storyversion_nofulltext to fetch.
     */
    where: inducks_storyversion_nofulltextWhereUniqueInput
  }


  /**
   * inducks_storyversion_nofulltext findUniqueOrThrow
   */
  export type inducks_storyversion_nofulltextFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyversion_nofulltext
     */
    select?: inducks_storyversion_nofulltextSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storyversion_nofulltext to fetch.
     */
    where: inducks_storyversion_nofulltextWhereUniqueInput
  }


  /**
   * inducks_storyversion_nofulltext findFirst
   */
  export type inducks_storyversion_nofulltextFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyversion_nofulltext
     */
    select?: inducks_storyversion_nofulltextSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storyversion_nofulltext to fetch.
     */
    where?: inducks_storyversion_nofulltextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_storyversion_nofulltexts to fetch.
     */
    orderBy?: inducks_storyversion_nofulltextOrderByWithRelationInput | inducks_storyversion_nofulltextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_storyversion_nofulltexts.
     */
    cursor?: inducks_storyversion_nofulltextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_storyversion_nofulltexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_storyversion_nofulltexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_storyversion_nofulltexts.
     */
    distinct?: Inducks_storyversion_nofulltextScalarFieldEnum | Inducks_storyversion_nofulltextScalarFieldEnum[]
  }


  /**
   * inducks_storyversion_nofulltext findFirstOrThrow
   */
  export type inducks_storyversion_nofulltextFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyversion_nofulltext
     */
    select?: inducks_storyversion_nofulltextSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storyversion_nofulltext to fetch.
     */
    where?: inducks_storyversion_nofulltextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_storyversion_nofulltexts to fetch.
     */
    orderBy?: inducks_storyversion_nofulltextOrderByWithRelationInput | inducks_storyversion_nofulltextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_storyversion_nofulltexts.
     */
    cursor?: inducks_storyversion_nofulltextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_storyversion_nofulltexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_storyversion_nofulltexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_storyversion_nofulltexts.
     */
    distinct?: Inducks_storyversion_nofulltextScalarFieldEnum | Inducks_storyversion_nofulltextScalarFieldEnum[]
  }


  /**
   * inducks_storyversion_nofulltext findMany
   */
  export type inducks_storyversion_nofulltextFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyversion_nofulltext
     */
    select?: inducks_storyversion_nofulltextSelect<ExtArgs> | null
    /**
     * Filter, which inducks_storyversion_nofulltexts to fetch.
     */
    where?: inducks_storyversion_nofulltextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_storyversion_nofulltexts to fetch.
     */
    orderBy?: inducks_storyversion_nofulltextOrderByWithRelationInput | inducks_storyversion_nofulltextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_storyversion_nofulltexts.
     */
    cursor?: inducks_storyversion_nofulltextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_storyversion_nofulltexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_storyversion_nofulltexts.
     */
    skip?: number
    distinct?: Inducks_storyversion_nofulltextScalarFieldEnum | Inducks_storyversion_nofulltextScalarFieldEnum[]
  }


  /**
   * inducks_storyversion_nofulltext create
   */
  export type inducks_storyversion_nofulltextCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyversion_nofulltext
     */
    select?: inducks_storyversion_nofulltextSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_storyversion_nofulltext.
     */
    data: XOR<inducks_storyversion_nofulltextCreateInput, inducks_storyversion_nofulltextUncheckedCreateInput>
  }


  /**
   * inducks_storyversion_nofulltext createMany
   */
  export type inducks_storyversion_nofulltextCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_storyversion_nofulltexts.
     */
    data: inducks_storyversion_nofulltextCreateManyInput | inducks_storyversion_nofulltextCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_storyversion_nofulltext update
   */
  export type inducks_storyversion_nofulltextUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyversion_nofulltext
     */
    select?: inducks_storyversion_nofulltextSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_storyversion_nofulltext.
     */
    data: XOR<inducks_storyversion_nofulltextUpdateInput, inducks_storyversion_nofulltextUncheckedUpdateInput>
    /**
     * Choose, which inducks_storyversion_nofulltext to update.
     */
    where: inducks_storyversion_nofulltextWhereUniqueInput
  }


  /**
   * inducks_storyversion_nofulltext updateMany
   */
  export type inducks_storyversion_nofulltextUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_storyversion_nofulltexts.
     */
    data: XOR<inducks_storyversion_nofulltextUpdateManyMutationInput, inducks_storyversion_nofulltextUncheckedUpdateManyInput>
    /**
     * Filter which inducks_storyversion_nofulltexts to update
     */
    where?: inducks_storyversion_nofulltextWhereInput
  }


  /**
   * inducks_storyversion_nofulltext upsert
   */
  export type inducks_storyversion_nofulltextUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyversion_nofulltext
     */
    select?: inducks_storyversion_nofulltextSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_storyversion_nofulltext to update in case it exists.
     */
    where: inducks_storyversion_nofulltextWhereUniqueInput
    /**
     * In case the inducks_storyversion_nofulltext found by the `where` argument doesn't exist, create a new inducks_storyversion_nofulltext with this data.
     */
    create: XOR<inducks_storyversion_nofulltextCreateInput, inducks_storyversion_nofulltextUncheckedCreateInput>
    /**
     * In case the inducks_storyversion_nofulltext was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_storyversion_nofulltextUpdateInput, inducks_storyversion_nofulltextUncheckedUpdateInput>
  }


  /**
   * inducks_storyversion_nofulltext delete
   */
  export type inducks_storyversion_nofulltextDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyversion_nofulltext
     */
    select?: inducks_storyversion_nofulltextSelect<ExtArgs> | null
    /**
     * Filter which inducks_storyversion_nofulltext to delete.
     */
    where: inducks_storyversion_nofulltextWhereUniqueInput
  }


  /**
   * inducks_storyversion_nofulltext deleteMany
   */
  export type inducks_storyversion_nofulltextDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_storyversion_nofulltexts to delete
     */
    where?: inducks_storyversion_nofulltextWhereInput
  }


  /**
   * inducks_storyversion_nofulltext without action
   */
  export type inducks_storyversion_nofulltextDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_storyversion_nofulltext
     */
    select?: inducks_storyversion_nofulltextSelect<ExtArgs> | null
  }



  /**
   * Model inducks_studio
   */

  export type AggregateInducks_studio = {
    _count: Inducks_studioCountAggregateOutputType | null
    _min: Inducks_studioMinAggregateOutputType | null
    _max: Inducks_studioMaxAggregateOutputType | null
  }

  export type Inducks_studioMinAggregateOutputType = {
    studiocode: string | null
    countrycode: string | null
    studioname: string | null
    city: string | null
    description: string | null
    othertext: string | null
    photofilename: string | null
    photocomment: string | null
    photosource: string | null
    studiorefs: string | null
  }

  export type Inducks_studioMaxAggregateOutputType = {
    studiocode: string | null
    countrycode: string | null
    studioname: string | null
    city: string | null
    description: string | null
    othertext: string | null
    photofilename: string | null
    photocomment: string | null
    photosource: string | null
    studiorefs: string | null
  }

  export type Inducks_studioCountAggregateOutputType = {
    studiocode: number
    countrycode: number
    studioname: number
    city: number
    description: number
    othertext: number
    photofilename: number
    photocomment: number
    photosource: number
    studiorefs: number
    _all: number
  }


  export type Inducks_studioMinAggregateInputType = {
    studiocode?: true
    countrycode?: true
    studioname?: true
    city?: true
    description?: true
    othertext?: true
    photofilename?: true
    photocomment?: true
    photosource?: true
    studiorefs?: true
  }

  export type Inducks_studioMaxAggregateInputType = {
    studiocode?: true
    countrycode?: true
    studioname?: true
    city?: true
    description?: true
    othertext?: true
    photofilename?: true
    photocomment?: true
    photosource?: true
    studiorefs?: true
  }

  export type Inducks_studioCountAggregateInputType = {
    studiocode?: true
    countrycode?: true
    studioname?: true
    city?: true
    description?: true
    othertext?: true
    photofilename?: true
    photocomment?: true
    photosource?: true
    studiorefs?: true
    _all?: true
  }

  export type Inducks_studioAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_studio to aggregate.
     */
    where?: inducks_studioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_studios to fetch.
     */
    orderBy?: inducks_studioOrderByWithRelationInput | inducks_studioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_studioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_studios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_studios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_studios
    **/
    _count?: true | Inducks_studioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_studioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_studioMaxAggregateInputType
  }

  export type GetInducks_studioAggregateType<T extends Inducks_studioAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_studio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_studio[P]>
      : GetScalarType<T[P], AggregateInducks_studio[P]>
  }




  export type inducks_studioGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_studioWhereInput
    orderBy?: inducks_studioOrderByWithAggregationInput | inducks_studioOrderByWithAggregationInput[]
    by: Inducks_studioScalarFieldEnum[] | Inducks_studioScalarFieldEnum
    having?: inducks_studioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_studioCountAggregateInputType | true
    _min?: Inducks_studioMinAggregateInputType
    _max?: Inducks_studioMaxAggregateInputType
  }

  export type Inducks_studioGroupByOutputType = {
    studiocode: string
    countrycode: string | null
    studioname: string | null
    city: string | null
    description: string | null
    othertext: string | null
    photofilename: string | null
    photocomment: string | null
    photosource: string | null
    studiorefs: string | null
    _count: Inducks_studioCountAggregateOutputType | null
    _min: Inducks_studioMinAggregateOutputType | null
    _max: Inducks_studioMaxAggregateOutputType | null
  }

  type GetInducks_studioGroupByPayload<T extends inducks_studioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_studioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_studioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_studioGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_studioGroupByOutputType[P]>
        }
      >
    >


  export type inducks_studioSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    studiocode?: boolean
    countrycode?: boolean
    studioname?: boolean
    city?: boolean
    description?: boolean
    othertext?: boolean
    photofilename?: boolean
    photocomment?: boolean
    photosource?: boolean
    studiorefs?: boolean
  }, ExtArgs["result"]["inducks_studio"]>

  export type inducks_studioSelectScalar = {
    studiocode?: boolean
    countrycode?: boolean
    studioname?: boolean
    city?: boolean
    description?: boolean
    othertext?: boolean
    photofilename?: boolean
    photocomment?: boolean
    photosource?: boolean
    studiorefs?: boolean
  }


  export type $inducks_studioPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_studio"
    objects: {}
    scalars: $Extensions.GetResult<{
      studiocode: string
      countrycode: string | null
      studioname: string | null
      city: string | null
      description: string | null
      othertext: string | null
      photofilename: string | null
      photocomment: string | null
      photosource: string | null
      studiorefs: string | null
    }, ExtArgs["result"]["inducks_studio"]>
    composites: {}
  }


  type inducks_studioGetPayload<S extends boolean | null | undefined | inducks_studioDefaultArgs> = $Result.GetResult<Prisma.$inducks_studioPayload, S>

  type inducks_studioCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_studioFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_studioCountAggregateInputType | true
    }

  export interface inducks_studioDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_studio'], meta: { name: 'inducks_studio' } }
    /**
     * Find zero or one Inducks_studio that matches the filter.
     * @param {inducks_studioFindUniqueArgs} args - Arguments to find a Inducks_studio
     * @example
     * // Get one Inducks_studio
     * const inducks_studio = await prisma.inducks_studio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_studioFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_studioFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_studioClient<$Result.GetResult<Prisma.$inducks_studioPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_studio that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_studioFindUniqueOrThrowArgs} args - Arguments to find a Inducks_studio
     * @example
     * // Get one Inducks_studio
     * const inducks_studio = await prisma.inducks_studio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_studioFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_studioFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_studioClient<$Result.GetResult<Prisma.$inducks_studioPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_studio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_studioFindFirstArgs} args - Arguments to find a Inducks_studio
     * @example
     * // Get one Inducks_studio
     * const inducks_studio = await prisma.inducks_studio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_studioFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_studioFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_studioClient<$Result.GetResult<Prisma.$inducks_studioPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_studio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_studioFindFirstOrThrowArgs} args - Arguments to find a Inducks_studio
     * @example
     * // Get one Inducks_studio
     * const inducks_studio = await prisma.inducks_studio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_studioFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_studioFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_studioClient<$Result.GetResult<Prisma.$inducks_studioPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_studios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_studioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_studios
     * const inducks_studios = await prisma.inducks_studio.findMany()
     * 
     * // Get first 10 Inducks_studios
     * const inducks_studios = await prisma.inducks_studio.findMany({ take: 10 })
     * 
     * // Only select the `studiocode`
     * const inducks_studioWithStudiocodeOnly = await prisma.inducks_studio.findMany({ select: { studiocode: true } })
     * 
    **/
    findMany<T extends inducks_studioFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_studioFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_studioPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_studio.
     * @param {inducks_studioCreateArgs} args - Arguments to create a Inducks_studio.
     * @example
     * // Create one Inducks_studio
     * const Inducks_studio = await prisma.inducks_studio.create({
     *   data: {
     *     // ... data to create a Inducks_studio
     *   }
     * })
     * 
    **/
    create<T extends inducks_studioCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_studioCreateArgs<ExtArgs>>
    ): Prisma__inducks_studioClient<$Result.GetResult<Prisma.$inducks_studioPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_studios.
     *     @param {inducks_studioCreateManyArgs} args - Arguments to create many Inducks_studios.
     *     @example
     *     // Create many Inducks_studios
     *     const inducks_studio = await prisma.inducks_studio.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_studioCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_studioCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_studio.
     * @param {inducks_studioDeleteArgs} args - Arguments to delete one Inducks_studio.
     * @example
     * // Delete one Inducks_studio
     * const Inducks_studio = await prisma.inducks_studio.delete({
     *   where: {
     *     // ... filter to delete one Inducks_studio
     *   }
     * })
     * 
    **/
    delete<T extends inducks_studioDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_studioDeleteArgs<ExtArgs>>
    ): Prisma__inducks_studioClient<$Result.GetResult<Prisma.$inducks_studioPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_studio.
     * @param {inducks_studioUpdateArgs} args - Arguments to update one Inducks_studio.
     * @example
     * // Update one Inducks_studio
     * const inducks_studio = await prisma.inducks_studio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_studioUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_studioUpdateArgs<ExtArgs>>
    ): Prisma__inducks_studioClient<$Result.GetResult<Prisma.$inducks_studioPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_studios.
     * @param {inducks_studioDeleteManyArgs} args - Arguments to filter Inducks_studios to delete.
     * @example
     * // Delete a few Inducks_studios
     * const { count } = await prisma.inducks_studio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_studioDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_studioDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_studios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_studioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_studios
     * const inducks_studio = await prisma.inducks_studio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_studioUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_studioUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_studio.
     * @param {inducks_studioUpsertArgs} args - Arguments to update or create a Inducks_studio.
     * @example
     * // Update or create a Inducks_studio
     * const inducks_studio = await prisma.inducks_studio.upsert({
     *   create: {
     *     // ... data to create a Inducks_studio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_studio we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_studioUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_studioUpsertArgs<ExtArgs>>
    ): Prisma__inducks_studioClient<$Result.GetResult<Prisma.$inducks_studioPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_studios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_studioCountArgs} args - Arguments to filter Inducks_studios to count.
     * @example
     * // Count the number of Inducks_studios
     * const count = await prisma.inducks_studio.count({
     *   where: {
     *     // ... the filter for the Inducks_studios we want to count
     *   }
     * })
    **/
    count<T extends inducks_studioCountArgs>(
      args?: Subset<T, inducks_studioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_studioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_studio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_studioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_studioAggregateArgs>(args: Subset<T, Inducks_studioAggregateArgs>): Prisma.PrismaPromise<GetInducks_studioAggregateType<T>>

    /**
     * Group by Inducks_studio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_studioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_studioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_studioGroupByArgs['orderBy'] }
        : { orderBy?: inducks_studioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_studioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_studioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_studio model
   */
  readonly fields: inducks_studioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_studio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_studioClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_studio model
   */ 
  interface inducks_studioFieldRefs {
    readonly studiocode: FieldRef<"inducks_studio", 'String'>
    readonly countrycode: FieldRef<"inducks_studio", 'String'>
    readonly studioname: FieldRef<"inducks_studio", 'String'>
    readonly city: FieldRef<"inducks_studio", 'String'>
    readonly description: FieldRef<"inducks_studio", 'String'>
    readonly othertext: FieldRef<"inducks_studio", 'String'>
    readonly photofilename: FieldRef<"inducks_studio", 'String'>
    readonly photocomment: FieldRef<"inducks_studio", 'String'>
    readonly photosource: FieldRef<"inducks_studio", 'String'>
    readonly studiorefs: FieldRef<"inducks_studio", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_studio findUnique
   */
  export type inducks_studioFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_studio
     */
    select?: inducks_studioSelect<ExtArgs> | null
    /**
     * Filter, which inducks_studio to fetch.
     */
    where: inducks_studioWhereUniqueInput
  }


  /**
   * inducks_studio findUniqueOrThrow
   */
  export type inducks_studioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_studio
     */
    select?: inducks_studioSelect<ExtArgs> | null
    /**
     * Filter, which inducks_studio to fetch.
     */
    where: inducks_studioWhereUniqueInput
  }


  /**
   * inducks_studio findFirst
   */
  export type inducks_studioFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_studio
     */
    select?: inducks_studioSelect<ExtArgs> | null
    /**
     * Filter, which inducks_studio to fetch.
     */
    where?: inducks_studioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_studios to fetch.
     */
    orderBy?: inducks_studioOrderByWithRelationInput | inducks_studioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_studios.
     */
    cursor?: inducks_studioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_studios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_studios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_studios.
     */
    distinct?: Inducks_studioScalarFieldEnum | Inducks_studioScalarFieldEnum[]
  }


  /**
   * inducks_studio findFirstOrThrow
   */
  export type inducks_studioFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_studio
     */
    select?: inducks_studioSelect<ExtArgs> | null
    /**
     * Filter, which inducks_studio to fetch.
     */
    where?: inducks_studioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_studios to fetch.
     */
    orderBy?: inducks_studioOrderByWithRelationInput | inducks_studioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_studios.
     */
    cursor?: inducks_studioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_studios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_studios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_studios.
     */
    distinct?: Inducks_studioScalarFieldEnum | Inducks_studioScalarFieldEnum[]
  }


  /**
   * inducks_studio findMany
   */
  export type inducks_studioFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_studio
     */
    select?: inducks_studioSelect<ExtArgs> | null
    /**
     * Filter, which inducks_studios to fetch.
     */
    where?: inducks_studioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_studios to fetch.
     */
    orderBy?: inducks_studioOrderByWithRelationInput | inducks_studioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_studios.
     */
    cursor?: inducks_studioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_studios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_studios.
     */
    skip?: number
    distinct?: Inducks_studioScalarFieldEnum | Inducks_studioScalarFieldEnum[]
  }


  /**
   * inducks_studio create
   */
  export type inducks_studioCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_studio
     */
    select?: inducks_studioSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_studio.
     */
    data: XOR<inducks_studioCreateInput, inducks_studioUncheckedCreateInput>
  }


  /**
   * inducks_studio createMany
   */
  export type inducks_studioCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_studios.
     */
    data: inducks_studioCreateManyInput | inducks_studioCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_studio update
   */
  export type inducks_studioUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_studio
     */
    select?: inducks_studioSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_studio.
     */
    data: XOR<inducks_studioUpdateInput, inducks_studioUncheckedUpdateInput>
    /**
     * Choose, which inducks_studio to update.
     */
    where: inducks_studioWhereUniqueInput
  }


  /**
   * inducks_studio updateMany
   */
  export type inducks_studioUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_studios.
     */
    data: XOR<inducks_studioUpdateManyMutationInput, inducks_studioUncheckedUpdateManyInput>
    /**
     * Filter which inducks_studios to update
     */
    where?: inducks_studioWhereInput
  }


  /**
   * inducks_studio upsert
   */
  export type inducks_studioUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_studio
     */
    select?: inducks_studioSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_studio to update in case it exists.
     */
    where: inducks_studioWhereUniqueInput
    /**
     * In case the inducks_studio found by the `where` argument doesn't exist, create a new inducks_studio with this data.
     */
    create: XOR<inducks_studioCreateInput, inducks_studioUncheckedCreateInput>
    /**
     * In case the inducks_studio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_studioUpdateInput, inducks_studioUncheckedUpdateInput>
  }


  /**
   * inducks_studio delete
   */
  export type inducks_studioDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_studio
     */
    select?: inducks_studioSelect<ExtArgs> | null
    /**
     * Filter which inducks_studio to delete.
     */
    where: inducks_studioWhereUniqueInput
  }


  /**
   * inducks_studio deleteMany
   */
  export type inducks_studioDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_studios to delete
     */
    where?: inducks_studioWhereInput
  }


  /**
   * inducks_studio without action
   */
  export type inducks_studioDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_studio
     */
    select?: inducks_studioSelect<ExtArgs> | null
  }



  /**
   * Model inducks_studiowork
   */

  export type AggregateInducks_studiowork = {
    _count: Inducks_studioworkCountAggregateOutputType | null
    _min: Inducks_studioworkMinAggregateOutputType | null
    _max: Inducks_studioworkMaxAggregateOutputType | null
  }

  export type Inducks_studioworkMinAggregateOutputType = {
    studiocode: string | null
    personcode: string | null
  }

  export type Inducks_studioworkMaxAggregateOutputType = {
    studiocode: string | null
    personcode: string | null
  }

  export type Inducks_studioworkCountAggregateOutputType = {
    studiocode: number
    personcode: number
    _all: number
  }


  export type Inducks_studioworkMinAggregateInputType = {
    studiocode?: true
    personcode?: true
  }

  export type Inducks_studioworkMaxAggregateInputType = {
    studiocode?: true
    personcode?: true
  }

  export type Inducks_studioworkCountAggregateInputType = {
    studiocode?: true
    personcode?: true
    _all?: true
  }

  export type Inducks_studioworkAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_studiowork to aggregate.
     */
    where?: inducks_studioworkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_studioworks to fetch.
     */
    orderBy?: inducks_studioworkOrderByWithRelationInput | inducks_studioworkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_studioworkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_studioworks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_studioworks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_studioworks
    **/
    _count?: true | Inducks_studioworkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_studioworkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_studioworkMaxAggregateInputType
  }

  export type GetInducks_studioworkAggregateType<T extends Inducks_studioworkAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_studiowork]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_studiowork[P]>
      : GetScalarType<T[P], AggregateInducks_studiowork[P]>
  }




  export type inducks_studioworkGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_studioworkWhereInput
    orderBy?: inducks_studioworkOrderByWithAggregationInput | inducks_studioworkOrderByWithAggregationInput[]
    by: Inducks_studioworkScalarFieldEnum[] | Inducks_studioworkScalarFieldEnum
    having?: inducks_studioworkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_studioworkCountAggregateInputType | true
    _min?: Inducks_studioworkMinAggregateInputType
    _max?: Inducks_studioworkMaxAggregateInputType
  }

  export type Inducks_studioworkGroupByOutputType = {
    studiocode: string
    personcode: string
    _count: Inducks_studioworkCountAggregateOutputType | null
    _min: Inducks_studioworkMinAggregateOutputType | null
    _max: Inducks_studioworkMaxAggregateOutputType | null
  }

  type GetInducks_studioworkGroupByPayload<T extends inducks_studioworkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_studioworkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_studioworkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_studioworkGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_studioworkGroupByOutputType[P]>
        }
      >
    >


  export type inducks_studioworkSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    studiocode?: boolean
    personcode?: boolean
  }, ExtArgs["result"]["inducks_studiowork"]>

  export type inducks_studioworkSelectScalar = {
    studiocode?: boolean
    personcode?: boolean
  }


  export type $inducks_studioworkPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_studiowork"
    objects: {}
    scalars: $Extensions.GetResult<{
      studiocode: string
      personcode: string
    }, ExtArgs["result"]["inducks_studiowork"]>
    composites: {}
  }


  type inducks_studioworkGetPayload<S extends boolean | null | undefined | inducks_studioworkDefaultArgs> = $Result.GetResult<Prisma.$inducks_studioworkPayload, S>

  type inducks_studioworkCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_studioworkFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_studioworkCountAggregateInputType | true
    }

  export interface inducks_studioworkDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_studiowork'], meta: { name: 'inducks_studiowork' } }
    /**
     * Find zero or one Inducks_studiowork that matches the filter.
     * @param {inducks_studioworkFindUniqueArgs} args - Arguments to find a Inducks_studiowork
     * @example
     * // Get one Inducks_studiowork
     * const inducks_studiowork = await prisma.inducks_studiowork.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_studioworkFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_studioworkFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_studioworkClient<$Result.GetResult<Prisma.$inducks_studioworkPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_studiowork that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_studioworkFindUniqueOrThrowArgs} args - Arguments to find a Inducks_studiowork
     * @example
     * // Get one Inducks_studiowork
     * const inducks_studiowork = await prisma.inducks_studiowork.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_studioworkFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_studioworkFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_studioworkClient<$Result.GetResult<Prisma.$inducks_studioworkPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_studiowork that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_studioworkFindFirstArgs} args - Arguments to find a Inducks_studiowork
     * @example
     * // Get one Inducks_studiowork
     * const inducks_studiowork = await prisma.inducks_studiowork.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_studioworkFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_studioworkFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_studioworkClient<$Result.GetResult<Prisma.$inducks_studioworkPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_studiowork that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_studioworkFindFirstOrThrowArgs} args - Arguments to find a Inducks_studiowork
     * @example
     * // Get one Inducks_studiowork
     * const inducks_studiowork = await prisma.inducks_studiowork.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_studioworkFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_studioworkFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_studioworkClient<$Result.GetResult<Prisma.$inducks_studioworkPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_studioworks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_studioworkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_studioworks
     * const inducks_studioworks = await prisma.inducks_studiowork.findMany()
     * 
     * // Get first 10 Inducks_studioworks
     * const inducks_studioworks = await prisma.inducks_studiowork.findMany({ take: 10 })
     * 
     * // Only select the `studiocode`
     * const inducks_studioworkWithStudiocodeOnly = await prisma.inducks_studiowork.findMany({ select: { studiocode: true } })
     * 
    **/
    findMany<T extends inducks_studioworkFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_studioworkFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_studioworkPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_studiowork.
     * @param {inducks_studioworkCreateArgs} args - Arguments to create a Inducks_studiowork.
     * @example
     * // Create one Inducks_studiowork
     * const Inducks_studiowork = await prisma.inducks_studiowork.create({
     *   data: {
     *     // ... data to create a Inducks_studiowork
     *   }
     * })
     * 
    **/
    create<T extends inducks_studioworkCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_studioworkCreateArgs<ExtArgs>>
    ): Prisma__inducks_studioworkClient<$Result.GetResult<Prisma.$inducks_studioworkPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_studioworks.
     *     @param {inducks_studioworkCreateManyArgs} args - Arguments to create many Inducks_studioworks.
     *     @example
     *     // Create many Inducks_studioworks
     *     const inducks_studiowork = await prisma.inducks_studiowork.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_studioworkCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_studioworkCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_studiowork.
     * @param {inducks_studioworkDeleteArgs} args - Arguments to delete one Inducks_studiowork.
     * @example
     * // Delete one Inducks_studiowork
     * const Inducks_studiowork = await prisma.inducks_studiowork.delete({
     *   where: {
     *     // ... filter to delete one Inducks_studiowork
     *   }
     * })
     * 
    **/
    delete<T extends inducks_studioworkDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_studioworkDeleteArgs<ExtArgs>>
    ): Prisma__inducks_studioworkClient<$Result.GetResult<Prisma.$inducks_studioworkPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_studiowork.
     * @param {inducks_studioworkUpdateArgs} args - Arguments to update one Inducks_studiowork.
     * @example
     * // Update one Inducks_studiowork
     * const inducks_studiowork = await prisma.inducks_studiowork.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_studioworkUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_studioworkUpdateArgs<ExtArgs>>
    ): Prisma__inducks_studioworkClient<$Result.GetResult<Prisma.$inducks_studioworkPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_studioworks.
     * @param {inducks_studioworkDeleteManyArgs} args - Arguments to filter Inducks_studioworks to delete.
     * @example
     * // Delete a few Inducks_studioworks
     * const { count } = await prisma.inducks_studiowork.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_studioworkDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_studioworkDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_studioworks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_studioworkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_studioworks
     * const inducks_studiowork = await prisma.inducks_studiowork.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_studioworkUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_studioworkUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_studiowork.
     * @param {inducks_studioworkUpsertArgs} args - Arguments to update or create a Inducks_studiowork.
     * @example
     * // Update or create a Inducks_studiowork
     * const inducks_studiowork = await prisma.inducks_studiowork.upsert({
     *   create: {
     *     // ... data to create a Inducks_studiowork
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_studiowork we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_studioworkUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_studioworkUpsertArgs<ExtArgs>>
    ): Prisma__inducks_studioworkClient<$Result.GetResult<Prisma.$inducks_studioworkPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_studioworks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_studioworkCountArgs} args - Arguments to filter Inducks_studioworks to count.
     * @example
     * // Count the number of Inducks_studioworks
     * const count = await prisma.inducks_studiowork.count({
     *   where: {
     *     // ... the filter for the Inducks_studioworks we want to count
     *   }
     * })
    **/
    count<T extends inducks_studioworkCountArgs>(
      args?: Subset<T, inducks_studioworkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_studioworkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_studiowork.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_studioworkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_studioworkAggregateArgs>(args: Subset<T, Inducks_studioworkAggregateArgs>): Prisma.PrismaPromise<GetInducks_studioworkAggregateType<T>>

    /**
     * Group by Inducks_studiowork.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_studioworkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_studioworkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_studioworkGroupByArgs['orderBy'] }
        : { orderBy?: inducks_studioworkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_studioworkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_studioworkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_studiowork model
   */
  readonly fields: inducks_studioworkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_studiowork.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_studioworkClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_studiowork model
   */ 
  interface inducks_studioworkFieldRefs {
    readonly studiocode: FieldRef<"inducks_studiowork", 'String'>
    readonly personcode: FieldRef<"inducks_studiowork", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_studiowork findUnique
   */
  export type inducks_studioworkFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_studiowork
     */
    select?: inducks_studioworkSelect<ExtArgs> | null
    /**
     * Filter, which inducks_studiowork to fetch.
     */
    where: inducks_studioworkWhereUniqueInput
  }


  /**
   * inducks_studiowork findUniqueOrThrow
   */
  export type inducks_studioworkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_studiowork
     */
    select?: inducks_studioworkSelect<ExtArgs> | null
    /**
     * Filter, which inducks_studiowork to fetch.
     */
    where: inducks_studioworkWhereUniqueInput
  }


  /**
   * inducks_studiowork findFirst
   */
  export type inducks_studioworkFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_studiowork
     */
    select?: inducks_studioworkSelect<ExtArgs> | null
    /**
     * Filter, which inducks_studiowork to fetch.
     */
    where?: inducks_studioworkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_studioworks to fetch.
     */
    orderBy?: inducks_studioworkOrderByWithRelationInput | inducks_studioworkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_studioworks.
     */
    cursor?: inducks_studioworkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_studioworks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_studioworks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_studioworks.
     */
    distinct?: Inducks_studioworkScalarFieldEnum | Inducks_studioworkScalarFieldEnum[]
  }


  /**
   * inducks_studiowork findFirstOrThrow
   */
  export type inducks_studioworkFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_studiowork
     */
    select?: inducks_studioworkSelect<ExtArgs> | null
    /**
     * Filter, which inducks_studiowork to fetch.
     */
    where?: inducks_studioworkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_studioworks to fetch.
     */
    orderBy?: inducks_studioworkOrderByWithRelationInput | inducks_studioworkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_studioworks.
     */
    cursor?: inducks_studioworkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_studioworks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_studioworks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_studioworks.
     */
    distinct?: Inducks_studioworkScalarFieldEnum | Inducks_studioworkScalarFieldEnum[]
  }


  /**
   * inducks_studiowork findMany
   */
  export type inducks_studioworkFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_studiowork
     */
    select?: inducks_studioworkSelect<ExtArgs> | null
    /**
     * Filter, which inducks_studioworks to fetch.
     */
    where?: inducks_studioworkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_studioworks to fetch.
     */
    orderBy?: inducks_studioworkOrderByWithRelationInput | inducks_studioworkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_studioworks.
     */
    cursor?: inducks_studioworkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_studioworks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_studioworks.
     */
    skip?: number
    distinct?: Inducks_studioworkScalarFieldEnum | Inducks_studioworkScalarFieldEnum[]
  }


  /**
   * inducks_studiowork create
   */
  export type inducks_studioworkCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_studiowork
     */
    select?: inducks_studioworkSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_studiowork.
     */
    data: XOR<inducks_studioworkCreateInput, inducks_studioworkUncheckedCreateInput>
  }


  /**
   * inducks_studiowork createMany
   */
  export type inducks_studioworkCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_studioworks.
     */
    data: inducks_studioworkCreateManyInput | inducks_studioworkCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_studiowork update
   */
  export type inducks_studioworkUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_studiowork
     */
    select?: inducks_studioworkSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_studiowork.
     */
    data: XOR<inducks_studioworkUpdateInput, inducks_studioworkUncheckedUpdateInput>
    /**
     * Choose, which inducks_studiowork to update.
     */
    where: inducks_studioworkWhereUniqueInput
  }


  /**
   * inducks_studiowork updateMany
   */
  export type inducks_studioworkUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_studioworks.
     */
    data: XOR<inducks_studioworkUpdateManyMutationInput, inducks_studioworkUncheckedUpdateManyInput>
    /**
     * Filter which inducks_studioworks to update
     */
    where?: inducks_studioworkWhereInput
  }


  /**
   * inducks_studiowork upsert
   */
  export type inducks_studioworkUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_studiowork
     */
    select?: inducks_studioworkSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_studiowork to update in case it exists.
     */
    where: inducks_studioworkWhereUniqueInput
    /**
     * In case the inducks_studiowork found by the `where` argument doesn't exist, create a new inducks_studiowork with this data.
     */
    create: XOR<inducks_studioworkCreateInput, inducks_studioworkUncheckedCreateInput>
    /**
     * In case the inducks_studiowork was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_studioworkUpdateInput, inducks_studioworkUncheckedUpdateInput>
  }


  /**
   * inducks_studiowork delete
   */
  export type inducks_studioworkDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_studiowork
     */
    select?: inducks_studioworkSelect<ExtArgs> | null
    /**
     * Filter which inducks_studiowork to delete.
     */
    where: inducks_studioworkWhereUniqueInput
  }


  /**
   * inducks_studiowork deleteMany
   */
  export type inducks_studioworkDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_studioworks to delete
     */
    where?: inducks_studioworkWhereInput
  }


  /**
   * inducks_studiowork without action
   */
  export type inducks_studioworkDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_studiowork
     */
    select?: inducks_studioworkSelect<ExtArgs> | null
  }



  /**
   * Model inducks_subseries
   */

  export type AggregateInducks_subseries = {
    _count: Inducks_subseriesCountAggregateOutputType | null
    _min: Inducks_subseriesMinAggregateOutputType | null
    _max: Inducks_subseriesMaxAggregateOutputType | null
  }

  export type Inducks_subseriesMinAggregateOutputType = {
    subseriescode: string | null
    subseriesname: string | null
    official: $Enums.inducks_subseries_official | null
    subseriescomment: string | null
    subseriescategory: string | null
  }

  export type Inducks_subseriesMaxAggregateOutputType = {
    subseriescode: string | null
    subseriesname: string | null
    official: $Enums.inducks_subseries_official | null
    subseriescomment: string | null
    subseriescategory: string | null
  }

  export type Inducks_subseriesCountAggregateOutputType = {
    subseriescode: number
    subseriesname: number
    official: number
    subseriescomment: number
    subseriescategory: number
    _all: number
  }


  export type Inducks_subseriesMinAggregateInputType = {
    subseriescode?: true
    subseriesname?: true
    official?: true
    subseriescomment?: true
    subseriescategory?: true
  }

  export type Inducks_subseriesMaxAggregateInputType = {
    subseriescode?: true
    subseriesname?: true
    official?: true
    subseriescomment?: true
    subseriescategory?: true
  }

  export type Inducks_subseriesCountAggregateInputType = {
    subseriescode?: true
    subseriesname?: true
    official?: true
    subseriescomment?: true
    subseriescategory?: true
    _all?: true
  }

  export type Inducks_subseriesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_subseries to aggregate.
     */
    where?: inducks_subseriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_subseries to fetch.
     */
    orderBy?: inducks_subseriesOrderByWithRelationInput | inducks_subseriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_subseriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_subseries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_subseries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_subseries
    **/
    _count?: true | Inducks_subseriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_subseriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_subseriesMaxAggregateInputType
  }

  export type GetInducks_subseriesAggregateType<T extends Inducks_subseriesAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_subseries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_subseries[P]>
      : GetScalarType<T[P], AggregateInducks_subseries[P]>
  }




  export type inducks_subseriesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_subseriesWhereInput
    orderBy?: inducks_subseriesOrderByWithAggregationInput | inducks_subseriesOrderByWithAggregationInput[]
    by: Inducks_subseriesScalarFieldEnum[] | Inducks_subseriesScalarFieldEnum
    having?: inducks_subseriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_subseriesCountAggregateInputType | true
    _min?: Inducks_subseriesMinAggregateInputType
    _max?: Inducks_subseriesMaxAggregateInputType
  }

  export type Inducks_subseriesGroupByOutputType = {
    subseriescode: string
    subseriesname: string | null
    official: $Enums.inducks_subseries_official | null
    subseriescomment: string | null
    subseriescategory: string | null
    _count: Inducks_subseriesCountAggregateOutputType | null
    _min: Inducks_subseriesMinAggregateOutputType | null
    _max: Inducks_subseriesMaxAggregateOutputType | null
  }

  type GetInducks_subseriesGroupByPayload<T extends inducks_subseriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_subseriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_subseriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_subseriesGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_subseriesGroupByOutputType[P]>
        }
      >
    >


  export type inducks_subseriesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subseriescode?: boolean
    subseriesname?: boolean
    official?: boolean
    subseriescomment?: boolean
    subseriescategory?: boolean
  }, ExtArgs["result"]["inducks_subseries"]>

  export type inducks_subseriesSelectScalar = {
    subseriescode?: boolean
    subseriesname?: boolean
    official?: boolean
    subseriescomment?: boolean
    subseriescategory?: boolean
  }


  export type $inducks_subseriesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_subseries"
    objects: {}
    scalars: $Extensions.GetResult<{
      subseriescode: string
      subseriesname: string | null
      official: $Enums.inducks_subseries_official | null
      subseriescomment: string | null
      subseriescategory: string | null
    }, ExtArgs["result"]["inducks_subseries"]>
    composites: {}
  }


  type inducks_subseriesGetPayload<S extends boolean | null | undefined | inducks_subseriesDefaultArgs> = $Result.GetResult<Prisma.$inducks_subseriesPayload, S>

  type inducks_subseriesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_subseriesFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_subseriesCountAggregateInputType | true
    }

  export interface inducks_subseriesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_subseries'], meta: { name: 'inducks_subseries' } }
    /**
     * Find zero or one Inducks_subseries that matches the filter.
     * @param {inducks_subseriesFindUniqueArgs} args - Arguments to find a Inducks_subseries
     * @example
     * // Get one Inducks_subseries
     * const inducks_subseries = await prisma.inducks_subseries.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_subseriesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_subseriesFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_subseriesClient<$Result.GetResult<Prisma.$inducks_subseriesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_subseries that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_subseriesFindUniqueOrThrowArgs} args - Arguments to find a Inducks_subseries
     * @example
     * // Get one Inducks_subseries
     * const inducks_subseries = await prisma.inducks_subseries.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_subseriesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_subseriesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_subseriesClient<$Result.GetResult<Prisma.$inducks_subseriesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_subseries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_subseriesFindFirstArgs} args - Arguments to find a Inducks_subseries
     * @example
     * // Get one Inducks_subseries
     * const inducks_subseries = await prisma.inducks_subseries.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_subseriesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_subseriesFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_subseriesClient<$Result.GetResult<Prisma.$inducks_subseriesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_subseries that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_subseriesFindFirstOrThrowArgs} args - Arguments to find a Inducks_subseries
     * @example
     * // Get one Inducks_subseries
     * const inducks_subseries = await prisma.inducks_subseries.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_subseriesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_subseriesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_subseriesClient<$Result.GetResult<Prisma.$inducks_subseriesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_subseries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_subseriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_subseries
     * const inducks_subseries = await prisma.inducks_subseries.findMany()
     * 
     * // Get first 10 Inducks_subseries
     * const inducks_subseries = await prisma.inducks_subseries.findMany({ take: 10 })
     * 
     * // Only select the `subseriescode`
     * const inducks_subseriesWithSubseriescodeOnly = await prisma.inducks_subseries.findMany({ select: { subseriescode: true } })
     * 
    **/
    findMany<T extends inducks_subseriesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_subseriesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_subseriesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_subseries.
     * @param {inducks_subseriesCreateArgs} args - Arguments to create a Inducks_subseries.
     * @example
     * // Create one Inducks_subseries
     * const Inducks_subseries = await prisma.inducks_subseries.create({
     *   data: {
     *     // ... data to create a Inducks_subseries
     *   }
     * })
     * 
    **/
    create<T extends inducks_subseriesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_subseriesCreateArgs<ExtArgs>>
    ): Prisma__inducks_subseriesClient<$Result.GetResult<Prisma.$inducks_subseriesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_subseries.
     *     @param {inducks_subseriesCreateManyArgs} args - Arguments to create many Inducks_subseries.
     *     @example
     *     // Create many Inducks_subseries
     *     const inducks_subseries = await prisma.inducks_subseries.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_subseriesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_subseriesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_subseries.
     * @param {inducks_subseriesDeleteArgs} args - Arguments to delete one Inducks_subseries.
     * @example
     * // Delete one Inducks_subseries
     * const Inducks_subseries = await prisma.inducks_subseries.delete({
     *   where: {
     *     // ... filter to delete one Inducks_subseries
     *   }
     * })
     * 
    **/
    delete<T extends inducks_subseriesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_subseriesDeleteArgs<ExtArgs>>
    ): Prisma__inducks_subseriesClient<$Result.GetResult<Prisma.$inducks_subseriesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_subseries.
     * @param {inducks_subseriesUpdateArgs} args - Arguments to update one Inducks_subseries.
     * @example
     * // Update one Inducks_subseries
     * const inducks_subseries = await prisma.inducks_subseries.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_subseriesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_subseriesUpdateArgs<ExtArgs>>
    ): Prisma__inducks_subseriesClient<$Result.GetResult<Prisma.$inducks_subseriesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_subseries.
     * @param {inducks_subseriesDeleteManyArgs} args - Arguments to filter Inducks_subseries to delete.
     * @example
     * // Delete a few Inducks_subseries
     * const { count } = await prisma.inducks_subseries.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_subseriesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_subseriesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_subseries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_subseriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_subseries
     * const inducks_subseries = await prisma.inducks_subseries.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_subseriesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_subseriesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_subseries.
     * @param {inducks_subseriesUpsertArgs} args - Arguments to update or create a Inducks_subseries.
     * @example
     * // Update or create a Inducks_subseries
     * const inducks_subseries = await prisma.inducks_subseries.upsert({
     *   create: {
     *     // ... data to create a Inducks_subseries
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_subseries we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_subseriesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_subseriesUpsertArgs<ExtArgs>>
    ): Prisma__inducks_subseriesClient<$Result.GetResult<Prisma.$inducks_subseriesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_subseries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_subseriesCountArgs} args - Arguments to filter Inducks_subseries to count.
     * @example
     * // Count the number of Inducks_subseries
     * const count = await prisma.inducks_subseries.count({
     *   where: {
     *     // ... the filter for the Inducks_subseries we want to count
     *   }
     * })
    **/
    count<T extends inducks_subseriesCountArgs>(
      args?: Subset<T, inducks_subseriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_subseriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_subseries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_subseriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_subseriesAggregateArgs>(args: Subset<T, Inducks_subseriesAggregateArgs>): Prisma.PrismaPromise<GetInducks_subseriesAggregateType<T>>

    /**
     * Group by Inducks_subseries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_subseriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_subseriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_subseriesGroupByArgs['orderBy'] }
        : { orderBy?: inducks_subseriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_subseriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_subseriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_subseries model
   */
  readonly fields: inducks_subseriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_subseries.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_subseriesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_subseries model
   */ 
  interface inducks_subseriesFieldRefs {
    readonly subseriescode: FieldRef<"inducks_subseries", 'String'>
    readonly subseriesname: FieldRef<"inducks_subseries", 'String'>
    readonly official: FieldRef<"inducks_subseries", 'inducks_subseries_official'>
    readonly subseriescomment: FieldRef<"inducks_subseries", 'String'>
    readonly subseriescategory: FieldRef<"inducks_subseries", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_subseries findUnique
   */
  export type inducks_subseriesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_subseries
     */
    select?: inducks_subseriesSelect<ExtArgs> | null
    /**
     * Filter, which inducks_subseries to fetch.
     */
    where: inducks_subseriesWhereUniqueInput
  }


  /**
   * inducks_subseries findUniqueOrThrow
   */
  export type inducks_subseriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_subseries
     */
    select?: inducks_subseriesSelect<ExtArgs> | null
    /**
     * Filter, which inducks_subseries to fetch.
     */
    where: inducks_subseriesWhereUniqueInput
  }


  /**
   * inducks_subseries findFirst
   */
  export type inducks_subseriesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_subseries
     */
    select?: inducks_subseriesSelect<ExtArgs> | null
    /**
     * Filter, which inducks_subseries to fetch.
     */
    where?: inducks_subseriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_subseries to fetch.
     */
    orderBy?: inducks_subseriesOrderByWithRelationInput | inducks_subseriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_subseries.
     */
    cursor?: inducks_subseriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_subseries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_subseries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_subseries.
     */
    distinct?: Inducks_subseriesScalarFieldEnum | Inducks_subseriesScalarFieldEnum[]
  }


  /**
   * inducks_subseries findFirstOrThrow
   */
  export type inducks_subseriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_subseries
     */
    select?: inducks_subseriesSelect<ExtArgs> | null
    /**
     * Filter, which inducks_subseries to fetch.
     */
    where?: inducks_subseriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_subseries to fetch.
     */
    orderBy?: inducks_subseriesOrderByWithRelationInput | inducks_subseriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_subseries.
     */
    cursor?: inducks_subseriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_subseries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_subseries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_subseries.
     */
    distinct?: Inducks_subseriesScalarFieldEnum | Inducks_subseriesScalarFieldEnum[]
  }


  /**
   * inducks_subseries findMany
   */
  export type inducks_subseriesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_subseries
     */
    select?: inducks_subseriesSelect<ExtArgs> | null
    /**
     * Filter, which inducks_subseries to fetch.
     */
    where?: inducks_subseriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_subseries to fetch.
     */
    orderBy?: inducks_subseriesOrderByWithRelationInput | inducks_subseriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_subseries.
     */
    cursor?: inducks_subseriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_subseries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_subseries.
     */
    skip?: number
    distinct?: Inducks_subseriesScalarFieldEnum | Inducks_subseriesScalarFieldEnum[]
  }


  /**
   * inducks_subseries create
   */
  export type inducks_subseriesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_subseries
     */
    select?: inducks_subseriesSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_subseries.
     */
    data: XOR<inducks_subseriesCreateInput, inducks_subseriesUncheckedCreateInput>
  }


  /**
   * inducks_subseries createMany
   */
  export type inducks_subseriesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_subseries.
     */
    data: inducks_subseriesCreateManyInput | inducks_subseriesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_subseries update
   */
  export type inducks_subseriesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_subseries
     */
    select?: inducks_subseriesSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_subseries.
     */
    data: XOR<inducks_subseriesUpdateInput, inducks_subseriesUncheckedUpdateInput>
    /**
     * Choose, which inducks_subseries to update.
     */
    where: inducks_subseriesWhereUniqueInput
  }


  /**
   * inducks_subseries updateMany
   */
  export type inducks_subseriesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_subseries.
     */
    data: XOR<inducks_subseriesUpdateManyMutationInput, inducks_subseriesUncheckedUpdateManyInput>
    /**
     * Filter which inducks_subseries to update
     */
    where?: inducks_subseriesWhereInput
  }


  /**
   * inducks_subseries upsert
   */
  export type inducks_subseriesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_subseries
     */
    select?: inducks_subseriesSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_subseries to update in case it exists.
     */
    where: inducks_subseriesWhereUniqueInput
    /**
     * In case the inducks_subseries found by the `where` argument doesn't exist, create a new inducks_subseries with this data.
     */
    create: XOR<inducks_subseriesCreateInput, inducks_subseriesUncheckedCreateInput>
    /**
     * In case the inducks_subseries was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_subseriesUpdateInput, inducks_subseriesUncheckedUpdateInput>
  }


  /**
   * inducks_subseries delete
   */
  export type inducks_subseriesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_subseries
     */
    select?: inducks_subseriesSelect<ExtArgs> | null
    /**
     * Filter which inducks_subseries to delete.
     */
    where: inducks_subseriesWhereUniqueInput
  }


  /**
   * inducks_subseries deleteMany
   */
  export type inducks_subseriesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_subseries to delete
     */
    where?: inducks_subseriesWhereInput
  }


  /**
   * inducks_subseries without action
   */
  export type inducks_subseriesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_subseries
     */
    select?: inducks_subseriesSelect<ExtArgs> | null
  }



  /**
   * Model inducks_subseriesname
   */

  export type AggregateInducks_subseriesname = {
    _count: Inducks_subseriesnameCountAggregateOutputType | null
    _min: Inducks_subseriesnameMinAggregateOutputType | null
    _max: Inducks_subseriesnameMaxAggregateOutputType | null
  }

  export type Inducks_subseriesnameMinAggregateOutputType = {
    subseriescode: string | null
    languagecode: string | null
    subseriesname: string | null
    preferred: $Enums.inducks_subseriesname_preferred | null
    subseriesnamecomment: string | null
  }

  export type Inducks_subseriesnameMaxAggregateOutputType = {
    subseriescode: string | null
    languagecode: string | null
    subseriesname: string | null
    preferred: $Enums.inducks_subseriesname_preferred | null
    subseriesnamecomment: string | null
  }

  export type Inducks_subseriesnameCountAggregateOutputType = {
    subseriescode: number
    languagecode: number
    subseriesname: number
    preferred: number
    subseriesnamecomment: number
    _all: number
  }


  export type Inducks_subseriesnameMinAggregateInputType = {
    subseriescode?: true
    languagecode?: true
    subseriesname?: true
    preferred?: true
    subseriesnamecomment?: true
  }

  export type Inducks_subseriesnameMaxAggregateInputType = {
    subseriescode?: true
    languagecode?: true
    subseriesname?: true
    preferred?: true
    subseriesnamecomment?: true
  }

  export type Inducks_subseriesnameCountAggregateInputType = {
    subseriescode?: true
    languagecode?: true
    subseriesname?: true
    preferred?: true
    subseriesnamecomment?: true
    _all?: true
  }

  export type Inducks_subseriesnameAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_subseriesname to aggregate.
     */
    where?: inducks_subseriesnameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_subseriesnames to fetch.
     */
    orderBy?: inducks_subseriesnameOrderByWithRelationInput | inducks_subseriesnameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_subseriesnameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_subseriesnames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_subseriesnames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_subseriesnames
    **/
    _count?: true | Inducks_subseriesnameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_subseriesnameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_subseriesnameMaxAggregateInputType
  }

  export type GetInducks_subseriesnameAggregateType<T extends Inducks_subseriesnameAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_subseriesname]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_subseriesname[P]>
      : GetScalarType<T[P], AggregateInducks_subseriesname[P]>
  }




  export type inducks_subseriesnameGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_subseriesnameWhereInput
    orderBy?: inducks_subseriesnameOrderByWithAggregationInput | inducks_subseriesnameOrderByWithAggregationInput[]
    by: Inducks_subseriesnameScalarFieldEnum[] | Inducks_subseriesnameScalarFieldEnum
    having?: inducks_subseriesnameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_subseriesnameCountAggregateInputType | true
    _min?: Inducks_subseriesnameMinAggregateInputType
    _max?: Inducks_subseriesnameMaxAggregateInputType
  }

  export type Inducks_subseriesnameGroupByOutputType = {
    subseriescode: string
    languagecode: string
    subseriesname: string | null
    preferred: $Enums.inducks_subseriesname_preferred | null
    subseriesnamecomment: string | null
    _count: Inducks_subseriesnameCountAggregateOutputType | null
    _min: Inducks_subseriesnameMinAggregateOutputType | null
    _max: Inducks_subseriesnameMaxAggregateOutputType | null
  }

  type GetInducks_subseriesnameGroupByPayload<T extends inducks_subseriesnameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_subseriesnameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_subseriesnameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_subseriesnameGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_subseriesnameGroupByOutputType[P]>
        }
      >
    >


  export type inducks_subseriesnameSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subseriescode?: boolean
    languagecode?: boolean
    subseriesname?: boolean
    preferred?: boolean
    subseriesnamecomment?: boolean
  }, ExtArgs["result"]["inducks_subseriesname"]>

  export type inducks_subseriesnameSelectScalar = {
    subseriescode?: boolean
    languagecode?: boolean
    subseriesname?: boolean
    preferred?: boolean
    subseriesnamecomment?: boolean
  }


  export type $inducks_subseriesnamePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_subseriesname"
    objects: {}
    scalars: $Extensions.GetResult<{
      subseriescode: string
      languagecode: string
      subseriesname: string | null
      preferred: $Enums.inducks_subseriesname_preferred | null
      subseriesnamecomment: string | null
    }, ExtArgs["result"]["inducks_subseriesname"]>
    composites: {}
  }


  type inducks_subseriesnameGetPayload<S extends boolean | null | undefined | inducks_subseriesnameDefaultArgs> = $Result.GetResult<Prisma.$inducks_subseriesnamePayload, S>

  type inducks_subseriesnameCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_subseriesnameFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_subseriesnameCountAggregateInputType | true
    }

  export interface inducks_subseriesnameDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_subseriesname'], meta: { name: 'inducks_subseriesname' } }
    /**
     * Find zero or one Inducks_subseriesname that matches the filter.
     * @param {inducks_subseriesnameFindUniqueArgs} args - Arguments to find a Inducks_subseriesname
     * @example
     * // Get one Inducks_subseriesname
     * const inducks_subseriesname = await prisma.inducks_subseriesname.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_subseriesnameFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_subseriesnameFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_subseriesnameClient<$Result.GetResult<Prisma.$inducks_subseriesnamePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_subseriesname that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_subseriesnameFindUniqueOrThrowArgs} args - Arguments to find a Inducks_subseriesname
     * @example
     * // Get one Inducks_subseriesname
     * const inducks_subseriesname = await prisma.inducks_subseriesname.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_subseriesnameFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_subseriesnameFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_subseriesnameClient<$Result.GetResult<Prisma.$inducks_subseriesnamePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_subseriesname that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_subseriesnameFindFirstArgs} args - Arguments to find a Inducks_subseriesname
     * @example
     * // Get one Inducks_subseriesname
     * const inducks_subseriesname = await prisma.inducks_subseriesname.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_subseriesnameFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_subseriesnameFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_subseriesnameClient<$Result.GetResult<Prisma.$inducks_subseriesnamePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_subseriesname that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_subseriesnameFindFirstOrThrowArgs} args - Arguments to find a Inducks_subseriesname
     * @example
     * // Get one Inducks_subseriesname
     * const inducks_subseriesname = await prisma.inducks_subseriesname.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_subseriesnameFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_subseriesnameFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_subseriesnameClient<$Result.GetResult<Prisma.$inducks_subseriesnamePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_subseriesnames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_subseriesnameFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_subseriesnames
     * const inducks_subseriesnames = await prisma.inducks_subseriesname.findMany()
     * 
     * // Get first 10 Inducks_subseriesnames
     * const inducks_subseriesnames = await prisma.inducks_subseriesname.findMany({ take: 10 })
     * 
     * // Only select the `subseriescode`
     * const inducks_subseriesnameWithSubseriescodeOnly = await prisma.inducks_subseriesname.findMany({ select: { subseriescode: true } })
     * 
    **/
    findMany<T extends inducks_subseriesnameFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_subseriesnameFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_subseriesnamePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_subseriesname.
     * @param {inducks_subseriesnameCreateArgs} args - Arguments to create a Inducks_subseriesname.
     * @example
     * // Create one Inducks_subseriesname
     * const Inducks_subseriesname = await prisma.inducks_subseriesname.create({
     *   data: {
     *     // ... data to create a Inducks_subseriesname
     *   }
     * })
     * 
    **/
    create<T extends inducks_subseriesnameCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_subseriesnameCreateArgs<ExtArgs>>
    ): Prisma__inducks_subseriesnameClient<$Result.GetResult<Prisma.$inducks_subseriesnamePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_subseriesnames.
     *     @param {inducks_subseriesnameCreateManyArgs} args - Arguments to create many Inducks_subseriesnames.
     *     @example
     *     // Create many Inducks_subseriesnames
     *     const inducks_subseriesname = await prisma.inducks_subseriesname.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_subseriesnameCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_subseriesnameCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_subseriesname.
     * @param {inducks_subseriesnameDeleteArgs} args - Arguments to delete one Inducks_subseriesname.
     * @example
     * // Delete one Inducks_subseriesname
     * const Inducks_subseriesname = await prisma.inducks_subseriesname.delete({
     *   where: {
     *     // ... filter to delete one Inducks_subseriesname
     *   }
     * })
     * 
    **/
    delete<T extends inducks_subseriesnameDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_subseriesnameDeleteArgs<ExtArgs>>
    ): Prisma__inducks_subseriesnameClient<$Result.GetResult<Prisma.$inducks_subseriesnamePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_subseriesname.
     * @param {inducks_subseriesnameUpdateArgs} args - Arguments to update one Inducks_subseriesname.
     * @example
     * // Update one Inducks_subseriesname
     * const inducks_subseriesname = await prisma.inducks_subseriesname.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_subseriesnameUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_subseriesnameUpdateArgs<ExtArgs>>
    ): Prisma__inducks_subseriesnameClient<$Result.GetResult<Prisma.$inducks_subseriesnamePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_subseriesnames.
     * @param {inducks_subseriesnameDeleteManyArgs} args - Arguments to filter Inducks_subseriesnames to delete.
     * @example
     * // Delete a few Inducks_subseriesnames
     * const { count } = await prisma.inducks_subseriesname.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_subseriesnameDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_subseriesnameDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_subseriesnames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_subseriesnameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_subseriesnames
     * const inducks_subseriesname = await prisma.inducks_subseriesname.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_subseriesnameUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_subseriesnameUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_subseriesname.
     * @param {inducks_subseriesnameUpsertArgs} args - Arguments to update or create a Inducks_subseriesname.
     * @example
     * // Update or create a Inducks_subseriesname
     * const inducks_subseriesname = await prisma.inducks_subseriesname.upsert({
     *   create: {
     *     // ... data to create a Inducks_subseriesname
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_subseriesname we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_subseriesnameUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_subseriesnameUpsertArgs<ExtArgs>>
    ): Prisma__inducks_subseriesnameClient<$Result.GetResult<Prisma.$inducks_subseriesnamePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_subseriesnames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_subseriesnameCountArgs} args - Arguments to filter Inducks_subseriesnames to count.
     * @example
     * // Count the number of Inducks_subseriesnames
     * const count = await prisma.inducks_subseriesname.count({
     *   where: {
     *     // ... the filter for the Inducks_subseriesnames we want to count
     *   }
     * })
    **/
    count<T extends inducks_subseriesnameCountArgs>(
      args?: Subset<T, inducks_subseriesnameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_subseriesnameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_subseriesname.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_subseriesnameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_subseriesnameAggregateArgs>(args: Subset<T, Inducks_subseriesnameAggregateArgs>): Prisma.PrismaPromise<GetInducks_subseriesnameAggregateType<T>>

    /**
     * Group by Inducks_subseriesname.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_subseriesnameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_subseriesnameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_subseriesnameGroupByArgs['orderBy'] }
        : { orderBy?: inducks_subseriesnameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_subseriesnameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_subseriesnameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_subseriesname model
   */
  readonly fields: inducks_subseriesnameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_subseriesname.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_subseriesnameClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_subseriesname model
   */ 
  interface inducks_subseriesnameFieldRefs {
    readonly subseriescode: FieldRef<"inducks_subseriesname", 'String'>
    readonly languagecode: FieldRef<"inducks_subseriesname", 'String'>
    readonly subseriesname: FieldRef<"inducks_subseriesname", 'String'>
    readonly preferred: FieldRef<"inducks_subseriesname", 'inducks_subseriesname_preferred'>
    readonly subseriesnamecomment: FieldRef<"inducks_subseriesname", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_subseriesname findUnique
   */
  export type inducks_subseriesnameFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_subseriesname
     */
    select?: inducks_subseriesnameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_subseriesname to fetch.
     */
    where: inducks_subseriesnameWhereUniqueInput
  }


  /**
   * inducks_subseriesname findUniqueOrThrow
   */
  export type inducks_subseriesnameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_subseriesname
     */
    select?: inducks_subseriesnameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_subseriesname to fetch.
     */
    where: inducks_subseriesnameWhereUniqueInput
  }


  /**
   * inducks_subseriesname findFirst
   */
  export type inducks_subseriesnameFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_subseriesname
     */
    select?: inducks_subseriesnameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_subseriesname to fetch.
     */
    where?: inducks_subseriesnameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_subseriesnames to fetch.
     */
    orderBy?: inducks_subseriesnameOrderByWithRelationInput | inducks_subseriesnameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_subseriesnames.
     */
    cursor?: inducks_subseriesnameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_subseriesnames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_subseriesnames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_subseriesnames.
     */
    distinct?: Inducks_subseriesnameScalarFieldEnum | Inducks_subseriesnameScalarFieldEnum[]
  }


  /**
   * inducks_subseriesname findFirstOrThrow
   */
  export type inducks_subseriesnameFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_subseriesname
     */
    select?: inducks_subseriesnameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_subseriesname to fetch.
     */
    where?: inducks_subseriesnameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_subseriesnames to fetch.
     */
    orderBy?: inducks_subseriesnameOrderByWithRelationInput | inducks_subseriesnameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_subseriesnames.
     */
    cursor?: inducks_subseriesnameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_subseriesnames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_subseriesnames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_subseriesnames.
     */
    distinct?: Inducks_subseriesnameScalarFieldEnum | Inducks_subseriesnameScalarFieldEnum[]
  }


  /**
   * inducks_subseriesname findMany
   */
  export type inducks_subseriesnameFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_subseriesname
     */
    select?: inducks_subseriesnameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_subseriesnames to fetch.
     */
    where?: inducks_subseriesnameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_subseriesnames to fetch.
     */
    orderBy?: inducks_subseriesnameOrderByWithRelationInput | inducks_subseriesnameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_subseriesnames.
     */
    cursor?: inducks_subseriesnameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_subseriesnames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_subseriesnames.
     */
    skip?: number
    distinct?: Inducks_subseriesnameScalarFieldEnum | Inducks_subseriesnameScalarFieldEnum[]
  }


  /**
   * inducks_subseriesname create
   */
  export type inducks_subseriesnameCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_subseriesname
     */
    select?: inducks_subseriesnameSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_subseriesname.
     */
    data: XOR<inducks_subseriesnameCreateInput, inducks_subseriesnameUncheckedCreateInput>
  }


  /**
   * inducks_subseriesname createMany
   */
  export type inducks_subseriesnameCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_subseriesnames.
     */
    data: inducks_subseriesnameCreateManyInput | inducks_subseriesnameCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_subseriesname update
   */
  export type inducks_subseriesnameUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_subseriesname
     */
    select?: inducks_subseriesnameSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_subseriesname.
     */
    data: XOR<inducks_subseriesnameUpdateInput, inducks_subseriesnameUncheckedUpdateInput>
    /**
     * Choose, which inducks_subseriesname to update.
     */
    where: inducks_subseriesnameWhereUniqueInput
  }


  /**
   * inducks_subseriesname updateMany
   */
  export type inducks_subseriesnameUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_subseriesnames.
     */
    data: XOR<inducks_subseriesnameUpdateManyMutationInput, inducks_subseriesnameUncheckedUpdateManyInput>
    /**
     * Filter which inducks_subseriesnames to update
     */
    where?: inducks_subseriesnameWhereInput
  }


  /**
   * inducks_subseriesname upsert
   */
  export type inducks_subseriesnameUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_subseriesname
     */
    select?: inducks_subseriesnameSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_subseriesname to update in case it exists.
     */
    where: inducks_subseriesnameWhereUniqueInput
    /**
     * In case the inducks_subseriesname found by the `where` argument doesn't exist, create a new inducks_subseriesname with this data.
     */
    create: XOR<inducks_subseriesnameCreateInput, inducks_subseriesnameUncheckedCreateInput>
    /**
     * In case the inducks_subseriesname was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_subseriesnameUpdateInput, inducks_subseriesnameUncheckedUpdateInput>
  }


  /**
   * inducks_subseriesname delete
   */
  export type inducks_subseriesnameDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_subseriesname
     */
    select?: inducks_subseriesnameSelect<ExtArgs> | null
    /**
     * Filter which inducks_subseriesname to delete.
     */
    where: inducks_subseriesnameWhereUniqueInput
  }


  /**
   * inducks_subseriesname deleteMany
   */
  export type inducks_subseriesnameDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_subseriesnames to delete
     */
    where?: inducks_subseriesnameWhereInput
  }


  /**
   * inducks_subseriesname without action
   */
  export type inducks_subseriesnameDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_subseriesname
     */
    select?: inducks_subseriesnameSelect<ExtArgs> | null
  }



  /**
   * Model inducks_substory
   */

  export type AggregateInducks_substory = {
    _count: Inducks_substoryCountAggregateOutputType | null
    _avg: Inducks_substoryAvgAggregateOutputType | null
    _sum: Inducks_substorySumAggregateOutputType | null
    _min: Inducks_substoryMinAggregateOutputType | null
    _max: Inducks_substoryMaxAggregateOutputType | null
  }

  export type Inducks_substoryAvgAggregateOutputType = {
    inputfilecode: number | null
  }

  export type Inducks_substorySumAggregateOutputType = {
    inputfilecode: number | null
  }

  export type Inducks_substoryMinAggregateOutputType = {
    storycode: string | null
    originalstoryversioncode: string | null
    superstorycode: string | null
    part: string | null
    firstpublicationdate: string | null
    title: string | null
    substorycomment: string | null
    error: $Enums.inducks_substory_error | null
    locked: $Enums.inducks_substory_locked | null
    inputfilecode: number | null
    maintenanceteamcode: string | null
  }

  export type Inducks_substoryMaxAggregateOutputType = {
    storycode: string | null
    originalstoryversioncode: string | null
    superstorycode: string | null
    part: string | null
    firstpublicationdate: string | null
    title: string | null
    substorycomment: string | null
    error: $Enums.inducks_substory_error | null
    locked: $Enums.inducks_substory_locked | null
    inputfilecode: number | null
    maintenanceteamcode: string | null
  }

  export type Inducks_substoryCountAggregateOutputType = {
    storycode: number
    originalstoryversioncode: number
    superstorycode: number
    part: number
    firstpublicationdate: number
    title: number
    substorycomment: number
    error: number
    locked: number
    inputfilecode: number
    maintenanceteamcode: number
    _all: number
  }


  export type Inducks_substoryAvgAggregateInputType = {
    inputfilecode?: true
  }

  export type Inducks_substorySumAggregateInputType = {
    inputfilecode?: true
  }

  export type Inducks_substoryMinAggregateInputType = {
    storycode?: true
    originalstoryversioncode?: true
    superstorycode?: true
    part?: true
    firstpublicationdate?: true
    title?: true
    substorycomment?: true
    error?: true
    locked?: true
    inputfilecode?: true
    maintenanceteamcode?: true
  }

  export type Inducks_substoryMaxAggregateInputType = {
    storycode?: true
    originalstoryversioncode?: true
    superstorycode?: true
    part?: true
    firstpublicationdate?: true
    title?: true
    substorycomment?: true
    error?: true
    locked?: true
    inputfilecode?: true
    maintenanceteamcode?: true
  }

  export type Inducks_substoryCountAggregateInputType = {
    storycode?: true
    originalstoryversioncode?: true
    superstorycode?: true
    part?: true
    firstpublicationdate?: true
    title?: true
    substorycomment?: true
    error?: true
    locked?: true
    inputfilecode?: true
    maintenanceteamcode?: true
    _all?: true
  }

  export type Inducks_substoryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_substory to aggregate.
     */
    where?: inducks_substoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_substories to fetch.
     */
    orderBy?: inducks_substoryOrderByWithRelationInput | inducks_substoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_substoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_substories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_substories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_substories
    **/
    _count?: true | Inducks_substoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Inducks_substoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Inducks_substorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_substoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_substoryMaxAggregateInputType
  }

  export type GetInducks_substoryAggregateType<T extends Inducks_substoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_substory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_substory[P]>
      : GetScalarType<T[P], AggregateInducks_substory[P]>
  }




  export type inducks_substoryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_substoryWhereInput
    orderBy?: inducks_substoryOrderByWithAggregationInput | inducks_substoryOrderByWithAggregationInput[]
    by: Inducks_substoryScalarFieldEnum[] | Inducks_substoryScalarFieldEnum
    having?: inducks_substoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_substoryCountAggregateInputType | true
    _avg?: Inducks_substoryAvgAggregateInputType
    _sum?: Inducks_substorySumAggregateInputType
    _min?: Inducks_substoryMinAggregateInputType
    _max?: Inducks_substoryMaxAggregateInputType
  }

  export type Inducks_substoryGroupByOutputType = {
    storycode: string
    originalstoryversioncode: string | null
    superstorycode: string | null
    part: string | null
    firstpublicationdate: string | null
    title: string | null
    substorycomment: string | null
    error: $Enums.inducks_substory_error | null
    locked: $Enums.inducks_substory_locked | null
    inputfilecode: number | null
    maintenanceteamcode: string | null
    _count: Inducks_substoryCountAggregateOutputType | null
    _avg: Inducks_substoryAvgAggregateOutputType | null
    _sum: Inducks_substorySumAggregateOutputType | null
    _min: Inducks_substoryMinAggregateOutputType | null
    _max: Inducks_substoryMaxAggregateOutputType | null
  }

  type GetInducks_substoryGroupByPayload<T extends inducks_substoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_substoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_substoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_substoryGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_substoryGroupByOutputType[P]>
        }
      >
    >


  export type inducks_substorySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    storycode?: boolean
    originalstoryversioncode?: boolean
    superstorycode?: boolean
    part?: boolean
    firstpublicationdate?: boolean
    title?: boolean
    substorycomment?: boolean
    error?: boolean
    locked?: boolean
    inputfilecode?: boolean
    maintenanceteamcode?: boolean
  }, ExtArgs["result"]["inducks_substory"]>

  export type inducks_substorySelectScalar = {
    storycode?: boolean
    originalstoryversioncode?: boolean
    superstorycode?: boolean
    part?: boolean
    firstpublicationdate?: boolean
    title?: boolean
    substorycomment?: boolean
    error?: boolean
    locked?: boolean
    inputfilecode?: boolean
    maintenanceteamcode?: boolean
  }


  export type $inducks_substoryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_substory"
    objects: {}
    scalars: $Extensions.GetResult<{
      storycode: string
      originalstoryversioncode: string | null
      superstorycode: string | null
      part: string | null
      firstpublicationdate: string | null
      title: string | null
      substorycomment: string | null
      error: $Enums.inducks_substory_error | null
      locked: $Enums.inducks_substory_locked | null
      inputfilecode: number | null
      maintenanceteamcode: string | null
    }, ExtArgs["result"]["inducks_substory"]>
    composites: {}
  }


  type inducks_substoryGetPayload<S extends boolean | null | undefined | inducks_substoryDefaultArgs> = $Result.GetResult<Prisma.$inducks_substoryPayload, S>

  type inducks_substoryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_substoryFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_substoryCountAggregateInputType | true
    }

  export interface inducks_substoryDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_substory'], meta: { name: 'inducks_substory' } }
    /**
     * Find zero or one Inducks_substory that matches the filter.
     * @param {inducks_substoryFindUniqueArgs} args - Arguments to find a Inducks_substory
     * @example
     * // Get one Inducks_substory
     * const inducks_substory = await prisma.inducks_substory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_substoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_substoryFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_substoryClient<$Result.GetResult<Prisma.$inducks_substoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_substory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_substoryFindUniqueOrThrowArgs} args - Arguments to find a Inducks_substory
     * @example
     * // Get one Inducks_substory
     * const inducks_substory = await prisma.inducks_substory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_substoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_substoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_substoryClient<$Result.GetResult<Prisma.$inducks_substoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_substory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_substoryFindFirstArgs} args - Arguments to find a Inducks_substory
     * @example
     * // Get one Inducks_substory
     * const inducks_substory = await prisma.inducks_substory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_substoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_substoryFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_substoryClient<$Result.GetResult<Prisma.$inducks_substoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_substory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_substoryFindFirstOrThrowArgs} args - Arguments to find a Inducks_substory
     * @example
     * // Get one Inducks_substory
     * const inducks_substory = await prisma.inducks_substory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_substoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_substoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_substoryClient<$Result.GetResult<Prisma.$inducks_substoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_substories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_substoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_substories
     * const inducks_substories = await prisma.inducks_substory.findMany()
     * 
     * // Get first 10 Inducks_substories
     * const inducks_substories = await prisma.inducks_substory.findMany({ take: 10 })
     * 
     * // Only select the `storycode`
     * const inducks_substoryWithStorycodeOnly = await prisma.inducks_substory.findMany({ select: { storycode: true } })
     * 
    **/
    findMany<T extends inducks_substoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_substoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_substoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_substory.
     * @param {inducks_substoryCreateArgs} args - Arguments to create a Inducks_substory.
     * @example
     * // Create one Inducks_substory
     * const Inducks_substory = await prisma.inducks_substory.create({
     *   data: {
     *     // ... data to create a Inducks_substory
     *   }
     * })
     * 
    **/
    create<T extends inducks_substoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_substoryCreateArgs<ExtArgs>>
    ): Prisma__inducks_substoryClient<$Result.GetResult<Prisma.$inducks_substoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_substories.
     *     @param {inducks_substoryCreateManyArgs} args - Arguments to create many Inducks_substories.
     *     @example
     *     // Create many Inducks_substories
     *     const inducks_substory = await prisma.inducks_substory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_substoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_substoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_substory.
     * @param {inducks_substoryDeleteArgs} args - Arguments to delete one Inducks_substory.
     * @example
     * // Delete one Inducks_substory
     * const Inducks_substory = await prisma.inducks_substory.delete({
     *   where: {
     *     // ... filter to delete one Inducks_substory
     *   }
     * })
     * 
    **/
    delete<T extends inducks_substoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_substoryDeleteArgs<ExtArgs>>
    ): Prisma__inducks_substoryClient<$Result.GetResult<Prisma.$inducks_substoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_substory.
     * @param {inducks_substoryUpdateArgs} args - Arguments to update one Inducks_substory.
     * @example
     * // Update one Inducks_substory
     * const inducks_substory = await prisma.inducks_substory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_substoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_substoryUpdateArgs<ExtArgs>>
    ): Prisma__inducks_substoryClient<$Result.GetResult<Prisma.$inducks_substoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_substories.
     * @param {inducks_substoryDeleteManyArgs} args - Arguments to filter Inducks_substories to delete.
     * @example
     * // Delete a few Inducks_substories
     * const { count } = await prisma.inducks_substory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_substoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_substoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_substories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_substoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_substories
     * const inducks_substory = await prisma.inducks_substory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_substoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_substoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_substory.
     * @param {inducks_substoryUpsertArgs} args - Arguments to update or create a Inducks_substory.
     * @example
     * // Update or create a Inducks_substory
     * const inducks_substory = await prisma.inducks_substory.upsert({
     *   create: {
     *     // ... data to create a Inducks_substory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_substory we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_substoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_substoryUpsertArgs<ExtArgs>>
    ): Prisma__inducks_substoryClient<$Result.GetResult<Prisma.$inducks_substoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_substories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_substoryCountArgs} args - Arguments to filter Inducks_substories to count.
     * @example
     * // Count the number of Inducks_substories
     * const count = await prisma.inducks_substory.count({
     *   where: {
     *     // ... the filter for the Inducks_substories we want to count
     *   }
     * })
    **/
    count<T extends inducks_substoryCountArgs>(
      args?: Subset<T, inducks_substoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_substoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_substory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_substoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_substoryAggregateArgs>(args: Subset<T, Inducks_substoryAggregateArgs>): Prisma.PrismaPromise<GetInducks_substoryAggregateType<T>>

    /**
     * Group by Inducks_substory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_substoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_substoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_substoryGroupByArgs['orderBy'] }
        : { orderBy?: inducks_substoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_substoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_substoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_substory model
   */
  readonly fields: inducks_substoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_substory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_substoryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_substory model
   */ 
  interface inducks_substoryFieldRefs {
    readonly storycode: FieldRef<"inducks_substory", 'String'>
    readonly originalstoryversioncode: FieldRef<"inducks_substory", 'String'>
    readonly superstorycode: FieldRef<"inducks_substory", 'String'>
    readonly part: FieldRef<"inducks_substory", 'String'>
    readonly firstpublicationdate: FieldRef<"inducks_substory", 'String'>
    readonly title: FieldRef<"inducks_substory", 'String'>
    readonly substorycomment: FieldRef<"inducks_substory", 'String'>
    readonly error: FieldRef<"inducks_substory", 'inducks_substory_error'>
    readonly locked: FieldRef<"inducks_substory", 'inducks_substory_locked'>
    readonly inputfilecode: FieldRef<"inducks_substory", 'Int'>
    readonly maintenanceteamcode: FieldRef<"inducks_substory", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_substory findUnique
   */
  export type inducks_substoryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_substory
     */
    select?: inducks_substorySelect<ExtArgs> | null
    /**
     * Filter, which inducks_substory to fetch.
     */
    where: inducks_substoryWhereUniqueInput
  }


  /**
   * inducks_substory findUniqueOrThrow
   */
  export type inducks_substoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_substory
     */
    select?: inducks_substorySelect<ExtArgs> | null
    /**
     * Filter, which inducks_substory to fetch.
     */
    where: inducks_substoryWhereUniqueInput
  }


  /**
   * inducks_substory findFirst
   */
  export type inducks_substoryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_substory
     */
    select?: inducks_substorySelect<ExtArgs> | null
    /**
     * Filter, which inducks_substory to fetch.
     */
    where?: inducks_substoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_substories to fetch.
     */
    orderBy?: inducks_substoryOrderByWithRelationInput | inducks_substoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_substories.
     */
    cursor?: inducks_substoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_substories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_substories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_substories.
     */
    distinct?: Inducks_substoryScalarFieldEnum | Inducks_substoryScalarFieldEnum[]
  }


  /**
   * inducks_substory findFirstOrThrow
   */
  export type inducks_substoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_substory
     */
    select?: inducks_substorySelect<ExtArgs> | null
    /**
     * Filter, which inducks_substory to fetch.
     */
    where?: inducks_substoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_substories to fetch.
     */
    orderBy?: inducks_substoryOrderByWithRelationInput | inducks_substoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_substories.
     */
    cursor?: inducks_substoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_substories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_substories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_substories.
     */
    distinct?: Inducks_substoryScalarFieldEnum | Inducks_substoryScalarFieldEnum[]
  }


  /**
   * inducks_substory findMany
   */
  export type inducks_substoryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_substory
     */
    select?: inducks_substorySelect<ExtArgs> | null
    /**
     * Filter, which inducks_substories to fetch.
     */
    where?: inducks_substoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_substories to fetch.
     */
    orderBy?: inducks_substoryOrderByWithRelationInput | inducks_substoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_substories.
     */
    cursor?: inducks_substoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_substories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_substories.
     */
    skip?: number
    distinct?: Inducks_substoryScalarFieldEnum | Inducks_substoryScalarFieldEnum[]
  }


  /**
   * inducks_substory create
   */
  export type inducks_substoryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_substory
     */
    select?: inducks_substorySelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_substory.
     */
    data: XOR<inducks_substoryCreateInput, inducks_substoryUncheckedCreateInput>
  }


  /**
   * inducks_substory createMany
   */
  export type inducks_substoryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_substories.
     */
    data: inducks_substoryCreateManyInput | inducks_substoryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_substory update
   */
  export type inducks_substoryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_substory
     */
    select?: inducks_substorySelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_substory.
     */
    data: XOR<inducks_substoryUpdateInput, inducks_substoryUncheckedUpdateInput>
    /**
     * Choose, which inducks_substory to update.
     */
    where: inducks_substoryWhereUniqueInput
  }


  /**
   * inducks_substory updateMany
   */
  export type inducks_substoryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_substories.
     */
    data: XOR<inducks_substoryUpdateManyMutationInput, inducks_substoryUncheckedUpdateManyInput>
    /**
     * Filter which inducks_substories to update
     */
    where?: inducks_substoryWhereInput
  }


  /**
   * inducks_substory upsert
   */
  export type inducks_substoryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_substory
     */
    select?: inducks_substorySelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_substory to update in case it exists.
     */
    where: inducks_substoryWhereUniqueInput
    /**
     * In case the inducks_substory found by the `where` argument doesn't exist, create a new inducks_substory with this data.
     */
    create: XOR<inducks_substoryCreateInput, inducks_substoryUncheckedCreateInput>
    /**
     * In case the inducks_substory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_substoryUpdateInput, inducks_substoryUncheckedUpdateInput>
  }


  /**
   * inducks_substory delete
   */
  export type inducks_substoryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_substory
     */
    select?: inducks_substorySelect<ExtArgs> | null
    /**
     * Filter which inducks_substory to delete.
     */
    where: inducks_substoryWhereUniqueInput
  }


  /**
   * inducks_substory deleteMany
   */
  export type inducks_substoryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_substories to delete
     */
    where?: inducks_substoryWhereInput
  }


  /**
   * inducks_substory without action
   */
  export type inducks_substoryDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_substory
     */
    select?: inducks_substorySelect<ExtArgs> | null
  }



  /**
   * Model inducks_team
   */

  export type AggregateInducks_team = {
    _count: Inducks_teamCountAggregateOutputType | null
    _min: Inducks_teamMinAggregateOutputType | null
    _max: Inducks_teamMaxAggregateOutputType | null
  }

  export type Inducks_teamMinAggregateOutputType = {
    teamcode: string | null
    teamdescriptionname: string | null
    teamshortname: string | null
  }

  export type Inducks_teamMaxAggregateOutputType = {
    teamcode: string | null
    teamdescriptionname: string | null
    teamshortname: string | null
  }

  export type Inducks_teamCountAggregateOutputType = {
    teamcode: number
    teamdescriptionname: number
    teamshortname: number
    _all: number
  }


  export type Inducks_teamMinAggregateInputType = {
    teamcode?: true
    teamdescriptionname?: true
    teamshortname?: true
  }

  export type Inducks_teamMaxAggregateInputType = {
    teamcode?: true
    teamdescriptionname?: true
    teamshortname?: true
  }

  export type Inducks_teamCountAggregateInputType = {
    teamcode?: true
    teamdescriptionname?: true
    teamshortname?: true
    _all?: true
  }

  export type Inducks_teamAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_team to aggregate.
     */
    where?: inducks_teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_teams to fetch.
     */
    orderBy?: inducks_teamOrderByWithRelationInput | inducks_teamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_teams
    **/
    _count?: true | Inducks_teamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_teamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_teamMaxAggregateInputType
  }

  export type GetInducks_teamAggregateType<T extends Inducks_teamAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_team]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_team[P]>
      : GetScalarType<T[P], AggregateInducks_team[P]>
  }




  export type inducks_teamGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_teamWhereInput
    orderBy?: inducks_teamOrderByWithAggregationInput | inducks_teamOrderByWithAggregationInput[]
    by: Inducks_teamScalarFieldEnum[] | Inducks_teamScalarFieldEnum
    having?: inducks_teamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_teamCountAggregateInputType | true
    _min?: Inducks_teamMinAggregateInputType
    _max?: Inducks_teamMaxAggregateInputType
  }

  export type Inducks_teamGroupByOutputType = {
    teamcode: string
    teamdescriptionname: string | null
    teamshortname: string | null
    _count: Inducks_teamCountAggregateOutputType | null
    _min: Inducks_teamMinAggregateOutputType | null
    _max: Inducks_teamMaxAggregateOutputType | null
  }

  type GetInducks_teamGroupByPayload<T extends inducks_teamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_teamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_teamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_teamGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_teamGroupByOutputType[P]>
        }
      >
    >


  export type inducks_teamSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    teamcode?: boolean
    teamdescriptionname?: boolean
    teamshortname?: boolean
  }, ExtArgs["result"]["inducks_team"]>

  export type inducks_teamSelectScalar = {
    teamcode?: boolean
    teamdescriptionname?: boolean
    teamshortname?: boolean
  }


  export type $inducks_teamPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_team"
    objects: {}
    scalars: $Extensions.GetResult<{
      teamcode: string
      teamdescriptionname: string | null
      teamshortname: string | null
    }, ExtArgs["result"]["inducks_team"]>
    composites: {}
  }


  type inducks_teamGetPayload<S extends boolean | null | undefined | inducks_teamDefaultArgs> = $Result.GetResult<Prisma.$inducks_teamPayload, S>

  type inducks_teamCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_teamFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_teamCountAggregateInputType | true
    }

  export interface inducks_teamDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_team'], meta: { name: 'inducks_team' } }
    /**
     * Find zero or one Inducks_team that matches the filter.
     * @param {inducks_teamFindUniqueArgs} args - Arguments to find a Inducks_team
     * @example
     * // Get one Inducks_team
     * const inducks_team = await prisma.inducks_team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_teamFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_teamFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_teamClient<$Result.GetResult<Prisma.$inducks_teamPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_team that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_teamFindUniqueOrThrowArgs} args - Arguments to find a Inducks_team
     * @example
     * // Get one Inducks_team
     * const inducks_team = await prisma.inducks_team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_teamFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_teamFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_teamClient<$Result.GetResult<Prisma.$inducks_teamPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_teamFindFirstArgs} args - Arguments to find a Inducks_team
     * @example
     * // Get one Inducks_team
     * const inducks_team = await prisma.inducks_team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_teamFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_teamFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_teamClient<$Result.GetResult<Prisma.$inducks_teamPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_teamFindFirstOrThrowArgs} args - Arguments to find a Inducks_team
     * @example
     * // Get one Inducks_team
     * const inducks_team = await prisma.inducks_team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_teamFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_teamFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_teamClient<$Result.GetResult<Prisma.$inducks_teamPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_teamFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_teams
     * const inducks_teams = await prisma.inducks_team.findMany()
     * 
     * // Get first 10 Inducks_teams
     * const inducks_teams = await prisma.inducks_team.findMany({ take: 10 })
     * 
     * // Only select the `teamcode`
     * const inducks_teamWithTeamcodeOnly = await prisma.inducks_team.findMany({ select: { teamcode: true } })
     * 
    **/
    findMany<T extends inducks_teamFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_teamFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_teamPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_team.
     * @param {inducks_teamCreateArgs} args - Arguments to create a Inducks_team.
     * @example
     * // Create one Inducks_team
     * const Inducks_team = await prisma.inducks_team.create({
     *   data: {
     *     // ... data to create a Inducks_team
     *   }
     * })
     * 
    **/
    create<T extends inducks_teamCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_teamCreateArgs<ExtArgs>>
    ): Prisma__inducks_teamClient<$Result.GetResult<Prisma.$inducks_teamPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_teams.
     *     @param {inducks_teamCreateManyArgs} args - Arguments to create many Inducks_teams.
     *     @example
     *     // Create many Inducks_teams
     *     const inducks_team = await prisma.inducks_team.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_teamCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_teamCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_team.
     * @param {inducks_teamDeleteArgs} args - Arguments to delete one Inducks_team.
     * @example
     * // Delete one Inducks_team
     * const Inducks_team = await prisma.inducks_team.delete({
     *   where: {
     *     // ... filter to delete one Inducks_team
     *   }
     * })
     * 
    **/
    delete<T extends inducks_teamDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_teamDeleteArgs<ExtArgs>>
    ): Prisma__inducks_teamClient<$Result.GetResult<Prisma.$inducks_teamPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_team.
     * @param {inducks_teamUpdateArgs} args - Arguments to update one Inducks_team.
     * @example
     * // Update one Inducks_team
     * const inducks_team = await prisma.inducks_team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_teamUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_teamUpdateArgs<ExtArgs>>
    ): Prisma__inducks_teamClient<$Result.GetResult<Prisma.$inducks_teamPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_teams.
     * @param {inducks_teamDeleteManyArgs} args - Arguments to filter Inducks_teams to delete.
     * @example
     * // Delete a few Inducks_teams
     * const { count } = await prisma.inducks_team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_teamDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_teamDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_teamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_teams
     * const inducks_team = await prisma.inducks_team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_teamUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_teamUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_team.
     * @param {inducks_teamUpsertArgs} args - Arguments to update or create a Inducks_team.
     * @example
     * // Update or create a Inducks_team
     * const inducks_team = await prisma.inducks_team.upsert({
     *   create: {
     *     // ... data to create a Inducks_team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_team we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_teamUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_teamUpsertArgs<ExtArgs>>
    ): Prisma__inducks_teamClient<$Result.GetResult<Prisma.$inducks_teamPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_teamCountArgs} args - Arguments to filter Inducks_teams to count.
     * @example
     * // Count the number of Inducks_teams
     * const count = await prisma.inducks_team.count({
     *   where: {
     *     // ... the filter for the Inducks_teams we want to count
     *   }
     * })
    **/
    count<T extends inducks_teamCountArgs>(
      args?: Subset<T, inducks_teamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_teamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_teamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_teamAggregateArgs>(args: Subset<T, Inducks_teamAggregateArgs>): Prisma.PrismaPromise<GetInducks_teamAggregateType<T>>

    /**
     * Group by Inducks_team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_teamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_teamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_teamGroupByArgs['orderBy'] }
        : { orderBy?: inducks_teamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_teamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_teamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_team model
   */
  readonly fields: inducks_teamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_teamClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_team model
   */ 
  interface inducks_teamFieldRefs {
    readonly teamcode: FieldRef<"inducks_team", 'String'>
    readonly teamdescriptionname: FieldRef<"inducks_team", 'String'>
    readonly teamshortname: FieldRef<"inducks_team", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_team findUnique
   */
  export type inducks_teamFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_team
     */
    select?: inducks_teamSelect<ExtArgs> | null
    /**
     * Filter, which inducks_team to fetch.
     */
    where: inducks_teamWhereUniqueInput
  }


  /**
   * inducks_team findUniqueOrThrow
   */
  export type inducks_teamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_team
     */
    select?: inducks_teamSelect<ExtArgs> | null
    /**
     * Filter, which inducks_team to fetch.
     */
    where: inducks_teamWhereUniqueInput
  }


  /**
   * inducks_team findFirst
   */
  export type inducks_teamFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_team
     */
    select?: inducks_teamSelect<ExtArgs> | null
    /**
     * Filter, which inducks_team to fetch.
     */
    where?: inducks_teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_teams to fetch.
     */
    orderBy?: inducks_teamOrderByWithRelationInput | inducks_teamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_teams.
     */
    cursor?: inducks_teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_teams.
     */
    distinct?: Inducks_teamScalarFieldEnum | Inducks_teamScalarFieldEnum[]
  }


  /**
   * inducks_team findFirstOrThrow
   */
  export type inducks_teamFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_team
     */
    select?: inducks_teamSelect<ExtArgs> | null
    /**
     * Filter, which inducks_team to fetch.
     */
    where?: inducks_teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_teams to fetch.
     */
    orderBy?: inducks_teamOrderByWithRelationInput | inducks_teamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_teams.
     */
    cursor?: inducks_teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_teams.
     */
    distinct?: Inducks_teamScalarFieldEnum | Inducks_teamScalarFieldEnum[]
  }


  /**
   * inducks_team findMany
   */
  export type inducks_teamFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_team
     */
    select?: inducks_teamSelect<ExtArgs> | null
    /**
     * Filter, which inducks_teams to fetch.
     */
    where?: inducks_teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_teams to fetch.
     */
    orderBy?: inducks_teamOrderByWithRelationInput | inducks_teamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_teams.
     */
    cursor?: inducks_teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_teams.
     */
    skip?: number
    distinct?: Inducks_teamScalarFieldEnum | Inducks_teamScalarFieldEnum[]
  }


  /**
   * inducks_team create
   */
  export type inducks_teamCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_team
     */
    select?: inducks_teamSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_team.
     */
    data: XOR<inducks_teamCreateInput, inducks_teamUncheckedCreateInput>
  }


  /**
   * inducks_team createMany
   */
  export type inducks_teamCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_teams.
     */
    data: inducks_teamCreateManyInput | inducks_teamCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_team update
   */
  export type inducks_teamUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_team
     */
    select?: inducks_teamSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_team.
     */
    data: XOR<inducks_teamUpdateInput, inducks_teamUncheckedUpdateInput>
    /**
     * Choose, which inducks_team to update.
     */
    where: inducks_teamWhereUniqueInput
  }


  /**
   * inducks_team updateMany
   */
  export type inducks_teamUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_teams.
     */
    data: XOR<inducks_teamUpdateManyMutationInput, inducks_teamUncheckedUpdateManyInput>
    /**
     * Filter which inducks_teams to update
     */
    where?: inducks_teamWhereInput
  }


  /**
   * inducks_team upsert
   */
  export type inducks_teamUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_team
     */
    select?: inducks_teamSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_team to update in case it exists.
     */
    where: inducks_teamWhereUniqueInput
    /**
     * In case the inducks_team found by the `where` argument doesn't exist, create a new inducks_team with this data.
     */
    create: XOR<inducks_teamCreateInput, inducks_teamUncheckedCreateInput>
    /**
     * In case the inducks_team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_teamUpdateInput, inducks_teamUncheckedUpdateInput>
  }


  /**
   * inducks_team delete
   */
  export type inducks_teamDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_team
     */
    select?: inducks_teamSelect<ExtArgs> | null
    /**
     * Filter which inducks_team to delete.
     */
    where: inducks_teamWhereUniqueInput
  }


  /**
   * inducks_team deleteMany
   */
  export type inducks_teamDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_teams to delete
     */
    where?: inducks_teamWhereInput
  }


  /**
   * inducks_team without action
   */
  export type inducks_teamDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_team
     */
    select?: inducks_teamSelect<ExtArgs> | null
  }



  /**
   * Model inducks_teammember
   */

  export type AggregateInducks_teammember = {
    _count: Inducks_teammemberCountAggregateOutputType | null
    _min: Inducks_teammemberMinAggregateOutputType | null
    _max: Inducks_teammemberMaxAggregateOutputType | null
  }

  export type Inducks_teammemberMinAggregateOutputType = {
    teamcode: string | null
    personcode: string | null
  }

  export type Inducks_teammemberMaxAggregateOutputType = {
    teamcode: string | null
    personcode: string | null
  }

  export type Inducks_teammemberCountAggregateOutputType = {
    teamcode: number
    personcode: number
    _all: number
  }


  export type Inducks_teammemberMinAggregateInputType = {
    teamcode?: true
    personcode?: true
  }

  export type Inducks_teammemberMaxAggregateInputType = {
    teamcode?: true
    personcode?: true
  }

  export type Inducks_teammemberCountAggregateInputType = {
    teamcode?: true
    personcode?: true
    _all?: true
  }

  export type Inducks_teammemberAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_teammember to aggregate.
     */
    where?: inducks_teammemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_teammembers to fetch.
     */
    orderBy?: inducks_teammemberOrderByWithRelationInput | inducks_teammemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_teammemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_teammembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_teammembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_teammembers
    **/
    _count?: true | Inducks_teammemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_teammemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_teammemberMaxAggregateInputType
  }

  export type GetInducks_teammemberAggregateType<T extends Inducks_teammemberAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_teammember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_teammember[P]>
      : GetScalarType<T[P], AggregateInducks_teammember[P]>
  }




  export type inducks_teammemberGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_teammemberWhereInput
    orderBy?: inducks_teammemberOrderByWithAggregationInput | inducks_teammemberOrderByWithAggregationInput[]
    by: Inducks_teammemberScalarFieldEnum[] | Inducks_teammemberScalarFieldEnum
    having?: inducks_teammemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_teammemberCountAggregateInputType | true
    _min?: Inducks_teammemberMinAggregateInputType
    _max?: Inducks_teammemberMaxAggregateInputType
  }

  export type Inducks_teammemberGroupByOutputType = {
    teamcode: string
    personcode: string | null
    _count: Inducks_teammemberCountAggregateOutputType | null
    _min: Inducks_teammemberMinAggregateOutputType | null
    _max: Inducks_teammemberMaxAggregateOutputType | null
  }

  type GetInducks_teammemberGroupByPayload<T extends inducks_teammemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_teammemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_teammemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_teammemberGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_teammemberGroupByOutputType[P]>
        }
      >
    >


  export type inducks_teammemberSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    teamcode?: boolean
    personcode?: boolean
  }, ExtArgs["result"]["inducks_teammember"]>

  export type inducks_teammemberSelectScalar = {
    teamcode?: boolean
    personcode?: boolean
  }


  export type $inducks_teammemberPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_teammember"
    objects: {}
    scalars: $Extensions.GetResult<{
      teamcode: string
      personcode: string | null
    }, ExtArgs["result"]["inducks_teammember"]>
    composites: {}
  }


  type inducks_teammemberGetPayload<S extends boolean | null | undefined | inducks_teammemberDefaultArgs> = $Result.GetResult<Prisma.$inducks_teammemberPayload, S>

  type inducks_teammemberCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_teammemberFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_teammemberCountAggregateInputType | true
    }

  export interface inducks_teammemberDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_teammember'], meta: { name: 'inducks_teammember' } }
    /**
     * Find zero or one Inducks_teammember that matches the filter.
     * @param {inducks_teammemberFindUniqueArgs} args - Arguments to find a Inducks_teammember
     * @example
     * // Get one Inducks_teammember
     * const inducks_teammember = await prisma.inducks_teammember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_teammemberFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_teammemberFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_teammemberClient<$Result.GetResult<Prisma.$inducks_teammemberPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_teammember that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_teammemberFindUniqueOrThrowArgs} args - Arguments to find a Inducks_teammember
     * @example
     * // Get one Inducks_teammember
     * const inducks_teammember = await prisma.inducks_teammember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_teammemberFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_teammemberFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_teammemberClient<$Result.GetResult<Prisma.$inducks_teammemberPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_teammember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_teammemberFindFirstArgs} args - Arguments to find a Inducks_teammember
     * @example
     * // Get one Inducks_teammember
     * const inducks_teammember = await prisma.inducks_teammember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_teammemberFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_teammemberFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_teammemberClient<$Result.GetResult<Prisma.$inducks_teammemberPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_teammember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_teammemberFindFirstOrThrowArgs} args - Arguments to find a Inducks_teammember
     * @example
     * // Get one Inducks_teammember
     * const inducks_teammember = await prisma.inducks_teammember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_teammemberFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_teammemberFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_teammemberClient<$Result.GetResult<Prisma.$inducks_teammemberPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_teammembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_teammemberFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_teammembers
     * const inducks_teammembers = await prisma.inducks_teammember.findMany()
     * 
     * // Get first 10 Inducks_teammembers
     * const inducks_teammembers = await prisma.inducks_teammember.findMany({ take: 10 })
     * 
     * // Only select the `teamcode`
     * const inducks_teammemberWithTeamcodeOnly = await prisma.inducks_teammember.findMany({ select: { teamcode: true } })
     * 
    **/
    findMany<T extends inducks_teammemberFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_teammemberFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_teammemberPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_teammember.
     * @param {inducks_teammemberCreateArgs} args - Arguments to create a Inducks_teammember.
     * @example
     * // Create one Inducks_teammember
     * const Inducks_teammember = await prisma.inducks_teammember.create({
     *   data: {
     *     // ... data to create a Inducks_teammember
     *   }
     * })
     * 
    **/
    create<T extends inducks_teammemberCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_teammemberCreateArgs<ExtArgs>>
    ): Prisma__inducks_teammemberClient<$Result.GetResult<Prisma.$inducks_teammemberPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_teammembers.
     *     @param {inducks_teammemberCreateManyArgs} args - Arguments to create many Inducks_teammembers.
     *     @example
     *     // Create many Inducks_teammembers
     *     const inducks_teammember = await prisma.inducks_teammember.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_teammemberCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_teammemberCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_teammember.
     * @param {inducks_teammemberDeleteArgs} args - Arguments to delete one Inducks_teammember.
     * @example
     * // Delete one Inducks_teammember
     * const Inducks_teammember = await prisma.inducks_teammember.delete({
     *   where: {
     *     // ... filter to delete one Inducks_teammember
     *   }
     * })
     * 
    **/
    delete<T extends inducks_teammemberDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_teammemberDeleteArgs<ExtArgs>>
    ): Prisma__inducks_teammemberClient<$Result.GetResult<Prisma.$inducks_teammemberPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_teammember.
     * @param {inducks_teammemberUpdateArgs} args - Arguments to update one Inducks_teammember.
     * @example
     * // Update one Inducks_teammember
     * const inducks_teammember = await prisma.inducks_teammember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_teammemberUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_teammemberUpdateArgs<ExtArgs>>
    ): Prisma__inducks_teammemberClient<$Result.GetResult<Prisma.$inducks_teammemberPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_teammembers.
     * @param {inducks_teammemberDeleteManyArgs} args - Arguments to filter Inducks_teammembers to delete.
     * @example
     * // Delete a few Inducks_teammembers
     * const { count } = await prisma.inducks_teammember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_teammemberDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_teammemberDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_teammembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_teammemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_teammembers
     * const inducks_teammember = await prisma.inducks_teammember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_teammemberUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_teammemberUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_teammember.
     * @param {inducks_teammemberUpsertArgs} args - Arguments to update or create a Inducks_teammember.
     * @example
     * // Update or create a Inducks_teammember
     * const inducks_teammember = await prisma.inducks_teammember.upsert({
     *   create: {
     *     // ... data to create a Inducks_teammember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_teammember we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_teammemberUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_teammemberUpsertArgs<ExtArgs>>
    ): Prisma__inducks_teammemberClient<$Result.GetResult<Prisma.$inducks_teammemberPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_teammembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_teammemberCountArgs} args - Arguments to filter Inducks_teammembers to count.
     * @example
     * // Count the number of Inducks_teammembers
     * const count = await prisma.inducks_teammember.count({
     *   where: {
     *     // ... the filter for the Inducks_teammembers we want to count
     *   }
     * })
    **/
    count<T extends inducks_teammemberCountArgs>(
      args?: Subset<T, inducks_teammemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_teammemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_teammember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_teammemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_teammemberAggregateArgs>(args: Subset<T, Inducks_teammemberAggregateArgs>): Prisma.PrismaPromise<GetInducks_teammemberAggregateType<T>>

    /**
     * Group by Inducks_teammember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_teammemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_teammemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_teammemberGroupByArgs['orderBy'] }
        : { orderBy?: inducks_teammemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_teammemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_teammemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_teammember model
   */
  readonly fields: inducks_teammemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_teammember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_teammemberClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_teammember model
   */ 
  interface inducks_teammemberFieldRefs {
    readonly teamcode: FieldRef<"inducks_teammember", 'String'>
    readonly personcode: FieldRef<"inducks_teammember", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_teammember findUnique
   */
  export type inducks_teammemberFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_teammember
     */
    select?: inducks_teammemberSelect<ExtArgs> | null
    /**
     * Filter, which inducks_teammember to fetch.
     */
    where: inducks_teammemberWhereUniqueInput
  }


  /**
   * inducks_teammember findUniqueOrThrow
   */
  export type inducks_teammemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_teammember
     */
    select?: inducks_teammemberSelect<ExtArgs> | null
    /**
     * Filter, which inducks_teammember to fetch.
     */
    where: inducks_teammemberWhereUniqueInput
  }


  /**
   * inducks_teammember findFirst
   */
  export type inducks_teammemberFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_teammember
     */
    select?: inducks_teammemberSelect<ExtArgs> | null
    /**
     * Filter, which inducks_teammember to fetch.
     */
    where?: inducks_teammemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_teammembers to fetch.
     */
    orderBy?: inducks_teammemberOrderByWithRelationInput | inducks_teammemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_teammembers.
     */
    cursor?: inducks_teammemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_teammembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_teammembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_teammembers.
     */
    distinct?: Inducks_teammemberScalarFieldEnum | Inducks_teammemberScalarFieldEnum[]
  }


  /**
   * inducks_teammember findFirstOrThrow
   */
  export type inducks_teammemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_teammember
     */
    select?: inducks_teammemberSelect<ExtArgs> | null
    /**
     * Filter, which inducks_teammember to fetch.
     */
    where?: inducks_teammemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_teammembers to fetch.
     */
    orderBy?: inducks_teammemberOrderByWithRelationInput | inducks_teammemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_teammembers.
     */
    cursor?: inducks_teammemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_teammembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_teammembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_teammembers.
     */
    distinct?: Inducks_teammemberScalarFieldEnum | Inducks_teammemberScalarFieldEnum[]
  }


  /**
   * inducks_teammember findMany
   */
  export type inducks_teammemberFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_teammember
     */
    select?: inducks_teammemberSelect<ExtArgs> | null
    /**
     * Filter, which inducks_teammembers to fetch.
     */
    where?: inducks_teammemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_teammembers to fetch.
     */
    orderBy?: inducks_teammemberOrderByWithRelationInput | inducks_teammemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_teammembers.
     */
    cursor?: inducks_teammemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_teammembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_teammembers.
     */
    skip?: number
    distinct?: Inducks_teammemberScalarFieldEnum | Inducks_teammemberScalarFieldEnum[]
  }


  /**
   * inducks_teammember create
   */
  export type inducks_teammemberCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_teammember
     */
    select?: inducks_teammemberSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_teammember.
     */
    data: XOR<inducks_teammemberCreateInput, inducks_teammemberUncheckedCreateInput>
  }


  /**
   * inducks_teammember createMany
   */
  export type inducks_teammemberCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_teammembers.
     */
    data: inducks_teammemberCreateManyInput | inducks_teammemberCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_teammember update
   */
  export type inducks_teammemberUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_teammember
     */
    select?: inducks_teammemberSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_teammember.
     */
    data: XOR<inducks_teammemberUpdateInput, inducks_teammemberUncheckedUpdateInput>
    /**
     * Choose, which inducks_teammember to update.
     */
    where: inducks_teammemberWhereUniqueInput
  }


  /**
   * inducks_teammember updateMany
   */
  export type inducks_teammemberUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_teammembers.
     */
    data: XOR<inducks_teammemberUpdateManyMutationInput, inducks_teammemberUncheckedUpdateManyInput>
    /**
     * Filter which inducks_teammembers to update
     */
    where?: inducks_teammemberWhereInput
  }


  /**
   * inducks_teammember upsert
   */
  export type inducks_teammemberUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_teammember
     */
    select?: inducks_teammemberSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_teammember to update in case it exists.
     */
    where: inducks_teammemberWhereUniqueInput
    /**
     * In case the inducks_teammember found by the `where` argument doesn't exist, create a new inducks_teammember with this data.
     */
    create: XOR<inducks_teammemberCreateInput, inducks_teammemberUncheckedCreateInput>
    /**
     * In case the inducks_teammember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_teammemberUpdateInput, inducks_teammemberUncheckedUpdateInput>
  }


  /**
   * inducks_teammember delete
   */
  export type inducks_teammemberDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_teammember
     */
    select?: inducks_teammemberSelect<ExtArgs> | null
    /**
     * Filter which inducks_teammember to delete.
     */
    where: inducks_teammemberWhereUniqueInput
  }


  /**
   * inducks_teammember deleteMany
   */
  export type inducks_teammemberDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_teammembers to delete
     */
    where?: inducks_teammemberWhereInput
  }


  /**
   * inducks_teammember without action
   */
  export type inducks_teammemberDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_teammember
     */
    select?: inducks_teammemberSelect<ExtArgs> | null
  }



  /**
   * Model inducks_ucrelation
   */

  export type AggregateInducks_ucrelation = {
    _count: Inducks_ucrelationCountAggregateOutputType | null
    _min: Inducks_ucrelationMinAggregateOutputType | null
    _max: Inducks_ucrelationMaxAggregateOutputType | null
  }

  export type Inducks_ucrelationMinAggregateOutputType = {
    universecode: string | null
    charactercode: string | null
  }

  export type Inducks_ucrelationMaxAggregateOutputType = {
    universecode: string | null
    charactercode: string | null
  }

  export type Inducks_ucrelationCountAggregateOutputType = {
    universecode: number
    charactercode: number
    _all: number
  }


  export type Inducks_ucrelationMinAggregateInputType = {
    universecode?: true
    charactercode?: true
  }

  export type Inducks_ucrelationMaxAggregateInputType = {
    universecode?: true
    charactercode?: true
  }

  export type Inducks_ucrelationCountAggregateInputType = {
    universecode?: true
    charactercode?: true
    _all?: true
  }

  export type Inducks_ucrelationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_ucrelation to aggregate.
     */
    where?: inducks_ucrelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_ucrelations to fetch.
     */
    orderBy?: inducks_ucrelationOrderByWithRelationInput | inducks_ucrelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_ucrelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_ucrelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_ucrelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_ucrelations
    **/
    _count?: true | Inducks_ucrelationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_ucrelationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_ucrelationMaxAggregateInputType
  }

  export type GetInducks_ucrelationAggregateType<T extends Inducks_ucrelationAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_ucrelation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_ucrelation[P]>
      : GetScalarType<T[P], AggregateInducks_ucrelation[P]>
  }




  export type inducks_ucrelationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_ucrelationWhereInput
    orderBy?: inducks_ucrelationOrderByWithAggregationInput | inducks_ucrelationOrderByWithAggregationInput[]
    by: Inducks_ucrelationScalarFieldEnum[] | Inducks_ucrelationScalarFieldEnum
    having?: inducks_ucrelationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_ucrelationCountAggregateInputType | true
    _min?: Inducks_ucrelationMinAggregateInputType
    _max?: Inducks_ucrelationMaxAggregateInputType
  }

  export type Inducks_ucrelationGroupByOutputType = {
    universecode: string
    charactercode: string
    _count: Inducks_ucrelationCountAggregateOutputType | null
    _min: Inducks_ucrelationMinAggregateOutputType | null
    _max: Inducks_ucrelationMaxAggregateOutputType | null
  }

  type GetInducks_ucrelationGroupByPayload<T extends inducks_ucrelationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_ucrelationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_ucrelationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_ucrelationGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_ucrelationGroupByOutputType[P]>
        }
      >
    >


  export type inducks_ucrelationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    universecode?: boolean
    charactercode?: boolean
  }, ExtArgs["result"]["inducks_ucrelation"]>

  export type inducks_ucrelationSelectScalar = {
    universecode?: boolean
    charactercode?: boolean
  }


  export type $inducks_ucrelationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_ucrelation"
    objects: {}
    scalars: $Extensions.GetResult<{
      universecode: string
      charactercode: string
    }, ExtArgs["result"]["inducks_ucrelation"]>
    composites: {}
  }


  type inducks_ucrelationGetPayload<S extends boolean | null | undefined | inducks_ucrelationDefaultArgs> = $Result.GetResult<Prisma.$inducks_ucrelationPayload, S>

  type inducks_ucrelationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_ucrelationFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_ucrelationCountAggregateInputType | true
    }

  export interface inducks_ucrelationDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_ucrelation'], meta: { name: 'inducks_ucrelation' } }
    /**
     * Find zero or one Inducks_ucrelation that matches the filter.
     * @param {inducks_ucrelationFindUniqueArgs} args - Arguments to find a Inducks_ucrelation
     * @example
     * // Get one Inducks_ucrelation
     * const inducks_ucrelation = await prisma.inducks_ucrelation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_ucrelationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_ucrelationFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_ucrelationClient<$Result.GetResult<Prisma.$inducks_ucrelationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_ucrelation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_ucrelationFindUniqueOrThrowArgs} args - Arguments to find a Inducks_ucrelation
     * @example
     * // Get one Inducks_ucrelation
     * const inducks_ucrelation = await prisma.inducks_ucrelation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_ucrelationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_ucrelationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_ucrelationClient<$Result.GetResult<Prisma.$inducks_ucrelationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_ucrelation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_ucrelationFindFirstArgs} args - Arguments to find a Inducks_ucrelation
     * @example
     * // Get one Inducks_ucrelation
     * const inducks_ucrelation = await prisma.inducks_ucrelation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_ucrelationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_ucrelationFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_ucrelationClient<$Result.GetResult<Prisma.$inducks_ucrelationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_ucrelation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_ucrelationFindFirstOrThrowArgs} args - Arguments to find a Inducks_ucrelation
     * @example
     * // Get one Inducks_ucrelation
     * const inducks_ucrelation = await prisma.inducks_ucrelation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_ucrelationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_ucrelationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_ucrelationClient<$Result.GetResult<Prisma.$inducks_ucrelationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_ucrelations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_ucrelationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_ucrelations
     * const inducks_ucrelations = await prisma.inducks_ucrelation.findMany()
     * 
     * // Get first 10 Inducks_ucrelations
     * const inducks_ucrelations = await prisma.inducks_ucrelation.findMany({ take: 10 })
     * 
     * // Only select the `universecode`
     * const inducks_ucrelationWithUniversecodeOnly = await prisma.inducks_ucrelation.findMany({ select: { universecode: true } })
     * 
    **/
    findMany<T extends inducks_ucrelationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_ucrelationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_ucrelationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_ucrelation.
     * @param {inducks_ucrelationCreateArgs} args - Arguments to create a Inducks_ucrelation.
     * @example
     * // Create one Inducks_ucrelation
     * const Inducks_ucrelation = await prisma.inducks_ucrelation.create({
     *   data: {
     *     // ... data to create a Inducks_ucrelation
     *   }
     * })
     * 
    **/
    create<T extends inducks_ucrelationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_ucrelationCreateArgs<ExtArgs>>
    ): Prisma__inducks_ucrelationClient<$Result.GetResult<Prisma.$inducks_ucrelationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_ucrelations.
     *     @param {inducks_ucrelationCreateManyArgs} args - Arguments to create many Inducks_ucrelations.
     *     @example
     *     // Create many Inducks_ucrelations
     *     const inducks_ucrelation = await prisma.inducks_ucrelation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_ucrelationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_ucrelationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_ucrelation.
     * @param {inducks_ucrelationDeleteArgs} args - Arguments to delete one Inducks_ucrelation.
     * @example
     * // Delete one Inducks_ucrelation
     * const Inducks_ucrelation = await prisma.inducks_ucrelation.delete({
     *   where: {
     *     // ... filter to delete one Inducks_ucrelation
     *   }
     * })
     * 
    **/
    delete<T extends inducks_ucrelationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_ucrelationDeleteArgs<ExtArgs>>
    ): Prisma__inducks_ucrelationClient<$Result.GetResult<Prisma.$inducks_ucrelationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_ucrelation.
     * @param {inducks_ucrelationUpdateArgs} args - Arguments to update one Inducks_ucrelation.
     * @example
     * // Update one Inducks_ucrelation
     * const inducks_ucrelation = await prisma.inducks_ucrelation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_ucrelationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_ucrelationUpdateArgs<ExtArgs>>
    ): Prisma__inducks_ucrelationClient<$Result.GetResult<Prisma.$inducks_ucrelationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_ucrelations.
     * @param {inducks_ucrelationDeleteManyArgs} args - Arguments to filter Inducks_ucrelations to delete.
     * @example
     * // Delete a few Inducks_ucrelations
     * const { count } = await prisma.inducks_ucrelation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_ucrelationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_ucrelationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_ucrelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_ucrelationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_ucrelations
     * const inducks_ucrelation = await prisma.inducks_ucrelation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_ucrelationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_ucrelationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_ucrelation.
     * @param {inducks_ucrelationUpsertArgs} args - Arguments to update or create a Inducks_ucrelation.
     * @example
     * // Update or create a Inducks_ucrelation
     * const inducks_ucrelation = await prisma.inducks_ucrelation.upsert({
     *   create: {
     *     // ... data to create a Inducks_ucrelation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_ucrelation we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_ucrelationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_ucrelationUpsertArgs<ExtArgs>>
    ): Prisma__inducks_ucrelationClient<$Result.GetResult<Prisma.$inducks_ucrelationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_ucrelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_ucrelationCountArgs} args - Arguments to filter Inducks_ucrelations to count.
     * @example
     * // Count the number of Inducks_ucrelations
     * const count = await prisma.inducks_ucrelation.count({
     *   where: {
     *     // ... the filter for the Inducks_ucrelations we want to count
     *   }
     * })
    **/
    count<T extends inducks_ucrelationCountArgs>(
      args?: Subset<T, inducks_ucrelationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_ucrelationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_ucrelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_ucrelationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_ucrelationAggregateArgs>(args: Subset<T, Inducks_ucrelationAggregateArgs>): Prisma.PrismaPromise<GetInducks_ucrelationAggregateType<T>>

    /**
     * Group by Inducks_ucrelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_ucrelationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_ucrelationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_ucrelationGroupByArgs['orderBy'] }
        : { orderBy?: inducks_ucrelationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_ucrelationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_ucrelationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_ucrelation model
   */
  readonly fields: inducks_ucrelationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_ucrelation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_ucrelationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_ucrelation model
   */ 
  interface inducks_ucrelationFieldRefs {
    readonly universecode: FieldRef<"inducks_ucrelation", 'String'>
    readonly charactercode: FieldRef<"inducks_ucrelation", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_ucrelation findUnique
   */
  export type inducks_ucrelationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_ucrelation
     */
    select?: inducks_ucrelationSelect<ExtArgs> | null
    /**
     * Filter, which inducks_ucrelation to fetch.
     */
    where: inducks_ucrelationWhereUniqueInput
  }


  /**
   * inducks_ucrelation findUniqueOrThrow
   */
  export type inducks_ucrelationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_ucrelation
     */
    select?: inducks_ucrelationSelect<ExtArgs> | null
    /**
     * Filter, which inducks_ucrelation to fetch.
     */
    where: inducks_ucrelationWhereUniqueInput
  }


  /**
   * inducks_ucrelation findFirst
   */
  export type inducks_ucrelationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_ucrelation
     */
    select?: inducks_ucrelationSelect<ExtArgs> | null
    /**
     * Filter, which inducks_ucrelation to fetch.
     */
    where?: inducks_ucrelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_ucrelations to fetch.
     */
    orderBy?: inducks_ucrelationOrderByWithRelationInput | inducks_ucrelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_ucrelations.
     */
    cursor?: inducks_ucrelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_ucrelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_ucrelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_ucrelations.
     */
    distinct?: Inducks_ucrelationScalarFieldEnum | Inducks_ucrelationScalarFieldEnum[]
  }


  /**
   * inducks_ucrelation findFirstOrThrow
   */
  export type inducks_ucrelationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_ucrelation
     */
    select?: inducks_ucrelationSelect<ExtArgs> | null
    /**
     * Filter, which inducks_ucrelation to fetch.
     */
    where?: inducks_ucrelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_ucrelations to fetch.
     */
    orderBy?: inducks_ucrelationOrderByWithRelationInput | inducks_ucrelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_ucrelations.
     */
    cursor?: inducks_ucrelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_ucrelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_ucrelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_ucrelations.
     */
    distinct?: Inducks_ucrelationScalarFieldEnum | Inducks_ucrelationScalarFieldEnum[]
  }


  /**
   * inducks_ucrelation findMany
   */
  export type inducks_ucrelationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_ucrelation
     */
    select?: inducks_ucrelationSelect<ExtArgs> | null
    /**
     * Filter, which inducks_ucrelations to fetch.
     */
    where?: inducks_ucrelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_ucrelations to fetch.
     */
    orderBy?: inducks_ucrelationOrderByWithRelationInput | inducks_ucrelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_ucrelations.
     */
    cursor?: inducks_ucrelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_ucrelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_ucrelations.
     */
    skip?: number
    distinct?: Inducks_ucrelationScalarFieldEnum | Inducks_ucrelationScalarFieldEnum[]
  }


  /**
   * inducks_ucrelation create
   */
  export type inducks_ucrelationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_ucrelation
     */
    select?: inducks_ucrelationSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_ucrelation.
     */
    data: XOR<inducks_ucrelationCreateInput, inducks_ucrelationUncheckedCreateInput>
  }


  /**
   * inducks_ucrelation createMany
   */
  export type inducks_ucrelationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_ucrelations.
     */
    data: inducks_ucrelationCreateManyInput | inducks_ucrelationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_ucrelation update
   */
  export type inducks_ucrelationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_ucrelation
     */
    select?: inducks_ucrelationSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_ucrelation.
     */
    data: XOR<inducks_ucrelationUpdateInput, inducks_ucrelationUncheckedUpdateInput>
    /**
     * Choose, which inducks_ucrelation to update.
     */
    where: inducks_ucrelationWhereUniqueInput
  }


  /**
   * inducks_ucrelation updateMany
   */
  export type inducks_ucrelationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_ucrelations.
     */
    data: XOR<inducks_ucrelationUpdateManyMutationInput, inducks_ucrelationUncheckedUpdateManyInput>
    /**
     * Filter which inducks_ucrelations to update
     */
    where?: inducks_ucrelationWhereInput
  }


  /**
   * inducks_ucrelation upsert
   */
  export type inducks_ucrelationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_ucrelation
     */
    select?: inducks_ucrelationSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_ucrelation to update in case it exists.
     */
    where: inducks_ucrelationWhereUniqueInput
    /**
     * In case the inducks_ucrelation found by the `where` argument doesn't exist, create a new inducks_ucrelation with this data.
     */
    create: XOR<inducks_ucrelationCreateInput, inducks_ucrelationUncheckedCreateInput>
    /**
     * In case the inducks_ucrelation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_ucrelationUpdateInput, inducks_ucrelationUncheckedUpdateInput>
  }


  /**
   * inducks_ucrelation delete
   */
  export type inducks_ucrelationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_ucrelation
     */
    select?: inducks_ucrelationSelect<ExtArgs> | null
    /**
     * Filter which inducks_ucrelation to delete.
     */
    where: inducks_ucrelationWhereUniqueInput
  }


  /**
   * inducks_ucrelation deleteMany
   */
  export type inducks_ucrelationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_ucrelations to delete
     */
    where?: inducks_ucrelationWhereInput
  }


  /**
   * inducks_ucrelation without action
   */
  export type inducks_ucrelationDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_ucrelation
     */
    select?: inducks_ucrelationSelect<ExtArgs> | null
  }



  /**
   * Model inducks_universe
   */

  export type AggregateInducks_universe = {
    _count: Inducks_universeCountAggregateOutputType | null
    _min: Inducks_universeMinAggregateOutputType | null
    _max: Inducks_universeMaxAggregateOutputType | null
  }

  export type Inducks_universeMinAggregateOutputType = {
    universecode: string | null
    universecomment: string | null
  }

  export type Inducks_universeMaxAggregateOutputType = {
    universecode: string | null
    universecomment: string | null
  }

  export type Inducks_universeCountAggregateOutputType = {
    universecode: number
    universecomment: number
    _all: number
  }


  export type Inducks_universeMinAggregateInputType = {
    universecode?: true
    universecomment?: true
  }

  export type Inducks_universeMaxAggregateInputType = {
    universecode?: true
    universecomment?: true
  }

  export type Inducks_universeCountAggregateInputType = {
    universecode?: true
    universecomment?: true
    _all?: true
  }

  export type Inducks_universeAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_universe to aggregate.
     */
    where?: inducks_universeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_universes to fetch.
     */
    orderBy?: inducks_universeOrderByWithRelationInput | inducks_universeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_universeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_universes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_universes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_universes
    **/
    _count?: true | Inducks_universeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_universeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_universeMaxAggregateInputType
  }

  export type GetInducks_universeAggregateType<T extends Inducks_universeAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_universe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_universe[P]>
      : GetScalarType<T[P], AggregateInducks_universe[P]>
  }




  export type inducks_universeGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_universeWhereInput
    orderBy?: inducks_universeOrderByWithAggregationInput | inducks_universeOrderByWithAggregationInput[]
    by: Inducks_universeScalarFieldEnum[] | Inducks_universeScalarFieldEnum
    having?: inducks_universeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_universeCountAggregateInputType | true
    _min?: Inducks_universeMinAggregateInputType
    _max?: Inducks_universeMaxAggregateInputType
  }

  export type Inducks_universeGroupByOutputType = {
    universecode: string
    universecomment: string | null
    _count: Inducks_universeCountAggregateOutputType | null
    _min: Inducks_universeMinAggregateOutputType | null
    _max: Inducks_universeMaxAggregateOutputType | null
  }

  type GetInducks_universeGroupByPayload<T extends inducks_universeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_universeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_universeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_universeGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_universeGroupByOutputType[P]>
        }
      >
    >


  export type inducks_universeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    universecode?: boolean
    universecomment?: boolean
  }, ExtArgs["result"]["inducks_universe"]>

  export type inducks_universeSelectScalar = {
    universecode?: boolean
    universecomment?: boolean
  }


  export type $inducks_universePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_universe"
    objects: {}
    scalars: $Extensions.GetResult<{
      universecode: string
      universecomment: string | null
    }, ExtArgs["result"]["inducks_universe"]>
    composites: {}
  }


  type inducks_universeGetPayload<S extends boolean | null | undefined | inducks_universeDefaultArgs> = $Result.GetResult<Prisma.$inducks_universePayload, S>

  type inducks_universeCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_universeFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_universeCountAggregateInputType | true
    }

  export interface inducks_universeDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_universe'], meta: { name: 'inducks_universe' } }
    /**
     * Find zero or one Inducks_universe that matches the filter.
     * @param {inducks_universeFindUniqueArgs} args - Arguments to find a Inducks_universe
     * @example
     * // Get one Inducks_universe
     * const inducks_universe = await prisma.inducks_universe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_universeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_universeFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_universeClient<$Result.GetResult<Prisma.$inducks_universePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_universe that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_universeFindUniqueOrThrowArgs} args - Arguments to find a Inducks_universe
     * @example
     * // Get one Inducks_universe
     * const inducks_universe = await prisma.inducks_universe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_universeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_universeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_universeClient<$Result.GetResult<Prisma.$inducks_universePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_universe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_universeFindFirstArgs} args - Arguments to find a Inducks_universe
     * @example
     * // Get one Inducks_universe
     * const inducks_universe = await prisma.inducks_universe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_universeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_universeFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_universeClient<$Result.GetResult<Prisma.$inducks_universePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_universe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_universeFindFirstOrThrowArgs} args - Arguments to find a Inducks_universe
     * @example
     * // Get one Inducks_universe
     * const inducks_universe = await prisma.inducks_universe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_universeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_universeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_universeClient<$Result.GetResult<Prisma.$inducks_universePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_universes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_universeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_universes
     * const inducks_universes = await prisma.inducks_universe.findMany()
     * 
     * // Get first 10 Inducks_universes
     * const inducks_universes = await prisma.inducks_universe.findMany({ take: 10 })
     * 
     * // Only select the `universecode`
     * const inducks_universeWithUniversecodeOnly = await prisma.inducks_universe.findMany({ select: { universecode: true } })
     * 
    **/
    findMany<T extends inducks_universeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_universeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_universePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_universe.
     * @param {inducks_universeCreateArgs} args - Arguments to create a Inducks_universe.
     * @example
     * // Create one Inducks_universe
     * const Inducks_universe = await prisma.inducks_universe.create({
     *   data: {
     *     // ... data to create a Inducks_universe
     *   }
     * })
     * 
    **/
    create<T extends inducks_universeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_universeCreateArgs<ExtArgs>>
    ): Prisma__inducks_universeClient<$Result.GetResult<Prisma.$inducks_universePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_universes.
     *     @param {inducks_universeCreateManyArgs} args - Arguments to create many Inducks_universes.
     *     @example
     *     // Create many Inducks_universes
     *     const inducks_universe = await prisma.inducks_universe.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_universeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_universeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_universe.
     * @param {inducks_universeDeleteArgs} args - Arguments to delete one Inducks_universe.
     * @example
     * // Delete one Inducks_universe
     * const Inducks_universe = await prisma.inducks_universe.delete({
     *   where: {
     *     // ... filter to delete one Inducks_universe
     *   }
     * })
     * 
    **/
    delete<T extends inducks_universeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_universeDeleteArgs<ExtArgs>>
    ): Prisma__inducks_universeClient<$Result.GetResult<Prisma.$inducks_universePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_universe.
     * @param {inducks_universeUpdateArgs} args - Arguments to update one Inducks_universe.
     * @example
     * // Update one Inducks_universe
     * const inducks_universe = await prisma.inducks_universe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_universeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_universeUpdateArgs<ExtArgs>>
    ): Prisma__inducks_universeClient<$Result.GetResult<Prisma.$inducks_universePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_universes.
     * @param {inducks_universeDeleteManyArgs} args - Arguments to filter Inducks_universes to delete.
     * @example
     * // Delete a few Inducks_universes
     * const { count } = await prisma.inducks_universe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_universeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_universeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_universes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_universeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_universes
     * const inducks_universe = await prisma.inducks_universe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_universeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_universeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_universe.
     * @param {inducks_universeUpsertArgs} args - Arguments to update or create a Inducks_universe.
     * @example
     * // Update or create a Inducks_universe
     * const inducks_universe = await prisma.inducks_universe.upsert({
     *   create: {
     *     // ... data to create a Inducks_universe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_universe we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_universeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_universeUpsertArgs<ExtArgs>>
    ): Prisma__inducks_universeClient<$Result.GetResult<Prisma.$inducks_universePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_universes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_universeCountArgs} args - Arguments to filter Inducks_universes to count.
     * @example
     * // Count the number of Inducks_universes
     * const count = await prisma.inducks_universe.count({
     *   where: {
     *     // ... the filter for the Inducks_universes we want to count
     *   }
     * })
    **/
    count<T extends inducks_universeCountArgs>(
      args?: Subset<T, inducks_universeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_universeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_universe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_universeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_universeAggregateArgs>(args: Subset<T, Inducks_universeAggregateArgs>): Prisma.PrismaPromise<GetInducks_universeAggregateType<T>>

    /**
     * Group by Inducks_universe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_universeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_universeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_universeGroupByArgs['orderBy'] }
        : { orderBy?: inducks_universeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_universeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_universeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_universe model
   */
  readonly fields: inducks_universeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_universe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_universeClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_universe model
   */ 
  interface inducks_universeFieldRefs {
    readonly universecode: FieldRef<"inducks_universe", 'String'>
    readonly universecomment: FieldRef<"inducks_universe", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_universe findUnique
   */
  export type inducks_universeFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_universe
     */
    select?: inducks_universeSelect<ExtArgs> | null
    /**
     * Filter, which inducks_universe to fetch.
     */
    where: inducks_universeWhereUniqueInput
  }


  /**
   * inducks_universe findUniqueOrThrow
   */
  export type inducks_universeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_universe
     */
    select?: inducks_universeSelect<ExtArgs> | null
    /**
     * Filter, which inducks_universe to fetch.
     */
    where: inducks_universeWhereUniqueInput
  }


  /**
   * inducks_universe findFirst
   */
  export type inducks_universeFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_universe
     */
    select?: inducks_universeSelect<ExtArgs> | null
    /**
     * Filter, which inducks_universe to fetch.
     */
    where?: inducks_universeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_universes to fetch.
     */
    orderBy?: inducks_universeOrderByWithRelationInput | inducks_universeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_universes.
     */
    cursor?: inducks_universeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_universes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_universes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_universes.
     */
    distinct?: Inducks_universeScalarFieldEnum | Inducks_universeScalarFieldEnum[]
  }


  /**
   * inducks_universe findFirstOrThrow
   */
  export type inducks_universeFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_universe
     */
    select?: inducks_universeSelect<ExtArgs> | null
    /**
     * Filter, which inducks_universe to fetch.
     */
    where?: inducks_universeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_universes to fetch.
     */
    orderBy?: inducks_universeOrderByWithRelationInput | inducks_universeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_universes.
     */
    cursor?: inducks_universeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_universes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_universes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_universes.
     */
    distinct?: Inducks_universeScalarFieldEnum | Inducks_universeScalarFieldEnum[]
  }


  /**
   * inducks_universe findMany
   */
  export type inducks_universeFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_universe
     */
    select?: inducks_universeSelect<ExtArgs> | null
    /**
     * Filter, which inducks_universes to fetch.
     */
    where?: inducks_universeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_universes to fetch.
     */
    orderBy?: inducks_universeOrderByWithRelationInput | inducks_universeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_universes.
     */
    cursor?: inducks_universeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_universes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_universes.
     */
    skip?: number
    distinct?: Inducks_universeScalarFieldEnum | Inducks_universeScalarFieldEnum[]
  }


  /**
   * inducks_universe create
   */
  export type inducks_universeCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_universe
     */
    select?: inducks_universeSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_universe.
     */
    data: XOR<inducks_universeCreateInput, inducks_universeUncheckedCreateInput>
  }


  /**
   * inducks_universe createMany
   */
  export type inducks_universeCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_universes.
     */
    data: inducks_universeCreateManyInput | inducks_universeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_universe update
   */
  export type inducks_universeUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_universe
     */
    select?: inducks_universeSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_universe.
     */
    data: XOR<inducks_universeUpdateInput, inducks_universeUncheckedUpdateInput>
    /**
     * Choose, which inducks_universe to update.
     */
    where: inducks_universeWhereUniqueInput
  }


  /**
   * inducks_universe updateMany
   */
  export type inducks_universeUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_universes.
     */
    data: XOR<inducks_universeUpdateManyMutationInput, inducks_universeUncheckedUpdateManyInput>
    /**
     * Filter which inducks_universes to update
     */
    where?: inducks_universeWhereInput
  }


  /**
   * inducks_universe upsert
   */
  export type inducks_universeUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_universe
     */
    select?: inducks_universeSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_universe to update in case it exists.
     */
    where: inducks_universeWhereUniqueInput
    /**
     * In case the inducks_universe found by the `where` argument doesn't exist, create a new inducks_universe with this data.
     */
    create: XOR<inducks_universeCreateInput, inducks_universeUncheckedCreateInput>
    /**
     * In case the inducks_universe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_universeUpdateInput, inducks_universeUncheckedUpdateInput>
  }


  /**
   * inducks_universe delete
   */
  export type inducks_universeDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_universe
     */
    select?: inducks_universeSelect<ExtArgs> | null
    /**
     * Filter which inducks_universe to delete.
     */
    where: inducks_universeWhereUniqueInput
  }


  /**
   * inducks_universe deleteMany
   */
  export type inducks_universeDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_universes to delete
     */
    where?: inducks_universeWhereInput
  }


  /**
   * inducks_universe without action
   */
  export type inducks_universeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_universe
     */
    select?: inducks_universeSelect<ExtArgs> | null
  }



  /**
   * Model inducks_universename
   */

  export type AggregateInducks_universename = {
    _count: Inducks_universenameCountAggregateOutputType | null
    _min: Inducks_universenameMinAggregateOutputType | null
    _max: Inducks_universenameMaxAggregateOutputType | null
  }

  export type Inducks_universenameMinAggregateOutputType = {
    universecode: string | null
    languagecode: string | null
    universename: string | null
  }

  export type Inducks_universenameMaxAggregateOutputType = {
    universecode: string | null
    languagecode: string | null
    universename: string | null
  }

  export type Inducks_universenameCountAggregateOutputType = {
    universecode: number
    languagecode: number
    universename: number
    _all: number
  }


  export type Inducks_universenameMinAggregateInputType = {
    universecode?: true
    languagecode?: true
    universename?: true
  }

  export type Inducks_universenameMaxAggregateInputType = {
    universecode?: true
    languagecode?: true
    universename?: true
  }

  export type Inducks_universenameCountAggregateInputType = {
    universecode?: true
    languagecode?: true
    universename?: true
    _all?: true
  }

  export type Inducks_universenameAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_universename to aggregate.
     */
    where?: inducks_universenameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_universenames to fetch.
     */
    orderBy?: inducks_universenameOrderByWithRelationInput | inducks_universenameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inducks_universenameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_universenames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_universenames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inducks_universenames
    **/
    _count?: true | Inducks_universenameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inducks_universenameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inducks_universenameMaxAggregateInputType
  }

  export type GetInducks_universenameAggregateType<T extends Inducks_universenameAggregateArgs> = {
        [P in keyof T & keyof AggregateInducks_universename]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInducks_universename[P]>
      : GetScalarType<T[P], AggregateInducks_universename[P]>
  }




  export type inducks_universenameGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: inducks_universenameWhereInput
    orderBy?: inducks_universenameOrderByWithAggregationInput | inducks_universenameOrderByWithAggregationInput[]
    by: Inducks_universenameScalarFieldEnum[] | Inducks_universenameScalarFieldEnum
    having?: inducks_universenameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inducks_universenameCountAggregateInputType | true
    _min?: Inducks_universenameMinAggregateInputType
    _max?: Inducks_universenameMaxAggregateInputType
  }

  export type Inducks_universenameGroupByOutputType = {
    universecode: string
    languagecode: string
    universename: string | null
    _count: Inducks_universenameCountAggregateOutputType | null
    _min: Inducks_universenameMinAggregateOutputType | null
    _max: Inducks_universenameMaxAggregateOutputType | null
  }

  type GetInducks_universenameGroupByPayload<T extends inducks_universenameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inducks_universenameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inducks_universenameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inducks_universenameGroupByOutputType[P]>
            : GetScalarType<T[P], Inducks_universenameGroupByOutputType[P]>
        }
      >
    >


  export type inducks_universenameSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    universecode?: boolean
    languagecode?: boolean
    universename?: boolean
  }, ExtArgs["result"]["inducks_universename"]>

  export type inducks_universenameSelectScalar = {
    universecode?: boolean
    languagecode?: boolean
    universename?: boolean
  }


  export type $inducks_universenamePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "inducks_universename"
    objects: {}
    scalars: $Extensions.GetResult<{
      universecode: string
      languagecode: string
      universename: string | null
    }, ExtArgs["result"]["inducks_universename"]>
    composites: {}
  }


  type inducks_universenameGetPayload<S extends boolean | null | undefined | inducks_universenameDefaultArgs> = $Result.GetResult<Prisma.$inducks_universenamePayload, S>

  type inducks_universenameCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<inducks_universenameFindManyArgs, 'select' | 'include'> & {
      select?: Inducks_universenameCountAggregateInputType | true
    }

  export interface inducks_universenameDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inducks_universename'], meta: { name: 'inducks_universename' } }
    /**
     * Find zero or one Inducks_universename that matches the filter.
     * @param {inducks_universenameFindUniqueArgs} args - Arguments to find a Inducks_universename
     * @example
     * // Get one Inducks_universename
     * const inducks_universename = await prisma.inducks_universename.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inducks_universenameFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_universenameFindUniqueArgs<ExtArgs>>
    ): Prisma__inducks_universenameClient<$Result.GetResult<Prisma.$inducks_universenamePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inducks_universename that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inducks_universenameFindUniqueOrThrowArgs} args - Arguments to find a Inducks_universename
     * @example
     * // Get one Inducks_universename
     * const inducks_universename = await prisma.inducks_universename.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inducks_universenameFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_universenameFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_universenameClient<$Result.GetResult<Prisma.$inducks_universenamePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inducks_universename that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_universenameFindFirstArgs} args - Arguments to find a Inducks_universename
     * @example
     * // Get one Inducks_universename
     * const inducks_universename = await prisma.inducks_universename.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inducks_universenameFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_universenameFindFirstArgs<ExtArgs>>
    ): Prisma__inducks_universenameClient<$Result.GetResult<Prisma.$inducks_universenamePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inducks_universename that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_universenameFindFirstOrThrowArgs} args - Arguments to find a Inducks_universename
     * @example
     * // Get one Inducks_universename
     * const inducks_universename = await prisma.inducks_universename.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inducks_universenameFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_universenameFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__inducks_universenameClient<$Result.GetResult<Prisma.$inducks_universenamePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inducks_universenames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_universenameFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inducks_universenames
     * const inducks_universenames = await prisma.inducks_universename.findMany()
     * 
     * // Get first 10 Inducks_universenames
     * const inducks_universenames = await prisma.inducks_universename.findMany({ take: 10 })
     * 
     * // Only select the `universecode`
     * const inducks_universenameWithUniversecodeOnly = await prisma.inducks_universename.findMany({ select: { universecode: true } })
     * 
    **/
    findMany<T extends inducks_universenameFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_universenameFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inducks_universenamePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inducks_universename.
     * @param {inducks_universenameCreateArgs} args - Arguments to create a Inducks_universename.
     * @example
     * // Create one Inducks_universename
     * const Inducks_universename = await prisma.inducks_universename.create({
     *   data: {
     *     // ... data to create a Inducks_universename
     *   }
     * })
     * 
    **/
    create<T extends inducks_universenameCreateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_universenameCreateArgs<ExtArgs>>
    ): Prisma__inducks_universenameClient<$Result.GetResult<Prisma.$inducks_universenamePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inducks_universenames.
     *     @param {inducks_universenameCreateManyArgs} args - Arguments to create many Inducks_universenames.
     *     @example
     *     // Create many Inducks_universenames
     *     const inducks_universename = await prisma.inducks_universename.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inducks_universenameCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_universenameCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inducks_universename.
     * @param {inducks_universenameDeleteArgs} args - Arguments to delete one Inducks_universename.
     * @example
     * // Delete one Inducks_universename
     * const Inducks_universename = await prisma.inducks_universename.delete({
     *   where: {
     *     // ... filter to delete one Inducks_universename
     *   }
     * })
     * 
    **/
    delete<T extends inducks_universenameDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_universenameDeleteArgs<ExtArgs>>
    ): Prisma__inducks_universenameClient<$Result.GetResult<Prisma.$inducks_universenamePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inducks_universename.
     * @param {inducks_universenameUpdateArgs} args - Arguments to update one Inducks_universename.
     * @example
     * // Update one Inducks_universename
     * const inducks_universename = await prisma.inducks_universename.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inducks_universenameUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_universenameUpdateArgs<ExtArgs>>
    ): Prisma__inducks_universenameClient<$Result.GetResult<Prisma.$inducks_universenamePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inducks_universenames.
     * @param {inducks_universenameDeleteManyArgs} args - Arguments to filter Inducks_universenames to delete.
     * @example
     * // Delete a few Inducks_universenames
     * const { count } = await prisma.inducks_universename.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inducks_universenameDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, inducks_universenameDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inducks_universenames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_universenameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inducks_universenames
     * const inducks_universename = await prisma.inducks_universename.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inducks_universenameUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_universenameUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inducks_universename.
     * @param {inducks_universenameUpsertArgs} args - Arguments to update or create a Inducks_universename.
     * @example
     * // Update or create a Inducks_universename
     * const inducks_universename = await prisma.inducks_universename.upsert({
     *   create: {
     *     // ... data to create a Inducks_universename
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inducks_universename we want to update
     *   }
     * })
    **/
    upsert<T extends inducks_universenameUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, inducks_universenameUpsertArgs<ExtArgs>>
    ): Prisma__inducks_universenameClient<$Result.GetResult<Prisma.$inducks_universenamePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inducks_universenames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_universenameCountArgs} args - Arguments to filter Inducks_universenames to count.
     * @example
     * // Count the number of Inducks_universenames
     * const count = await prisma.inducks_universename.count({
     *   where: {
     *     // ... the filter for the Inducks_universenames we want to count
     *   }
     * })
    **/
    count<T extends inducks_universenameCountArgs>(
      args?: Subset<T, inducks_universenameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inducks_universenameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inducks_universename.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inducks_universenameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inducks_universenameAggregateArgs>(args: Subset<T, Inducks_universenameAggregateArgs>): Prisma.PrismaPromise<GetInducks_universenameAggregateType<T>>

    /**
     * Group by Inducks_universename.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inducks_universenameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inducks_universenameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inducks_universenameGroupByArgs['orderBy'] }
        : { orderBy?: inducks_universenameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inducks_universenameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInducks_universenameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inducks_universename model
   */
  readonly fields: inducks_universenameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inducks_universename.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inducks_universenameClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the inducks_universename model
   */ 
  interface inducks_universenameFieldRefs {
    readonly universecode: FieldRef<"inducks_universename", 'String'>
    readonly languagecode: FieldRef<"inducks_universename", 'String'>
    readonly universename: FieldRef<"inducks_universename", 'String'>
  }
    

  // Custom InputTypes

  /**
   * inducks_universename findUnique
   */
  export type inducks_universenameFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_universename
     */
    select?: inducks_universenameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_universename to fetch.
     */
    where: inducks_universenameWhereUniqueInput
  }


  /**
   * inducks_universename findUniqueOrThrow
   */
  export type inducks_universenameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_universename
     */
    select?: inducks_universenameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_universename to fetch.
     */
    where: inducks_universenameWhereUniqueInput
  }


  /**
   * inducks_universename findFirst
   */
  export type inducks_universenameFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_universename
     */
    select?: inducks_universenameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_universename to fetch.
     */
    where?: inducks_universenameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_universenames to fetch.
     */
    orderBy?: inducks_universenameOrderByWithRelationInput | inducks_universenameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_universenames.
     */
    cursor?: inducks_universenameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_universenames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_universenames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_universenames.
     */
    distinct?: Inducks_universenameScalarFieldEnum | Inducks_universenameScalarFieldEnum[]
  }


  /**
   * inducks_universename findFirstOrThrow
   */
  export type inducks_universenameFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_universename
     */
    select?: inducks_universenameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_universename to fetch.
     */
    where?: inducks_universenameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_universenames to fetch.
     */
    orderBy?: inducks_universenameOrderByWithRelationInput | inducks_universenameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inducks_universenames.
     */
    cursor?: inducks_universenameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_universenames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_universenames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inducks_universenames.
     */
    distinct?: Inducks_universenameScalarFieldEnum | Inducks_universenameScalarFieldEnum[]
  }


  /**
   * inducks_universename findMany
   */
  export type inducks_universenameFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_universename
     */
    select?: inducks_universenameSelect<ExtArgs> | null
    /**
     * Filter, which inducks_universenames to fetch.
     */
    where?: inducks_universenameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inducks_universenames to fetch.
     */
    orderBy?: inducks_universenameOrderByWithRelationInput | inducks_universenameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inducks_universenames.
     */
    cursor?: inducks_universenameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inducks_universenames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inducks_universenames.
     */
    skip?: number
    distinct?: Inducks_universenameScalarFieldEnum | Inducks_universenameScalarFieldEnum[]
  }


  /**
   * inducks_universename create
   */
  export type inducks_universenameCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_universename
     */
    select?: inducks_universenameSelect<ExtArgs> | null
    /**
     * The data needed to create a inducks_universename.
     */
    data: XOR<inducks_universenameCreateInput, inducks_universenameUncheckedCreateInput>
  }


  /**
   * inducks_universename createMany
   */
  export type inducks_universenameCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inducks_universenames.
     */
    data: inducks_universenameCreateManyInput | inducks_universenameCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * inducks_universename update
   */
  export type inducks_universenameUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_universename
     */
    select?: inducks_universenameSelect<ExtArgs> | null
    /**
     * The data needed to update a inducks_universename.
     */
    data: XOR<inducks_universenameUpdateInput, inducks_universenameUncheckedUpdateInput>
    /**
     * Choose, which inducks_universename to update.
     */
    where: inducks_universenameWhereUniqueInput
  }


  /**
   * inducks_universename updateMany
   */
  export type inducks_universenameUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inducks_universenames.
     */
    data: XOR<inducks_universenameUpdateManyMutationInput, inducks_universenameUncheckedUpdateManyInput>
    /**
     * Filter which inducks_universenames to update
     */
    where?: inducks_universenameWhereInput
  }


  /**
   * inducks_universename upsert
   */
  export type inducks_universenameUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_universename
     */
    select?: inducks_universenameSelect<ExtArgs> | null
    /**
     * The filter to search for the inducks_universename to update in case it exists.
     */
    where: inducks_universenameWhereUniqueInput
    /**
     * In case the inducks_universename found by the `where` argument doesn't exist, create a new inducks_universename with this data.
     */
    create: XOR<inducks_universenameCreateInput, inducks_universenameUncheckedCreateInput>
    /**
     * In case the inducks_universename was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inducks_universenameUpdateInput, inducks_universenameUncheckedUpdateInput>
  }


  /**
   * inducks_universename delete
   */
  export type inducks_universenameDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_universename
     */
    select?: inducks_universenameSelect<ExtArgs> | null
    /**
     * Filter which inducks_universename to delete.
     */
    where: inducks_universenameWhereUniqueInput
  }


  /**
   * inducks_universename deleteMany
   */
  export type inducks_universenameDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which inducks_universenames to delete
     */
    where?: inducks_universenameWhereInput
  }


  /**
   * inducks_universename without action
   */
  export type inducks_universenameDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inducks_universename
     */
    select?: inducks_universenameSelect<ExtArgs> | null
  }



  /**
   * Model numeros_cpt
   */

  export type AggregateNumeros_cpt = {
    _count: Numeros_cptCountAggregateOutputType | null
    _avg: Numeros_cptAvgAggregateOutputType | null
    _sum: Numeros_cptSumAggregateOutputType | null
    _min: Numeros_cptMinAggregateOutputType | null
    _max: Numeros_cptMaxAggregateOutputType | null
  }

  export type Numeros_cptAvgAggregateOutputType = {
    Cpt: number | null
  }

  export type Numeros_cptSumAggregateOutputType = {
    Cpt: number | null
  }

  export type Numeros_cptMinAggregateOutputType = {
    Pays: string | null
    Magazine: string | null
    publicationcode: string | null
    Numero: string | null
    Cpt: number | null
  }

  export type Numeros_cptMaxAggregateOutputType = {
    Pays: string | null
    Magazine: string | null
    publicationcode: string | null
    Numero: string | null
    Cpt: number | null
  }

  export type Numeros_cptCountAggregateOutputType = {
    Pays: number
    Magazine: number
    publicationcode: number
    Numero: number
    Cpt: number
    _all: number
  }


  export type Numeros_cptAvgAggregateInputType = {
    Cpt?: true
  }

  export type Numeros_cptSumAggregateInputType = {
    Cpt?: true
  }

  export type Numeros_cptMinAggregateInputType = {
    Pays?: true
    Magazine?: true
    publicationcode?: true
    Numero?: true
    Cpt?: true
  }

  export type Numeros_cptMaxAggregateInputType = {
    Pays?: true
    Magazine?: true
    publicationcode?: true
    Numero?: true
    Cpt?: true
  }

  export type Numeros_cptCountAggregateInputType = {
    Pays?: true
    Magazine?: true
    publicationcode?: true
    Numero?: true
    Cpt?: true
    _all?: true
  }

  export type Numeros_cptAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which numeros_cpt to aggregate.
     */
    where?: numeros_cptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of numeros_cpts to fetch.
     */
    orderBy?: numeros_cptOrderByWithRelationInput | numeros_cptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: numeros_cptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` numeros_cpts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` numeros_cpts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned numeros_cpts
    **/
    _count?: true | Numeros_cptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Numeros_cptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Numeros_cptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Numeros_cptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Numeros_cptMaxAggregateInputType
  }

  export type GetNumeros_cptAggregateType<T extends Numeros_cptAggregateArgs> = {
        [P in keyof T & keyof AggregateNumeros_cpt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNumeros_cpt[P]>
      : GetScalarType<T[P], AggregateNumeros_cpt[P]>
  }




  export type numeros_cptGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: numeros_cptWhereInput
    orderBy?: numeros_cptOrderByWithAggregationInput | numeros_cptOrderByWithAggregationInput[]
    by: Numeros_cptScalarFieldEnum[] | Numeros_cptScalarFieldEnum
    having?: numeros_cptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Numeros_cptCountAggregateInputType | true
    _avg?: Numeros_cptAvgAggregateInputType
    _sum?: Numeros_cptSumAggregateInputType
    _min?: Numeros_cptMinAggregateInputType
    _max?: Numeros_cptMaxAggregateInputType
  }

  export type Numeros_cptGroupByOutputType = {
    Pays: string
    Magazine: string
    publicationcode: string
    Numero: string
    Cpt: number | null
    _count: Numeros_cptCountAggregateOutputType | null
    _avg: Numeros_cptAvgAggregateOutputType | null
    _sum: Numeros_cptSumAggregateOutputType | null
    _min: Numeros_cptMinAggregateOutputType | null
    _max: Numeros_cptMaxAggregateOutputType | null
  }

  type GetNumeros_cptGroupByPayload<T extends numeros_cptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Numeros_cptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Numeros_cptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Numeros_cptGroupByOutputType[P]>
            : GetScalarType<T[P], Numeros_cptGroupByOutputType[P]>
        }
      >
    >


  export type numeros_cptSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Pays?: boolean
    Magazine?: boolean
    publicationcode?: boolean
    Numero?: boolean
    Cpt?: boolean
  }, ExtArgs["result"]["numeros_cpt"]>

  export type numeros_cptSelectScalar = {
    Pays?: boolean
    Magazine?: boolean
    publicationcode?: boolean
    Numero?: boolean
    Cpt?: boolean
  }


  export type $numeros_cptPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "numeros_cpt"
    objects: {}
    scalars: $Extensions.GetResult<{
      Pays: string
      Magazine: string
      publicationcode: string
      Numero: string
      Cpt: number | null
    }, ExtArgs["result"]["numeros_cpt"]>
    composites: {}
  }


  type numeros_cptGetPayload<S extends boolean | null | undefined | numeros_cptDefaultArgs> = $Result.GetResult<Prisma.$numeros_cptPayload, S>

  type numeros_cptCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<numeros_cptFindManyArgs, 'select' | 'include'> & {
      select?: Numeros_cptCountAggregateInputType | true
    }

  export interface numeros_cptDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['numeros_cpt'], meta: { name: 'numeros_cpt' } }
    /**
     * Find zero or one Numeros_cpt that matches the filter.
     * @param {numeros_cptFindUniqueArgs} args - Arguments to find a Numeros_cpt
     * @example
     * // Get one Numeros_cpt
     * const numeros_cpt = await prisma.numeros_cpt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends numeros_cptFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, numeros_cptFindUniqueArgs<ExtArgs>>
    ): Prisma__numeros_cptClient<$Result.GetResult<Prisma.$numeros_cptPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Numeros_cpt that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {numeros_cptFindUniqueOrThrowArgs} args - Arguments to find a Numeros_cpt
     * @example
     * // Get one Numeros_cpt
     * const numeros_cpt = await prisma.numeros_cpt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends numeros_cptFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, numeros_cptFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__numeros_cptClient<$Result.GetResult<Prisma.$numeros_cptPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Numeros_cpt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {numeros_cptFindFirstArgs} args - Arguments to find a Numeros_cpt
     * @example
     * // Get one Numeros_cpt
     * const numeros_cpt = await prisma.numeros_cpt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends numeros_cptFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, numeros_cptFindFirstArgs<ExtArgs>>
    ): Prisma__numeros_cptClient<$Result.GetResult<Prisma.$numeros_cptPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Numeros_cpt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {numeros_cptFindFirstOrThrowArgs} args - Arguments to find a Numeros_cpt
     * @example
     * // Get one Numeros_cpt
     * const numeros_cpt = await prisma.numeros_cpt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends numeros_cptFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, numeros_cptFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__numeros_cptClient<$Result.GetResult<Prisma.$numeros_cptPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Numeros_cpts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {numeros_cptFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Numeros_cpts
     * const numeros_cpts = await prisma.numeros_cpt.findMany()
     * 
     * // Get first 10 Numeros_cpts
     * const numeros_cpts = await prisma.numeros_cpt.findMany({ take: 10 })
     * 
     * // Only select the `Pays`
     * const numeros_cptWithPaysOnly = await prisma.numeros_cpt.findMany({ select: { Pays: true } })
     * 
    **/
    findMany<T extends numeros_cptFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, numeros_cptFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$numeros_cptPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Numeros_cpt.
     * @param {numeros_cptCreateArgs} args - Arguments to create a Numeros_cpt.
     * @example
     * // Create one Numeros_cpt
     * const Numeros_cpt = await prisma.numeros_cpt.create({
     *   data: {
     *     // ... data to create a Numeros_cpt
     *   }
     * })
     * 
    **/
    create<T extends numeros_cptCreateArgs<ExtArgs>>(
      args: SelectSubset<T, numeros_cptCreateArgs<ExtArgs>>
    ): Prisma__numeros_cptClient<$Result.GetResult<Prisma.$numeros_cptPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Numeros_cpts.
     *     @param {numeros_cptCreateManyArgs} args - Arguments to create many Numeros_cpts.
     *     @example
     *     // Create many Numeros_cpts
     *     const numeros_cpt = await prisma.numeros_cpt.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends numeros_cptCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, numeros_cptCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Numeros_cpt.
     * @param {numeros_cptDeleteArgs} args - Arguments to delete one Numeros_cpt.
     * @example
     * // Delete one Numeros_cpt
     * const Numeros_cpt = await prisma.numeros_cpt.delete({
     *   where: {
     *     // ... filter to delete one Numeros_cpt
     *   }
     * })
     * 
    **/
    delete<T extends numeros_cptDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, numeros_cptDeleteArgs<ExtArgs>>
    ): Prisma__numeros_cptClient<$Result.GetResult<Prisma.$numeros_cptPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Numeros_cpt.
     * @param {numeros_cptUpdateArgs} args - Arguments to update one Numeros_cpt.
     * @example
     * // Update one Numeros_cpt
     * const numeros_cpt = await prisma.numeros_cpt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends numeros_cptUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, numeros_cptUpdateArgs<ExtArgs>>
    ): Prisma__numeros_cptClient<$Result.GetResult<Prisma.$numeros_cptPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Numeros_cpts.
     * @param {numeros_cptDeleteManyArgs} args - Arguments to filter Numeros_cpts to delete.
     * @example
     * // Delete a few Numeros_cpts
     * const { count } = await prisma.numeros_cpt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends numeros_cptDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, numeros_cptDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Numeros_cpts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {numeros_cptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Numeros_cpts
     * const numeros_cpt = await prisma.numeros_cpt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends numeros_cptUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, numeros_cptUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Numeros_cpt.
     * @param {numeros_cptUpsertArgs} args - Arguments to update or create a Numeros_cpt.
     * @example
     * // Update or create a Numeros_cpt
     * const numeros_cpt = await prisma.numeros_cpt.upsert({
     *   create: {
     *     // ... data to create a Numeros_cpt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Numeros_cpt we want to update
     *   }
     * })
    **/
    upsert<T extends numeros_cptUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, numeros_cptUpsertArgs<ExtArgs>>
    ): Prisma__numeros_cptClient<$Result.GetResult<Prisma.$numeros_cptPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Numeros_cpts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {numeros_cptCountArgs} args - Arguments to filter Numeros_cpts to count.
     * @example
     * // Count the number of Numeros_cpts
     * const count = await prisma.numeros_cpt.count({
     *   where: {
     *     // ... the filter for the Numeros_cpts we want to count
     *   }
     * })
    **/
    count<T extends numeros_cptCountArgs>(
      args?: Subset<T, numeros_cptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Numeros_cptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Numeros_cpt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Numeros_cptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Numeros_cptAggregateArgs>(args: Subset<T, Numeros_cptAggregateArgs>): Prisma.PrismaPromise<GetNumeros_cptAggregateType<T>>

    /**
     * Group by Numeros_cpt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {numeros_cptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends numeros_cptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: numeros_cptGroupByArgs['orderBy'] }
        : { orderBy?: numeros_cptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, numeros_cptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNumeros_cptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the numeros_cpt model
   */
  readonly fields: numeros_cptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for numeros_cpt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__numeros_cptClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the numeros_cpt model
   */ 
  interface numeros_cptFieldRefs {
    readonly Pays: FieldRef<"numeros_cpt", 'String'>
    readonly Magazine: FieldRef<"numeros_cpt", 'String'>
    readonly publicationcode: FieldRef<"numeros_cpt", 'String'>
    readonly Numero: FieldRef<"numeros_cpt", 'String'>
    readonly Cpt: FieldRef<"numeros_cpt", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * numeros_cpt findUnique
   */
  export type numeros_cptFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the numeros_cpt
     */
    select?: numeros_cptSelect<ExtArgs> | null
    /**
     * Filter, which numeros_cpt to fetch.
     */
    where: numeros_cptWhereUniqueInput
  }


  /**
   * numeros_cpt findUniqueOrThrow
   */
  export type numeros_cptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the numeros_cpt
     */
    select?: numeros_cptSelect<ExtArgs> | null
    /**
     * Filter, which numeros_cpt to fetch.
     */
    where: numeros_cptWhereUniqueInput
  }


  /**
   * numeros_cpt findFirst
   */
  export type numeros_cptFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the numeros_cpt
     */
    select?: numeros_cptSelect<ExtArgs> | null
    /**
     * Filter, which numeros_cpt to fetch.
     */
    where?: numeros_cptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of numeros_cpts to fetch.
     */
    orderBy?: numeros_cptOrderByWithRelationInput | numeros_cptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for numeros_cpts.
     */
    cursor?: numeros_cptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` numeros_cpts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` numeros_cpts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of numeros_cpts.
     */
    distinct?: Numeros_cptScalarFieldEnum | Numeros_cptScalarFieldEnum[]
  }


  /**
   * numeros_cpt findFirstOrThrow
   */
  export type numeros_cptFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the numeros_cpt
     */
    select?: numeros_cptSelect<ExtArgs> | null
    /**
     * Filter, which numeros_cpt to fetch.
     */
    where?: numeros_cptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of numeros_cpts to fetch.
     */
    orderBy?: numeros_cptOrderByWithRelationInput | numeros_cptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for numeros_cpts.
     */
    cursor?: numeros_cptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` numeros_cpts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` numeros_cpts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of numeros_cpts.
     */
    distinct?: Numeros_cptScalarFieldEnum | Numeros_cptScalarFieldEnum[]
  }


  /**
   * numeros_cpt findMany
   */
  export type numeros_cptFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the numeros_cpt
     */
    select?: numeros_cptSelect<ExtArgs> | null
    /**
     * Filter, which numeros_cpts to fetch.
     */
    where?: numeros_cptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of numeros_cpts to fetch.
     */
    orderBy?: numeros_cptOrderByWithRelationInput | numeros_cptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing numeros_cpts.
     */
    cursor?: numeros_cptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` numeros_cpts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` numeros_cpts.
     */
    skip?: number
    distinct?: Numeros_cptScalarFieldEnum | Numeros_cptScalarFieldEnum[]
  }


  /**
   * numeros_cpt create
   */
  export type numeros_cptCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the numeros_cpt
     */
    select?: numeros_cptSelect<ExtArgs> | null
    /**
     * The data needed to create a numeros_cpt.
     */
    data: XOR<numeros_cptCreateInput, numeros_cptUncheckedCreateInput>
  }


  /**
   * numeros_cpt createMany
   */
  export type numeros_cptCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many numeros_cpts.
     */
    data: numeros_cptCreateManyInput | numeros_cptCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * numeros_cpt update
   */
  export type numeros_cptUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the numeros_cpt
     */
    select?: numeros_cptSelect<ExtArgs> | null
    /**
     * The data needed to update a numeros_cpt.
     */
    data: XOR<numeros_cptUpdateInput, numeros_cptUncheckedUpdateInput>
    /**
     * Choose, which numeros_cpt to update.
     */
    where: numeros_cptWhereUniqueInput
  }


  /**
   * numeros_cpt updateMany
   */
  export type numeros_cptUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update numeros_cpts.
     */
    data: XOR<numeros_cptUpdateManyMutationInput, numeros_cptUncheckedUpdateManyInput>
    /**
     * Filter which numeros_cpts to update
     */
    where?: numeros_cptWhereInput
  }


  /**
   * numeros_cpt upsert
   */
  export type numeros_cptUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the numeros_cpt
     */
    select?: numeros_cptSelect<ExtArgs> | null
    /**
     * The filter to search for the numeros_cpt to update in case it exists.
     */
    where: numeros_cptWhereUniqueInput
    /**
     * In case the numeros_cpt found by the `where` argument doesn't exist, create a new numeros_cpt with this data.
     */
    create: XOR<numeros_cptCreateInput, numeros_cptUncheckedCreateInput>
    /**
     * In case the numeros_cpt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<numeros_cptUpdateInput, numeros_cptUncheckedUpdateInput>
  }


  /**
   * numeros_cpt delete
   */
  export type numeros_cptDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the numeros_cpt
     */
    select?: numeros_cptSelect<ExtArgs> | null
    /**
     * Filter which numeros_cpt to delete.
     */
    where: numeros_cptWhereUniqueInput
  }


  /**
   * numeros_cpt deleteMany
   */
  export type numeros_cptDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which numeros_cpts to delete
     */
    where?: numeros_cptWhereInput
  }


  /**
   * numeros_cpt without action
   */
  export type numeros_cptDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the numeros_cpt
     */
    select?: numeros_cptSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Datasets_entryurlsScalarFieldEnum: {
    id: 'id',
    dataset_id: 'dataset_id',
    sitecode_url: 'sitecode_url'
  };

  export type Datasets_entryurlsScalarFieldEnum = (typeof Datasets_entryurlsScalarFieldEnum)[keyof typeof Datasets_entryurlsScalarFieldEnum]


  export const Inducks_appearanceScalarFieldEnum: {
    storyversioncode: 'storyversioncode',
    charactercode: 'charactercode',
    number: 'number',
    appearancecomment: 'appearancecomment',
    doubt: 'doubt'
  };

  export type Inducks_appearanceScalarFieldEnum = (typeof Inducks_appearanceScalarFieldEnum)[keyof typeof Inducks_appearanceScalarFieldEnum]


  export const Inducks_characterScalarFieldEnum: {
    charactercode: 'charactercode',
    charactername: 'charactername',
    official: 'official',
    onetime: 'onetime',
    heroonly: 'heroonly',
    charactercomment: 'charactercomment'
  };

  export type Inducks_characterScalarFieldEnum = (typeof Inducks_characterScalarFieldEnum)[keyof typeof Inducks_characterScalarFieldEnum]


  export const Inducks_characteraliasScalarFieldEnum: {
    charactercode: 'charactercode',
    charactername: 'charactername'
  };

  export type Inducks_characteraliasScalarFieldEnum = (typeof Inducks_characteraliasScalarFieldEnum)[keyof typeof Inducks_characteraliasScalarFieldEnum]


  export const Inducks_characterdetailScalarFieldEnum: {
    charactername: 'charactername',
    charactercode: 'charactercode',
    number: 'number'
  };

  export type Inducks_characterdetailScalarFieldEnum = (typeof Inducks_characterdetailScalarFieldEnum)[keyof typeof Inducks_characterdetailScalarFieldEnum]


  export const Inducks_characternameScalarFieldEnum: {
    charactercode: 'charactercode',
    languagecode: 'languagecode',
    charactername: 'charactername',
    preferred: 'preferred',
    characternamecomment: 'characternamecomment'
  };

  export type Inducks_characternameScalarFieldEnum = (typeof Inducks_characternameScalarFieldEnum)[keyof typeof Inducks_characternameScalarFieldEnum]


  export const Inducks_characterreferenceScalarFieldEnum: {
    fromcharactercode: 'fromcharactercode',
    tocharactercode: 'tocharactercode',
    isgroupofcharacters: 'isgroupofcharacters'
  };

  export type Inducks_characterreferenceScalarFieldEnum = (typeof Inducks_characterreferenceScalarFieldEnum)[keyof typeof Inducks_characterreferenceScalarFieldEnum]


  export const Inducks_characterurlScalarFieldEnum: {
    charactercode: 'charactercode',
    sitecode: 'sitecode',
    url: 'url'
  };

  export type Inducks_characterurlScalarFieldEnum = (typeof Inducks_characterurlScalarFieldEnum)[keyof typeof Inducks_characterurlScalarFieldEnum]


  export const Inducks_countryScalarFieldEnum: {
    countrycode: 'countrycode',
    countryname: 'countryname',
    defaultlanguage: 'defaultlanguage',
    defaultmaintenanceteam: 'defaultmaintenanceteam'
  };

  export type Inducks_countryScalarFieldEnum = (typeof Inducks_countryScalarFieldEnum)[keyof typeof Inducks_countryScalarFieldEnum]


  export const Inducks_countrynameScalarFieldEnum: {
    countrycode: 'countrycode',
    languagecode: 'languagecode',
    countryname: 'countryname'
  };

  export type Inducks_countrynameScalarFieldEnum = (typeof Inducks_countrynameScalarFieldEnum)[keyof typeof Inducks_countrynameScalarFieldEnum]


  export const Inducks_currencyScalarFieldEnum: {
    currencycode: 'currencycode',
    currencyname: 'currencyname'
  };

  export type Inducks_currencyScalarFieldEnum = (typeof Inducks_currencyScalarFieldEnum)[keyof typeof Inducks_currencyScalarFieldEnum]


  export const Inducks_currencynameScalarFieldEnum: {
    currencycode: 'currencycode',
    languagecode: 'languagecode',
    shortcurrencyname: 'shortcurrencyname',
    longcurrencyname: 'longcurrencyname'
  };

  export type Inducks_currencynameScalarFieldEnum = (typeof Inducks_currencynameScalarFieldEnum)[keyof typeof Inducks_currencynameScalarFieldEnum]


  export const Inducks_entryScalarFieldEnum: {
    entrycode: 'entrycode',
    issuecode: 'issuecode',
    storyversioncode: 'storyversioncode',
    languagecode: 'languagecode',
    includedinentrycode: 'includedinentrycode',
    position: 'position',
    printedcode: 'printedcode',
    guessedcode: 'guessedcode',
    title: 'title',
    reallytitle: 'reallytitle',
    printedhero: 'printedhero',
    changes: 'changes',
    cut: 'cut',
    minorchanges: 'minorchanges',
    missingpanels: 'missingpanels',
    mirrored: 'mirrored',
    sideways: 'sideways',
    startdate: 'startdate',
    enddate: 'enddate',
    identificationuncertain: 'identificationuncertain',
    alsoreprint: 'alsoreprint',
    part: 'part',
    entrycomment: 'entrycomment',
    error: 'error'
  };

  export type Inducks_entryScalarFieldEnum = (typeof Inducks_entryScalarFieldEnum)[keyof typeof Inducks_entryScalarFieldEnum]


  export const Inducks_entry_nofulltextScalarFieldEnum: {
    entrycode: 'entrycode',
    issuecode: 'issuecode',
    storyversioncode: 'storyversioncode',
    languagecode: 'languagecode',
    includedinentrycode: 'includedinentrycode',
    position: 'position',
    printedcode: 'printedcode',
    guessedcode: 'guessedcode',
    title: 'title',
    reallytitle: 'reallytitle',
    printedhero: 'printedhero',
    changes: 'changes',
    cut: 'cut',
    minorchanges: 'minorchanges',
    missingpanels: 'missingpanels',
    mirrored: 'mirrored',
    sideways: 'sideways',
    startdate: 'startdate',
    enddate: 'enddate',
    identificationuncertain: 'identificationuncertain',
    alsoreprint: 'alsoreprint',
    part: 'part',
    entrycomment: 'entrycomment',
    error: 'error'
  };

  export type Inducks_entry_nofulltextScalarFieldEnum = (typeof Inducks_entry_nofulltextScalarFieldEnum)[keyof typeof Inducks_entry_nofulltextScalarFieldEnum]


  export const Inducks_entrycharacternameScalarFieldEnum: {
    entrycode: 'entrycode',
    charactercode: 'charactercode',
    charactername: 'charactername'
  };

  export type Inducks_entrycharacternameScalarFieldEnum = (typeof Inducks_entrycharacternameScalarFieldEnum)[keyof typeof Inducks_entrycharacternameScalarFieldEnum]


  export const Inducks_entryjobScalarFieldEnum: {
    entrycode: 'entrycode',
    personcode: 'personcode',
    transletcol: 'transletcol',
    entryjobcomment: 'entryjobcomment',
    doubt: 'doubt'
  };

  export type Inducks_entryjobScalarFieldEnum = (typeof Inducks_entryjobScalarFieldEnum)[keyof typeof Inducks_entryjobScalarFieldEnum]


  export const Inducks_entryurlScalarFieldEnum: {
    entrycode: 'entrycode',
    sitecode: 'sitecode',
    pagenumber: 'pagenumber',
    url: 'url',
    storycode: 'storycode',
    public: 'public',
    id: 'id'
  };

  export type Inducks_entryurlScalarFieldEnum = (typeof Inducks_entryurlScalarFieldEnum)[keyof typeof Inducks_entryurlScalarFieldEnum]


  export const Inducks_equivScalarFieldEnum: {
    issuecode: 'issuecode',
    equivid: 'equivid',
    equivcomment: 'equivcomment'
  };

  export type Inducks_equivScalarFieldEnum = (typeof Inducks_equivScalarFieldEnum)[keyof typeof Inducks_equivScalarFieldEnum]


  export const Inducks_herocharacterScalarFieldEnum: {
    storycode: 'storycode',
    charactercode: 'charactercode',
    number: 'number',
    doubt: 'doubt'
  };

  export type Inducks_herocharacterScalarFieldEnum = (typeof Inducks_herocharacterScalarFieldEnum)[keyof typeof Inducks_herocharacterScalarFieldEnum]


  export const Inducks_inputfileScalarFieldEnum: {
    inputfilecode: 'inputfilecode',
    path: 'path',
    filename: 'filename',
    layout: 'layout',
    locked: 'locked',
    maintenanceteamcode: 'maintenanceteamcode',
    countrycode: 'countrycode',
    languagecode: 'languagecode',
    producercode: 'producercode',
    secundary: 'secundary'
  };

  export type Inducks_inputfileScalarFieldEnum = (typeof Inducks_inputfileScalarFieldEnum)[keyof typeof Inducks_inputfileScalarFieldEnum]


  export const Inducks_issueScalarFieldEnum: {
    issuecode: 'issuecode',
    issuerangecode: 'issuerangecode',
    publicationcode: 'publicationcode',
    issuenumber: 'issuenumber',
    title: 'title',
    size: 'size',
    pages: 'pages',
    price: 'price',
    printrun: 'printrun',
    attached: 'attached',
    oldestdate: 'oldestdate',
    fullyindexed: 'fullyindexed',
    issuecomment: 'issuecomment',
    error: 'error',
    filledoldestdate: 'filledoldestdate',
    locked: 'locked',
    inxforbidden: 'inxforbidden',
    inputfilecode: 'inputfilecode',
    maintenanceteamcode: 'maintenanceteamcode'
  };

  export type Inducks_issueScalarFieldEnum = (typeof Inducks_issueScalarFieldEnum)[keyof typeof Inducks_issueScalarFieldEnum]


  export const Inducks_issuecollectingScalarFieldEnum: {
    collectingissuecode: 'collectingissuecode',
    collectedissuecode: 'collectedissuecode'
  };

  export type Inducks_issuecollectingScalarFieldEnum = (typeof Inducks_issuecollectingScalarFieldEnum)[keyof typeof Inducks_issuecollectingScalarFieldEnum]


  export const Inducks_issuedateScalarFieldEnum: {
    issuecode: 'issuecode',
    date: 'date',
    kindofdate: 'kindofdate',
    doubt: 'doubt'
  };

  export type Inducks_issuedateScalarFieldEnum = (typeof Inducks_issuedateScalarFieldEnum)[keyof typeof Inducks_issuedateScalarFieldEnum]


  export const Inducks_issuejobScalarFieldEnum: {
    issuecode: 'issuecode',
    personcode: 'personcode',
    inxtransletcol: 'inxtransletcol',
    issuejobcomment: 'issuejobcomment',
    doubt: 'doubt'
  };

  export type Inducks_issuejobScalarFieldEnum = (typeof Inducks_issuejobScalarFieldEnum)[keyof typeof Inducks_issuejobScalarFieldEnum]


  export const Inducks_issuepriceScalarFieldEnum: {
    issuecode: 'issuecode',
    amount: 'amount',
    currency: 'currency',
    comment: 'comment',
    sequencenumber: 'sequencenumber'
  };

  export type Inducks_issuepriceScalarFieldEnum = (typeof Inducks_issuepriceScalarFieldEnum)[keyof typeof Inducks_issuepriceScalarFieldEnum]


  export const Inducks_issuequotationScalarFieldEnum: {
    ID: 'ID',
    publicationcode: 'publicationcode',
    issuenumber: 'issuenumber',
    estimationmin: 'estimationmin',
    estimationmax: 'estimationmax',
    scrapedate: 'scrapedate',
    source: 'source',
    issuecode: 'issuecode'
  };

  export type Inducks_issuequotationScalarFieldEnum = (typeof Inducks_issuequotationScalarFieldEnum)[keyof typeof Inducks_issuequotationScalarFieldEnum]


  export const Inducks_issuerangeScalarFieldEnum: {
    issuerangecode: 'issuerangecode',
    publicationcode: 'publicationcode',
    title: 'title',
    circulation: 'circulation',
    issuerangecomment: 'issuerangecomment',
    numbersarefake: 'numbersarefake',
    error: 'error'
  };

  export type Inducks_issuerangeScalarFieldEnum = (typeof Inducks_issuerangeScalarFieldEnum)[keyof typeof Inducks_issuerangeScalarFieldEnum]


  export const Inducks_issueurlScalarFieldEnum: {
    issuecode: 'issuecode',
    sitecode: 'sitecode',
    url: 'url'
  };

  export type Inducks_issueurlScalarFieldEnum = (typeof Inducks_issueurlScalarFieldEnum)[keyof typeof Inducks_issueurlScalarFieldEnum]


  export const Inducks_languageScalarFieldEnum: {
    languagecode: 'languagecode',
    defaultlanguagecode: 'defaultlanguagecode',
    languagename: 'languagename'
  };

  export type Inducks_languageScalarFieldEnum = (typeof Inducks_languageScalarFieldEnum)[keyof typeof Inducks_languageScalarFieldEnum]


  export const Inducks_languagenameScalarFieldEnum: {
    desclanguagecode: 'desclanguagecode',
    languagecode: 'languagecode',
    languagename: 'languagename'
  };

  export type Inducks_languagenameScalarFieldEnum = (typeof Inducks_languagenameScalarFieldEnum)[keyof typeof Inducks_languagenameScalarFieldEnum]


  export const Inducks_logScalarFieldEnum: {
    number: 'number',
    logkey: 'logkey',
    storycode: 'storycode',
    logid: 'logid',
    logtype: 'logtype',
    par1: 'par1',
    par2: 'par2',
    par3: 'par3',
    marked: 'marked',
    inputfilecode: 'inputfilecode',
    maintenanceteamcode: 'maintenanceteamcode'
  };

  export type Inducks_logScalarFieldEnum = (typeof Inducks_logScalarFieldEnum)[keyof typeof Inducks_logScalarFieldEnum]


  export const Inducks_logdataScalarFieldEnum: {
    logid: 'logid',
    category: 'category',
    logtext: 'logtext'
  };

  export type Inducks_logdataScalarFieldEnum = (typeof Inducks_logdataScalarFieldEnum)[keyof typeof Inducks_logdataScalarFieldEnum]


  export const Inducks_logocharacterScalarFieldEnum: {
    entrycode: 'entrycode',
    charactercode: 'charactercode',
    reallyintitle: 'reallyintitle',
    number: 'number',
    logocharactercomment: 'logocharactercomment'
  };

  export type Inducks_logocharacterScalarFieldEnum = (typeof Inducks_logocharacterScalarFieldEnum)[keyof typeof Inducks_logocharacterScalarFieldEnum]


  export const Inducks_movieScalarFieldEnum: {
    moviecode: 'moviecode',
    title: 'title',
    moviecomment: 'moviecomment',
    appsummary: 'appsummary',
    moviejobsummary: 'moviejobsummary',
    locked: 'locked',
    inputfilecode: 'inputfilecode',
    maintenanceteamcode: 'maintenanceteamcode',
    aka: 'aka',
    creationdate: 'creationdate',
    moviedescription: 'moviedescription',
    distributor: 'distributor',
    genre: 'genre',
    orderer: 'orderer',
    publicationdate: 'publicationdate',
    source: 'source',
    tim: 'tim'
  };

  export type Inducks_movieScalarFieldEnum = (typeof Inducks_movieScalarFieldEnum)[keyof typeof Inducks_movieScalarFieldEnum]


  export const Inducks_moviecharacterScalarFieldEnum: {
    moviecode: 'moviecode',
    charactercode: 'charactercode',
    istitlecharacter: 'istitlecharacter'
  };

  export type Inducks_moviecharacterScalarFieldEnum = (typeof Inducks_moviecharacterScalarFieldEnum)[keyof typeof Inducks_moviecharacterScalarFieldEnum]


  export const Inducks_moviejobScalarFieldEnum: {
    moviecode: 'moviecode',
    personcode: 'personcode',
    role: 'role',
    moviejobcomment: 'moviejobcomment',
    indirect: 'indirect',
    doubt: 'doubt'
  };

  export type Inducks_moviejobScalarFieldEnum = (typeof Inducks_moviejobScalarFieldEnum)[keyof typeof Inducks_moviejobScalarFieldEnum]


  export const Inducks_moviereferenceScalarFieldEnum: {
    storycode: 'storycode',
    moviecode: 'moviecode',
    referencereasonid: 'referencereasonid',
    frommovietostory: 'frommovietostory'
  };

  export type Inducks_moviereferenceScalarFieldEnum = (typeof Inducks_moviereferenceScalarFieldEnum)[keyof typeof Inducks_moviereferenceScalarFieldEnum]


  export const Inducks_personScalarFieldEnum: {
    personcode: 'personcode',
    nationalitycountrycode: 'nationalitycountrycode',
    fullname: 'fullname',
    official: 'official',
    personcomment: 'personcomment',
    unknownstudiomember: 'unknownstudiomember',
    isfake: 'isfake',
    numberofindexedissues: 'numberofindexedissues',
    birthname: 'birthname',
    borndate: 'borndate',
    bornplace: 'bornplace',
    deceaseddate: 'deceaseddate',
    deceasedplace: 'deceasedplace',
    education: 'education',
    moviestext: 'moviestext',
    comicstext: 'comicstext',
    othertext: 'othertext',
    photofilename: 'photofilename',
    photocomment: 'photocomment',
    photosource: 'photosource',
    personrefs: 'personrefs'
  };

  export type Inducks_personScalarFieldEnum = (typeof Inducks_personScalarFieldEnum)[keyof typeof Inducks_personScalarFieldEnum]


  export const Inducks_personurlScalarFieldEnum: {
    personcode: 'personcode',
    sitecode: 'sitecode',
    url: 'url'
  };

  export type Inducks_personurlScalarFieldEnum = (typeof Inducks_personurlScalarFieldEnum)[keyof typeof Inducks_personurlScalarFieldEnum]


  export const Inducks_publicationScalarFieldEnum: {
    publicationcode: 'publicationcode',
    countrycode: 'countrycode',
    languagecode: 'languagecode',
    title: 'title',
    size: 'size',
    publicationcomment: 'publicationcomment',
    circulation: 'circulation',
    numbersarefake: 'numbersarefake',
    error: 'error',
    locked: 'locked',
    inxforbidden: 'inxforbidden',
    inputfilecode: 'inputfilecode',
    maintenanceteamcode: 'maintenanceteamcode'
  };

  export type Inducks_publicationScalarFieldEnum = (typeof Inducks_publicationScalarFieldEnum)[keyof typeof Inducks_publicationScalarFieldEnum]


  export const Inducks_publicationcategoryScalarFieldEnum: {
    publicationcode: 'publicationcode',
    category: 'category'
  };

  export type Inducks_publicationcategoryScalarFieldEnum = (typeof Inducks_publicationcategoryScalarFieldEnum)[keyof typeof Inducks_publicationcategoryScalarFieldEnum]


  export const Inducks_publicationnameScalarFieldEnum: {
    publicationcode: 'publicationcode',
    publicationname: 'publicationname'
  };

  export type Inducks_publicationnameScalarFieldEnum = (typeof Inducks_publicationnameScalarFieldEnum)[keyof typeof Inducks_publicationnameScalarFieldEnum]


  export const Inducks_publicationurlScalarFieldEnum: {
    publicationcode: 'publicationcode',
    sitecode: 'sitecode',
    url: 'url'
  };

  export type Inducks_publicationurlScalarFieldEnum = (typeof Inducks_publicationurlScalarFieldEnum)[keyof typeof Inducks_publicationurlScalarFieldEnum]


  export const Inducks_publisherScalarFieldEnum: {
    publisherid: 'publisherid',
    publishername: 'publishername'
  };

  export type Inducks_publisherScalarFieldEnum = (typeof Inducks_publisherScalarFieldEnum)[keyof typeof Inducks_publisherScalarFieldEnum]


  export const Inducks_publishingjobScalarFieldEnum: {
    publisherid: 'publisherid',
    issuecode: 'issuecode',
    publishingjobcomment: 'publishingjobcomment'
  };

  export type Inducks_publishingjobScalarFieldEnum = (typeof Inducks_publishingjobScalarFieldEnum)[keyof typeof Inducks_publishingjobScalarFieldEnum]


  export const Inducks_referencereasonScalarFieldEnum: {
    referencereasonid: 'referencereasonid',
    referencereasontext: 'referencereasontext'
  };

  export type Inducks_referencereasonScalarFieldEnum = (typeof Inducks_referencereasonScalarFieldEnum)[keyof typeof Inducks_referencereasonScalarFieldEnum]


  export const Inducks_referencereasonnameScalarFieldEnum: {
    referencereasonid: 'referencereasonid',
    languagecode: 'languagecode',
    referencereasontranslation: 'referencereasontranslation'
  };

  export type Inducks_referencereasonnameScalarFieldEnum = (typeof Inducks_referencereasonnameScalarFieldEnum)[keyof typeof Inducks_referencereasonnameScalarFieldEnum]


  export const Inducks_siteScalarFieldEnum: {
    sitecode: 'sitecode',
    urlbase: 'urlbase',
    images: 'images',
    sitename: 'sitename',
    sitelogo: 'sitelogo',
    properties: 'properties'
  };

  export type Inducks_siteScalarFieldEnum = (typeof Inducks_siteScalarFieldEnum)[keyof typeof Inducks_siteScalarFieldEnum]


  export const Inducks_statcharactercharacterScalarFieldEnum: {
    charactercode: 'charactercode',
    cocharactercode: 'cocharactercode',
    total: 'total',
    yearrange: 'yearrange'
  };

  export type Inducks_statcharactercharacterScalarFieldEnum = (typeof Inducks_statcharactercharacterScalarFieldEnum)[keyof typeof Inducks_statcharactercharacterScalarFieldEnum]


  export const Inducks_statcharactercountryScalarFieldEnum: {
    charactercode: 'charactercode',
    countrycode: 'countrycode',
    total: 'total'
  };

  export type Inducks_statcharactercountryScalarFieldEnum = (typeof Inducks_statcharactercountryScalarFieldEnum)[keyof typeof Inducks_statcharactercountryScalarFieldEnum]


  export const Inducks_statcharacterstoryScalarFieldEnum: {
    charactercode: 'charactercode',
    storyheadercode: 'storyheadercode',
    total: 'total',
    yearrange: 'yearrange'
  };

  export type Inducks_statcharacterstoryScalarFieldEnum = (typeof Inducks_statcharacterstoryScalarFieldEnum)[keyof typeof Inducks_statcharacterstoryScalarFieldEnum]


  export const Inducks_statpersoncharacterScalarFieldEnum: {
    personcode: 'personcode',
    charactercode: 'charactercode',
    total: 'total',
    yearrange: 'yearrange'
  };

  export type Inducks_statpersoncharacterScalarFieldEnum = (typeof Inducks_statpersoncharacterScalarFieldEnum)[keyof typeof Inducks_statpersoncharacterScalarFieldEnum]


  export const Inducks_statpersoncountryScalarFieldEnum: {
    personcode: 'personcode',
    countrycode: 'countrycode',
    total: 'total'
  };

  export type Inducks_statpersoncountryScalarFieldEnum = (typeof Inducks_statpersoncountryScalarFieldEnum)[keyof typeof Inducks_statpersoncountryScalarFieldEnum]


  export const Inducks_statpersonpersonScalarFieldEnum: {
    personcode: 'personcode',
    copersoncode: 'copersoncode',
    total: 'total',
    yearrange: 'yearrange'
  };

  export type Inducks_statpersonpersonScalarFieldEnum = (typeof Inducks_statpersonpersonScalarFieldEnum)[keyof typeof Inducks_statpersonpersonScalarFieldEnum]


  export const Inducks_statpersonstoryScalarFieldEnum: {
    personcode: 'personcode',
    storyheadercode: 'storyheadercode',
    total: 'total',
    yearrange: 'yearrange'
  };

  export type Inducks_statpersonstoryScalarFieldEnum = (typeof Inducks_statpersonstoryScalarFieldEnum)[keyof typeof Inducks_statpersonstoryScalarFieldEnum]


  export const Inducks_storyScalarFieldEnum: {
    storycode: 'storycode',
    originalstoryversioncode: 'originalstoryversioncode',
    creationdate: 'creationdate',
    firstpublicationdate: 'firstpublicationdate',
    endpublicationdate: 'endpublicationdate',
    title: 'title',
    usedifferentcode: 'usedifferentcode',
    storycomment: 'storycomment',
    error: 'error',
    repcountrysummary: 'repcountrysummary',
    storyparts: 'storyparts',
    locked: 'locked',
    inputfilecode: 'inputfilecode',
    issuecodeofstoryitem: 'issuecodeofstoryitem',
    maintenanceteamcode: 'maintenanceteamcode',
    storyheadercode: 'storyheadercode'
  };

  export type Inducks_storyScalarFieldEnum = (typeof Inducks_storyScalarFieldEnum)[keyof typeof Inducks_storyScalarFieldEnum]


  export const Inducks_storycodesScalarFieldEnum: {
    storycode: 'storycode',
    alternativecode: 'alternativecode',
    unpackedcode: 'unpackedcode',
    codecomment: 'codecomment'
  };

  export type Inducks_storycodesScalarFieldEnum = (typeof Inducks_storycodesScalarFieldEnum)[keyof typeof Inducks_storycodesScalarFieldEnum]


  export const Inducks_storydescriptionScalarFieldEnum: {
    storyversioncode: 'storyversioncode',
    languagecode: 'languagecode',
    desctext: 'desctext'
  };

  export type Inducks_storydescriptionScalarFieldEnum = (typeof Inducks_storydescriptionScalarFieldEnum)[keyof typeof Inducks_storydescriptionScalarFieldEnum]


  export const Inducks_storyheaderScalarFieldEnum: {
    storyheadercode: 'storyheadercode',
    level: 'level',
    title: 'title',
    storyheadercomment: 'storyheadercomment',
    countrycode: 'countrycode'
  };

  export type Inducks_storyheaderScalarFieldEnum = (typeof Inducks_storyheaderScalarFieldEnum)[keyof typeof Inducks_storyheaderScalarFieldEnum]


  export const Inducks_storyjobScalarFieldEnum: {
    storyversioncode: 'storyversioncode',
    personcode: 'personcode',
    plotwritartink: 'plotwritartink',
    storyjobcomment: 'storyjobcomment',
    indirect: 'indirect',
    doubt: 'doubt'
  };

  export type Inducks_storyjobScalarFieldEnum = (typeof Inducks_storyjobScalarFieldEnum)[keyof typeof Inducks_storyjobScalarFieldEnum]


  export const Inducks_storyreferenceScalarFieldEnum: {
    fromstorycode: 'fromstorycode',
    tostorycode: 'tostorycode',
    referencereasonid: 'referencereasonid'
  };

  export type Inducks_storyreferenceScalarFieldEnum = (typeof Inducks_storyreferenceScalarFieldEnum)[keyof typeof Inducks_storyreferenceScalarFieldEnum]


  export const Inducks_storysubseriesScalarFieldEnum: {
    storycode: 'storycode',
    subseriescode: 'subseriescode',
    storysubseriescomment: 'storysubseriescomment'
  };

  export type Inducks_storysubseriesScalarFieldEnum = (typeof Inducks_storysubseriesScalarFieldEnum)[keyof typeof Inducks_storysubseriesScalarFieldEnum]


  export const Inducks_storyurlScalarFieldEnum: {
    storycode: 'storycode',
    sitecode: 'sitecode',
    url: 'url'
  };

  export type Inducks_storyurlScalarFieldEnum = (typeof Inducks_storyurlScalarFieldEnum)[keyof typeof Inducks_storyurlScalarFieldEnum]


  export const Inducks_storyversionScalarFieldEnum: {
    storyversioncode: 'storyversioncode',
    storycode: 'storycode',
    entirepages: 'entirepages',
    brokenpagenumerator: 'brokenpagenumerator',
    brokenpagedenominator: 'brokenpagedenominator',
    brokenpageunspecified: 'brokenpageunspecified',
    kind: 'kind',
    rowsperpage: 'rowsperpage',
    columnsperpage: 'columnsperpage',
    appisxapp: 'appisxapp',
    what: 'what',
    appsummary: 'appsummary',
    plotsummary: 'plotsummary',
    writsummary: 'writsummary',
    artsummary: 'artsummary',
    inksummary: 'inksummary',
    creatorrefsummary: 'creatorrefsummary',
    keywordsummary: 'keywordsummary',
    estimatedpanels: 'estimatedpanels'
  };

  export type Inducks_storyversionScalarFieldEnum = (typeof Inducks_storyversionScalarFieldEnum)[keyof typeof Inducks_storyversionScalarFieldEnum]


  export const Inducks_storyversion_nofulltextScalarFieldEnum: {
    storyversioncode: 'storyversioncode',
    storycode: 'storycode',
    entirepages: 'entirepages',
    brokenpagenumerator: 'brokenpagenumerator',
    brokenpagedenominator: 'brokenpagedenominator',
    brokenpageunspecified: 'brokenpageunspecified',
    kind: 'kind',
    rowsperpage: 'rowsperpage',
    columnsperpage: 'columnsperpage',
    appisxapp: 'appisxapp',
    what: 'what',
    appsummary: 'appsummary',
    plotsummary: 'plotsummary',
    writsummary: 'writsummary',
    artsummary: 'artsummary',
    inksummary: 'inksummary',
    creatorrefsummary: 'creatorrefsummary',
    keywordsummary: 'keywordsummary',
    estimatedpanels: 'estimatedpanels'
  };

  export type Inducks_storyversion_nofulltextScalarFieldEnum = (typeof Inducks_storyversion_nofulltextScalarFieldEnum)[keyof typeof Inducks_storyversion_nofulltextScalarFieldEnum]


  export const Inducks_studioScalarFieldEnum: {
    studiocode: 'studiocode',
    countrycode: 'countrycode',
    studioname: 'studioname',
    city: 'city',
    description: 'description',
    othertext: 'othertext',
    photofilename: 'photofilename',
    photocomment: 'photocomment',
    photosource: 'photosource',
    studiorefs: 'studiorefs'
  };

  export type Inducks_studioScalarFieldEnum = (typeof Inducks_studioScalarFieldEnum)[keyof typeof Inducks_studioScalarFieldEnum]


  export const Inducks_studioworkScalarFieldEnum: {
    studiocode: 'studiocode',
    personcode: 'personcode'
  };

  export type Inducks_studioworkScalarFieldEnum = (typeof Inducks_studioworkScalarFieldEnum)[keyof typeof Inducks_studioworkScalarFieldEnum]


  export const Inducks_subseriesScalarFieldEnum: {
    subseriescode: 'subseriescode',
    subseriesname: 'subseriesname',
    official: 'official',
    subseriescomment: 'subseriescomment',
    subseriescategory: 'subseriescategory'
  };

  export type Inducks_subseriesScalarFieldEnum = (typeof Inducks_subseriesScalarFieldEnum)[keyof typeof Inducks_subseriesScalarFieldEnum]


  export const Inducks_subseriesnameScalarFieldEnum: {
    subseriescode: 'subseriescode',
    languagecode: 'languagecode',
    subseriesname: 'subseriesname',
    preferred: 'preferred',
    subseriesnamecomment: 'subseriesnamecomment'
  };

  export type Inducks_subseriesnameScalarFieldEnum = (typeof Inducks_subseriesnameScalarFieldEnum)[keyof typeof Inducks_subseriesnameScalarFieldEnum]


  export const Inducks_substoryScalarFieldEnum: {
    storycode: 'storycode',
    originalstoryversioncode: 'originalstoryversioncode',
    superstorycode: 'superstorycode',
    part: 'part',
    firstpublicationdate: 'firstpublicationdate',
    title: 'title',
    substorycomment: 'substorycomment',
    error: 'error',
    locked: 'locked',
    inputfilecode: 'inputfilecode',
    maintenanceteamcode: 'maintenanceteamcode'
  };

  export type Inducks_substoryScalarFieldEnum = (typeof Inducks_substoryScalarFieldEnum)[keyof typeof Inducks_substoryScalarFieldEnum]


  export const Inducks_teamScalarFieldEnum: {
    teamcode: 'teamcode',
    teamdescriptionname: 'teamdescriptionname',
    teamshortname: 'teamshortname'
  };

  export type Inducks_teamScalarFieldEnum = (typeof Inducks_teamScalarFieldEnum)[keyof typeof Inducks_teamScalarFieldEnum]


  export const Inducks_teammemberScalarFieldEnum: {
    teamcode: 'teamcode',
    personcode: 'personcode'
  };

  export type Inducks_teammemberScalarFieldEnum = (typeof Inducks_teammemberScalarFieldEnum)[keyof typeof Inducks_teammemberScalarFieldEnum]


  export const Inducks_ucrelationScalarFieldEnum: {
    universecode: 'universecode',
    charactercode: 'charactercode'
  };

  export type Inducks_ucrelationScalarFieldEnum = (typeof Inducks_ucrelationScalarFieldEnum)[keyof typeof Inducks_ucrelationScalarFieldEnum]


  export const Inducks_universeScalarFieldEnum: {
    universecode: 'universecode',
    universecomment: 'universecomment'
  };

  export type Inducks_universeScalarFieldEnum = (typeof Inducks_universeScalarFieldEnum)[keyof typeof Inducks_universeScalarFieldEnum]


  export const Inducks_universenameScalarFieldEnum: {
    universecode: 'universecode',
    languagecode: 'languagecode',
    universename: 'universename'
  };

  export type Inducks_universenameScalarFieldEnum = (typeof Inducks_universenameScalarFieldEnum)[keyof typeof Inducks_universenameScalarFieldEnum]


  export const Numeros_cptScalarFieldEnum: {
    Pays: 'Pays',
    Magazine: 'Magazine',
    publicationcode: 'publicationcode',
    Numero: 'Numero',
    Cpt: 'Cpt'
  };

  export type Numeros_cptScalarFieldEnum = (typeof Numeros_cptScalarFieldEnum)[keyof typeof Numeros_cptScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'inducks_appearance_doubt'
   */
  export type Enuminducks_appearance_doubtFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_appearance_doubt'>
    


  /**
   * Reference to a field of type 'inducks_character_official'
   */
  export type Enuminducks_character_officialFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_character_official'>
    


  /**
   * Reference to a field of type 'inducks_character_onetime'
   */
  export type Enuminducks_character_onetimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_character_onetime'>
    


  /**
   * Reference to a field of type 'inducks_character_heroonly'
   */
  export type Enuminducks_character_heroonlyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_character_heroonly'>
    


  /**
   * Reference to a field of type 'inducks_charactername_preferred'
   */
  export type Enuminducks_charactername_preferredFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_charactername_preferred'>
    


  /**
   * Reference to a field of type 'inducks_characterreference_isgroupofcharacters'
   */
  export type Enuminducks_characterreference_isgroupofcharactersFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_characterreference_isgroupofcharacters'>
    


  /**
   * Reference to a field of type 'inducks_entry_reallytitle'
   */
  export type Enuminducks_entry_reallytitleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_entry_reallytitle'>
    


  /**
   * Reference to a field of type 'inducks_entry_mirrored'
   */
  export type Enuminducks_entry_mirroredFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_entry_mirrored'>
    


  /**
   * Reference to a field of type 'inducks_entry_sideways'
   */
  export type Enuminducks_entry_sidewaysFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_entry_sideways'>
    


  /**
   * Reference to a field of type 'inducks_entry_identificationuncertain'
   */
  export type Enuminducks_entry_identificationuncertainFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_entry_identificationuncertain'>
    


  /**
   * Reference to a field of type 'inducks_entry_error'
   */
  export type Enuminducks_entry_errorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_entry_error'>
    


  /**
   * Reference to a field of type 'inducks_entry_nofulltext_reallytitle'
   */
  export type Enuminducks_entry_nofulltext_reallytitleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_entry_nofulltext_reallytitle'>
    


  /**
   * Reference to a field of type 'inducks_entry_nofulltext_mirrored'
   */
  export type Enuminducks_entry_nofulltext_mirroredFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_entry_nofulltext_mirrored'>
    


  /**
   * Reference to a field of type 'inducks_entry_nofulltext_sideways'
   */
  export type Enuminducks_entry_nofulltext_sidewaysFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_entry_nofulltext_sideways'>
    


  /**
   * Reference to a field of type 'inducks_entry_nofulltext_identificationuncertain'
   */
  export type Enuminducks_entry_nofulltext_identificationuncertainFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_entry_nofulltext_identificationuncertain'>
    


  /**
   * Reference to a field of type 'inducks_entry_nofulltext_error'
   */
  export type Enuminducks_entry_nofulltext_errorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_entry_nofulltext_error'>
    


  /**
   * Reference to a field of type 'inducks_entryjob_doubt'
   */
  export type Enuminducks_entryjob_doubtFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_entryjob_doubt'>
    


  /**
   * Reference to a field of type 'inducks_entryurl_public'
   */
  export type Enuminducks_entryurl_publicFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_entryurl_public'>
    


  /**
   * Reference to a field of type 'inducks_herocharacter_doubt'
   */
  export type Enuminducks_herocharacter_doubtFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_herocharacter_doubt'>
    


  /**
   * Reference to a field of type 'inducks_inputfile_locked'
   */
  export type Enuminducks_inputfile_lockedFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_inputfile_locked'>
    


  /**
   * Reference to a field of type 'inducks_inputfile_secundary'
   */
  export type Enuminducks_inputfile_secundaryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_inputfile_secundary'>
    


  /**
   * Reference to a field of type 'inducks_issue_fullyindexed'
   */
  export type Enuminducks_issue_fullyindexedFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_issue_fullyindexed'>
    


  /**
   * Reference to a field of type 'inducks_issue_error'
   */
  export type Enuminducks_issue_errorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_issue_error'>
    


  /**
   * Reference to a field of type 'inducks_issue_locked'
   */
  export type Enuminducks_issue_lockedFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_issue_locked'>
    


  /**
   * Reference to a field of type 'inducks_issue_inxforbidden'
   */
  export type Enuminducks_issue_inxforbiddenFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_issue_inxforbidden'>
    


  /**
   * Reference to a field of type 'inducks_issuedate_doubt'
   */
  export type Enuminducks_issuedate_doubtFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_issuedate_doubt'>
    


  /**
   * Reference to a field of type 'inducks_issuejob_doubt'
   */
  export type Enuminducks_issuejob_doubtFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_issuejob_doubt'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'inducks_issuerange_numbersarefake'
   */
  export type Enuminducks_issuerange_numbersarefakeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_issuerange_numbersarefake'>
    


  /**
   * Reference to a field of type 'inducks_issuerange_error'
   */
  export type Enuminducks_issuerange_errorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_issuerange_error'>
    


  /**
   * Reference to a field of type 'inducks_log_marked'
   */
  export type Enuminducks_log_markedFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_log_marked'>
    


  /**
   * Reference to a field of type 'inducks_logocharacter_reallyintitle'
   */
  export type Enuminducks_logocharacter_reallyintitleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_logocharacter_reallyintitle'>
    


  /**
   * Reference to a field of type 'inducks_movie_locked'
   */
  export type Enuminducks_movie_lockedFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_movie_locked'>
    


  /**
   * Reference to a field of type 'inducks_moviecharacter_istitlecharacter'
   */
  export type Enuminducks_moviecharacter_istitlecharacterFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_moviecharacter_istitlecharacter'>
    


  /**
   * Reference to a field of type 'inducks_moviejob_indirect'
   */
  export type Enuminducks_moviejob_indirectFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_moviejob_indirect'>
    


  /**
   * Reference to a field of type 'inducks_moviejob_doubt'
   */
  export type Enuminducks_moviejob_doubtFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_moviejob_doubt'>
    


  /**
   * Reference to a field of type 'inducks_moviereference_frommovietostory'
   */
  export type Enuminducks_moviereference_frommovietostoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_moviereference_frommovietostory'>
    


  /**
   * Reference to a field of type 'inducks_person_official'
   */
  export type Enuminducks_person_officialFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_person_official'>
    


  /**
   * Reference to a field of type 'inducks_person_unknownstudiomember'
   */
  export type Enuminducks_person_unknownstudiomemberFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_person_unknownstudiomember'>
    


  /**
   * Reference to a field of type 'inducks_person_isfake'
   */
  export type Enuminducks_person_isfakeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_person_isfake'>
    


  /**
   * Reference to a field of type 'inducks_publication_numbersarefake'
   */
  export type Enuminducks_publication_numbersarefakeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_publication_numbersarefake'>
    


  /**
   * Reference to a field of type 'inducks_publication_error'
   */
  export type Enuminducks_publication_errorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_publication_error'>
    


  /**
   * Reference to a field of type 'inducks_publication_locked'
   */
  export type Enuminducks_publication_lockedFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_publication_locked'>
    


  /**
   * Reference to a field of type 'inducks_publication_inxforbidden'
   */
  export type Enuminducks_publication_inxforbiddenFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_publication_inxforbidden'>
    


  /**
   * Reference to a field of type 'inducks_site_images'
   */
  export type Enuminducks_site_imagesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_site_images'>
    


  /**
   * Reference to a field of type 'inducks_story_error'
   */
  export type Enuminducks_story_errorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_story_error'>
    


  /**
   * Reference to a field of type 'inducks_story_locked'
   */
  export type Enuminducks_story_lockedFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_story_locked'>
    


  /**
   * Reference to a field of type 'inducks_storyjob_indirect'
   */
  export type Enuminducks_storyjob_indirectFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_storyjob_indirect'>
    


  /**
   * Reference to a field of type 'inducks_storyjob_doubt'
   */
  export type Enuminducks_storyjob_doubtFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_storyjob_doubt'>
    


  /**
   * Reference to a field of type 'inducks_storyversion_brokenpageunspecified'
   */
  export type Enuminducks_storyversion_brokenpageunspecifiedFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_storyversion_brokenpageunspecified'>
    


  /**
   * Reference to a field of type 'inducks_storyversion_appisxapp'
   */
  export type Enuminducks_storyversion_appisxappFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_storyversion_appisxapp'>
    


  /**
   * Reference to a field of type 'inducks_storyversion_nofulltext_brokenpageunspecified'
   */
  export type Enuminducks_storyversion_nofulltext_brokenpageunspecifiedFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_storyversion_nofulltext_brokenpageunspecified'>
    


  /**
   * Reference to a field of type 'inducks_storyversion_nofulltext_appisxapp'
   */
  export type Enuminducks_storyversion_nofulltext_appisxappFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_storyversion_nofulltext_appisxapp'>
    


  /**
   * Reference to a field of type 'inducks_subseries_official'
   */
  export type Enuminducks_subseries_officialFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_subseries_official'>
    


  /**
   * Reference to a field of type 'inducks_subseriesname_preferred'
   */
  export type Enuminducks_subseriesname_preferredFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_subseriesname_preferred'>
    


  /**
   * Reference to a field of type 'inducks_substory_error'
   */
  export type Enuminducks_substory_errorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_substory_error'>
    


  /**
   * Reference to a field of type 'inducks_substory_locked'
   */
  export type Enuminducks_substory_lockedFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'inducks_substory_locked'>
    
  /**
   * Deep Input Types
   */


  export type datasets_entryurlsWhereInput = {
    AND?: datasets_entryurlsWhereInput | datasets_entryurlsWhereInput[]
    OR?: datasets_entryurlsWhereInput[]
    NOT?: datasets_entryurlsWhereInput | datasets_entryurlsWhereInput[]
    id?: IntFilter<"datasets_entryurls"> | number
    dataset_id?: IntFilter<"datasets_entryurls"> | number
    sitecode_url?: StringFilter<"datasets_entryurls"> | string
  }

  export type datasets_entryurlsOrderByWithRelationInput = {
    id?: SortOrder
    dataset_id?: SortOrder
    sitecode_url?: SortOrder
  }

  export type datasets_entryurlsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: datasets_entryurlsWhereInput | datasets_entryurlsWhereInput[]
    OR?: datasets_entryurlsWhereInput[]
    NOT?: datasets_entryurlsWhereInput | datasets_entryurlsWhereInput[]
    dataset_id?: IntFilter<"datasets_entryurls"> | number
    sitecode_url?: StringFilter<"datasets_entryurls"> | string
  }, "id">

  export type datasets_entryurlsOrderByWithAggregationInput = {
    id?: SortOrder
    dataset_id?: SortOrder
    sitecode_url?: SortOrder
    _count?: datasets_entryurlsCountOrderByAggregateInput
    _avg?: datasets_entryurlsAvgOrderByAggregateInput
    _max?: datasets_entryurlsMaxOrderByAggregateInput
    _min?: datasets_entryurlsMinOrderByAggregateInput
    _sum?: datasets_entryurlsSumOrderByAggregateInput
  }

  export type datasets_entryurlsScalarWhereWithAggregatesInput = {
    AND?: datasets_entryurlsScalarWhereWithAggregatesInput | datasets_entryurlsScalarWhereWithAggregatesInput[]
    OR?: datasets_entryurlsScalarWhereWithAggregatesInput[]
    NOT?: datasets_entryurlsScalarWhereWithAggregatesInput | datasets_entryurlsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"datasets_entryurls"> | number
    dataset_id?: IntWithAggregatesFilter<"datasets_entryurls"> | number
    sitecode_url?: StringWithAggregatesFilter<"datasets_entryurls"> | string
  }

  export type inducks_appearanceWhereInput = {
    AND?: inducks_appearanceWhereInput | inducks_appearanceWhereInput[]
    OR?: inducks_appearanceWhereInput[]
    NOT?: inducks_appearanceWhereInput | inducks_appearanceWhereInput[]
    storyversioncode?: StringFilter<"inducks_appearance"> | string
    charactercode?: StringFilter<"inducks_appearance"> | string
    number?: IntNullableFilter<"inducks_appearance"> | number | null
    appearancecomment?: StringNullableFilter<"inducks_appearance"> | string | null
    doubt?: Enuminducks_appearance_doubtNullableFilter<"inducks_appearance"> | $Enums.inducks_appearance_doubt | null
  }

  export type inducks_appearanceOrderByWithRelationInput = {
    storyversioncode?: SortOrder
    charactercode?: SortOrder
    number?: SortOrderInput | SortOrder
    appearancecomment?: SortOrderInput | SortOrder
    doubt?: SortOrderInput | SortOrder
  }

  export type inducks_appearanceWhereUniqueInput = Prisma.AtLeast<{
    storyversioncode_charactercode?: inducks_appearanceStoryversioncodeCharactercodeCompoundUniqueInput
    AND?: inducks_appearanceWhereInput | inducks_appearanceWhereInput[]
    OR?: inducks_appearanceWhereInput[]
    NOT?: inducks_appearanceWhereInput | inducks_appearanceWhereInput[]
    storyversioncode?: StringFilter<"inducks_appearance"> | string
    charactercode?: StringFilter<"inducks_appearance"> | string
    number?: IntNullableFilter<"inducks_appearance"> | number | null
    appearancecomment?: StringNullableFilter<"inducks_appearance"> | string | null
    doubt?: Enuminducks_appearance_doubtNullableFilter<"inducks_appearance"> | $Enums.inducks_appearance_doubt | null
  }, "storyversioncode_charactercode">

  export type inducks_appearanceOrderByWithAggregationInput = {
    storyversioncode?: SortOrder
    charactercode?: SortOrder
    number?: SortOrderInput | SortOrder
    appearancecomment?: SortOrderInput | SortOrder
    doubt?: SortOrderInput | SortOrder
    _count?: inducks_appearanceCountOrderByAggregateInput
    _avg?: inducks_appearanceAvgOrderByAggregateInput
    _max?: inducks_appearanceMaxOrderByAggregateInput
    _min?: inducks_appearanceMinOrderByAggregateInput
    _sum?: inducks_appearanceSumOrderByAggregateInput
  }

  export type inducks_appearanceScalarWhereWithAggregatesInput = {
    AND?: inducks_appearanceScalarWhereWithAggregatesInput | inducks_appearanceScalarWhereWithAggregatesInput[]
    OR?: inducks_appearanceScalarWhereWithAggregatesInput[]
    NOT?: inducks_appearanceScalarWhereWithAggregatesInput | inducks_appearanceScalarWhereWithAggregatesInput[]
    storyversioncode?: StringWithAggregatesFilter<"inducks_appearance"> | string
    charactercode?: StringWithAggregatesFilter<"inducks_appearance"> | string
    number?: IntNullableWithAggregatesFilter<"inducks_appearance"> | number | null
    appearancecomment?: StringNullableWithAggregatesFilter<"inducks_appearance"> | string | null
    doubt?: Enuminducks_appearance_doubtNullableWithAggregatesFilter<"inducks_appearance"> | $Enums.inducks_appearance_doubt | null
  }

  export type inducks_characterWhereInput = {
    AND?: inducks_characterWhereInput | inducks_characterWhereInput[]
    OR?: inducks_characterWhereInput[]
    NOT?: inducks_characterWhereInput | inducks_characterWhereInput[]
    charactercode?: StringFilter<"inducks_character"> | string
    charactername?: StringNullableFilter<"inducks_character"> | string | null
    official?: Enuminducks_character_officialNullableFilter<"inducks_character"> | $Enums.inducks_character_official | null
    onetime?: Enuminducks_character_onetimeNullableFilter<"inducks_character"> | $Enums.inducks_character_onetime | null
    heroonly?: Enuminducks_character_heroonlyNullableFilter<"inducks_character"> | $Enums.inducks_character_heroonly | null
    charactercomment?: StringNullableFilter<"inducks_character"> | string | null
  }

  export type inducks_characterOrderByWithRelationInput = {
    charactercode?: SortOrder
    charactername?: SortOrderInput | SortOrder
    official?: SortOrderInput | SortOrder
    onetime?: SortOrderInput | SortOrder
    heroonly?: SortOrderInput | SortOrder
    charactercomment?: SortOrderInput | SortOrder
  }

  export type inducks_characterWhereUniqueInput = Prisma.AtLeast<{
    charactercode?: string
    AND?: inducks_characterWhereInput | inducks_characterWhereInput[]
    OR?: inducks_characterWhereInput[]
    NOT?: inducks_characterWhereInput | inducks_characterWhereInput[]
    charactername?: StringNullableFilter<"inducks_character"> | string | null
    official?: Enuminducks_character_officialNullableFilter<"inducks_character"> | $Enums.inducks_character_official | null
    onetime?: Enuminducks_character_onetimeNullableFilter<"inducks_character"> | $Enums.inducks_character_onetime | null
    heroonly?: Enuminducks_character_heroonlyNullableFilter<"inducks_character"> | $Enums.inducks_character_heroonly | null
    charactercomment?: StringNullableFilter<"inducks_character"> | string | null
  }, "charactercode">

  export type inducks_characterOrderByWithAggregationInput = {
    charactercode?: SortOrder
    charactername?: SortOrderInput | SortOrder
    official?: SortOrderInput | SortOrder
    onetime?: SortOrderInput | SortOrder
    heroonly?: SortOrderInput | SortOrder
    charactercomment?: SortOrderInput | SortOrder
    _count?: inducks_characterCountOrderByAggregateInput
    _max?: inducks_characterMaxOrderByAggregateInput
    _min?: inducks_characterMinOrderByAggregateInput
  }

  export type inducks_characterScalarWhereWithAggregatesInput = {
    AND?: inducks_characterScalarWhereWithAggregatesInput | inducks_characterScalarWhereWithAggregatesInput[]
    OR?: inducks_characterScalarWhereWithAggregatesInput[]
    NOT?: inducks_characterScalarWhereWithAggregatesInput | inducks_characterScalarWhereWithAggregatesInput[]
    charactercode?: StringWithAggregatesFilter<"inducks_character"> | string
    charactername?: StringNullableWithAggregatesFilter<"inducks_character"> | string | null
    official?: Enuminducks_character_officialNullableWithAggregatesFilter<"inducks_character"> | $Enums.inducks_character_official | null
    onetime?: Enuminducks_character_onetimeNullableWithAggregatesFilter<"inducks_character"> | $Enums.inducks_character_onetime | null
    heroonly?: Enuminducks_character_heroonlyNullableWithAggregatesFilter<"inducks_character"> | $Enums.inducks_character_heroonly | null
    charactercomment?: StringNullableWithAggregatesFilter<"inducks_character"> | string | null
  }

  export type inducks_characteraliasWhereInput = {
    AND?: inducks_characteraliasWhereInput | inducks_characteraliasWhereInput[]
    OR?: inducks_characteraliasWhereInput[]
    NOT?: inducks_characteraliasWhereInput | inducks_characteraliasWhereInput[]
    charactercode?: StringNullableFilter<"inducks_characteralias"> | string | null
    charactername?: StringFilter<"inducks_characteralias"> | string
  }

  export type inducks_characteraliasOrderByWithRelationInput = {
    charactercode?: SortOrderInput | SortOrder
    charactername?: SortOrder
  }

  export type inducks_characteraliasWhereUniqueInput = Prisma.AtLeast<{
    charactername?: string
    AND?: inducks_characteraliasWhereInput | inducks_characteraliasWhereInput[]
    OR?: inducks_characteraliasWhereInput[]
    NOT?: inducks_characteraliasWhereInput | inducks_characteraliasWhereInput[]
    charactercode?: StringNullableFilter<"inducks_characteralias"> | string | null
  }, "charactername">

  export type inducks_characteraliasOrderByWithAggregationInput = {
    charactercode?: SortOrderInput | SortOrder
    charactername?: SortOrder
    _count?: inducks_characteraliasCountOrderByAggregateInput
    _max?: inducks_characteraliasMaxOrderByAggregateInput
    _min?: inducks_characteraliasMinOrderByAggregateInput
  }

  export type inducks_characteraliasScalarWhereWithAggregatesInput = {
    AND?: inducks_characteraliasScalarWhereWithAggregatesInput | inducks_characteraliasScalarWhereWithAggregatesInput[]
    OR?: inducks_characteraliasScalarWhereWithAggregatesInput[]
    NOT?: inducks_characteraliasScalarWhereWithAggregatesInput | inducks_characteraliasScalarWhereWithAggregatesInput[]
    charactercode?: StringNullableWithAggregatesFilter<"inducks_characteralias"> | string | null
    charactername?: StringWithAggregatesFilter<"inducks_characteralias"> | string
  }

  export type inducks_characterdetailWhereInput = {
    AND?: inducks_characterdetailWhereInput | inducks_characterdetailWhereInput[]
    OR?: inducks_characterdetailWhereInput[]
    NOT?: inducks_characterdetailWhereInput | inducks_characterdetailWhereInput[]
    charactername?: StringNullableFilter<"inducks_characterdetail"> | string | null
    charactercode?: StringFilter<"inducks_characterdetail"> | string
    number?: IntNullableFilter<"inducks_characterdetail"> | number | null
  }

  export type inducks_characterdetailOrderByWithRelationInput = {
    charactername?: SortOrderInput | SortOrder
    charactercode?: SortOrder
    number?: SortOrderInput | SortOrder
  }

  export type inducks_characterdetailWhereUniqueInput = Prisma.AtLeast<{
    charactercode?: string
    AND?: inducks_characterdetailWhereInput | inducks_characterdetailWhereInput[]
    OR?: inducks_characterdetailWhereInput[]
    NOT?: inducks_characterdetailWhereInput | inducks_characterdetailWhereInput[]
    charactername?: StringNullableFilter<"inducks_characterdetail"> | string | null
    number?: IntNullableFilter<"inducks_characterdetail"> | number | null
  }, "charactercode">

  export type inducks_characterdetailOrderByWithAggregationInput = {
    charactername?: SortOrderInput | SortOrder
    charactercode?: SortOrder
    number?: SortOrderInput | SortOrder
    _count?: inducks_characterdetailCountOrderByAggregateInput
    _avg?: inducks_characterdetailAvgOrderByAggregateInput
    _max?: inducks_characterdetailMaxOrderByAggregateInput
    _min?: inducks_characterdetailMinOrderByAggregateInput
    _sum?: inducks_characterdetailSumOrderByAggregateInput
  }

  export type inducks_characterdetailScalarWhereWithAggregatesInput = {
    AND?: inducks_characterdetailScalarWhereWithAggregatesInput | inducks_characterdetailScalarWhereWithAggregatesInput[]
    OR?: inducks_characterdetailScalarWhereWithAggregatesInput[]
    NOT?: inducks_characterdetailScalarWhereWithAggregatesInput | inducks_characterdetailScalarWhereWithAggregatesInput[]
    charactername?: StringNullableWithAggregatesFilter<"inducks_characterdetail"> | string | null
    charactercode?: StringWithAggregatesFilter<"inducks_characterdetail"> | string
    number?: IntNullableWithAggregatesFilter<"inducks_characterdetail"> | number | null
  }

  export type inducks_characternameWhereInput = {
    AND?: inducks_characternameWhereInput | inducks_characternameWhereInput[]
    OR?: inducks_characternameWhereInput[]
    NOT?: inducks_characternameWhereInput | inducks_characternameWhereInput[]
    charactercode?: StringFilter<"inducks_charactername"> | string
    languagecode?: StringFilter<"inducks_charactername"> | string
    charactername?: StringFilter<"inducks_charactername"> | string
    preferred?: Enuminducks_charactername_preferredNullableFilter<"inducks_charactername"> | $Enums.inducks_charactername_preferred | null
    characternamecomment?: StringNullableFilter<"inducks_charactername"> | string | null
  }

  export type inducks_characternameOrderByWithRelationInput = {
    charactercode?: SortOrder
    languagecode?: SortOrder
    charactername?: SortOrder
    preferred?: SortOrderInput | SortOrder
    characternamecomment?: SortOrderInput | SortOrder
  }

  export type inducks_characternameWhereUniqueInput = Prisma.AtLeast<{
    charactercode_languagecode_charactername?: inducks_characternameCharactercodeLanguagecodeCharacternameCompoundUniqueInput
    AND?: inducks_characternameWhereInput | inducks_characternameWhereInput[]
    OR?: inducks_characternameWhereInput[]
    NOT?: inducks_characternameWhereInput | inducks_characternameWhereInput[]
    charactercode?: StringFilter<"inducks_charactername"> | string
    languagecode?: StringFilter<"inducks_charactername"> | string
    charactername?: StringFilter<"inducks_charactername"> | string
    preferred?: Enuminducks_charactername_preferredNullableFilter<"inducks_charactername"> | $Enums.inducks_charactername_preferred | null
    characternamecomment?: StringNullableFilter<"inducks_charactername"> | string | null
  }, "charactercode_languagecode_charactername">

  export type inducks_characternameOrderByWithAggregationInput = {
    charactercode?: SortOrder
    languagecode?: SortOrder
    charactername?: SortOrder
    preferred?: SortOrderInput | SortOrder
    characternamecomment?: SortOrderInput | SortOrder
    _count?: inducks_characternameCountOrderByAggregateInput
    _max?: inducks_characternameMaxOrderByAggregateInput
    _min?: inducks_characternameMinOrderByAggregateInput
  }

  export type inducks_characternameScalarWhereWithAggregatesInput = {
    AND?: inducks_characternameScalarWhereWithAggregatesInput | inducks_characternameScalarWhereWithAggregatesInput[]
    OR?: inducks_characternameScalarWhereWithAggregatesInput[]
    NOT?: inducks_characternameScalarWhereWithAggregatesInput | inducks_characternameScalarWhereWithAggregatesInput[]
    charactercode?: StringWithAggregatesFilter<"inducks_charactername"> | string
    languagecode?: StringWithAggregatesFilter<"inducks_charactername"> | string
    charactername?: StringWithAggregatesFilter<"inducks_charactername"> | string
    preferred?: Enuminducks_charactername_preferredNullableWithAggregatesFilter<"inducks_charactername"> | $Enums.inducks_charactername_preferred | null
    characternamecomment?: StringNullableWithAggregatesFilter<"inducks_charactername"> | string | null
  }

  export type inducks_characterreferenceWhereInput = {
    AND?: inducks_characterreferenceWhereInput | inducks_characterreferenceWhereInput[]
    OR?: inducks_characterreferenceWhereInput[]
    NOT?: inducks_characterreferenceWhereInput | inducks_characterreferenceWhereInput[]
    fromcharactercode?: StringFilter<"inducks_characterreference"> | string
    tocharactercode?: StringFilter<"inducks_characterreference"> | string
    isgroupofcharacters?: Enuminducks_characterreference_isgroupofcharactersNullableFilter<"inducks_characterreference"> | $Enums.inducks_characterreference_isgroupofcharacters | null
  }

  export type inducks_characterreferenceOrderByWithRelationInput = {
    fromcharactercode?: SortOrder
    tocharactercode?: SortOrder
    isgroupofcharacters?: SortOrderInput | SortOrder
  }

  export type inducks_characterreferenceWhereUniqueInput = Prisma.AtLeast<{
    fromcharactercode_tocharactercode?: inducks_characterreferenceFromcharactercodeTocharactercodeCompoundUniqueInput
    AND?: inducks_characterreferenceWhereInput | inducks_characterreferenceWhereInput[]
    OR?: inducks_characterreferenceWhereInput[]
    NOT?: inducks_characterreferenceWhereInput | inducks_characterreferenceWhereInput[]
    fromcharactercode?: StringFilter<"inducks_characterreference"> | string
    tocharactercode?: StringFilter<"inducks_characterreference"> | string
    isgroupofcharacters?: Enuminducks_characterreference_isgroupofcharactersNullableFilter<"inducks_characterreference"> | $Enums.inducks_characterreference_isgroupofcharacters | null
  }, "fromcharactercode_tocharactercode">

  export type inducks_characterreferenceOrderByWithAggregationInput = {
    fromcharactercode?: SortOrder
    tocharactercode?: SortOrder
    isgroupofcharacters?: SortOrderInput | SortOrder
    _count?: inducks_characterreferenceCountOrderByAggregateInput
    _max?: inducks_characterreferenceMaxOrderByAggregateInput
    _min?: inducks_characterreferenceMinOrderByAggregateInput
  }

  export type inducks_characterreferenceScalarWhereWithAggregatesInput = {
    AND?: inducks_characterreferenceScalarWhereWithAggregatesInput | inducks_characterreferenceScalarWhereWithAggregatesInput[]
    OR?: inducks_characterreferenceScalarWhereWithAggregatesInput[]
    NOT?: inducks_characterreferenceScalarWhereWithAggregatesInput | inducks_characterreferenceScalarWhereWithAggregatesInput[]
    fromcharactercode?: StringWithAggregatesFilter<"inducks_characterreference"> | string
    tocharactercode?: StringWithAggregatesFilter<"inducks_characterreference"> | string
    isgroupofcharacters?: Enuminducks_characterreference_isgroupofcharactersNullableWithAggregatesFilter<"inducks_characterreference"> | $Enums.inducks_characterreference_isgroupofcharacters | null
  }

  export type inducks_characterurlWhereInput = {
    AND?: inducks_characterurlWhereInput | inducks_characterurlWhereInput[]
    OR?: inducks_characterurlWhereInput[]
    NOT?: inducks_characterurlWhereInput | inducks_characterurlWhereInput[]
    charactercode?: StringFilter<"inducks_characterurl"> | string
    sitecode?: StringFilter<"inducks_characterurl"> | string
    url?: StringNullableFilter<"inducks_characterurl"> | string | null
  }

  export type inducks_characterurlOrderByWithRelationInput = {
    charactercode?: SortOrder
    sitecode?: SortOrder
    url?: SortOrderInput | SortOrder
  }

  export type inducks_characterurlWhereUniqueInput = Prisma.AtLeast<{
    charactercode_sitecode?: inducks_characterurlCharactercodeSitecodeCompoundUniqueInput
    AND?: inducks_characterurlWhereInput | inducks_characterurlWhereInput[]
    OR?: inducks_characterurlWhereInput[]
    NOT?: inducks_characterurlWhereInput | inducks_characterurlWhereInput[]
    charactercode?: StringFilter<"inducks_characterurl"> | string
    sitecode?: StringFilter<"inducks_characterurl"> | string
    url?: StringNullableFilter<"inducks_characterurl"> | string | null
  }, "charactercode_sitecode">

  export type inducks_characterurlOrderByWithAggregationInput = {
    charactercode?: SortOrder
    sitecode?: SortOrder
    url?: SortOrderInput | SortOrder
    _count?: inducks_characterurlCountOrderByAggregateInput
    _max?: inducks_characterurlMaxOrderByAggregateInput
    _min?: inducks_characterurlMinOrderByAggregateInput
  }

  export type inducks_characterurlScalarWhereWithAggregatesInput = {
    AND?: inducks_characterurlScalarWhereWithAggregatesInput | inducks_characterurlScalarWhereWithAggregatesInput[]
    OR?: inducks_characterurlScalarWhereWithAggregatesInput[]
    NOT?: inducks_characterurlScalarWhereWithAggregatesInput | inducks_characterurlScalarWhereWithAggregatesInput[]
    charactercode?: StringWithAggregatesFilter<"inducks_characterurl"> | string
    sitecode?: StringWithAggregatesFilter<"inducks_characterurl"> | string
    url?: StringNullableWithAggregatesFilter<"inducks_characterurl"> | string | null
  }

  export type inducks_countryWhereInput = {
    AND?: inducks_countryWhereInput | inducks_countryWhereInput[]
    OR?: inducks_countryWhereInput[]
    NOT?: inducks_countryWhereInput | inducks_countryWhereInput[]
    countrycode?: StringFilter<"inducks_country"> | string
    countryname?: StringNullableFilter<"inducks_country"> | string | null
    defaultlanguage?: StringNullableFilter<"inducks_country"> | string | null
    defaultmaintenanceteam?: StringNullableFilter<"inducks_country"> | string | null
  }

  export type inducks_countryOrderByWithRelationInput = {
    countrycode?: SortOrder
    countryname?: SortOrderInput | SortOrder
    defaultlanguage?: SortOrderInput | SortOrder
    defaultmaintenanceteam?: SortOrderInput | SortOrder
  }

  export type inducks_countryWhereUniqueInput = Prisma.AtLeast<{
    countrycode?: string
    AND?: inducks_countryWhereInput | inducks_countryWhereInput[]
    OR?: inducks_countryWhereInput[]
    NOT?: inducks_countryWhereInput | inducks_countryWhereInput[]
    countryname?: StringNullableFilter<"inducks_country"> | string | null
    defaultlanguage?: StringNullableFilter<"inducks_country"> | string | null
    defaultmaintenanceteam?: StringNullableFilter<"inducks_country"> | string | null
  }, "countrycode">

  export type inducks_countryOrderByWithAggregationInput = {
    countrycode?: SortOrder
    countryname?: SortOrderInput | SortOrder
    defaultlanguage?: SortOrderInput | SortOrder
    defaultmaintenanceteam?: SortOrderInput | SortOrder
    _count?: inducks_countryCountOrderByAggregateInput
    _max?: inducks_countryMaxOrderByAggregateInput
    _min?: inducks_countryMinOrderByAggregateInput
  }

  export type inducks_countryScalarWhereWithAggregatesInput = {
    AND?: inducks_countryScalarWhereWithAggregatesInput | inducks_countryScalarWhereWithAggregatesInput[]
    OR?: inducks_countryScalarWhereWithAggregatesInput[]
    NOT?: inducks_countryScalarWhereWithAggregatesInput | inducks_countryScalarWhereWithAggregatesInput[]
    countrycode?: StringWithAggregatesFilter<"inducks_country"> | string
    countryname?: StringNullableWithAggregatesFilter<"inducks_country"> | string | null
    defaultlanguage?: StringNullableWithAggregatesFilter<"inducks_country"> | string | null
    defaultmaintenanceteam?: StringNullableWithAggregatesFilter<"inducks_country"> | string | null
  }

  export type inducks_countrynameWhereInput = {
    AND?: inducks_countrynameWhereInput | inducks_countrynameWhereInput[]
    OR?: inducks_countrynameWhereInput[]
    NOT?: inducks_countrynameWhereInput | inducks_countrynameWhereInput[]
    countrycode?: StringFilter<"inducks_countryname"> | string
    languagecode?: StringFilter<"inducks_countryname"> | string
    countryname?: StringNullableFilter<"inducks_countryname"> | string | null
  }

  export type inducks_countrynameOrderByWithRelationInput = {
    countrycode?: SortOrder
    languagecode?: SortOrder
    countryname?: SortOrderInput | SortOrder
  }

  export type inducks_countrynameWhereUniqueInput = Prisma.AtLeast<{
    countrycode_languagecode?: inducks_countrynameCountrycodeLanguagecodeCompoundUniqueInput
    AND?: inducks_countrynameWhereInput | inducks_countrynameWhereInput[]
    OR?: inducks_countrynameWhereInput[]
    NOT?: inducks_countrynameWhereInput | inducks_countrynameWhereInput[]
    countrycode?: StringFilter<"inducks_countryname"> | string
    languagecode?: StringFilter<"inducks_countryname"> | string
    countryname?: StringNullableFilter<"inducks_countryname"> | string | null
  }, "countrycode_languagecode">

  export type inducks_countrynameOrderByWithAggregationInput = {
    countrycode?: SortOrder
    languagecode?: SortOrder
    countryname?: SortOrderInput | SortOrder
    _count?: inducks_countrynameCountOrderByAggregateInput
    _max?: inducks_countrynameMaxOrderByAggregateInput
    _min?: inducks_countrynameMinOrderByAggregateInput
  }

  export type inducks_countrynameScalarWhereWithAggregatesInput = {
    AND?: inducks_countrynameScalarWhereWithAggregatesInput | inducks_countrynameScalarWhereWithAggregatesInput[]
    OR?: inducks_countrynameScalarWhereWithAggregatesInput[]
    NOT?: inducks_countrynameScalarWhereWithAggregatesInput | inducks_countrynameScalarWhereWithAggregatesInput[]
    countrycode?: StringWithAggregatesFilter<"inducks_countryname"> | string
    languagecode?: StringWithAggregatesFilter<"inducks_countryname"> | string
    countryname?: StringNullableWithAggregatesFilter<"inducks_countryname"> | string | null
  }

  export type inducks_currencyWhereInput = {
    AND?: inducks_currencyWhereInput | inducks_currencyWhereInput[]
    OR?: inducks_currencyWhereInput[]
    NOT?: inducks_currencyWhereInput | inducks_currencyWhereInput[]
    currencycode?: StringFilter<"inducks_currency"> | string
    currencyname?: StringNullableFilter<"inducks_currency"> | string | null
  }

  export type inducks_currencyOrderByWithRelationInput = {
    currencycode?: SortOrder
    currencyname?: SortOrderInput | SortOrder
  }

  export type inducks_currencyWhereUniqueInput = Prisma.AtLeast<{
    currencycode?: string
    AND?: inducks_currencyWhereInput | inducks_currencyWhereInput[]
    OR?: inducks_currencyWhereInput[]
    NOT?: inducks_currencyWhereInput | inducks_currencyWhereInput[]
    currencyname?: StringNullableFilter<"inducks_currency"> | string | null
  }, "currencycode">

  export type inducks_currencyOrderByWithAggregationInput = {
    currencycode?: SortOrder
    currencyname?: SortOrderInput | SortOrder
    _count?: inducks_currencyCountOrderByAggregateInput
    _max?: inducks_currencyMaxOrderByAggregateInput
    _min?: inducks_currencyMinOrderByAggregateInput
  }

  export type inducks_currencyScalarWhereWithAggregatesInput = {
    AND?: inducks_currencyScalarWhereWithAggregatesInput | inducks_currencyScalarWhereWithAggregatesInput[]
    OR?: inducks_currencyScalarWhereWithAggregatesInput[]
    NOT?: inducks_currencyScalarWhereWithAggregatesInput | inducks_currencyScalarWhereWithAggregatesInput[]
    currencycode?: StringWithAggregatesFilter<"inducks_currency"> | string
    currencyname?: StringNullableWithAggregatesFilter<"inducks_currency"> | string | null
  }

  export type inducks_currencynameWhereInput = {
    AND?: inducks_currencynameWhereInput | inducks_currencynameWhereInput[]
    OR?: inducks_currencynameWhereInput[]
    NOT?: inducks_currencynameWhereInput | inducks_currencynameWhereInput[]
    currencycode?: StringFilter<"inducks_currencyname"> | string
    languagecode?: StringFilter<"inducks_currencyname"> | string
    shortcurrencyname?: StringNullableFilter<"inducks_currencyname"> | string | null
    longcurrencyname?: StringNullableFilter<"inducks_currencyname"> | string | null
  }

  export type inducks_currencynameOrderByWithRelationInput = {
    currencycode?: SortOrder
    languagecode?: SortOrder
    shortcurrencyname?: SortOrderInput | SortOrder
    longcurrencyname?: SortOrderInput | SortOrder
  }

  export type inducks_currencynameWhereUniqueInput = Prisma.AtLeast<{
    currencycode_languagecode?: inducks_currencynameCurrencycodeLanguagecodeCompoundUniqueInput
    AND?: inducks_currencynameWhereInput | inducks_currencynameWhereInput[]
    OR?: inducks_currencynameWhereInput[]
    NOT?: inducks_currencynameWhereInput | inducks_currencynameWhereInput[]
    currencycode?: StringFilter<"inducks_currencyname"> | string
    languagecode?: StringFilter<"inducks_currencyname"> | string
    shortcurrencyname?: StringNullableFilter<"inducks_currencyname"> | string | null
    longcurrencyname?: StringNullableFilter<"inducks_currencyname"> | string | null
  }, "currencycode_languagecode">

  export type inducks_currencynameOrderByWithAggregationInput = {
    currencycode?: SortOrder
    languagecode?: SortOrder
    shortcurrencyname?: SortOrderInput | SortOrder
    longcurrencyname?: SortOrderInput | SortOrder
    _count?: inducks_currencynameCountOrderByAggregateInput
    _max?: inducks_currencynameMaxOrderByAggregateInput
    _min?: inducks_currencynameMinOrderByAggregateInput
  }

  export type inducks_currencynameScalarWhereWithAggregatesInput = {
    AND?: inducks_currencynameScalarWhereWithAggregatesInput | inducks_currencynameScalarWhereWithAggregatesInput[]
    OR?: inducks_currencynameScalarWhereWithAggregatesInput[]
    NOT?: inducks_currencynameScalarWhereWithAggregatesInput | inducks_currencynameScalarWhereWithAggregatesInput[]
    currencycode?: StringWithAggregatesFilter<"inducks_currencyname"> | string
    languagecode?: StringWithAggregatesFilter<"inducks_currencyname"> | string
    shortcurrencyname?: StringNullableWithAggregatesFilter<"inducks_currencyname"> | string | null
    longcurrencyname?: StringNullableWithAggregatesFilter<"inducks_currencyname"> | string | null
  }

  export type inducks_entryWhereInput = {
    AND?: inducks_entryWhereInput | inducks_entryWhereInput[]
    OR?: inducks_entryWhereInput[]
    NOT?: inducks_entryWhereInput | inducks_entryWhereInput[]
    entrycode?: StringFilter<"inducks_entry"> | string
    issuecode?: StringNullableFilter<"inducks_entry"> | string | null
    storyversioncode?: StringNullableFilter<"inducks_entry"> | string | null
    languagecode?: StringNullableFilter<"inducks_entry"> | string | null
    includedinentrycode?: StringNullableFilter<"inducks_entry"> | string | null
    position?: StringNullableFilter<"inducks_entry"> | string | null
    printedcode?: StringNullableFilter<"inducks_entry"> | string | null
    guessedcode?: StringNullableFilter<"inducks_entry"> | string | null
    title?: StringNullableFilter<"inducks_entry"> | string | null
    reallytitle?: Enuminducks_entry_reallytitleNullableFilter<"inducks_entry"> | $Enums.inducks_entry_reallytitle | null
    printedhero?: StringNullableFilter<"inducks_entry"> | string | null
    changes?: StringNullableFilter<"inducks_entry"> | string | null
    cut?: StringNullableFilter<"inducks_entry"> | string | null
    minorchanges?: StringNullableFilter<"inducks_entry"> | string | null
    missingpanels?: StringNullableFilter<"inducks_entry"> | string | null
    mirrored?: Enuminducks_entry_mirroredNullableFilter<"inducks_entry"> | $Enums.inducks_entry_mirrored | null
    sideways?: Enuminducks_entry_sidewaysNullableFilter<"inducks_entry"> | $Enums.inducks_entry_sideways | null
    startdate?: StringNullableFilter<"inducks_entry"> | string | null
    enddate?: StringNullableFilter<"inducks_entry"> | string | null
    identificationuncertain?: Enuminducks_entry_identificationuncertainNullableFilter<"inducks_entry"> | $Enums.inducks_entry_identificationuncertain | null
    alsoreprint?: StringNullableFilter<"inducks_entry"> | string | null
    part?: StringNullableFilter<"inducks_entry"> | string | null
    entrycomment?: StringNullableFilter<"inducks_entry"> | string | null
    error?: Enuminducks_entry_errorNullableFilter<"inducks_entry"> | $Enums.inducks_entry_error | null
  }

  export type inducks_entryOrderByWithRelationInput = {
    entrycode?: SortOrder
    issuecode?: SortOrderInput | SortOrder
    storyversioncode?: SortOrderInput | SortOrder
    languagecode?: SortOrderInput | SortOrder
    includedinentrycode?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    printedcode?: SortOrderInput | SortOrder
    guessedcode?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    reallytitle?: SortOrderInput | SortOrder
    printedhero?: SortOrderInput | SortOrder
    changes?: SortOrderInput | SortOrder
    cut?: SortOrderInput | SortOrder
    minorchanges?: SortOrderInput | SortOrder
    missingpanels?: SortOrderInput | SortOrder
    mirrored?: SortOrderInput | SortOrder
    sideways?: SortOrderInput | SortOrder
    startdate?: SortOrderInput | SortOrder
    enddate?: SortOrderInput | SortOrder
    identificationuncertain?: SortOrderInput | SortOrder
    alsoreprint?: SortOrderInput | SortOrder
    part?: SortOrderInput | SortOrder
    entrycomment?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
  }

  export type inducks_entryWhereUniqueInput = Prisma.AtLeast<{
    entrycode?: string
    AND?: inducks_entryWhereInput | inducks_entryWhereInput[]
    OR?: inducks_entryWhereInput[]
    NOT?: inducks_entryWhereInput | inducks_entryWhereInput[]
    issuecode?: StringNullableFilter<"inducks_entry"> | string | null
    storyversioncode?: StringNullableFilter<"inducks_entry"> | string | null
    languagecode?: StringNullableFilter<"inducks_entry"> | string | null
    includedinentrycode?: StringNullableFilter<"inducks_entry"> | string | null
    position?: StringNullableFilter<"inducks_entry"> | string | null
    printedcode?: StringNullableFilter<"inducks_entry"> | string | null
    guessedcode?: StringNullableFilter<"inducks_entry"> | string | null
    title?: StringNullableFilter<"inducks_entry"> | string | null
    reallytitle?: Enuminducks_entry_reallytitleNullableFilter<"inducks_entry"> | $Enums.inducks_entry_reallytitle | null
    printedhero?: StringNullableFilter<"inducks_entry"> | string | null
    changes?: StringNullableFilter<"inducks_entry"> | string | null
    cut?: StringNullableFilter<"inducks_entry"> | string | null
    minorchanges?: StringNullableFilter<"inducks_entry"> | string | null
    missingpanels?: StringNullableFilter<"inducks_entry"> | string | null
    mirrored?: Enuminducks_entry_mirroredNullableFilter<"inducks_entry"> | $Enums.inducks_entry_mirrored | null
    sideways?: Enuminducks_entry_sidewaysNullableFilter<"inducks_entry"> | $Enums.inducks_entry_sideways | null
    startdate?: StringNullableFilter<"inducks_entry"> | string | null
    enddate?: StringNullableFilter<"inducks_entry"> | string | null
    identificationuncertain?: Enuminducks_entry_identificationuncertainNullableFilter<"inducks_entry"> | $Enums.inducks_entry_identificationuncertain | null
    alsoreprint?: StringNullableFilter<"inducks_entry"> | string | null
    part?: StringNullableFilter<"inducks_entry"> | string | null
    entrycomment?: StringNullableFilter<"inducks_entry"> | string | null
    error?: Enuminducks_entry_errorNullableFilter<"inducks_entry"> | $Enums.inducks_entry_error | null
  }, "entrycode">

  export type inducks_entryOrderByWithAggregationInput = {
    entrycode?: SortOrder
    issuecode?: SortOrderInput | SortOrder
    storyversioncode?: SortOrderInput | SortOrder
    languagecode?: SortOrderInput | SortOrder
    includedinentrycode?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    printedcode?: SortOrderInput | SortOrder
    guessedcode?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    reallytitle?: SortOrderInput | SortOrder
    printedhero?: SortOrderInput | SortOrder
    changes?: SortOrderInput | SortOrder
    cut?: SortOrderInput | SortOrder
    minorchanges?: SortOrderInput | SortOrder
    missingpanels?: SortOrderInput | SortOrder
    mirrored?: SortOrderInput | SortOrder
    sideways?: SortOrderInput | SortOrder
    startdate?: SortOrderInput | SortOrder
    enddate?: SortOrderInput | SortOrder
    identificationuncertain?: SortOrderInput | SortOrder
    alsoreprint?: SortOrderInput | SortOrder
    part?: SortOrderInput | SortOrder
    entrycomment?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    _count?: inducks_entryCountOrderByAggregateInput
    _max?: inducks_entryMaxOrderByAggregateInput
    _min?: inducks_entryMinOrderByAggregateInput
  }

  export type inducks_entryScalarWhereWithAggregatesInput = {
    AND?: inducks_entryScalarWhereWithAggregatesInput | inducks_entryScalarWhereWithAggregatesInput[]
    OR?: inducks_entryScalarWhereWithAggregatesInput[]
    NOT?: inducks_entryScalarWhereWithAggregatesInput | inducks_entryScalarWhereWithAggregatesInput[]
    entrycode?: StringWithAggregatesFilter<"inducks_entry"> | string
    issuecode?: StringNullableWithAggregatesFilter<"inducks_entry"> | string | null
    storyversioncode?: StringNullableWithAggregatesFilter<"inducks_entry"> | string | null
    languagecode?: StringNullableWithAggregatesFilter<"inducks_entry"> | string | null
    includedinentrycode?: StringNullableWithAggregatesFilter<"inducks_entry"> | string | null
    position?: StringNullableWithAggregatesFilter<"inducks_entry"> | string | null
    printedcode?: StringNullableWithAggregatesFilter<"inducks_entry"> | string | null
    guessedcode?: StringNullableWithAggregatesFilter<"inducks_entry"> | string | null
    title?: StringNullableWithAggregatesFilter<"inducks_entry"> | string | null
    reallytitle?: Enuminducks_entry_reallytitleNullableWithAggregatesFilter<"inducks_entry"> | $Enums.inducks_entry_reallytitle | null
    printedhero?: StringNullableWithAggregatesFilter<"inducks_entry"> | string | null
    changes?: StringNullableWithAggregatesFilter<"inducks_entry"> | string | null
    cut?: StringNullableWithAggregatesFilter<"inducks_entry"> | string | null
    minorchanges?: StringNullableWithAggregatesFilter<"inducks_entry"> | string | null
    missingpanels?: StringNullableWithAggregatesFilter<"inducks_entry"> | string | null
    mirrored?: Enuminducks_entry_mirroredNullableWithAggregatesFilter<"inducks_entry"> | $Enums.inducks_entry_mirrored | null
    sideways?: Enuminducks_entry_sidewaysNullableWithAggregatesFilter<"inducks_entry"> | $Enums.inducks_entry_sideways | null
    startdate?: StringNullableWithAggregatesFilter<"inducks_entry"> | string | null
    enddate?: StringNullableWithAggregatesFilter<"inducks_entry"> | string | null
    identificationuncertain?: Enuminducks_entry_identificationuncertainNullableWithAggregatesFilter<"inducks_entry"> | $Enums.inducks_entry_identificationuncertain | null
    alsoreprint?: StringNullableWithAggregatesFilter<"inducks_entry"> | string | null
    part?: StringNullableWithAggregatesFilter<"inducks_entry"> | string | null
    entrycomment?: StringNullableWithAggregatesFilter<"inducks_entry"> | string | null
    error?: Enuminducks_entry_errorNullableWithAggregatesFilter<"inducks_entry"> | $Enums.inducks_entry_error | null
  }

  export type inducks_entry_nofulltextWhereInput = {
    AND?: inducks_entry_nofulltextWhereInput | inducks_entry_nofulltextWhereInput[]
    OR?: inducks_entry_nofulltextWhereInput[]
    NOT?: inducks_entry_nofulltextWhereInput | inducks_entry_nofulltextWhereInput[]
    entrycode?: StringFilter<"inducks_entry_nofulltext"> | string
    issuecode?: StringNullableFilter<"inducks_entry_nofulltext"> | string | null
    storyversioncode?: StringNullableFilter<"inducks_entry_nofulltext"> | string | null
    languagecode?: StringNullableFilter<"inducks_entry_nofulltext"> | string | null
    includedinentrycode?: StringNullableFilter<"inducks_entry_nofulltext"> | string | null
    position?: StringNullableFilter<"inducks_entry_nofulltext"> | string | null
    printedcode?: StringNullableFilter<"inducks_entry_nofulltext"> | string | null
    guessedcode?: StringNullableFilter<"inducks_entry_nofulltext"> | string | null
    title?: StringNullableFilter<"inducks_entry_nofulltext"> | string | null
    reallytitle?: Enuminducks_entry_nofulltext_reallytitleNullableFilter<"inducks_entry_nofulltext"> | $Enums.inducks_entry_nofulltext_reallytitle | null
    printedhero?: StringNullableFilter<"inducks_entry_nofulltext"> | string | null
    changes?: StringNullableFilter<"inducks_entry_nofulltext"> | string | null
    cut?: StringNullableFilter<"inducks_entry_nofulltext"> | string | null
    minorchanges?: StringNullableFilter<"inducks_entry_nofulltext"> | string | null
    missingpanels?: StringNullableFilter<"inducks_entry_nofulltext"> | string | null
    mirrored?: Enuminducks_entry_nofulltext_mirroredNullableFilter<"inducks_entry_nofulltext"> | $Enums.inducks_entry_nofulltext_mirrored | null
    sideways?: Enuminducks_entry_nofulltext_sidewaysNullableFilter<"inducks_entry_nofulltext"> | $Enums.inducks_entry_nofulltext_sideways | null
    startdate?: StringNullableFilter<"inducks_entry_nofulltext"> | string | null
    enddate?: StringNullableFilter<"inducks_entry_nofulltext"> | string | null
    identificationuncertain?: Enuminducks_entry_nofulltext_identificationuncertainNullableFilter<"inducks_entry_nofulltext"> | $Enums.inducks_entry_nofulltext_identificationuncertain | null
    alsoreprint?: StringNullableFilter<"inducks_entry_nofulltext"> | string | null
    part?: StringNullableFilter<"inducks_entry_nofulltext"> | string | null
    entrycomment?: StringNullableFilter<"inducks_entry_nofulltext"> | string | null
    error?: Enuminducks_entry_nofulltext_errorNullableFilter<"inducks_entry_nofulltext"> | $Enums.inducks_entry_nofulltext_error | null
  }

  export type inducks_entry_nofulltextOrderByWithRelationInput = {
    entrycode?: SortOrder
    issuecode?: SortOrderInput | SortOrder
    storyversioncode?: SortOrderInput | SortOrder
    languagecode?: SortOrderInput | SortOrder
    includedinentrycode?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    printedcode?: SortOrderInput | SortOrder
    guessedcode?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    reallytitle?: SortOrderInput | SortOrder
    printedhero?: SortOrderInput | SortOrder
    changes?: SortOrderInput | SortOrder
    cut?: SortOrderInput | SortOrder
    minorchanges?: SortOrderInput | SortOrder
    missingpanels?: SortOrderInput | SortOrder
    mirrored?: SortOrderInput | SortOrder
    sideways?: SortOrderInput | SortOrder
    startdate?: SortOrderInput | SortOrder
    enddate?: SortOrderInput | SortOrder
    identificationuncertain?: SortOrderInput | SortOrder
    alsoreprint?: SortOrderInput | SortOrder
    part?: SortOrderInput | SortOrder
    entrycomment?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
  }

  export type inducks_entry_nofulltextWhereUniqueInput = Prisma.AtLeast<{
    entrycode?: string
    AND?: inducks_entry_nofulltextWhereInput | inducks_entry_nofulltextWhereInput[]
    OR?: inducks_entry_nofulltextWhereInput[]
    NOT?: inducks_entry_nofulltextWhereInput | inducks_entry_nofulltextWhereInput[]
    issuecode?: StringNullableFilter<"inducks_entry_nofulltext"> | string | null
    storyversioncode?: StringNullableFilter<"inducks_entry_nofulltext"> | string | null
    languagecode?: StringNullableFilter<"inducks_entry_nofulltext"> | string | null
    includedinentrycode?: StringNullableFilter<"inducks_entry_nofulltext"> | string | null
    position?: StringNullableFilter<"inducks_entry_nofulltext"> | string | null
    printedcode?: StringNullableFilter<"inducks_entry_nofulltext"> | string | null
    guessedcode?: StringNullableFilter<"inducks_entry_nofulltext"> | string | null
    title?: StringNullableFilter<"inducks_entry_nofulltext"> | string | null
    reallytitle?: Enuminducks_entry_nofulltext_reallytitleNullableFilter<"inducks_entry_nofulltext"> | $Enums.inducks_entry_nofulltext_reallytitle | null
    printedhero?: StringNullableFilter<"inducks_entry_nofulltext"> | string | null
    changes?: StringNullableFilter<"inducks_entry_nofulltext"> | string | null
    cut?: StringNullableFilter<"inducks_entry_nofulltext"> | string | null
    minorchanges?: StringNullableFilter<"inducks_entry_nofulltext"> | string | null
    missingpanels?: StringNullableFilter<"inducks_entry_nofulltext"> | string | null
    mirrored?: Enuminducks_entry_nofulltext_mirroredNullableFilter<"inducks_entry_nofulltext"> | $Enums.inducks_entry_nofulltext_mirrored | null
    sideways?: Enuminducks_entry_nofulltext_sidewaysNullableFilter<"inducks_entry_nofulltext"> | $Enums.inducks_entry_nofulltext_sideways | null
    startdate?: StringNullableFilter<"inducks_entry_nofulltext"> | string | null
    enddate?: StringNullableFilter<"inducks_entry_nofulltext"> | string | null
    identificationuncertain?: Enuminducks_entry_nofulltext_identificationuncertainNullableFilter<"inducks_entry_nofulltext"> | $Enums.inducks_entry_nofulltext_identificationuncertain | null
    alsoreprint?: StringNullableFilter<"inducks_entry_nofulltext"> | string | null
    part?: StringNullableFilter<"inducks_entry_nofulltext"> | string | null
    entrycomment?: StringNullableFilter<"inducks_entry_nofulltext"> | string | null
    error?: Enuminducks_entry_nofulltext_errorNullableFilter<"inducks_entry_nofulltext"> | $Enums.inducks_entry_nofulltext_error | null
  }, "entrycode">

  export type inducks_entry_nofulltextOrderByWithAggregationInput = {
    entrycode?: SortOrder
    issuecode?: SortOrderInput | SortOrder
    storyversioncode?: SortOrderInput | SortOrder
    languagecode?: SortOrderInput | SortOrder
    includedinentrycode?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    printedcode?: SortOrderInput | SortOrder
    guessedcode?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    reallytitle?: SortOrderInput | SortOrder
    printedhero?: SortOrderInput | SortOrder
    changes?: SortOrderInput | SortOrder
    cut?: SortOrderInput | SortOrder
    minorchanges?: SortOrderInput | SortOrder
    missingpanels?: SortOrderInput | SortOrder
    mirrored?: SortOrderInput | SortOrder
    sideways?: SortOrderInput | SortOrder
    startdate?: SortOrderInput | SortOrder
    enddate?: SortOrderInput | SortOrder
    identificationuncertain?: SortOrderInput | SortOrder
    alsoreprint?: SortOrderInput | SortOrder
    part?: SortOrderInput | SortOrder
    entrycomment?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    _count?: inducks_entry_nofulltextCountOrderByAggregateInput
    _max?: inducks_entry_nofulltextMaxOrderByAggregateInput
    _min?: inducks_entry_nofulltextMinOrderByAggregateInput
  }

  export type inducks_entry_nofulltextScalarWhereWithAggregatesInput = {
    AND?: inducks_entry_nofulltextScalarWhereWithAggregatesInput | inducks_entry_nofulltextScalarWhereWithAggregatesInput[]
    OR?: inducks_entry_nofulltextScalarWhereWithAggregatesInput[]
    NOT?: inducks_entry_nofulltextScalarWhereWithAggregatesInput | inducks_entry_nofulltextScalarWhereWithAggregatesInput[]
    entrycode?: StringWithAggregatesFilter<"inducks_entry_nofulltext"> | string
    issuecode?: StringNullableWithAggregatesFilter<"inducks_entry_nofulltext"> | string | null
    storyversioncode?: StringNullableWithAggregatesFilter<"inducks_entry_nofulltext"> | string | null
    languagecode?: StringNullableWithAggregatesFilter<"inducks_entry_nofulltext"> | string | null
    includedinentrycode?: StringNullableWithAggregatesFilter<"inducks_entry_nofulltext"> | string | null
    position?: StringNullableWithAggregatesFilter<"inducks_entry_nofulltext"> | string | null
    printedcode?: StringNullableWithAggregatesFilter<"inducks_entry_nofulltext"> | string | null
    guessedcode?: StringNullableWithAggregatesFilter<"inducks_entry_nofulltext"> | string | null
    title?: StringNullableWithAggregatesFilter<"inducks_entry_nofulltext"> | string | null
    reallytitle?: Enuminducks_entry_nofulltext_reallytitleNullableWithAggregatesFilter<"inducks_entry_nofulltext"> | $Enums.inducks_entry_nofulltext_reallytitle | null
    printedhero?: StringNullableWithAggregatesFilter<"inducks_entry_nofulltext"> | string | null
    changes?: StringNullableWithAggregatesFilter<"inducks_entry_nofulltext"> | string | null
    cut?: StringNullableWithAggregatesFilter<"inducks_entry_nofulltext"> | string | null
    minorchanges?: StringNullableWithAggregatesFilter<"inducks_entry_nofulltext"> | string | null
    missingpanels?: StringNullableWithAggregatesFilter<"inducks_entry_nofulltext"> | string | null
    mirrored?: Enuminducks_entry_nofulltext_mirroredNullableWithAggregatesFilter<"inducks_entry_nofulltext"> | $Enums.inducks_entry_nofulltext_mirrored | null
    sideways?: Enuminducks_entry_nofulltext_sidewaysNullableWithAggregatesFilter<"inducks_entry_nofulltext"> | $Enums.inducks_entry_nofulltext_sideways | null
    startdate?: StringNullableWithAggregatesFilter<"inducks_entry_nofulltext"> | string | null
    enddate?: StringNullableWithAggregatesFilter<"inducks_entry_nofulltext"> | string | null
    identificationuncertain?: Enuminducks_entry_nofulltext_identificationuncertainNullableWithAggregatesFilter<"inducks_entry_nofulltext"> | $Enums.inducks_entry_nofulltext_identificationuncertain | null
    alsoreprint?: StringNullableWithAggregatesFilter<"inducks_entry_nofulltext"> | string | null
    part?: StringNullableWithAggregatesFilter<"inducks_entry_nofulltext"> | string | null
    entrycomment?: StringNullableWithAggregatesFilter<"inducks_entry_nofulltext"> | string | null
    error?: Enuminducks_entry_nofulltext_errorNullableWithAggregatesFilter<"inducks_entry_nofulltext"> | $Enums.inducks_entry_nofulltext_error | null
  }

  export type inducks_entrycharacternameWhereInput = {
    AND?: inducks_entrycharacternameWhereInput | inducks_entrycharacternameWhereInput[]
    OR?: inducks_entrycharacternameWhereInput[]
    NOT?: inducks_entrycharacternameWhereInput | inducks_entrycharacternameWhereInput[]
    entrycode?: StringFilter<"inducks_entrycharactername"> | string
    charactercode?: StringFilter<"inducks_entrycharactername"> | string
    charactername?: StringNullableFilter<"inducks_entrycharactername"> | string | null
  }

  export type inducks_entrycharacternameOrderByWithRelationInput = {
    entrycode?: SortOrder
    charactercode?: SortOrder
    charactername?: SortOrderInput | SortOrder
  }

  export type inducks_entrycharacternameWhereUniqueInput = Prisma.AtLeast<{
    entrycode_charactercode?: inducks_entrycharacternameEntrycodeCharactercodeCompoundUniqueInput
    AND?: inducks_entrycharacternameWhereInput | inducks_entrycharacternameWhereInput[]
    OR?: inducks_entrycharacternameWhereInput[]
    NOT?: inducks_entrycharacternameWhereInput | inducks_entrycharacternameWhereInput[]
    entrycode?: StringFilter<"inducks_entrycharactername"> | string
    charactercode?: StringFilter<"inducks_entrycharactername"> | string
    charactername?: StringNullableFilter<"inducks_entrycharactername"> | string | null
  }, "entrycode_charactercode">

  export type inducks_entrycharacternameOrderByWithAggregationInput = {
    entrycode?: SortOrder
    charactercode?: SortOrder
    charactername?: SortOrderInput | SortOrder
    _count?: inducks_entrycharacternameCountOrderByAggregateInput
    _max?: inducks_entrycharacternameMaxOrderByAggregateInput
    _min?: inducks_entrycharacternameMinOrderByAggregateInput
  }

  export type inducks_entrycharacternameScalarWhereWithAggregatesInput = {
    AND?: inducks_entrycharacternameScalarWhereWithAggregatesInput | inducks_entrycharacternameScalarWhereWithAggregatesInput[]
    OR?: inducks_entrycharacternameScalarWhereWithAggregatesInput[]
    NOT?: inducks_entrycharacternameScalarWhereWithAggregatesInput | inducks_entrycharacternameScalarWhereWithAggregatesInput[]
    entrycode?: StringWithAggregatesFilter<"inducks_entrycharactername"> | string
    charactercode?: StringWithAggregatesFilter<"inducks_entrycharactername"> | string
    charactername?: StringNullableWithAggregatesFilter<"inducks_entrycharactername"> | string | null
  }

  export type inducks_entryjobWhereInput = {
    AND?: inducks_entryjobWhereInput | inducks_entryjobWhereInput[]
    OR?: inducks_entryjobWhereInput[]
    NOT?: inducks_entryjobWhereInput | inducks_entryjobWhereInput[]
    entrycode?: StringFilter<"inducks_entryjob"> | string
    personcode?: StringFilter<"inducks_entryjob"> | string
    transletcol?: StringFilter<"inducks_entryjob"> | string
    entryjobcomment?: StringNullableFilter<"inducks_entryjob"> | string | null
    doubt?: Enuminducks_entryjob_doubtNullableFilter<"inducks_entryjob"> | $Enums.inducks_entryjob_doubt | null
  }

  export type inducks_entryjobOrderByWithRelationInput = {
    entrycode?: SortOrder
    personcode?: SortOrder
    transletcol?: SortOrder
    entryjobcomment?: SortOrderInput | SortOrder
    doubt?: SortOrderInput | SortOrder
  }

  export type inducks_entryjobWhereUniqueInput = Prisma.AtLeast<{
    entrycode_personcode_transletcol?: inducks_entryjobEntrycodePersoncodeTransletcolCompoundUniqueInput
    AND?: inducks_entryjobWhereInput | inducks_entryjobWhereInput[]
    OR?: inducks_entryjobWhereInput[]
    NOT?: inducks_entryjobWhereInput | inducks_entryjobWhereInput[]
    entrycode?: StringFilter<"inducks_entryjob"> | string
    personcode?: StringFilter<"inducks_entryjob"> | string
    transletcol?: StringFilter<"inducks_entryjob"> | string
    entryjobcomment?: StringNullableFilter<"inducks_entryjob"> | string | null
    doubt?: Enuminducks_entryjob_doubtNullableFilter<"inducks_entryjob"> | $Enums.inducks_entryjob_doubt | null
  }, "entrycode_personcode_transletcol">

  export type inducks_entryjobOrderByWithAggregationInput = {
    entrycode?: SortOrder
    personcode?: SortOrder
    transletcol?: SortOrder
    entryjobcomment?: SortOrderInput | SortOrder
    doubt?: SortOrderInput | SortOrder
    _count?: inducks_entryjobCountOrderByAggregateInput
    _max?: inducks_entryjobMaxOrderByAggregateInput
    _min?: inducks_entryjobMinOrderByAggregateInput
  }

  export type inducks_entryjobScalarWhereWithAggregatesInput = {
    AND?: inducks_entryjobScalarWhereWithAggregatesInput | inducks_entryjobScalarWhereWithAggregatesInput[]
    OR?: inducks_entryjobScalarWhereWithAggregatesInput[]
    NOT?: inducks_entryjobScalarWhereWithAggregatesInput | inducks_entryjobScalarWhereWithAggregatesInput[]
    entrycode?: StringWithAggregatesFilter<"inducks_entryjob"> | string
    personcode?: StringWithAggregatesFilter<"inducks_entryjob"> | string
    transletcol?: StringWithAggregatesFilter<"inducks_entryjob"> | string
    entryjobcomment?: StringNullableWithAggregatesFilter<"inducks_entryjob"> | string | null
    doubt?: Enuminducks_entryjob_doubtNullableWithAggregatesFilter<"inducks_entryjob"> | $Enums.inducks_entryjob_doubt | null
  }

  export type inducks_entryurlWhereInput = {
    AND?: inducks_entryurlWhereInput | inducks_entryurlWhereInput[]
    OR?: inducks_entryurlWhereInput[]
    NOT?: inducks_entryurlWhereInput | inducks_entryurlWhereInput[]
    entrycode?: StringNullableFilter<"inducks_entryurl"> | string | null
    sitecode?: StringNullableFilter<"inducks_entryurl"> | string | null
    pagenumber?: IntNullableFilter<"inducks_entryurl"> | number | null
    url?: StringNullableFilter<"inducks_entryurl"> | string | null
    storycode?: StringNullableFilter<"inducks_entryurl"> | string | null
    public?: Enuminducks_entryurl_publicNullableFilter<"inducks_entryurl"> | $Enums.inducks_entryurl_public | null
    id?: IntFilter<"inducks_entryurl"> | number
  }

  export type inducks_entryurlOrderByWithRelationInput = {
    entrycode?: SortOrderInput | SortOrder
    sitecode?: SortOrderInput | SortOrder
    pagenumber?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    storycode?: SortOrderInput | SortOrder
    public?: SortOrderInput | SortOrder
    id?: SortOrder
  }

  export type inducks_entryurlWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: inducks_entryurlWhereInput | inducks_entryurlWhereInput[]
    OR?: inducks_entryurlWhereInput[]
    NOT?: inducks_entryurlWhereInput | inducks_entryurlWhereInput[]
    entrycode?: StringNullableFilter<"inducks_entryurl"> | string | null
    sitecode?: StringNullableFilter<"inducks_entryurl"> | string | null
    pagenumber?: IntNullableFilter<"inducks_entryurl"> | number | null
    url?: StringNullableFilter<"inducks_entryurl"> | string | null
    storycode?: StringNullableFilter<"inducks_entryurl"> | string | null
    public?: Enuminducks_entryurl_publicNullableFilter<"inducks_entryurl"> | $Enums.inducks_entryurl_public | null
  }, "id">

  export type inducks_entryurlOrderByWithAggregationInput = {
    entrycode?: SortOrderInput | SortOrder
    sitecode?: SortOrderInput | SortOrder
    pagenumber?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    storycode?: SortOrderInput | SortOrder
    public?: SortOrderInput | SortOrder
    id?: SortOrder
    _count?: inducks_entryurlCountOrderByAggregateInput
    _avg?: inducks_entryurlAvgOrderByAggregateInput
    _max?: inducks_entryurlMaxOrderByAggregateInput
    _min?: inducks_entryurlMinOrderByAggregateInput
    _sum?: inducks_entryurlSumOrderByAggregateInput
  }

  export type inducks_entryurlScalarWhereWithAggregatesInput = {
    AND?: inducks_entryurlScalarWhereWithAggregatesInput | inducks_entryurlScalarWhereWithAggregatesInput[]
    OR?: inducks_entryurlScalarWhereWithAggregatesInput[]
    NOT?: inducks_entryurlScalarWhereWithAggregatesInput | inducks_entryurlScalarWhereWithAggregatesInput[]
    entrycode?: StringNullableWithAggregatesFilter<"inducks_entryurl"> | string | null
    sitecode?: StringNullableWithAggregatesFilter<"inducks_entryurl"> | string | null
    pagenumber?: IntNullableWithAggregatesFilter<"inducks_entryurl"> | number | null
    url?: StringNullableWithAggregatesFilter<"inducks_entryurl"> | string | null
    storycode?: StringNullableWithAggregatesFilter<"inducks_entryurl"> | string | null
    public?: Enuminducks_entryurl_publicNullableWithAggregatesFilter<"inducks_entryurl"> | $Enums.inducks_entryurl_public | null
    id?: IntWithAggregatesFilter<"inducks_entryurl"> | number
  }

  export type inducks_equivWhereInput = {
    AND?: inducks_equivWhereInput | inducks_equivWhereInput[]
    OR?: inducks_equivWhereInput[]
    NOT?: inducks_equivWhereInput | inducks_equivWhereInput[]
    issuecode?: StringFilter<"inducks_equiv"> | string
    equivid?: IntFilter<"inducks_equiv"> | number
    equivcomment?: StringNullableFilter<"inducks_equiv"> | string | null
  }

  export type inducks_equivOrderByWithRelationInput = {
    issuecode?: SortOrder
    equivid?: SortOrder
    equivcomment?: SortOrderInput | SortOrder
  }

  export type inducks_equivWhereUniqueInput = Prisma.AtLeast<{
    issuecode_equivid?: inducks_equivIssuecodeEquividCompoundUniqueInput
    AND?: inducks_equivWhereInput | inducks_equivWhereInput[]
    OR?: inducks_equivWhereInput[]
    NOT?: inducks_equivWhereInput | inducks_equivWhereInput[]
    issuecode?: StringFilter<"inducks_equiv"> | string
    equivid?: IntFilter<"inducks_equiv"> | number
    equivcomment?: StringNullableFilter<"inducks_equiv"> | string | null
  }, "issuecode_equivid">

  export type inducks_equivOrderByWithAggregationInput = {
    issuecode?: SortOrder
    equivid?: SortOrder
    equivcomment?: SortOrderInput | SortOrder
    _count?: inducks_equivCountOrderByAggregateInput
    _avg?: inducks_equivAvgOrderByAggregateInput
    _max?: inducks_equivMaxOrderByAggregateInput
    _min?: inducks_equivMinOrderByAggregateInput
    _sum?: inducks_equivSumOrderByAggregateInput
  }

  export type inducks_equivScalarWhereWithAggregatesInput = {
    AND?: inducks_equivScalarWhereWithAggregatesInput | inducks_equivScalarWhereWithAggregatesInput[]
    OR?: inducks_equivScalarWhereWithAggregatesInput[]
    NOT?: inducks_equivScalarWhereWithAggregatesInput | inducks_equivScalarWhereWithAggregatesInput[]
    issuecode?: StringWithAggregatesFilter<"inducks_equiv"> | string
    equivid?: IntWithAggregatesFilter<"inducks_equiv"> | number
    equivcomment?: StringNullableWithAggregatesFilter<"inducks_equiv"> | string | null
  }

  export type inducks_herocharacterWhereInput = {
    AND?: inducks_herocharacterWhereInput | inducks_herocharacterWhereInput[]
    OR?: inducks_herocharacterWhereInput[]
    NOT?: inducks_herocharacterWhereInput | inducks_herocharacterWhereInput[]
    storycode?: StringFilter<"inducks_herocharacter"> | string
    charactercode?: StringFilter<"inducks_herocharacter"> | string
    number?: IntNullableFilter<"inducks_herocharacter"> | number | null
    doubt?: Enuminducks_herocharacter_doubtNullableFilter<"inducks_herocharacter"> | $Enums.inducks_herocharacter_doubt | null
  }

  export type inducks_herocharacterOrderByWithRelationInput = {
    storycode?: SortOrder
    charactercode?: SortOrder
    number?: SortOrderInput | SortOrder
    doubt?: SortOrderInput | SortOrder
  }

  export type inducks_herocharacterWhereUniqueInput = Prisma.AtLeast<{
    storycode_charactercode?: inducks_herocharacterStorycodeCharactercodeCompoundUniqueInput
    AND?: inducks_herocharacterWhereInput | inducks_herocharacterWhereInput[]
    OR?: inducks_herocharacterWhereInput[]
    NOT?: inducks_herocharacterWhereInput | inducks_herocharacterWhereInput[]
    storycode?: StringFilter<"inducks_herocharacter"> | string
    charactercode?: StringFilter<"inducks_herocharacter"> | string
    number?: IntNullableFilter<"inducks_herocharacter"> | number | null
    doubt?: Enuminducks_herocharacter_doubtNullableFilter<"inducks_herocharacter"> | $Enums.inducks_herocharacter_doubt | null
  }, "storycode_charactercode">

  export type inducks_herocharacterOrderByWithAggregationInput = {
    storycode?: SortOrder
    charactercode?: SortOrder
    number?: SortOrderInput | SortOrder
    doubt?: SortOrderInput | SortOrder
    _count?: inducks_herocharacterCountOrderByAggregateInput
    _avg?: inducks_herocharacterAvgOrderByAggregateInput
    _max?: inducks_herocharacterMaxOrderByAggregateInput
    _min?: inducks_herocharacterMinOrderByAggregateInput
    _sum?: inducks_herocharacterSumOrderByAggregateInput
  }

  export type inducks_herocharacterScalarWhereWithAggregatesInput = {
    AND?: inducks_herocharacterScalarWhereWithAggregatesInput | inducks_herocharacterScalarWhereWithAggregatesInput[]
    OR?: inducks_herocharacterScalarWhereWithAggregatesInput[]
    NOT?: inducks_herocharacterScalarWhereWithAggregatesInput | inducks_herocharacterScalarWhereWithAggregatesInput[]
    storycode?: StringWithAggregatesFilter<"inducks_herocharacter"> | string
    charactercode?: StringWithAggregatesFilter<"inducks_herocharacter"> | string
    number?: IntNullableWithAggregatesFilter<"inducks_herocharacter"> | number | null
    doubt?: Enuminducks_herocharacter_doubtNullableWithAggregatesFilter<"inducks_herocharacter"> | $Enums.inducks_herocharacter_doubt | null
  }

  export type inducks_inputfileWhereInput = {
    AND?: inducks_inputfileWhereInput | inducks_inputfileWhereInput[]
    OR?: inducks_inputfileWhereInput[]
    NOT?: inducks_inputfileWhereInput | inducks_inputfileWhereInput[]
    inputfilecode?: IntFilter<"inducks_inputfile"> | number
    path?: StringNullableFilter<"inducks_inputfile"> | string | null
    filename?: StringNullableFilter<"inducks_inputfile"> | string | null
    layout?: StringNullableFilter<"inducks_inputfile"> | string | null
    locked?: Enuminducks_inputfile_lockedNullableFilter<"inducks_inputfile"> | $Enums.inducks_inputfile_locked | null
    maintenanceteamcode?: StringNullableFilter<"inducks_inputfile"> | string | null
    countrycode?: StringNullableFilter<"inducks_inputfile"> | string | null
    languagecode?: StringNullableFilter<"inducks_inputfile"> | string | null
    producercode?: StringNullableFilter<"inducks_inputfile"> | string | null
    secundary?: Enuminducks_inputfile_secundaryNullableFilter<"inducks_inputfile"> | $Enums.inducks_inputfile_secundary | null
  }

  export type inducks_inputfileOrderByWithRelationInput = {
    inputfilecode?: SortOrder
    path?: SortOrderInput | SortOrder
    filename?: SortOrderInput | SortOrder
    layout?: SortOrderInput | SortOrder
    locked?: SortOrderInput | SortOrder
    maintenanceteamcode?: SortOrderInput | SortOrder
    countrycode?: SortOrderInput | SortOrder
    languagecode?: SortOrderInput | SortOrder
    producercode?: SortOrderInput | SortOrder
    secundary?: SortOrderInput | SortOrder
  }

  export type inducks_inputfileWhereUniqueInput = Prisma.AtLeast<{
    inputfilecode?: number
    AND?: inducks_inputfileWhereInput | inducks_inputfileWhereInput[]
    OR?: inducks_inputfileWhereInput[]
    NOT?: inducks_inputfileWhereInput | inducks_inputfileWhereInput[]
    path?: StringNullableFilter<"inducks_inputfile"> | string | null
    filename?: StringNullableFilter<"inducks_inputfile"> | string | null
    layout?: StringNullableFilter<"inducks_inputfile"> | string | null
    locked?: Enuminducks_inputfile_lockedNullableFilter<"inducks_inputfile"> | $Enums.inducks_inputfile_locked | null
    maintenanceteamcode?: StringNullableFilter<"inducks_inputfile"> | string | null
    countrycode?: StringNullableFilter<"inducks_inputfile"> | string | null
    languagecode?: StringNullableFilter<"inducks_inputfile"> | string | null
    producercode?: StringNullableFilter<"inducks_inputfile"> | string | null
    secundary?: Enuminducks_inputfile_secundaryNullableFilter<"inducks_inputfile"> | $Enums.inducks_inputfile_secundary | null
  }, "inputfilecode">

  export type inducks_inputfileOrderByWithAggregationInput = {
    inputfilecode?: SortOrder
    path?: SortOrderInput | SortOrder
    filename?: SortOrderInput | SortOrder
    layout?: SortOrderInput | SortOrder
    locked?: SortOrderInput | SortOrder
    maintenanceteamcode?: SortOrderInput | SortOrder
    countrycode?: SortOrderInput | SortOrder
    languagecode?: SortOrderInput | SortOrder
    producercode?: SortOrderInput | SortOrder
    secundary?: SortOrderInput | SortOrder
    _count?: inducks_inputfileCountOrderByAggregateInput
    _avg?: inducks_inputfileAvgOrderByAggregateInput
    _max?: inducks_inputfileMaxOrderByAggregateInput
    _min?: inducks_inputfileMinOrderByAggregateInput
    _sum?: inducks_inputfileSumOrderByAggregateInput
  }

  export type inducks_inputfileScalarWhereWithAggregatesInput = {
    AND?: inducks_inputfileScalarWhereWithAggregatesInput | inducks_inputfileScalarWhereWithAggregatesInput[]
    OR?: inducks_inputfileScalarWhereWithAggregatesInput[]
    NOT?: inducks_inputfileScalarWhereWithAggregatesInput | inducks_inputfileScalarWhereWithAggregatesInput[]
    inputfilecode?: IntWithAggregatesFilter<"inducks_inputfile"> | number
    path?: StringNullableWithAggregatesFilter<"inducks_inputfile"> | string | null
    filename?: StringNullableWithAggregatesFilter<"inducks_inputfile"> | string | null
    layout?: StringNullableWithAggregatesFilter<"inducks_inputfile"> | string | null
    locked?: Enuminducks_inputfile_lockedNullableWithAggregatesFilter<"inducks_inputfile"> | $Enums.inducks_inputfile_locked | null
    maintenanceteamcode?: StringNullableWithAggregatesFilter<"inducks_inputfile"> | string | null
    countrycode?: StringNullableWithAggregatesFilter<"inducks_inputfile"> | string | null
    languagecode?: StringNullableWithAggregatesFilter<"inducks_inputfile"> | string | null
    producercode?: StringNullableWithAggregatesFilter<"inducks_inputfile"> | string | null
    secundary?: Enuminducks_inputfile_secundaryNullableWithAggregatesFilter<"inducks_inputfile"> | $Enums.inducks_inputfile_secundary | null
  }

  export type inducks_issueWhereInput = {
    AND?: inducks_issueWhereInput | inducks_issueWhereInput[]
    OR?: inducks_issueWhereInput[]
    NOT?: inducks_issueWhereInput | inducks_issueWhereInput[]
    issuecode?: StringFilter<"inducks_issue"> | string
    issuerangecode?: StringNullableFilter<"inducks_issue"> | string | null
    publicationcode?: StringNullableFilter<"inducks_issue"> | string | null
    issuenumber?: StringNullableFilter<"inducks_issue"> | string | null
    title?: StringNullableFilter<"inducks_issue"> | string | null
    size?: StringNullableFilter<"inducks_issue"> | string | null
    pages?: StringNullableFilter<"inducks_issue"> | string | null
    price?: StringNullableFilter<"inducks_issue"> | string | null
    printrun?: StringNullableFilter<"inducks_issue"> | string | null
    attached?: StringNullableFilter<"inducks_issue"> | string | null
    oldestdate?: StringNullableFilter<"inducks_issue"> | string | null
    fullyindexed?: Enuminducks_issue_fullyindexedNullableFilter<"inducks_issue"> | $Enums.inducks_issue_fullyindexed | null
    issuecomment?: StringNullableFilter<"inducks_issue"> | string | null
    error?: Enuminducks_issue_errorNullableFilter<"inducks_issue"> | $Enums.inducks_issue_error | null
    filledoldestdate?: StringNullableFilter<"inducks_issue"> | string | null
    locked?: Enuminducks_issue_lockedNullableFilter<"inducks_issue"> | $Enums.inducks_issue_locked | null
    inxforbidden?: Enuminducks_issue_inxforbiddenNullableFilter<"inducks_issue"> | $Enums.inducks_issue_inxforbidden | null
    inputfilecode?: IntNullableFilter<"inducks_issue"> | number | null
    maintenanceteamcode?: StringNullableFilter<"inducks_issue"> | string | null
  }

  export type inducks_issueOrderByWithRelationInput = {
    issuecode?: SortOrder
    issuerangecode?: SortOrderInput | SortOrder
    publicationcode?: SortOrderInput | SortOrder
    issuenumber?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    pages?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    printrun?: SortOrderInput | SortOrder
    attached?: SortOrderInput | SortOrder
    oldestdate?: SortOrderInput | SortOrder
    fullyindexed?: SortOrderInput | SortOrder
    issuecomment?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    filledoldestdate?: SortOrderInput | SortOrder
    locked?: SortOrderInput | SortOrder
    inxforbidden?: SortOrderInput | SortOrder
    inputfilecode?: SortOrderInput | SortOrder
    maintenanceteamcode?: SortOrderInput | SortOrder
  }

  export type inducks_issueWhereUniqueInput = Prisma.AtLeast<{
    issuecode?: string
    AND?: inducks_issueWhereInput | inducks_issueWhereInput[]
    OR?: inducks_issueWhereInput[]
    NOT?: inducks_issueWhereInput | inducks_issueWhereInput[]
    issuerangecode?: StringNullableFilter<"inducks_issue"> | string | null
    publicationcode?: StringNullableFilter<"inducks_issue"> | string | null
    issuenumber?: StringNullableFilter<"inducks_issue"> | string | null
    title?: StringNullableFilter<"inducks_issue"> | string | null
    size?: StringNullableFilter<"inducks_issue"> | string | null
    pages?: StringNullableFilter<"inducks_issue"> | string | null
    price?: StringNullableFilter<"inducks_issue"> | string | null
    printrun?: StringNullableFilter<"inducks_issue"> | string | null
    attached?: StringNullableFilter<"inducks_issue"> | string | null
    oldestdate?: StringNullableFilter<"inducks_issue"> | string | null
    fullyindexed?: Enuminducks_issue_fullyindexedNullableFilter<"inducks_issue"> | $Enums.inducks_issue_fullyindexed | null
    issuecomment?: StringNullableFilter<"inducks_issue"> | string | null
    error?: Enuminducks_issue_errorNullableFilter<"inducks_issue"> | $Enums.inducks_issue_error | null
    filledoldestdate?: StringNullableFilter<"inducks_issue"> | string | null
    locked?: Enuminducks_issue_lockedNullableFilter<"inducks_issue"> | $Enums.inducks_issue_locked | null
    inxforbidden?: Enuminducks_issue_inxforbiddenNullableFilter<"inducks_issue"> | $Enums.inducks_issue_inxforbidden | null
    inputfilecode?: IntNullableFilter<"inducks_issue"> | number | null
    maintenanceteamcode?: StringNullableFilter<"inducks_issue"> | string | null
  }, "issuecode">

  export type inducks_issueOrderByWithAggregationInput = {
    issuecode?: SortOrder
    issuerangecode?: SortOrderInput | SortOrder
    publicationcode?: SortOrderInput | SortOrder
    issuenumber?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    pages?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    printrun?: SortOrderInput | SortOrder
    attached?: SortOrderInput | SortOrder
    oldestdate?: SortOrderInput | SortOrder
    fullyindexed?: SortOrderInput | SortOrder
    issuecomment?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    filledoldestdate?: SortOrderInput | SortOrder
    locked?: SortOrderInput | SortOrder
    inxforbidden?: SortOrderInput | SortOrder
    inputfilecode?: SortOrderInput | SortOrder
    maintenanceteamcode?: SortOrderInput | SortOrder
    _count?: inducks_issueCountOrderByAggregateInput
    _avg?: inducks_issueAvgOrderByAggregateInput
    _max?: inducks_issueMaxOrderByAggregateInput
    _min?: inducks_issueMinOrderByAggregateInput
    _sum?: inducks_issueSumOrderByAggregateInput
  }

  export type inducks_issueScalarWhereWithAggregatesInput = {
    AND?: inducks_issueScalarWhereWithAggregatesInput | inducks_issueScalarWhereWithAggregatesInput[]
    OR?: inducks_issueScalarWhereWithAggregatesInput[]
    NOT?: inducks_issueScalarWhereWithAggregatesInput | inducks_issueScalarWhereWithAggregatesInput[]
    issuecode?: StringWithAggregatesFilter<"inducks_issue"> | string
    issuerangecode?: StringNullableWithAggregatesFilter<"inducks_issue"> | string | null
    publicationcode?: StringNullableWithAggregatesFilter<"inducks_issue"> | string | null
    issuenumber?: StringNullableWithAggregatesFilter<"inducks_issue"> | string | null
    title?: StringNullableWithAggregatesFilter<"inducks_issue"> | string | null
    size?: StringNullableWithAggregatesFilter<"inducks_issue"> | string | null
    pages?: StringNullableWithAggregatesFilter<"inducks_issue"> | string | null
    price?: StringNullableWithAggregatesFilter<"inducks_issue"> | string | null
    printrun?: StringNullableWithAggregatesFilter<"inducks_issue"> | string | null
    attached?: StringNullableWithAggregatesFilter<"inducks_issue"> | string | null
    oldestdate?: StringNullableWithAggregatesFilter<"inducks_issue"> | string | null
    fullyindexed?: Enuminducks_issue_fullyindexedNullableWithAggregatesFilter<"inducks_issue"> | $Enums.inducks_issue_fullyindexed | null
    issuecomment?: StringNullableWithAggregatesFilter<"inducks_issue"> | string | null
    error?: Enuminducks_issue_errorNullableWithAggregatesFilter<"inducks_issue"> | $Enums.inducks_issue_error | null
    filledoldestdate?: StringNullableWithAggregatesFilter<"inducks_issue"> | string | null
    locked?: Enuminducks_issue_lockedNullableWithAggregatesFilter<"inducks_issue"> | $Enums.inducks_issue_locked | null
    inxforbidden?: Enuminducks_issue_inxforbiddenNullableWithAggregatesFilter<"inducks_issue"> | $Enums.inducks_issue_inxforbidden | null
    inputfilecode?: IntNullableWithAggregatesFilter<"inducks_issue"> | number | null
    maintenanceteamcode?: StringNullableWithAggregatesFilter<"inducks_issue"> | string | null
  }

  export type inducks_issuecollectingWhereInput = {
    AND?: inducks_issuecollectingWhereInput | inducks_issuecollectingWhereInput[]
    OR?: inducks_issuecollectingWhereInput[]
    NOT?: inducks_issuecollectingWhereInput | inducks_issuecollectingWhereInput[]
    collectingissuecode?: StringFilter<"inducks_issuecollecting"> | string
    collectedissuecode?: StringFilter<"inducks_issuecollecting"> | string
  }

  export type inducks_issuecollectingOrderByWithRelationInput = {
    collectingissuecode?: SortOrder
    collectedissuecode?: SortOrder
  }

  export type inducks_issuecollectingWhereUniqueInput = Prisma.AtLeast<{
    collectingissuecode_collectedissuecode?: inducks_issuecollectingCollectingissuecodeCollectedissuecodeCompoundUniqueInput
    AND?: inducks_issuecollectingWhereInput | inducks_issuecollectingWhereInput[]
    OR?: inducks_issuecollectingWhereInput[]
    NOT?: inducks_issuecollectingWhereInput | inducks_issuecollectingWhereInput[]
    collectingissuecode?: StringFilter<"inducks_issuecollecting"> | string
    collectedissuecode?: StringFilter<"inducks_issuecollecting"> | string
  }, "collectingissuecode_collectedissuecode">

  export type inducks_issuecollectingOrderByWithAggregationInput = {
    collectingissuecode?: SortOrder
    collectedissuecode?: SortOrder
    _count?: inducks_issuecollectingCountOrderByAggregateInput
    _max?: inducks_issuecollectingMaxOrderByAggregateInput
    _min?: inducks_issuecollectingMinOrderByAggregateInput
  }

  export type inducks_issuecollectingScalarWhereWithAggregatesInput = {
    AND?: inducks_issuecollectingScalarWhereWithAggregatesInput | inducks_issuecollectingScalarWhereWithAggregatesInput[]
    OR?: inducks_issuecollectingScalarWhereWithAggregatesInput[]
    NOT?: inducks_issuecollectingScalarWhereWithAggregatesInput | inducks_issuecollectingScalarWhereWithAggregatesInput[]
    collectingissuecode?: StringWithAggregatesFilter<"inducks_issuecollecting"> | string
    collectedissuecode?: StringWithAggregatesFilter<"inducks_issuecollecting"> | string
  }

  export type inducks_issuedateWhereInput = {
    AND?: inducks_issuedateWhereInput | inducks_issuedateWhereInput[]
    OR?: inducks_issuedateWhereInput[]
    NOT?: inducks_issuedateWhereInput | inducks_issuedateWhereInput[]
    issuecode?: StringFilter<"inducks_issuedate"> | string
    date?: StringFilter<"inducks_issuedate"> | string
    kindofdate?: StringNullableFilter<"inducks_issuedate"> | string | null
    doubt?: Enuminducks_issuedate_doubtNullableFilter<"inducks_issuedate"> | $Enums.inducks_issuedate_doubt | null
  }

  export type inducks_issuedateOrderByWithRelationInput = {
    issuecode?: SortOrder
    date?: SortOrder
    kindofdate?: SortOrderInput | SortOrder
    doubt?: SortOrderInput | SortOrder
  }

  export type inducks_issuedateWhereUniqueInput = Prisma.AtLeast<{
    issuecode_date?: inducks_issuedateIssuecodeDateCompoundUniqueInput
    AND?: inducks_issuedateWhereInput | inducks_issuedateWhereInput[]
    OR?: inducks_issuedateWhereInput[]
    NOT?: inducks_issuedateWhereInput | inducks_issuedateWhereInput[]
    issuecode?: StringFilter<"inducks_issuedate"> | string
    date?: StringFilter<"inducks_issuedate"> | string
    kindofdate?: StringNullableFilter<"inducks_issuedate"> | string | null
    doubt?: Enuminducks_issuedate_doubtNullableFilter<"inducks_issuedate"> | $Enums.inducks_issuedate_doubt | null
  }, "issuecode_date">

  export type inducks_issuedateOrderByWithAggregationInput = {
    issuecode?: SortOrder
    date?: SortOrder
    kindofdate?: SortOrderInput | SortOrder
    doubt?: SortOrderInput | SortOrder
    _count?: inducks_issuedateCountOrderByAggregateInput
    _max?: inducks_issuedateMaxOrderByAggregateInput
    _min?: inducks_issuedateMinOrderByAggregateInput
  }

  export type inducks_issuedateScalarWhereWithAggregatesInput = {
    AND?: inducks_issuedateScalarWhereWithAggregatesInput | inducks_issuedateScalarWhereWithAggregatesInput[]
    OR?: inducks_issuedateScalarWhereWithAggregatesInput[]
    NOT?: inducks_issuedateScalarWhereWithAggregatesInput | inducks_issuedateScalarWhereWithAggregatesInput[]
    issuecode?: StringWithAggregatesFilter<"inducks_issuedate"> | string
    date?: StringWithAggregatesFilter<"inducks_issuedate"> | string
    kindofdate?: StringNullableWithAggregatesFilter<"inducks_issuedate"> | string | null
    doubt?: Enuminducks_issuedate_doubtNullableWithAggregatesFilter<"inducks_issuedate"> | $Enums.inducks_issuedate_doubt | null
  }

  export type inducks_issuejobWhereInput = {
    AND?: inducks_issuejobWhereInput | inducks_issuejobWhereInput[]
    OR?: inducks_issuejobWhereInput[]
    NOT?: inducks_issuejobWhereInput | inducks_issuejobWhereInput[]
    issuecode?: StringFilter<"inducks_issuejob"> | string
    personcode?: StringFilter<"inducks_issuejob"> | string
    inxtransletcol?: StringFilter<"inducks_issuejob"> | string
    issuejobcomment?: StringNullableFilter<"inducks_issuejob"> | string | null
    doubt?: Enuminducks_issuejob_doubtNullableFilter<"inducks_issuejob"> | $Enums.inducks_issuejob_doubt | null
  }

  export type inducks_issuejobOrderByWithRelationInput = {
    issuecode?: SortOrder
    personcode?: SortOrder
    inxtransletcol?: SortOrder
    issuejobcomment?: SortOrderInput | SortOrder
    doubt?: SortOrderInput | SortOrder
  }

  export type inducks_issuejobWhereUniqueInput = Prisma.AtLeast<{
    issuecode_personcode_inxtransletcol?: inducks_issuejobIssuecodePersoncodeInxtransletcolCompoundUniqueInput
    AND?: inducks_issuejobWhereInput | inducks_issuejobWhereInput[]
    OR?: inducks_issuejobWhereInput[]
    NOT?: inducks_issuejobWhereInput | inducks_issuejobWhereInput[]
    issuecode?: StringFilter<"inducks_issuejob"> | string
    personcode?: StringFilter<"inducks_issuejob"> | string
    inxtransletcol?: StringFilter<"inducks_issuejob"> | string
    issuejobcomment?: StringNullableFilter<"inducks_issuejob"> | string | null
    doubt?: Enuminducks_issuejob_doubtNullableFilter<"inducks_issuejob"> | $Enums.inducks_issuejob_doubt | null
  }, "issuecode_personcode_inxtransletcol">

  export type inducks_issuejobOrderByWithAggregationInput = {
    issuecode?: SortOrder
    personcode?: SortOrder
    inxtransletcol?: SortOrder
    issuejobcomment?: SortOrderInput | SortOrder
    doubt?: SortOrderInput | SortOrder
    _count?: inducks_issuejobCountOrderByAggregateInput
    _max?: inducks_issuejobMaxOrderByAggregateInput
    _min?: inducks_issuejobMinOrderByAggregateInput
  }

  export type inducks_issuejobScalarWhereWithAggregatesInput = {
    AND?: inducks_issuejobScalarWhereWithAggregatesInput | inducks_issuejobScalarWhereWithAggregatesInput[]
    OR?: inducks_issuejobScalarWhereWithAggregatesInput[]
    NOT?: inducks_issuejobScalarWhereWithAggregatesInput | inducks_issuejobScalarWhereWithAggregatesInput[]
    issuecode?: StringWithAggregatesFilter<"inducks_issuejob"> | string
    personcode?: StringWithAggregatesFilter<"inducks_issuejob"> | string
    inxtransletcol?: StringWithAggregatesFilter<"inducks_issuejob"> | string
    issuejobcomment?: StringNullableWithAggregatesFilter<"inducks_issuejob"> | string | null
    doubt?: Enuminducks_issuejob_doubtNullableWithAggregatesFilter<"inducks_issuejob"> | $Enums.inducks_issuejob_doubt | null
  }

  export type inducks_issuepriceWhereInput = {
    AND?: inducks_issuepriceWhereInput | inducks_issuepriceWhereInput[]
    OR?: inducks_issuepriceWhereInput[]
    NOT?: inducks_issuepriceWhereInput | inducks_issuepriceWhereInput[]
    issuecode?: StringFilter<"inducks_issueprice"> | string
    amount?: StringFilter<"inducks_issueprice"> | string
    currency?: StringNullableFilter<"inducks_issueprice"> | string | null
    comment?: StringNullableFilter<"inducks_issueprice"> | string | null
    sequencenumber?: IntNullableFilter<"inducks_issueprice"> | number | null
  }

  export type inducks_issuepriceOrderByWithRelationInput = {
    issuecode?: SortOrder
    amount?: SortOrder
    currency?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    sequencenumber?: SortOrderInput | SortOrder
  }

  export type inducks_issuepriceWhereUniqueInput = Prisma.AtLeast<{
    issuecode_amount?: inducks_issuepriceIssuecodeAmountCompoundUniqueInput
    AND?: inducks_issuepriceWhereInput | inducks_issuepriceWhereInput[]
    OR?: inducks_issuepriceWhereInput[]
    NOT?: inducks_issuepriceWhereInput | inducks_issuepriceWhereInput[]
    issuecode?: StringFilter<"inducks_issueprice"> | string
    amount?: StringFilter<"inducks_issueprice"> | string
    currency?: StringNullableFilter<"inducks_issueprice"> | string | null
    comment?: StringNullableFilter<"inducks_issueprice"> | string | null
    sequencenumber?: IntNullableFilter<"inducks_issueprice"> | number | null
  }, "issuecode_amount">

  export type inducks_issuepriceOrderByWithAggregationInput = {
    issuecode?: SortOrder
    amount?: SortOrder
    currency?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    sequencenumber?: SortOrderInput | SortOrder
    _count?: inducks_issuepriceCountOrderByAggregateInput
    _avg?: inducks_issuepriceAvgOrderByAggregateInput
    _max?: inducks_issuepriceMaxOrderByAggregateInput
    _min?: inducks_issuepriceMinOrderByAggregateInput
    _sum?: inducks_issuepriceSumOrderByAggregateInput
  }

  export type inducks_issuepriceScalarWhereWithAggregatesInput = {
    AND?: inducks_issuepriceScalarWhereWithAggregatesInput | inducks_issuepriceScalarWhereWithAggregatesInput[]
    OR?: inducks_issuepriceScalarWhereWithAggregatesInput[]
    NOT?: inducks_issuepriceScalarWhereWithAggregatesInput | inducks_issuepriceScalarWhereWithAggregatesInput[]
    issuecode?: StringWithAggregatesFilter<"inducks_issueprice"> | string
    amount?: StringWithAggregatesFilter<"inducks_issueprice"> | string
    currency?: StringNullableWithAggregatesFilter<"inducks_issueprice"> | string | null
    comment?: StringNullableWithAggregatesFilter<"inducks_issueprice"> | string | null
    sequencenumber?: IntNullableWithAggregatesFilter<"inducks_issueprice"> | number | null
  }

  export type inducks_issuequotationWhereInput = {
    AND?: inducks_issuequotationWhereInput | inducks_issuequotationWhereInput[]
    OR?: inducks_issuequotationWhereInput[]
    NOT?: inducks_issuequotationWhereInput | inducks_issuequotationWhereInput[]
    ID?: IntFilter<"inducks_issuequotation"> | number
    publicationcode?: StringFilter<"inducks_issuequotation"> | string
    issuenumber?: StringFilter<"inducks_issuequotation"> | string
    estimationmin?: FloatNullableFilter<"inducks_issuequotation"> | number | null
    estimationmax?: FloatNullableFilter<"inducks_issuequotation"> | number | null
    scrapedate?: DateTimeNullableFilter<"inducks_issuequotation"> | Date | string | null
    source?: StringFilter<"inducks_issuequotation"> | string
    issuecode?: StringNullableFilter<"inducks_issuequotation"> | string | null
  }

  export type inducks_issuequotationOrderByWithRelationInput = {
    ID?: SortOrder
    publicationcode?: SortOrder
    issuenumber?: SortOrder
    estimationmin?: SortOrderInput | SortOrder
    estimationmax?: SortOrderInput | SortOrder
    scrapedate?: SortOrderInput | SortOrder
    source?: SortOrder
    issuecode?: SortOrderInput | SortOrder
  }

  export type inducks_issuequotationWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    issuecode?: string
    AND?: inducks_issuequotationWhereInput | inducks_issuequotationWhereInput[]
    OR?: inducks_issuequotationWhereInput[]
    NOT?: inducks_issuequotationWhereInput | inducks_issuequotationWhereInput[]
    publicationcode?: StringFilter<"inducks_issuequotation"> | string
    issuenumber?: StringFilter<"inducks_issuequotation"> | string
    estimationmin?: FloatNullableFilter<"inducks_issuequotation"> | number | null
    estimationmax?: FloatNullableFilter<"inducks_issuequotation"> | number | null
    scrapedate?: DateTimeNullableFilter<"inducks_issuequotation"> | Date | string | null
    source?: StringFilter<"inducks_issuequotation"> | string
  }, "ID" | "issuecode">

  export type inducks_issuequotationOrderByWithAggregationInput = {
    ID?: SortOrder
    publicationcode?: SortOrder
    issuenumber?: SortOrder
    estimationmin?: SortOrderInput | SortOrder
    estimationmax?: SortOrderInput | SortOrder
    scrapedate?: SortOrderInput | SortOrder
    source?: SortOrder
    issuecode?: SortOrderInput | SortOrder
    _count?: inducks_issuequotationCountOrderByAggregateInput
    _avg?: inducks_issuequotationAvgOrderByAggregateInput
    _max?: inducks_issuequotationMaxOrderByAggregateInput
    _min?: inducks_issuequotationMinOrderByAggregateInput
    _sum?: inducks_issuequotationSumOrderByAggregateInput
  }

  export type inducks_issuequotationScalarWhereWithAggregatesInput = {
    AND?: inducks_issuequotationScalarWhereWithAggregatesInput | inducks_issuequotationScalarWhereWithAggregatesInput[]
    OR?: inducks_issuequotationScalarWhereWithAggregatesInput[]
    NOT?: inducks_issuequotationScalarWhereWithAggregatesInput | inducks_issuequotationScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"inducks_issuequotation"> | number
    publicationcode?: StringWithAggregatesFilter<"inducks_issuequotation"> | string
    issuenumber?: StringWithAggregatesFilter<"inducks_issuequotation"> | string
    estimationmin?: FloatNullableWithAggregatesFilter<"inducks_issuequotation"> | number | null
    estimationmax?: FloatNullableWithAggregatesFilter<"inducks_issuequotation"> | number | null
    scrapedate?: DateTimeNullableWithAggregatesFilter<"inducks_issuequotation"> | Date | string | null
    source?: StringWithAggregatesFilter<"inducks_issuequotation"> | string
    issuecode?: StringNullableWithAggregatesFilter<"inducks_issuequotation"> | string | null
  }

  export type inducks_issuerangeWhereInput = {
    AND?: inducks_issuerangeWhereInput | inducks_issuerangeWhereInput[]
    OR?: inducks_issuerangeWhereInput[]
    NOT?: inducks_issuerangeWhereInput | inducks_issuerangeWhereInput[]
    issuerangecode?: StringFilter<"inducks_issuerange"> | string
    publicationcode?: StringNullableFilter<"inducks_issuerange"> | string | null
    title?: StringNullableFilter<"inducks_issuerange"> | string | null
    circulation?: StringNullableFilter<"inducks_issuerange"> | string | null
    issuerangecomment?: StringNullableFilter<"inducks_issuerange"> | string | null
    numbersarefake?: Enuminducks_issuerange_numbersarefakeNullableFilter<"inducks_issuerange"> | $Enums.inducks_issuerange_numbersarefake | null
    error?: Enuminducks_issuerange_errorNullableFilter<"inducks_issuerange"> | $Enums.inducks_issuerange_error | null
  }

  export type inducks_issuerangeOrderByWithRelationInput = {
    issuerangecode?: SortOrder
    publicationcode?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    circulation?: SortOrderInput | SortOrder
    issuerangecomment?: SortOrderInput | SortOrder
    numbersarefake?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
  }

  export type inducks_issuerangeWhereUniqueInput = Prisma.AtLeast<{
    issuerangecode?: string
    AND?: inducks_issuerangeWhereInput | inducks_issuerangeWhereInput[]
    OR?: inducks_issuerangeWhereInput[]
    NOT?: inducks_issuerangeWhereInput | inducks_issuerangeWhereInput[]
    publicationcode?: StringNullableFilter<"inducks_issuerange"> | string | null
    title?: StringNullableFilter<"inducks_issuerange"> | string | null
    circulation?: StringNullableFilter<"inducks_issuerange"> | string | null
    issuerangecomment?: StringNullableFilter<"inducks_issuerange"> | string | null
    numbersarefake?: Enuminducks_issuerange_numbersarefakeNullableFilter<"inducks_issuerange"> | $Enums.inducks_issuerange_numbersarefake | null
    error?: Enuminducks_issuerange_errorNullableFilter<"inducks_issuerange"> | $Enums.inducks_issuerange_error | null
  }, "issuerangecode">

  export type inducks_issuerangeOrderByWithAggregationInput = {
    issuerangecode?: SortOrder
    publicationcode?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    circulation?: SortOrderInput | SortOrder
    issuerangecomment?: SortOrderInput | SortOrder
    numbersarefake?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    _count?: inducks_issuerangeCountOrderByAggregateInput
    _max?: inducks_issuerangeMaxOrderByAggregateInput
    _min?: inducks_issuerangeMinOrderByAggregateInput
  }

  export type inducks_issuerangeScalarWhereWithAggregatesInput = {
    AND?: inducks_issuerangeScalarWhereWithAggregatesInput | inducks_issuerangeScalarWhereWithAggregatesInput[]
    OR?: inducks_issuerangeScalarWhereWithAggregatesInput[]
    NOT?: inducks_issuerangeScalarWhereWithAggregatesInput | inducks_issuerangeScalarWhereWithAggregatesInput[]
    issuerangecode?: StringWithAggregatesFilter<"inducks_issuerange"> | string
    publicationcode?: StringNullableWithAggregatesFilter<"inducks_issuerange"> | string | null
    title?: StringNullableWithAggregatesFilter<"inducks_issuerange"> | string | null
    circulation?: StringNullableWithAggregatesFilter<"inducks_issuerange"> | string | null
    issuerangecomment?: StringNullableWithAggregatesFilter<"inducks_issuerange"> | string | null
    numbersarefake?: Enuminducks_issuerange_numbersarefakeNullableWithAggregatesFilter<"inducks_issuerange"> | $Enums.inducks_issuerange_numbersarefake | null
    error?: Enuminducks_issuerange_errorNullableWithAggregatesFilter<"inducks_issuerange"> | $Enums.inducks_issuerange_error | null
  }

  export type inducks_issueurlWhereInput = {
    AND?: inducks_issueurlWhereInput | inducks_issueurlWhereInput[]
    OR?: inducks_issueurlWhereInput[]
    NOT?: inducks_issueurlWhereInput | inducks_issueurlWhereInput[]
    issuecode?: StringFilter<"inducks_issueurl"> | string
    sitecode?: StringFilter<"inducks_issueurl"> | string
    url?: StringNullableFilter<"inducks_issueurl"> | string | null
  }

  export type inducks_issueurlOrderByWithRelationInput = {
    issuecode?: SortOrder
    sitecode?: SortOrder
    url?: SortOrderInput | SortOrder
  }

  export type inducks_issueurlWhereUniqueInput = Prisma.AtLeast<{
    issuecode_sitecode?: inducks_issueurlIssuecodeSitecodeCompoundUniqueInput
    AND?: inducks_issueurlWhereInput | inducks_issueurlWhereInput[]
    OR?: inducks_issueurlWhereInput[]
    NOT?: inducks_issueurlWhereInput | inducks_issueurlWhereInput[]
    issuecode?: StringFilter<"inducks_issueurl"> | string
    sitecode?: StringFilter<"inducks_issueurl"> | string
    url?: StringNullableFilter<"inducks_issueurl"> | string | null
  }, "issuecode_sitecode">

  export type inducks_issueurlOrderByWithAggregationInput = {
    issuecode?: SortOrder
    sitecode?: SortOrder
    url?: SortOrderInput | SortOrder
    _count?: inducks_issueurlCountOrderByAggregateInput
    _max?: inducks_issueurlMaxOrderByAggregateInput
    _min?: inducks_issueurlMinOrderByAggregateInput
  }

  export type inducks_issueurlScalarWhereWithAggregatesInput = {
    AND?: inducks_issueurlScalarWhereWithAggregatesInput | inducks_issueurlScalarWhereWithAggregatesInput[]
    OR?: inducks_issueurlScalarWhereWithAggregatesInput[]
    NOT?: inducks_issueurlScalarWhereWithAggregatesInput | inducks_issueurlScalarWhereWithAggregatesInput[]
    issuecode?: StringWithAggregatesFilter<"inducks_issueurl"> | string
    sitecode?: StringWithAggregatesFilter<"inducks_issueurl"> | string
    url?: StringNullableWithAggregatesFilter<"inducks_issueurl"> | string | null
  }

  export type inducks_languageWhereInput = {
    AND?: inducks_languageWhereInput | inducks_languageWhereInput[]
    OR?: inducks_languageWhereInput[]
    NOT?: inducks_languageWhereInput | inducks_languageWhereInput[]
    languagecode?: StringFilter<"inducks_language"> | string
    defaultlanguagecode?: StringNullableFilter<"inducks_language"> | string | null
    languagename?: StringNullableFilter<"inducks_language"> | string | null
  }

  export type inducks_languageOrderByWithRelationInput = {
    languagecode?: SortOrder
    defaultlanguagecode?: SortOrderInput | SortOrder
    languagename?: SortOrderInput | SortOrder
  }

  export type inducks_languageWhereUniqueInput = Prisma.AtLeast<{
    languagecode?: string
    AND?: inducks_languageWhereInput | inducks_languageWhereInput[]
    OR?: inducks_languageWhereInput[]
    NOT?: inducks_languageWhereInput | inducks_languageWhereInput[]
    defaultlanguagecode?: StringNullableFilter<"inducks_language"> | string | null
    languagename?: StringNullableFilter<"inducks_language"> | string | null
  }, "languagecode">

  export type inducks_languageOrderByWithAggregationInput = {
    languagecode?: SortOrder
    defaultlanguagecode?: SortOrderInput | SortOrder
    languagename?: SortOrderInput | SortOrder
    _count?: inducks_languageCountOrderByAggregateInput
    _max?: inducks_languageMaxOrderByAggregateInput
    _min?: inducks_languageMinOrderByAggregateInput
  }

  export type inducks_languageScalarWhereWithAggregatesInput = {
    AND?: inducks_languageScalarWhereWithAggregatesInput | inducks_languageScalarWhereWithAggregatesInput[]
    OR?: inducks_languageScalarWhereWithAggregatesInput[]
    NOT?: inducks_languageScalarWhereWithAggregatesInput | inducks_languageScalarWhereWithAggregatesInput[]
    languagecode?: StringWithAggregatesFilter<"inducks_language"> | string
    defaultlanguagecode?: StringNullableWithAggregatesFilter<"inducks_language"> | string | null
    languagename?: StringNullableWithAggregatesFilter<"inducks_language"> | string | null
  }

  export type inducks_languagenameWhereInput = {
    AND?: inducks_languagenameWhereInput | inducks_languagenameWhereInput[]
    OR?: inducks_languagenameWhereInput[]
    NOT?: inducks_languagenameWhereInput | inducks_languagenameWhereInput[]
    desclanguagecode?: StringFilter<"inducks_languagename"> | string
    languagecode?: StringFilter<"inducks_languagename"> | string
    languagename?: StringNullableFilter<"inducks_languagename"> | string | null
  }

  export type inducks_languagenameOrderByWithRelationInput = {
    desclanguagecode?: SortOrder
    languagecode?: SortOrder
    languagename?: SortOrderInput | SortOrder
  }

  export type inducks_languagenameWhereUniqueInput = Prisma.AtLeast<{
    desclanguagecode_languagecode?: inducks_languagenameDesclanguagecodeLanguagecodeCompoundUniqueInput
    AND?: inducks_languagenameWhereInput | inducks_languagenameWhereInput[]
    OR?: inducks_languagenameWhereInput[]
    NOT?: inducks_languagenameWhereInput | inducks_languagenameWhereInput[]
    desclanguagecode?: StringFilter<"inducks_languagename"> | string
    languagecode?: StringFilter<"inducks_languagename"> | string
    languagename?: StringNullableFilter<"inducks_languagename"> | string | null
  }, "desclanguagecode_languagecode">

  export type inducks_languagenameOrderByWithAggregationInput = {
    desclanguagecode?: SortOrder
    languagecode?: SortOrder
    languagename?: SortOrderInput | SortOrder
    _count?: inducks_languagenameCountOrderByAggregateInput
    _max?: inducks_languagenameMaxOrderByAggregateInput
    _min?: inducks_languagenameMinOrderByAggregateInput
  }

  export type inducks_languagenameScalarWhereWithAggregatesInput = {
    AND?: inducks_languagenameScalarWhereWithAggregatesInput | inducks_languagenameScalarWhereWithAggregatesInput[]
    OR?: inducks_languagenameScalarWhereWithAggregatesInput[]
    NOT?: inducks_languagenameScalarWhereWithAggregatesInput | inducks_languagenameScalarWhereWithAggregatesInput[]
    desclanguagecode?: StringWithAggregatesFilter<"inducks_languagename"> | string
    languagecode?: StringWithAggregatesFilter<"inducks_languagename"> | string
    languagename?: StringNullableWithAggregatesFilter<"inducks_languagename"> | string | null
  }

  export type inducks_logWhereInput = {
    AND?: inducks_logWhereInput | inducks_logWhereInput[]
    OR?: inducks_logWhereInput[]
    NOT?: inducks_logWhereInput | inducks_logWhereInput[]
    number?: IntFilter<"inducks_log"> | number
    logkey?: StringNullableFilter<"inducks_log"> | string | null
    storycode?: StringNullableFilter<"inducks_log"> | string | null
    logid?: StringNullableFilter<"inducks_log"> | string | null
    logtype?: StringNullableFilter<"inducks_log"> | string | null
    par1?: StringNullableFilter<"inducks_log"> | string | null
    par2?: StringNullableFilter<"inducks_log"> | string | null
    par3?: StringNullableFilter<"inducks_log"> | string | null
    marked?: Enuminducks_log_markedNullableFilter<"inducks_log"> | $Enums.inducks_log_marked | null
    inputfilecode?: IntNullableFilter<"inducks_log"> | number | null
    maintenanceteamcode?: StringNullableFilter<"inducks_log"> | string | null
  }

  export type inducks_logOrderByWithRelationInput = {
    number?: SortOrder
    logkey?: SortOrderInput | SortOrder
    storycode?: SortOrderInput | SortOrder
    logid?: SortOrderInput | SortOrder
    logtype?: SortOrderInput | SortOrder
    par1?: SortOrderInput | SortOrder
    par2?: SortOrderInput | SortOrder
    par3?: SortOrderInput | SortOrder
    marked?: SortOrderInput | SortOrder
    inputfilecode?: SortOrderInput | SortOrder
    maintenanceteamcode?: SortOrderInput | SortOrder
  }

  export type inducks_logWhereUniqueInput = Prisma.AtLeast<{
    number?: number
    AND?: inducks_logWhereInput | inducks_logWhereInput[]
    OR?: inducks_logWhereInput[]
    NOT?: inducks_logWhereInput | inducks_logWhereInput[]
    logkey?: StringNullableFilter<"inducks_log"> | string | null
    storycode?: StringNullableFilter<"inducks_log"> | string | null
    logid?: StringNullableFilter<"inducks_log"> | string | null
    logtype?: StringNullableFilter<"inducks_log"> | string | null
    par1?: StringNullableFilter<"inducks_log"> | string | null
    par2?: StringNullableFilter<"inducks_log"> | string | null
    par3?: StringNullableFilter<"inducks_log"> | string | null
    marked?: Enuminducks_log_markedNullableFilter<"inducks_log"> | $Enums.inducks_log_marked | null
    inputfilecode?: IntNullableFilter<"inducks_log"> | number | null
    maintenanceteamcode?: StringNullableFilter<"inducks_log"> | string | null
  }, "number">

  export type inducks_logOrderByWithAggregationInput = {
    number?: SortOrder
    logkey?: SortOrderInput | SortOrder
    storycode?: SortOrderInput | SortOrder
    logid?: SortOrderInput | SortOrder
    logtype?: SortOrderInput | SortOrder
    par1?: SortOrderInput | SortOrder
    par2?: SortOrderInput | SortOrder
    par3?: SortOrderInput | SortOrder
    marked?: SortOrderInput | SortOrder
    inputfilecode?: SortOrderInput | SortOrder
    maintenanceteamcode?: SortOrderInput | SortOrder
    _count?: inducks_logCountOrderByAggregateInput
    _avg?: inducks_logAvgOrderByAggregateInput
    _max?: inducks_logMaxOrderByAggregateInput
    _min?: inducks_logMinOrderByAggregateInput
    _sum?: inducks_logSumOrderByAggregateInput
  }

  export type inducks_logScalarWhereWithAggregatesInput = {
    AND?: inducks_logScalarWhereWithAggregatesInput | inducks_logScalarWhereWithAggregatesInput[]
    OR?: inducks_logScalarWhereWithAggregatesInput[]
    NOT?: inducks_logScalarWhereWithAggregatesInput | inducks_logScalarWhereWithAggregatesInput[]
    number?: IntWithAggregatesFilter<"inducks_log"> | number
    logkey?: StringNullableWithAggregatesFilter<"inducks_log"> | string | null
    storycode?: StringNullableWithAggregatesFilter<"inducks_log"> | string | null
    logid?: StringNullableWithAggregatesFilter<"inducks_log"> | string | null
    logtype?: StringNullableWithAggregatesFilter<"inducks_log"> | string | null
    par1?: StringNullableWithAggregatesFilter<"inducks_log"> | string | null
    par2?: StringNullableWithAggregatesFilter<"inducks_log"> | string | null
    par3?: StringNullableWithAggregatesFilter<"inducks_log"> | string | null
    marked?: Enuminducks_log_markedNullableWithAggregatesFilter<"inducks_log"> | $Enums.inducks_log_marked | null
    inputfilecode?: IntNullableWithAggregatesFilter<"inducks_log"> | number | null
    maintenanceteamcode?: StringNullableWithAggregatesFilter<"inducks_log"> | string | null
  }

  export type inducks_logdataWhereInput = {
    AND?: inducks_logdataWhereInput | inducks_logdataWhereInput[]
    OR?: inducks_logdataWhereInput[]
    NOT?: inducks_logdataWhereInput | inducks_logdataWhereInput[]
    logid?: StringFilter<"inducks_logdata"> | string
    category?: IntNullableFilter<"inducks_logdata"> | number | null
    logtext?: StringNullableFilter<"inducks_logdata"> | string | null
  }

  export type inducks_logdataOrderByWithRelationInput = {
    logid?: SortOrder
    category?: SortOrderInput | SortOrder
    logtext?: SortOrderInput | SortOrder
  }

  export type inducks_logdataWhereUniqueInput = Prisma.AtLeast<{
    logid?: string
    AND?: inducks_logdataWhereInput | inducks_logdataWhereInput[]
    OR?: inducks_logdataWhereInput[]
    NOT?: inducks_logdataWhereInput | inducks_logdataWhereInput[]
    category?: IntNullableFilter<"inducks_logdata"> | number | null
    logtext?: StringNullableFilter<"inducks_logdata"> | string | null
  }, "logid">

  export type inducks_logdataOrderByWithAggregationInput = {
    logid?: SortOrder
    category?: SortOrderInput | SortOrder
    logtext?: SortOrderInput | SortOrder
    _count?: inducks_logdataCountOrderByAggregateInput
    _avg?: inducks_logdataAvgOrderByAggregateInput
    _max?: inducks_logdataMaxOrderByAggregateInput
    _min?: inducks_logdataMinOrderByAggregateInput
    _sum?: inducks_logdataSumOrderByAggregateInput
  }

  export type inducks_logdataScalarWhereWithAggregatesInput = {
    AND?: inducks_logdataScalarWhereWithAggregatesInput | inducks_logdataScalarWhereWithAggregatesInput[]
    OR?: inducks_logdataScalarWhereWithAggregatesInput[]
    NOT?: inducks_logdataScalarWhereWithAggregatesInput | inducks_logdataScalarWhereWithAggregatesInput[]
    logid?: StringWithAggregatesFilter<"inducks_logdata"> | string
    category?: IntNullableWithAggregatesFilter<"inducks_logdata"> | number | null
    logtext?: StringNullableWithAggregatesFilter<"inducks_logdata"> | string | null
  }

  export type inducks_logocharacterWhereInput = {
    AND?: inducks_logocharacterWhereInput | inducks_logocharacterWhereInput[]
    OR?: inducks_logocharacterWhereInput[]
    NOT?: inducks_logocharacterWhereInput | inducks_logocharacterWhereInput[]
    entrycode?: StringFilter<"inducks_logocharacter"> | string
    charactercode?: StringFilter<"inducks_logocharacter"> | string
    reallyintitle?: Enuminducks_logocharacter_reallyintitleNullableFilter<"inducks_logocharacter"> | $Enums.inducks_logocharacter_reallyintitle | null
    number?: IntNullableFilter<"inducks_logocharacter"> | number | null
    logocharactercomment?: StringNullableFilter<"inducks_logocharacter"> | string | null
  }

  export type inducks_logocharacterOrderByWithRelationInput = {
    entrycode?: SortOrder
    charactercode?: SortOrder
    reallyintitle?: SortOrderInput | SortOrder
    number?: SortOrderInput | SortOrder
    logocharactercomment?: SortOrderInput | SortOrder
  }

  export type inducks_logocharacterWhereUniqueInput = Prisma.AtLeast<{
    entrycode_charactercode?: inducks_logocharacterEntrycodeCharactercodeCompoundUniqueInput
    AND?: inducks_logocharacterWhereInput | inducks_logocharacterWhereInput[]
    OR?: inducks_logocharacterWhereInput[]
    NOT?: inducks_logocharacterWhereInput | inducks_logocharacterWhereInput[]
    entrycode?: StringFilter<"inducks_logocharacter"> | string
    charactercode?: StringFilter<"inducks_logocharacter"> | string
    reallyintitle?: Enuminducks_logocharacter_reallyintitleNullableFilter<"inducks_logocharacter"> | $Enums.inducks_logocharacter_reallyintitle | null
    number?: IntNullableFilter<"inducks_logocharacter"> | number | null
    logocharactercomment?: StringNullableFilter<"inducks_logocharacter"> | string | null
  }, "entrycode_charactercode">

  export type inducks_logocharacterOrderByWithAggregationInput = {
    entrycode?: SortOrder
    charactercode?: SortOrder
    reallyintitle?: SortOrderInput | SortOrder
    number?: SortOrderInput | SortOrder
    logocharactercomment?: SortOrderInput | SortOrder
    _count?: inducks_logocharacterCountOrderByAggregateInput
    _avg?: inducks_logocharacterAvgOrderByAggregateInput
    _max?: inducks_logocharacterMaxOrderByAggregateInput
    _min?: inducks_logocharacterMinOrderByAggregateInput
    _sum?: inducks_logocharacterSumOrderByAggregateInput
  }

  export type inducks_logocharacterScalarWhereWithAggregatesInput = {
    AND?: inducks_logocharacterScalarWhereWithAggregatesInput | inducks_logocharacterScalarWhereWithAggregatesInput[]
    OR?: inducks_logocharacterScalarWhereWithAggregatesInput[]
    NOT?: inducks_logocharacterScalarWhereWithAggregatesInput | inducks_logocharacterScalarWhereWithAggregatesInput[]
    entrycode?: StringWithAggregatesFilter<"inducks_logocharacter"> | string
    charactercode?: StringWithAggregatesFilter<"inducks_logocharacter"> | string
    reallyintitle?: Enuminducks_logocharacter_reallyintitleNullableWithAggregatesFilter<"inducks_logocharacter"> | $Enums.inducks_logocharacter_reallyintitle | null
    number?: IntNullableWithAggregatesFilter<"inducks_logocharacter"> | number | null
    logocharactercomment?: StringNullableWithAggregatesFilter<"inducks_logocharacter"> | string | null
  }

  export type inducks_movieWhereInput = {
    AND?: inducks_movieWhereInput | inducks_movieWhereInput[]
    OR?: inducks_movieWhereInput[]
    NOT?: inducks_movieWhereInput | inducks_movieWhereInput[]
    moviecode?: StringFilter<"inducks_movie"> | string
    title?: StringNullableFilter<"inducks_movie"> | string | null
    moviecomment?: StringNullableFilter<"inducks_movie"> | string | null
    appsummary?: StringNullableFilter<"inducks_movie"> | string | null
    moviejobsummary?: StringNullableFilter<"inducks_movie"> | string | null
    locked?: Enuminducks_movie_lockedNullableFilter<"inducks_movie"> | $Enums.inducks_movie_locked | null
    inputfilecode?: IntNullableFilter<"inducks_movie"> | number | null
    maintenanceteamcode?: StringNullableFilter<"inducks_movie"> | string | null
    aka?: StringNullableFilter<"inducks_movie"> | string | null
    creationdate?: StringNullableFilter<"inducks_movie"> | string | null
    moviedescription?: StringNullableFilter<"inducks_movie"> | string | null
    distributor?: StringNullableFilter<"inducks_movie"> | string | null
    genre?: StringNullableFilter<"inducks_movie"> | string | null
    orderer?: StringNullableFilter<"inducks_movie"> | string | null
    publicationdate?: StringNullableFilter<"inducks_movie"> | string | null
    source?: StringNullableFilter<"inducks_movie"> | string | null
    tim?: StringNullableFilter<"inducks_movie"> | string | null
  }

  export type inducks_movieOrderByWithRelationInput = {
    moviecode?: SortOrder
    title?: SortOrderInput | SortOrder
    moviecomment?: SortOrderInput | SortOrder
    appsummary?: SortOrderInput | SortOrder
    moviejobsummary?: SortOrderInput | SortOrder
    locked?: SortOrderInput | SortOrder
    inputfilecode?: SortOrderInput | SortOrder
    maintenanceteamcode?: SortOrderInput | SortOrder
    aka?: SortOrderInput | SortOrder
    creationdate?: SortOrderInput | SortOrder
    moviedescription?: SortOrderInput | SortOrder
    distributor?: SortOrderInput | SortOrder
    genre?: SortOrderInput | SortOrder
    orderer?: SortOrderInput | SortOrder
    publicationdate?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    tim?: SortOrderInput | SortOrder
  }

  export type inducks_movieWhereUniqueInput = Prisma.AtLeast<{
    moviecode?: string
    AND?: inducks_movieWhereInput | inducks_movieWhereInput[]
    OR?: inducks_movieWhereInput[]
    NOT?: inducks_movieWhereInput | inducks_movieWhereInput[]
    title?: StringNullableFilter<"inducks_movie"> | string | null
    moviecomment?: StringNullableFilter<"inducks_movie"> | string | null
    appsummary?: StringNullableFilter<"inducks_movie"> | string | null
    moviejobsummary?: StringNullableFilter<"inducks_movie"> | string | null
    locked?: Enuminducks_movie_lockedNullableFilter<"inducks_movie"> | $Enums.inducks_movie_locked | null
    inputfilecode?: IntNullableFilter<"inducks_movie"> | number | null
    maintenanceteamcode?: StringNullableFilter<"inducks_movie"> | string | null
    aka?: StringNullableFilter<"inducks_movie"> | string | null
    creationdate?: StringNullableFilter<"inducks_movie"> | string | null
    moviedescription?: StringNullableFilter<"inducks_movie"> | string | null
    distributor?: StringNullableFilter<"inducks_movie"> | string | null
    genre?: StringNullableFilter<"inducks_movie"> | string | null
    orderer?: StringNullableFilter<"inducks_movie"> | string | null
    publicationdate?: StringNullableFilter<"inducks_movie"> | string | null
    source?: StringNullableFilter<"inducks_movie"> | string | null
    tim?: StringNullableFilter<"inducks_movie"> | string | null
  }, "moviecode">

  export type inducks_movieOrderByWithAggregationInput = {
    moviecode?: SortOrder
    title?: SortOrderInput | SortOrder
    moviecomment?: SortOrderInput | SortOrder
    appsummary?: SortOrderInput | SortOrder
    moviejobsummary?: SortOrderInput | SortOrder
    locked?: SortOrderInput | SortOrder
    inputfilecode?: SortOrderInput | SortOrder
    maintenanceteamcode?: SortOrderInput | SortOrder
    aka?: SortOrderInput | SortOrder
    creationdate?: SortOrderInput | SortOrder
    moviedescription?: SortOrderInput | SortOrder
    distributor?: SortOrderInput | SortOrder
    genre?: SortOrderInput | SortOrder
    orderer?: SortOrderInput | SortOrder
    publicationdate?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    tim?: SortOrderInput | SortOrder
    _count?: inducks_movieCountOrderByAggregateInput
    _avg?: inducks_movieAvgOrderByAggregateInput
    _max?: inducks_movieMaxOrderByAggregateInput
    _min?: inducks_movieMinOrderByAggregateInput
    _sum?: inducks_movieSumOrderByAggregateInput
  }

  export type inducks_movieScalarWhereWithAggregatesInput = {
    AND?: inducks_movieScalarWhereWithAggregatesInput | inducks_movieScalarWhereWithAggregatesInput[]
    OR?: inducks_movieScalarWhereWithAggregatesInput[]
    NOT?: inducks_movieScalarWhereWithAggregatesInput | inducks_movieScalarWhereWithAggregatesInput[]
    moviecode?: StringWithAggregatesFilter<"inducks_movie"> | string
    title?: StringNullableWithAggregatesFilter<"inducks_movie"> | string | null
    moviecomment?: StringNullableWithAggregatesFilter<"inducks_movie"> | string | null
    appsummary?: StringNullableWithAggregatesFilter<"inducks_movie"> | string | null
    moviejobsummary?: StringNullableWithAggregatesFilter<"inducks_movie"> | string | null
    locked?: Enuminducks_movie_lockedNullableWithAggregatesFilter<"inducks_movie"> | $Enums.inducks_movie_locked | null
    inputfilecode?: IntNullableWithAggregatesFilter<"inducks_movie"> | number | null
    maintenanceteamcode?: StringNullableWithAggregatesFilter<"inducks_movie"> | string | null
    aka?: StringNullableWithAggregatesFilter<"inducks_movie"> | string | null
    creationdate?: StringNullableWithAggregatesFilter<"inducks_movie"> | string | null
    moviedescription?: StringNullableWithAggregatesFilter<"inducks_movie"> | string | null
    distributor?: StringNullableWithAggregatesFilter<"inducks_movie"> | string | null
    genre?: StringNullableWithAggregatesFilter<"inducks_movie"> | string | null
    orderer?: StringNullableWithAggregatesFilter<"inducks_movie"> | string | null
    publicationdate?: StringNullableWithAggregatesFilter<"inducks_movie"> | string | null
    source?: StringNullableWithAggregatesFilter<"inducks_movie"> | string | null
    tim?: StringNullableWithAggregatesFilter<"inducks_movie"> | string | null
  }

  export type inducks_moviecharacterWhereInput = {
    AND?: inducks_moviecharacterWhereInput | inducks_moviecharacterWhereInput[]
    OR?: inducks_moviecharacterWhereInput[]
    NOT?: inducks_moviecharacterWhereInput | inducks_moviecharacterWhereInput[]
    moviecode?: StringFilter<"inducks_moviecharacter"> | string
    charactercode?: StringFilter<"inducks_moviecharacter"> | string
    istitlecharacter?: Enuminducks_moviecharacter_istitlecharacterNullableFilter<"inducks_moviecharacter"> | $Enums.inducks_moviecharacter_istitlecharacter | null
  }

  export type inducks_moviecharacterOrderByWithRelationInput = {
    moviecode?: SortOrder
    charactercode?: SortOrder
    istitlecharacter?: SortOrderInput | SortOrder
  }

  export type inducks_moviecharacterWhereUniqueInput = Prisma.AtLeast<{
    moviecode_charactercode?: inducks_moviecharacterMoviecodeCharactercodeCompoundUniqueInput
    AND?: inducks_moviecharacterWhereInput | inducks_moviecharacterWhereInput[]
    OR?: inducks_moviecharacterWhereInput[]
    NOT?: inducks_moviecharacterWhereInput | inducks_moviecharacterWhereInput[]
    moviecode?: StringFilter<"inducks_moviecharacter"> | string
    charactercode?: StringFilter<"inducks_moviecharacter"> | string
    istitlecharacter?: Enuminducks_moviecharacter_istitlecharacterNullableFilter<"inducks_moviecharacter"> | $Enums.inducks_moviecharacter_istitlecharacter | null
  }, "moviecode_charactercode">

  export type inducks_moviecharacterOrderByWithAggregationInput = {
    moviecode?: SortOrder
    charactercode?: SortOrder
    istitlecharacter?: SortOrderInput | SortOrder
    _count?: inducks_moviecharacterCountOrderByAggregateInput
    _max?: inducks_moviecharacterMaxOrderByAggregateInput
    _min?: inducks_moviecharacterMinOrderByAggregateInput
  }

  export type inducks_moviecharacterScalarWhereWithAggregatesInput = {
    AND?: inducks_moviecharacterScalarWhereWithAggregatesInput | inducks_moviecharacterScalarWhereWithAggregatesInput[]
    OR?: inducks_moviecharacterScalarWhereWithAggregatesInput[]
    NOT?: inducks_moviecharacterScalarWhereWithAggregatesInput | inducks_moviecharacterScalarWhereWithAggregatesInput[]
    moviecode?: StringWithAggregatesFilter<"inducks_moviecharacter"> | string
    charactercode?: StringWithAggregatesFilter<"inducks_moviecharacter"> | string
    istitlecharacter?: Enuminducks_moviecharacter_istitlecharacterNullableWithAggregatesFilter<"inducks_moviecharacter"> | $Enums.inducks_moviecharacter_istitlecharacter | null
  }

  export type inducks_moviejobWhereInput = {
    AND?: inducks_moviejobWhereInput | inducks_moviejobWhereInput[]
    OR?: inducks_moviejobWhereInput[]
    NOT?: inducks_moviejobWhereInput | inducks_moviejobWhereInput[]
    moviecode?: StringFilter<"inducks_moviejob"> | string
    personcode?: StringFilter<"inducks_moviejob"> | string
    role?: StringFilter<"inducks_moviejob"> | string
    moviejobcomment?: StringNullableFilter<"inducks_moviejob"> | string | null
    indirect?: Enuminducks_moviejob_indirectNullableFilter<"inducks_moviejob"> | $Enums.inducks_moviejob_indirect | null
    doubt?: Enuminducks_moviejob_doubtNullableFilter<"inducks_moviejob"> | $Enums.inducks_moviejob_doubt | null
  }

  export type inducks_moviejobOrderByWithRelationInput = {
    moviecode?: SortOrder
    personcode?: SortOrder
    role?: SortOrder
    moviejobcomment?: SortOrderInput | SortOrder
    indirect?: SortOrderInput | SortOrder
    doubt?: SortOrderInput | SortOrder
  }

  export type inducks_moviejobWhereUniqueInput = Prisma.AtLeast<{
    moviecode_personcode_role?: inducks_moviejobMoviecodePersoncodeRoleCompoundUniqueInput
    AND?: inducks_moviejobWhereInput | inducks_moviejobWhereInput[]
    OR?: inducks_moviejobWhereInput[]
    NOT?: inducks_moviejobWhereInput | inducks_moviejobWhereInput[]
    moviecode?: StringFilter<"inducks_moviejob"> | string
    personcode?: StringFilter<"inducks_moviejob"> | string
    role?: StringFilter<"inducks_moviejob"> | string
    moviejobcomment?: StringNullableFilter<"inducks_moviejob"> | string | null
    indirect?: Enuminducks_moviejob_indirectNullableFilter<"inducks_moviejob"> | $Enums.inducks_moviejob_indirect | null
    doubt?: Enuminducks_moviejob_doubtNullableFilter<"inducks_moviejob"> | $Enums.inducks_moviejob_doubt | null
  }, "moviecode_personcode_role">

  export type inducks_moviejobOrderByWithAggregationInput = {
    moviecode?: SortOrder
    personcode?: SortOrder
    role?: SortOrder
    moviejobcomment?: SortOrderInput | SortOrder
    indirect?: SortOrderInput | SortOrder
    doubt?: SortOrderInput | SortOrder
    _count?: inducks_moviejobCountOrderByAggregateInput
    _max?: inducks_moviejobMaxOrderByAggregateInput
    _min?: inducks_moviejobMinOrderByAggregateInput
  }

  export type inducks_moviejobScalarWhereWithAggregatesInput = {
    AND?: inducks_moviejobScalarWhereWithAggregatesInput | inducks_moviejobScalarWhereWithAggregatesInput[]
    OR?: inducks_moviejobScalarWhereWithAggregatesInput[]
    NOT?: inducks_moviejobScalarWhereWithAggregatesInput | inducks_moviejobScalarWhereWithAggregatesInput[]
    moviecode?: StringWithAggregatesFilter<"inducks_moviejob"> | string
    personcode?: StringWithAggregatesFilter<"inducks_moviejob"> | string
    role?: StringWithAggregatesFilter<"inducks_moviejob"> | string
    moviejobcomment?: StringNullableWithAggregatesFilter<"inducks_moviejob"> | string | null
    indirect?: Enuminducks_moviejob_indirectNullableWithAggregatesFilter<"inducks_moviejob"> | $Enums.inducks_moviejob_indirect | null
    doubt?: Enuminducks_moviejob_doubtNullableWithAggregatesFilter<"inducks_moviejob"> | $Enums.inducks_moviejob_doubt | null
  }

  export type inducks_moviereferenceWhereInput = {
    AND?: inducks_moviereferenceWhereInput | inducks_moviereferenceWhereInput[]
    OR?: inducks_moviereferenceWhereInput[]
    NOT?: inducks_moviereferenceWhereInput | inducks_moviereferenceWhereInput[]
    storycode?: StringFilter<"inducks_moviereference"> | string
    moviecode?: StringFilter<"inducks_moviereference"> | string
    referencereasonid?: IntNullableFilter<"inducks_moviereference"> | number | null
    frommovietostory?: Enuminducks_moviereference_frommovietostoryNullableFilter<"inducks_moviereference"> | $Enums.inducks_moviereference_frommovietostory | null
  }

  export type inducks_moviereferenceOrderByWithRelationInput = {
    storycode?: SortOrder
    moviecode?: SortOrder
    referencereasonid?: SortOrderInput | SortOrder
    frommovietostory?: SortOrderInput | SortOrder
  }

  export type inducks_moviereferenceWhereUniqueInput = Prisma.AtLeast<{
    storycode_moviecode?: inducks_moviereferenceStorycodeMoviecodeCompoundUniqueInput
    AND?: inducks_moviereferenceWhereInput | inducks_moviereferenceWhereInput[]
    OR?: inducks_moviereferenceWhereInput[]
    NOT?: inducks_moviereferenceWhereInput | inducks_moviereferenceWhereInput[]
    storycode?: StringFilter<"inducks_moviereference"> | string
    moviecode?: StringFilter<"inducks_moviereference"> | string
    referencereasonid?: IntNullableFilter<"inducks_moviereference"> | number | null
    frommovietostory?: Enuminducks_moviereference_frommovietostoryNullableFilter<"inducks_moviereference"> | $Enums.inducks_moviereference_frommovietostory | null
  }, "storycode_moviecode">

  export type inducks_moviereferenceOrderByWithAggregationInput = {
    storycode?: SortOrder
    moviecode?: SortOrder
    referencereasonid?: SortOrderInput | SortOrder
    frommovietostory?: SortOrderInput | SortOrder
    _count?: inducks_moviereferenceCountOrderByAggregateInput
    _avg?: inducks_moviereferenceAvgOrderByAggregateInput
    _max?: inducks_moviereferenceMaxOrderByAggregateInput
    _min?: inducks_moviereferenceMinOrderByAggregateInput
    _sum?: inducks_moviereferenceSumOrderByAggregateInput
  }

  export type inducks_moviereferenceScalarWhereWithAggregatesInput = {
    AND?: inducks_moviereferenceScalarWhereWithAggregatesInput | inducks_moviereferenceScalarWhereWithAggregatesInput[]
    OR?: inducks_moviereferenceScalarWhereWithAggregatesInput[]
    NOT?: inducks_moviereferenceScalarWhereWithAggregatesInput | inducks_moviereferenceScalarWhereWithAggregatesInput[]
    storycode?: StringWithAggregatesFilter<"inducks_moviereference"> | string
    moviecode?: StringWithAggregatesFilter<"inducks_moviereference"> | string
    referencereasonid?: IntNullableWithAggregatesFilter<"inducks_moviereference"> | number | null
    frommovietostory?: Enuminducks_moviereference_frommovietostoryNullableWithAggregatesFilter<"inducks_moviereference"> | $Enums.inducks_moviereference_frommovietostory | null
  }

  export type inducks_personWhereInput = {
    AND?: inducks_personWhereInput | inducks_personWhereInput[]
    OR?: inducks_personWhereInput[]
    NOT?: inducks_personWhereInput | inducks_personWhereInput[]
    personcode?: StringFilter<"inducks_person"> | string
    nationalitycountrycode?: StringNullableFilter<"inducks_person"> | string | null
    fullname?: StringNullableFilter<"inducks_person"> | string | null
    official?: Enuminducks_person_officialNullableFilter<"inducks_person"> | $Enums.inducks_person_official | null
    personcomment?: StringNullableFilter<"inducks_person"> | string | null
    unknownstudiomember?: Enuminducks_person_unknownstudiomemberNullableFilter<"inducks_person"> | $Enums.inducks_person_unknownstudiomember | null
    isfake?: Enuminducks_person_isfakeNullableFilter<"inducks_person"> | $Enums.inducks_person_isfake | null
    numberofindexedissues?: IntNullableFilter<"inducks_person"> | number | null
    birthname?: StringNullableFilter<"inducks_person"> | string | null
    borndate?: StringNullableFilter<"inducks_person"> | string | null
    bornplace?: StringNullableFilter<"inducks_person"> | string | null
    deceaseddate?: StringNullableFilter<"inducks_person"> | string | null
    deceasedplace?: StringNullableFilter<"inducks_person"> | string | null
    education?: StringNullableFilter<"inducks_person"> | string | null
    moviestext?: StringNullableFilter<"inducks_person"> | string | null
    comicstext?: StringNullableFilter<"inducks_person"> | string | null
    othertext?: StringNullableFilter<"inducks_person"> | string | null
    photofilename?: StringNullableFilter<"inducks_person"> | string | null
    photocomment?: StringNullableFilter<"inducks_person"> | string | null
    photosource?: StringNullableFilter<"inducks_person"> | string | null
    personrefs?: StringNullableFilter<"inducks_person"> | string | null
  }

  export type inducks_personOrderByWithRelationInput = {
    personcode?: SortOrder
    nationalitycountrycode?: SortOrderInput | SortOrder
    fullname?: SortOrderInput | SortOrder
    official?: SortOrderInput | SortOrder
    personcomment?: SortOrderInput | SortOrder
    unknownstudiomember?: SortOrderInput | SortOrder
    isfake?: SortOrderInput | SortOrder
    numberofindexedissues?: SortOrderInput | SortOrder
    birthname?: SortOrderInput | SortOrder
    borndate?: SortOrderInput | SortOrder
    bornplace?: SortOrderInput | SortOrder
    deceaseddate?: SortOrderInput | SortOrder
    deceasedplace?: SortOrderInput | SortOrder
    education?: SortOrderInput | SortOrder
    moviestext?: SortOrderInput | SortOrder
    comicstext?: SortOrderInput | SortOrder
    othertext?: SortOrderInput | SortOrder
    photofilename?: SortOrderInput | SortOrder
    photocomment?: SortOrderInput | SortOrder
    photosource?: SortOrderInput | SortOrder
    personrefs?: SortOrderInput | SortOrder
  }

  export type inducks_personWhereUniqueInput = Prisma.AtLeast<{
    personcode?: string
    AND?: inducks_personWhereInput | inducks_personWhereInput[]
    OR?: inducks_personWhereInput[]
    NOT?: inducks_personWhereInput | inducks_personWhereInput[]
    nationalitycountrycode?: StringNullableFilter<"inducks_person"> | string | null
    fullname?: StringNullableFilter<"inducks_person"> | string | null
    official?: Enuminducks_person_officialNullableFilter<"inducks_person"> | $Enums.inducks_person_official | null
    personcomment?: StringNullableFilter<"inducks_person"> | string | null
    unknownstudiomember?: Enuminducks_person_unknownstudiomemberNullableFilter<"inducks_person"> | $Enums.inducks_person_unknownstudiomember | null
    isfake?: Enuminducks_person_isfakeNullableFilter<"inducks_person"> | $Enums.inducks_person_isfake | null
    numberofindexedissues?: IntNullableFilter<"inducks_person"> | number | null
    birthname?: StringNullableFilter<"inducks_person"> | string | null
    borndate?: StringNullableFilter<"inducks_person"> | string | null
    bornplace?: StringNullableFilter<"inducks_person"> | string | null
    deceaseddate?: StringNullableFilter<"inducks_person"> | string | null
    deceasedplace?: StringNullableFilter<"inducks_person"> | string | null
    education?: StringNullableFilter<"inducks_person"> | string | null
    moviestext?: StringNullableFilter<"inducks_person"> | string | null
    comicstext?: StringNullableFilter<"inducks_person"> | string | null
    othertext?: StringNullableFilter<"inducks_person"> | string | null
    photofilename?: StringNullableFilter<"inducks_person"> | string | null
    photocomment?: StringNullableFilter<"inducks_person"> | string | null
    photosource?: StringNullableFilter<"inducks_person"> | string | null
    personrefs?: StringNullableFilter<"inducks_person"> | string | null
  }, "personcode">

  export type inducks_personOrderByWithAggregationInput = {
    personcode?: SortOrder
    nationalitycountrycode?: SortOrderInput | SortOrder
    fullname?: SortOrderInput | SortOrder
    official?: SortOrderInput | SortOrder
    personcomment?: SortOrderInput | SortOrder
    unknownstudiomember?: SortOrderInput | SortOrder
    isfake?: SortOrderInput | SortOrder
    numberofindexedissues?: SortOrderInput | SortOrder
    birthname?: SortOrderInput | SortOrder
    borndate?: SortOrderInput | SortOrder
    bornplace?: SortOrderInput | SortOrder
    deceaseddate?: SortOrderInput | SortOrder
    deceasedplace?: SortOrderInput | SortOrder
    education?: SortOrderInput | SortOrder
    moviestext?: SortOrderInput | SortOrder
    comicstext?: SortOrderInput | SortOrder
    othertext?: SortOrderInput | SortOrder
    photofilename?: SortOrderInput | SortOrder
    photocomment?: SortOrderInput | SortOrder
    photosource?: SortOrderInput | SortOrder
    personrefs?: SortOrderInput | SortOrder
    _count?: inducks_personCountOrderByAggregateInput
    _avg?: inducks_personAvgOrderByAggregateInput
    _max?: inducks_personMaxOrderByAggregateInput
    _min?: inducks_personMinOrderByAggregateInput
    _sum?: inducks_personSumOrderByAggregateInput
  }

  export type inducks_personScalarWhereWithAggregatesInput = {
    AND?: inducks_personScalarWhereWithAggregatesInput | inducks_personScalarWhereWithAggregatesInput[]
    OR?: inducks_personScalarWhereWithAggregatesInput[]
    NOT?: inducks_personScalarWhereWithAggregatesInput | inducks_personScalarWhereWithAggregatesInput[]
    personcode?: StringWithAggregatesFilter<"inducks_person"> | string
    nationalitycountrycode?: StringNullableWithAggregatesFilter<"inducks_person"> | string | null
    fullname?: StringNullableWithAggregatesFilter<"inducks_person"> | string | null
    official?: Enuminducks_person_officialNullableWithAggregatesFilter<"inducks_person"> | $Enums.inducks_person_official | null
    personcomment?: StringNullableWithAggregatesFilter<"inducks_person"> | string | null
    unknownstudiomember?: Enuminducks_person_unknownstudiomemberNullableWithAggregatesFilter<"inducks_person"> | $Enums.inducks_person_unknownstudiomember | null
    isfake?: Enuminducks_person_isfakeNullableWithAggregatesFilter<"inducks_person"> | $Enums.inducks_person_isfake | null
    numberofindexedissues?: IntNullableWithAggregatesFilter<"inducks_person"> | number | null
    birthname?: StringNullableWithAggregatesFilter<"inducks_person"> | string | null
    borndate?: StringNullableWithAggregatesFilter<"inducks_person"> | string | null
    bornplace?: StringNullableWithAggregatesFilter<"inducks_person"> | string | null
    deceaseddate?: StringNullableWithAggregatesFilter<"inducks_person"> | string | null
    deceasedplace?: StringNullableWithAggregatesFilter<"inducks_person"> | string | null
    education?: StringNullableWithAggregatesFilter<"inducks_person"> | string | null
    moviestext?: StringNullableWithAggregatesFilter<"inducks_person"> | string | null
    comicstext?: StringNullableWithAggregatesFilter<"inducks_person"> | string | null
    othertext?: StringNullableWithAggregatesFilter<"inducks_person"> | string | null
    photofilename?: StringNullableWithAggregatesFilter<"inducks_person"> | string | null
    photocomment?: StringNullableWithAggregatesFilter<"inducks_person"> | string | null
    photosource?: StringNullableWithAggregatesFilter<"inducks_person"> | string | null
    personrefs?: StringNullableWithAggregatesFilter<"inducks_person"> | string | null
  }

  export type inducks_personurlWhereInput = {
    AND?: inducks_personurlWhereInput | inducks_personurlWhereInput[]
    OR?: inducks_personurlWhereInput[]
    NOT?: inducks_personurlWhereInput | inducks_personurlWhereInput[]
    personcode?: StringFilter<"inducks_personurl"> | string
    sitecode?: StringFilter<"inducks_personurl"> | string
    url?: StringNullableFilter<"inducks_personurl"> | string | null
  }

  export type inducks_personurlOrderByWithRelationInput = {
    personcode?: SortOrder
    sitecode?: SortOrder
    url?: SortOrderInput | SortOrder
  }

  export type inducks_personurlWhereUniqueInput = Prisma.AtLeast<{
    personcode_sitecode?: inducks_personurlPersoncodeSitecodeCompoundUniqueInput
    AND?: inducks_personurlWhereInput | inducks_personurlWhereInput[]
    OR?: inducks_personurlWhereInput[]
    NOT?: inducks_personurlWhereInput | inducks_personurlWhereInput[]
    personcode?: StringFilter<"inducks_personurl"> | string
    sitecode?: StringFilter<"inducks_personurl"> | string
    url?: StringNullableFilter<"inducks_personurl"> | string | null
  }, "personcode_sitecode">

  export type inducks_personurlOrderByWithAggregationInput = {
    personcode?: SortOrder
    sitecode?: SortOrder
    url?: SortOrderInput | SortOrder
    _count?: inducks_personurlCountOrderByAggregateInput
    _max?: inducks_personurlMaxOrderByAggregateInput
    _min?: inducks_personurlMinOrderByAggregateInput
  }

  export type inducks_personurlScalarWhereWithAggregatesInput = {
    AND?: inducks_personurlScalarWhereWithAggregatesInput | inducks_personurlScalarWhereWithAggregatesInput[]
    OR?: inducks_personurlScalarWhereWithAggregatesInput[]
    NOT?: inducks_personurlScalarWhereWithAggregatesInput | inducks_personurlScalarWhereWithAggregatesInput[]
    personcode?: StringWithAggregatesFilter<"inducks_personurl"> | string
    sitecode?: StringWithAggregatesFilter<"inducks_personurl"> | string
    url?: StringNullableWithAggregatesFilter<"inducks_personurl"> | string | null
  }

  export type inducks_publicationWhereInput = {
    AND?: inducks_publicationWhereInput | inducks_publicationWhereInput[]
    OR?: inducks_publicationWhereInput[]
    NOT?: inducks_publicationWhereInput | inducks_publicationWhereInput[]
    publicationcode?: StringFilter<"inducks_publication"> | string
    countrycode?: StringNullableFilter<"inducks_publication"> | string | null
    languagecode?: StringNullableFilter<"inducks_publication"> | string | null
    title?: StringNullableFilter<"inducks_publication"> | string | null
    size?: StringNullableFilter<"inducks_publication"> | string | null
    publicationcomment?: StringNullableFilter<"inducks_publication"> | string | null
    circulation?: StringNullableFilter<"inducks_publication"> | string | null
    numbersarefake?: Enuminducks_publication_numbersarefakeNullableFilter<"inducks_publication"> | $Enums.inducks_publication_numbersarefake | null
    error?: Enuminducks_publication_errorNullableFilter<"inducks_publication"> | $Enums.inducks_publication_error | null
    locked?: Enuminducks_publication_lockedNullableFilter<"inducks_publication"> | $Enums.inducks_publication_locked | null
    inxforbidden?: Enuminducks_publication_inxforbiddenNullableFilter<"inducks_publication"> | $Enums.inducks_publication_inxforbidden | null
    inputfilecode?: IntNullableFilter<"inducks_publication"> | number | null
    maintenanceteamcode?: StringNullableFilter<"inducks_publication"> | string | null
  }

  export type inducks_publicationOrderByWithRelationInput = {
    publicationcode?: SortOrder
    countrycode?: SortOrderInput | SortOrder
    languagecode?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    publicationcomment?: SortOrderInput | SortOrder
    circulation?: SortOrderInput | SortOrder
    numbersarefake?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    locked?: SortOrderInput | SortOrder
    inxforbidden?: SortOrderInput | SortOrder
    inputfilecode?: SortOrderInput | SortOrder
    maintenanceteamcode?: SortOrderInput | SortOrder
  }

  export type inducks_publicationWhereUniqueInput = Prisma.AtLeast<{
    publicationcode?: string
    AND?: inducks_publicationWhereInput | inducks_publicationWhereInput[]
    OR?: inducks_publicationWhereInput[]
    NOT?: inducks_publicationWhereInput | inducks_publicationWhereInput[]
    countrycode?: StringNullableFilter<"inducks_publication"> | string | null
    languagecode?: StringNullableFilter<"inducks_publication"> | string | null
    title?: StringNullableFilter<"inducks_publication"> | string | null
    size?: StringNullableFilter<"inducks_publication"> | string | null
    publicationcomment?: StringNullableFilter<"inducks_publication"> | string | null
    circulation?: StringNullableFilter<"inducks_publication"> | string | null
    numbersarefake?: Enuminducks_publication_numbersarefakeNullableFilter<"inducks_publication"> | $Enums.inducks_publication_numbersarefake | null
    error?: Enuminducks_publication_errorNullableFilter<"inducks_publication"> | $Enums.inducks_publication_error | null
    locked?: Enuminducks_publication_lockedNullableFilter<"inducks_publication"> | $Enums.inducks_publication_locked | null
    inxforbidden?: Enuminducks_publication_inxforbiddenNullableFilter<"inducks_publication"> | $Enums.inducks_publication_inxforbidden | null
    inputfilecode?: IntNullableFilter<"inducks_publication"> | number | null
    maintenanceteamcode?: StringNullableFilter<"inducks_publication"> | string | null
  }, "publicationcode">

  export type inducks_publicationOrderByWithAggregationInput = {
    publicationcode?: SortOrder
    countrycode?: SortOrderInput | SortOrder
    languagecode?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    publicationcomment?: SortOrderInput | SortOrder
    circulation?: SortOrderInput | SortOrder
    numbersarefake?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    locked?: SortOrderInput | SortOrder
    inxforbidden?: SortOrderInput | SortOrder
    inputfilecode?: SortOrderInput | SortOrder
    maintenanceteamcode?: SortOrderInput | SortOrder
    _count?: inducks_publicationCountOrderByAggregateInput
    _avg?: inducks_publicationAvgOrderByAggregateInput
    _max?: inducks_publicationMaxOrderByAggregateInput
    _min?: inducks_publicationMinOrderByAggregateInput
    _sum?: inducks_publicationSumOrderByAggregateInput
  }

  export type inducks_publicationScalarWhereWithAggregatesInput = {
    AND?: inducks_publicationScalarWhereWithAggregatesInput | inducks_publicationScalarWhereWithAggregatesInput[]
    OR?: inducks_publicationScalarWhereWithAggregatesInput[]
    NOT?: inducks_publicationScalarWhereWithAggregatesInput | inducks_publicationScalarWhereWithAggregatesInput[]
    publicationcode?: StringWithAggregatesFilter<"inducks_publication"> | string
    countrycode?: StringNullableWithAggregatesFilter<"inducks_publication"> | string | null
    languagecode?: StringNullableWithAggregatesFilter<"inducks_publication"> | string | null
    title?: StringNullableWithAggregatesFilter<"inducks_publication"> | string | null
    size?: StringNullableWithAggregatesFilter<"inducks_publication"> | string | null
    publicationcomment?: StringNullableWithAggregatesFilter<"inducks_publication"> | string | null
    circulation?: StringNullableWithAggregatesFilter<"inducks_publication"> | string | null
    numbersarefake?: Enuminducks_publication_numbersarefakeNullableWithAggregatesFilter<"inducks_publication"> | $Enums.inducks_publication_numbersarefake | null
    error?: Enuminducks_publication_errorNullableWithAggregatesFilter<"inducks_publication"> | $Enums.inducks_publication_error | null
    locked?: Enuminducks_publication_lockedNullableWithAggregatesFilter<"inducks_publication"> | $Enums.inducks_publication_locked | null
    inxforbidden?: Enuminducks_publication_inxforbiddenNullableWithAggregatesFilter<"inducks_publication"> | $Enums.inducks_publication_inxforbidden | null
    inputfilecode?: IntNullableWithAggregatesFilter<"inducks_publication"> | number | null
    maintenanceteamcode?: StringNullableWithAggregatesFilter<"inducks_publication"> | string | null
  }

  export type inducks_publicationcategoryWhereInput = {
    AND?: inducks_publicationcategoryWhereInput | inducks_publicationcategoryWhereInput[]
    OR?: inducks_publicationcategoryWhereInput[]
    NOT?: inducks_publicationcategoryWhereInput | inducks_publicationcategoryWhereInput[]
    publicationcode?: StringFilter<"inducks_publicationcategory"> | string
    category?: StringNullableFilter<"inducks_publicationcategory"> | string | null
  }

  export type inducks_publicationcategoryOrderByWithRelationInput = {
    publicationcode?: SortOrder
    category?: SortOrderInput | SortOrder
  }

  export type inducks_publicationcategoryWhereUniqueInput = Prisma.AtLeast<{
    publicationcode?: string
    AND?: inducks_publicationcategoryWhereInput | inducks_publicationcategoryWhereInput[]
    OR?: inducks_publicationcategoryWhereInput[]
    NOT?: inducks_publicationcategoryWhereInput | inducks_publicationcategoryWhereInput[]
    category?: StringNullableFilter<"inducks_publicationcategory"> | string | null
  }, "publicationcode">

  export type inducks_publicationcategoryOrderByWithAggregationInput = {
    publicationcode?: SortOrder
    category?: SortOrderInput | SortOrder
    _count?: inducks_publicationcategoryCountOrderByAggregateInput
    _max?: inducks_publicationcategoryMaxOrderByAggregateInput
    _min?: inducks_publicationcategoryMinOrderByAggregateInput
  }

  export type inducks_publicationcategoryScalarWhereWithAggregatesInput = {
    AND?: inducks_publicationcategoryScalarWhereWithAggregatesInput | inducks_publicationcategoryScalarWhereWithAggregatesInput[]
    OR?: inducks_publicationcategoryScalarWhereWithAggregatesInput[]
    NOT?: inducks_publicationcategoryScalarWhereWithAggregatesInput | inducks_publicationcategoryScalarWhereWithAggregatesInput[]
    publicationcode?: StringWithAggregatesFilter<"inducks_publicationcategory"> | string
    category?: StringNullableWithAggregatesFilter<"inducks_publicationcategory"> | string | null
  }

  export type inducks_publicationnameWhereInput = {
    AND?: inducks_publicationnameWhereInput | inducks_publicationnameWhereInput[]
    OR?: inducks_publicationnameWhereInput[]
    NOT?: inducks_publicationnameWhereInput | inducks_publicationnameWhereInput[]
    publicationcode?: StringFilter<"inducks_publicationname"> | string
    publicationname?: StringNullableFilter<"inducks_publicationname"> | string | null
  }

  export type inducks_publicationnameOrderByWithRelationInput = {
    publicationcode?: SortOrder
    publicationname?: SortOrderInput | SortOrder
  }

  export type inducks_publicationnameWhereUniqueInput = Prisma.AtLeast<{
    publicationcode?: string
    AND?: inducks_publicationnameWhereInput | inducks_publicationnameWhereInput[]
    OR?: inducks_publicationnameWhereInput[]
    NOT?: inducks_publicationnameWhereInput | inducks_publicationnameWhereInput[]
    publicationname?: StringNullableFilter<"inducks_publicationname"> | string | null
  }, "publicationcode">

  export type inducks_publicationnameOrderByWithAggregationInput = {
    publicationcode?: SortOrder
    publicationname?: SortOrderInput | SortOrder
    _count?: inducks_publicationnameCountOrderByAggregateInput
    _max?: inducks_publicationnameMaxOrderByAggregateInput
    _min?: inducks_publicationnameMinOrderByAggregateInput
  }

  export type inducks_publicationnameScalarWhereWithAggregatesInput = {
    AND?: inducks_publicationnameScalarWhereWithAggregatesInput | inducks_publicationnameScalarWhereWithAggregatesInput[]
    OR?: inducks_publicationnameScalarWhereWithAggregatesInput[]
    NOT?: inducks_publicationnameScalarWhereWithAggregatesInput | inducks_publicationnameScalarWhereWithAggregatesInput[]
    publicationcode?: StringWithAggregatesFilter<"inducks_publicationname"> | string
    publicationname?: StringNullableWithAggregatesFilter<"inducks_publicationname"> | string | null
  }

  export type inducks_publicationurlWhereInput = {
    AND?: inducks_publicationurlWhereInput | inducks_publicationurlWhereInput[]
    OR?: inducks_publicationurlWhereInput[]
    NOT?: inducks_publicationurlWhereInput | inducks_publicationurlWhereInput[]
    publicationcode?: StringFilter<"inducks_publicationurl"> | string
    sitecode?: StringFilter<"inducks_publicationurl"> | string
    url?: StringNullableFilter<"inducks_publicationurl"> | string | null
  }

  export type inducks_publicationurlOrderByWithRelationInput = {
    publicationcode?: SortOrder
    sitecode?: SortOrder
    url?: SortOrderInput | SortOrder
  }

  export type inducks_publicationurlWhereUniqueInput = Prisma.AtLeast<{
    publicationcode_sitecode?: inducks_publicationurlPublicationcodeSitecodeCompoundUniqueInput
    AND?: inducks_publicationurlWhereInput | inducks_publicationurlWhereInput[]
    OR?: inducks_publicationurlWhereInput[]
    NOT?: inducks_publicationurlWhereInput | inducks_publicationurlWhereInput[]
    publicationcode?: StringFilter<"inducks_publicationurl"> | string
    sitecode?: StringFilter<"inducks_publicationurl"> | string
    url?: StringNullableFilter<"inducks_publicationurl"> | string | null
  }, "publicationcode_sitecode">

  export type inducks_publicationurlOrderByWithAggregationInput = {
    publicationcode?: SortOrder
    sitecode?: SortOrder
    url?: SortOrderInput | SortOrder
    _count?: inducks_publicationurlCountOrderByAggregateInput
    _max?: inducks_publicationurlMaxOrderByAggregateInput
    _min?: inducks_publicationurlMinOrderByAggregateInput
  }

  export type inducks_publicationurlScalarWhereWithAggregatesInput = {
    AND?: inducks_publicationurlScalarWhereWithAggregatesInput | inducks_publicationurlScalarWhereWithAggregatesInput[]
    OR?: inducks_publicationurlScalarWhereWithAggregatesInput[]
    NOT?: inducks_publicationurlScalarWhereWithAggregatesInput | inducks_publicationurlScalarWhereWithAggregatesInput[]
    publicationcode?: StringWithAggregatesFilter<"inducks_publicationurl"> | string
    sitecode?: StringWithAggregatesFilter<"inducks_publicationurl"> | string
    url?: StringNullableWithAggregatesFilter<"inducks_publicationurl"> | string | null
  }

  export type inducks_publisherWhereInput = {
    AND?: inducks_publisherWhereInput | inducks_publisherWhereInput[]
    OR?: inducks_publisherWhereInput[]
    NOT?: inducks_publisherWhereInput | inducks_publisherWhereInput[]
    publisherid?: StringFilter<"inducks_publisher"> | string
    publishername?: StringNullableFilter<"inducks_publisher"> | string | null
  }

  export type inducks_publisherOrderByWithRelationInput = {
    publisherid?: SortOrder
    publishername?: SortOrderInput | SortOrder
  }

  export type inducks_publisherWhereUniqueInput = Prisma.AtLeast<{
    publisherid?: string
    AND?: inducks_publisherWhereInput | inducks_publisherWhereInput[]
    OR?: inducks_publisherWhereInput[]
    NOT?: inducks_publisherWhereInput | inducks_publisherWhereInput[]
    publishername?: StringNullableFilter<"inducks_publisher"> | string | null
  }, "publisherid">

  export type inducks_publisherOrderByWithAggregationInput = {
    publisherid?: SortOrder
    publishername?: SortOrderInput | SortOrder
    _count?: inducks_publisherCountOrderByAggregateInput
    _max?: inducks_publisherMaxOrderByAggregateInput
    _min?: inducks_publisherMinOrderByAggregateInput
  }

  export type inducks_publisherScalarWhereWithAggregatesInput = {
    AND?: inducks_publisherScalarWhereWithAggregatesInput | inducks_publisherScalarWhereWithAggregatesInput[]
    OR?: inducks_publisherScalarWhereWithAggregatesInput[]
    NOT?: inducks_publisherScalarWhereWithAggregatesInput | inducks_publisherScalarWhereWithAggregatesInput[]
    publisherid?: StringWithAggregatesFilter<"inducks_publisher"> | string
    publishername?: StringNullableWithAggregatesFilter<"inducks_publisher"> | string | null
  }

  export type inducks_publishingjobWhereInput = {
    AND?: inducks_publishingjobWhereInput | inducks_publishingjobWhereInput[]
    OR?: inducks_publishingjobWhereInput[]
    NOT?: inducks_publishingjobWhereInput | inducks_publishingjobWhereInput[]
    publisherid?: StringFilter<"inducks_publishingjob"> | string
    issuecode?: StringFilter<"inducks_publishingjob"> | string
    publishingjobcomment?: StringNullableFilter<"inducks_publishingjob"> | string | null
  }

  export type inducks_publishingjobOrderByWithRelationInput = {
    publisherid?: SortOrder
    issuecode?: SortOrder
    publishingjobcomment?: SortOrderInput | SortOrder
  }

  export type inducks_publishingjobWhereUniqueInput = Prisma.AtLeast<{
    publisherid_issuecode?: inducks_publishingjobPublisheridIssuecodeCompoundUniqueInput
    AND?: inducks_publishingjobWhereInput | inducks_publishingjobWhereInput[]
    OR?: inducks_publishingjobWhereInput[]
    NOT?: inducks_publishingjobWhereInput | inducks_publishingjobWhereInput[]
    publisherid?: StringFilter<"inducks_publishingjob"> | string
    issuecode?: StringFilter<"inducks_publishingjob"> | string
    publishingjobcomment?: StringNullableFilter<"inducks_publishingjob"> | string | null
  }, "publisherid_issuecode">

  export type inducks_publishingjobOrderByWithAggregationInput = {
    publisherid?: SortOrder
    issuecode?: SortOrder
    publishingjobcomment?: SortOrderInput | SortOrder
    _count?: inducks_publishingjobCountOrderByAggregateInput
    _max?: inducks_publishingjobMaxOrderByAggregateInput
    _min?: inducks_publishingjobMinOrderByAggregateInput
  }

  export type inducks_publishingjobScalarWhereWithAggregatesInput = {
    AND?: inducks_publishingjobScalarWhereWithAggregatesInput | inducks_publishingjobScalarWhereWithAggregatesInput[]
    OR?: inducks_publishingjobScalarWhereWithAggregatesInput[]
    NOT?: inducks_publishingjobScalarWhereWithAggregatesInput | inducks_publishingjobScalarWhereWithAggregatesInput[]
    publisherid?: StringWithAggregatesFilter<"inducks_publishingjob"> | string
    issuecode?: StringWithAggregatesFilter<"inducks_publishingjob"> | string
    publishingjobcomment?: StringNullableWithAggregatesFilter<"inducks_publishingjob"> | string | null
  }

  export type inducks_referencereasonWhereInput = {
    AND?: inducks_referencereasonWhereInput | inducks_referencereasonWhereInput[]
    OR?: inducks_referencereasonWhereInput[]
    NOT?: inducks_referencereasonWhereInput | inducks_referencereasonWhereInput[]
    referencereasonid?: IntFilter<"inducks_referencereason"> | number
    referencereasontext?: StringNullableFilter<"inducks_referencereason"> | string | null
  }

  export type inducks_referencereasonOrderByWithRelationInput = {
    referencereasonid?: SortOrder
    referencereasontext?: SortOrderInput | SortOrder
  }

  export type inducks_referencereasonWhereUniqueInput = Prisma.AtLeast<{
    referencereasonid?: number
    AND?: inducks_referencereasonWhereInput | inducks_referencereasonWhereInput[]
    OR?: inducks_referencereasonWhereInput[]
    NOT?: inducks_referencereasonWhereInput | inducks_referencereasonWhereInput[]
    referencereasontext?: StringNullableFilter<"inducks_referencereason"> | string | null
  }, "referencereasonid">

  export type inducks_referencereasonOrderByWithAggregationInput = {
    referencereasonid?: SortOrder
    referencereasontext?: SortOrderInput | SortOrder
    _count?: inducks_referencereasonCountOrderByAggregateInput
    _avg?: inducks_referencereasonAvgOrderByAggregateInput
    _max?: inducks_referencereasonMaxOrderByAggregateInput
    _min?: inducks_referencereasonMinOrderByAggregateInput
    _sum?: inducks_referencereasonSumOrderByAggregateInput
  }

  export type inducks_referencereasonScalarWhereWithAggregatesInput = {
    AND?: inducks_referencereasonScalarWhereWithAggregatesInput | inducks_referencereasonScalarWhereWithAggregatesInput[]
    OR?: inducks_referencereasonScalarWhereWithAggregatesInput[]
    NOT?: inducks_referencereasonScalarWhereWithAggregatesInput | inducks_referencereasonScalarWhereWithAggregatesInput[]
    referencereasonid?: IntWithAggregatesFilter<"inducks_referencereason"> | number
    referencereasontext?: StringNullableWithAggregatesFilter<"inducks_referencereason"> | string | null
  }

  export type inducks_referencereasonnameWhereInput = {
    AND?: inducks_referencereasonnameWhereInput | inducks_referencereasonnameWhereInput[]
    OR?: inducks_referencereasonnameWhereInput[]
    NOT?: inducks_referencereasonnameWhereInput | inducks_referencereasonnameWhereInput[]
    referencereasonid?: IntFilter<"inducks_referencereasonname"> | number
    languagecode?: StringFilter<"inducks_referencereasonname"> | string
    referencereasontranslation?: StringNullableFilter<"inducks_referencereasonname"> | string | null
  }

  export type inducks_referencereasonnameOrderByWithRelationInput = {
    referencereasonid?: SortOrder
    languagecode?: SortOrder
    referencereasontranslation?: SortOrderInput | SortOrder
  }

  export type inducks_referencereasonnameWhereUniqueInput = Prisma.AtLeast<{
    referencereasonid_languagecode?: inducks_referencereasonnameReferencereasonidLanguagecodeCompoundUniqueInput
    AND?: inducks_referencereasonnameWhereInput | inducks_referencereasonnameWhereInput[]
    OR?: inducks_referencereasonnameWhereInput[]
    NOT?: inducks_referencereasonnameWhereInput | inducks_referencereasonnameWhereInput[]
    referencereasonid?: IntFilter<"inducks_referencereasonname"> | number
    languagecode?: StringFilter<"inducks_referencereasonname"> | string
    referencereasontranslation?: StringNullableFilter<"inducks_referencereasonname"> | string | null
  }, "referencereasonid_languagecode">

  export type inducks_referencereasonnameOrderByWithAggregationInput = {
    referencereasonid?: SortOrder
    languagecode?: SortOrder
    referencereasontranslation?: SortOrderInput | SortOrder
    _count?: inducks_referencereasonnameCountOrderByAggregateInput
    _avg?: inducks_referencereasonnameAvgOrderByAggregateInput
    _max?: inducks_referencereasonnameMaxOrderByAggregateInput
    _min?: inducks_referencereasonnameMinOrderByAggregateInput
    _sum?: inducks_referencereasonnameSumOrderByAggregateInput
  }

  export type inducks_referencereasonnameScalarWhereWithAggregatesInput = {
    AND?: inducks_referencereasonnameScalarWhereWithAggregatesInput | inducks_referencereasonnameScalarWhereWithAggregatesInput[]
    OR?: inducks_referencereasonnameScalarWhereWithAggregatesInput[]
    NOT?: inducks_referencereasonnameScalarWhereWithAggregatesInput | inducks_referencereasonnameScalarWhereWithAggregatesInput[]
    referencereasonid?: IntWithAggregatesFilter<"inducks_referencereasonname"> | number
    languagecode?: StringWithAggregatesFilter<"inducks_referencereasonname"> | string
    referencereasontranslation?: StringNullableWithAggregatesFilter<"inducks_referencereasonname"> | string | null
  }

  export type inducks_siteWhereInput = {
    AND?: inducks_siteWhereInput | inducks_siteWhereInput[]
    OR?: inducks_siteWhereInput[]
    NOT?: inducks_siteWhereInput | inducks_siteWhereInput[]
    sitecode?: StringFilter<"inducks_site"> | string
    urlbase?: StringNullableFilter<"inducks_site"> | string | null
    images?: Enuminducks_site_imagesNullableFilter<"inducks_site"> | $Enums.inducks_site_images | null
    sitename?: StringNullableFilter<"inducks_site"> | string | null
    sitelogo?: StringNullableFilter<"inducks_site"> | string | null
    properties?: StringNullableFilter<"inducks_site"> | string | null
  }

  export type inducks_siteOrderByWithRelationInput = {
    sitecode?: SortOrder
    urlbase?: SortOrderInput | SortOrder
    images?: SortOrderInput | SortOrder
    sitename?: SortOrderInput | SortOrder
    sitelogo?: SortOrderInput | SortOrder
    properties?: SortOrderInput | SortOrder
  }

  export type inducks_siteWhereUniqueInput = Prisma.AtLeast<{
    sitecode?: string
    AND?: inducks_siteWhereInput | inducks_siteWhereInput[]
    OR?: inducks_siteWhereInput[]
    NOT?: inducks_siteWhereInput | inducks_siteWhereInput[]
    urlbase?: StringNullableFilter<"inducks_site"> | string | null
    images?: Enuminducks_site_imagesNullableFilter<"inducks_site"> | $Enums.inducks_site_images | null
    sitename?: StringNullableFilter<"inducks_site"> | string | null
    sitelogo?: StringNullableFilter<"inducks_site"> | string | null
    properties?: StringNullableFilter<"inducks_site"> | string | null
  }, "sitecode">

  export type inducks_siteOrderByWithAggregationInput = {
    sitecode?: SortOrder
    urlbase?: SortOrderInput | SortOrder
    images?: SortOrderInput | SortOrder
    sitename?: SortOrderInput | SortOrder
    sitelogo?: SortOrderInput | SortOrder
    properties?: SortOrderInput | SortOrder
    _count?: inducks_siteCountOrderByAggregateInput
    _max?: inducks_siteMaxOrderByAggregateInput
    _min?: inducks_siteMinOrderByAggregateInput
  }

  export type inducks_siteScalarWhereWithAggregatesInput = {
    AND?: inducks_siteScalarWhereWithAggregatesInput | inducks_siteScalarWhereWithAggregatesInput[]
    OR?: inducks_siteScalarWhereWithAggregatesInput[]
    NOT?: inducks_siteScalarWhereWithAggregatesInput | inducks_siteScalarWhereWithAggregatesInput[]
    sitecode?: StringWithAggregatesFilter<"inducks_site"> | string
    urlbase?: StringNullableWithAggregatesFilter<"inducks_site"> | string | null
    images?: Enuminducks_site_imagesNullableWithAggregatesFilter<"inducks_site"> | $Enums.inducks_site_images | null
    sitename?: StringNullableWithAggregatesFilter<"inducks_site"> | string | null
    sitelogo?: StringNullableWithAggregatesFilter<"inducks_site"> | string | null
    properties?: StringNullableWithAggregatesFilter<"inducks_site"> | string | null
  }

  export type inducks_statcharactercharacterWhereInput = {
    AND?: inducks_statcharactercharacterWhereInput | inducks_statcharactercharacterWhereInput[]
    OR?: inducks_statcharactercharacterWhereInput[]
    NOT?: inducks_statcharactercharacterWhereInput | inducks_statcharactercharacterWhereInput[]
    charactercode?: StringFilter<"inducks_statcharactercharacter"> | string
    cocharactercode?: StringNullableFilter<"inducks_statcharactercharacter"> | string | null
    total?: IntFilter<"inducks_statcharactercharacter"> | number
    yearrange?: StringNullableFilter<"inducks_statcharactercharacter"> | string | null
  }

  export type inducks_statcharactercharacterOrderByWithRelationInput = {
    charactercode?: SortOrder
    cocharactercode?: SortOrderInput | SortOrder
    total?: SortOrder
    yearrange?: SortOrderInput | SortOrder
  }

  export type inducks_statcharactercharacterWhereUniqueInput = Prisma.AtLeast<{
    charactercode_total?: inducks_statcharactercharacterCharactercodeTotalCompoundUniqueInput
    AND?: inducks_statcharactercharacterWhereInput | inducks_statcharactercharacterWhereInput[]
    OR?: inducks_statcharactercharacterWhereInput[]
    NOT?: inducks_statcharactercharacterWhereInput | inducks_statcharactercharacterWhereInput[]
    charactercode?: StringFilter<"inducks_statcharactercharacter"> | string
    cocharactercode?: StringNullableFilter<"inducks_statcharactercharacter"> | string | null
    total?: IntFilter<"inducks_statcharactercharacter"> | number
    yearrange?: StringNullableFilter<"inducks_statcharactercharacter"> | string | null
  }, "charactercode_total">

  export type inducks_statcharactercharacterOrderByWithAggregationInput = {
    charactercode?: SortOrder
    cocharactercode?: SortOrderInput | SortOrder
    total?: SortOrder
    yearrange?: SortOrderInput | SortOrder
    _count?: inducks_statcharactercharacterCountOrderByAggregateInput
    _avg?: inducks_statcharactercharacterAvgOrderByAggregateInput
    _max?: inducks_statcharactercharacterMaxOrderByAggregateInput
    _min?: inducks_statcharactercharacterMinOrderByAggregateInput
    _sum?: inducks_statcharactercharacterSumOrderByAggregateInput
  }

  export type inducks_statcharactercharacterScalarWhereWithAggregatesInput = {
    AND?: inducks_statcharactercharacterScalarWhereWithAggregatesInput | inducks_statcharactercharacterScalarWhereWithAggregatesInput[]
    OR?: inducks_statcharactercharacterScalarWhereWithAggregatesInput[]
    NOT?: inducks_statcharactercharacterScalarWhereWithAggregatesInput | inducks_statcharactercharacterScalarWhereWithAggregatesInput[]
    charactercode?: StringWithAggregatesFilter<"inducks_statcharactercharacter"> | string
    cocharactercode?: StringNullableWithAggregatesFilter<"inducks_statcharactercharacter"> | string | null
    total?: IntWithAggregatesFilter<"inducks_statcharactercharacter"> | number
    yearrange?: StringNullableWithAggregatesFilter<"inducks_statcharactercharacter"> | string | null
  }

  export type inducks_statcharactercountryWhereInput = {
    AND?: inducks_statcharactercountryWhereInput | inducks_statcharactercountryWhereInput[]
    OR?: inducks_statcharactercountryWhereInput[]
    NOT?: inducks_statcharactercountryWhereInput | inducks_statcharactercountryWhereInput[]
    charactercode?: StringFilter<"inducks_statcharactercountry"> | string
    countrycode?: StringFilter<"inducks_statcharactercountry"> | string
    total?: IntNullableFilter<"inducks_statcharactercountry"> | number | null
  }

  export type inducks_statcharactercountryOrderByWithRelationInput = {
    charactercode?: SortOrder
    countrycode?: SortOrder
    total?: SortOrderInput | SortOrder
  }

  export type inducks_statcharactercountryWhereUniqueInput = Prisma.AtLeast<{
    charactercode_countrycode?: inducks_statcharactercountryCharactercodeCountrycodeCompoundUniqueInput
    AND?: inducks_statcharactercountryWhereInput | inducks_statcharactercountryWhereInput[]
    OR?: inducks_statcharactercountryWhereInput[]
    NOT?: inducks_statcharactercountryWhereInput | inducks_statcharactercountryWhereInput[]
    charactercode?: StringFilter<"inducks_statcharactercountry"> | string
    countrycode?: StringFilter<"inducks_statcharactercountry"> | string
    total?: IntNullableFilter<"inducks_statcharactercountry"> | number | null
  }, "charactercode_countrycode">

  export type inducks_statcharactercountryOrderByWithAggregationInput = {
    charactercode?: SortOrder
    countrycode?: SortOrder
    total?: SortOrderInput | SortOrder
    _count?: inducks_statcharactercountryCountOrderByAggregateInput
    _avg?: inducks_statcharactercountryAvgOrderByAggregateInput
    _max?: inducks_statcharactercountryMaxOrderByAggregateInput
    _min?: inducks_statcharactercountryMinOrderByAggregateInput
    _sum?: inducks_statcharactercountrySumOrderByAggregateInput
  }

  export type inducks_statcharactercountryScalarWhereWithAggregatesInput = {
    AND?: inducks_statcharactercountryScalarWhereWithAggregatesInput | inducks_statcharactercountryScalarWhereWithAggregatesInput[]
    OR?: inducks_statcharactercountryScalarWhereWithAggregatesInput[]
    NOT?: inducks_statcharactercountryScalarWhereWithAggregatesInput | inducks_statcharactercountryScalarWhereWithAggregatesInput[]
    charactercode?: StringWithAggregatesFilter<"inducks_statcharactercountry"> | string
    countrycode?: StringWithAggregatesFilter<"inducks_statcharactercountry"> | string
    total?: IntNullableWithAggregatesFilter<"inducks_statcharactercountry"> | number | null
  }

  export type inducks_statcharacterstoryWhereInput = {
    AND?: inducks_statcharacterstoryWhereInput | inducks_statcharacterstoryWhereInput[]
    OR?: inducks_statcharacterstoryWhereInput[]
    NOT?: inducks_statcharacterstoryWhereInput | inducks_statcharacterstoryWhereInput[]
    charactercode?: StringFilter<"inducks_statcharacterstory"> | string
    storyheadercode?: StringFilter<"inducks_statcharacterstory"> | string
    total?: IntNullableFilter<"inducks_statcharacterstory"> | number | null
    yearrange?: StringNullableFilter<"inducks_statcharacterstory"> | string | null
  }

  export type inducks_statcharacterstoryOrderByWithRelationInput = {
    charactercode?: SortOrder
    storyheadercode?: SortOrder
    total?: SortOrderInput | SortOrder
    yearrange?: SortOrderInput | SortOrder
  }

  export type inducks_statcharacterstoryWhereUniqueInput = Prisma.AtLeast<{
    charactercode_storyheadercode?: inducks_statcharacterstoryCharactercodeStoryheadercodeCompoundUniqueInput
    AND?: inducks_statcharacterstoryWhereInput | inducks_statcharacterstoryWhereInput[]
    OR?: inducks_statcharacterstoryWhereInput[]
    NOT?: inducks_statcharacterstoryWhereInput | inducks_statcharacterstoryWhereInput[]
    charactercode?: StringFilter<"inducks_statcharacterstory"> | string
    storyheadercode?: StringFilter<"inducks_statcharacterstory"> | string
    total?: IntNullableFilter<"inducks_statcharacterstory"> | number | null
    yearrange?: StringNullableFilter<"inducks_statcharacterstory"> | string | null
  }, "charactercode_storyheadercode">

  export type inducks_statcharacterstoryOrderByWithAggregationInput = {
    charactercode?: SortOrder
    storyheadercode?: SortOrder
    total?: SortOrderInput | SortOrder
    yearrange?: SortOrderInput | SortOrder
    _count?: inducks_statcharacterstoryCountOrderByAggregateInput
    _avg?: inducks_statcharacterstoryAvgOrderByAggregateInput
    _max?: inducks_statcharacterstoryMaxOrderByAggregateInput
    _min?: inducks_statcharacterstoryMinOrderByAggregateInput
    _sum?: inducks_statcharacterstorySumOrderByAggregateInput
  }

  export type inducks_statcharacterstoryScalarWhereWithAggregatesInput = {
    AND?: inducks_statcharacterstoryScalarWhereWithAggregatesInput | inducks_statcharacterstoryScalarWhereWithAggregatesInput[]
    OR?: inducks_statcharacterstoryScalarWhereWithAggregatesInput[]
    NOT?: inducks_statcharacterstoryScalarWhereWithAggregatesInput | inducks_statcharacterstoryScalarWhereWithAggregatesInput[]
    charactercode?: StringWithAggregatesFilter<"inducks_statcharacterstory"> | string
    storyheadercode?: StringWithAggregatesFilter<"inducks_statcharacterstory"> | string
    total?: IntNullableWithAggregatesFilter<"inducks_statcharacterstory"> | number | null
    yearrange?: StringNullableWithAggregatesFilter<"inducks_statcharacterstory"> | string | null
  }

  export type inducks_statpersoncharacterWhereInput = {
    AND?: inducks_statpersoncharacterWhereInput | inducks_statpersoncharacterWhereInput[]
    OR?: inducks_statpersoncharacterWhereInput[]
    NOT?: inducks_statpersoncharacterWhereInput | inducks_statpersoncharacterWhereInput[]
    personcode?: StringFilter<"inducks_statpersoncharacter"> | string
    charactercode?: StringNullableFilter<"inducks_statpersoncharacter"> | string | null
    total?: IntFilter<"inducks_statpersoncharacter"> | number
    yearrange?: StringNullableFilter<"inducks_statpersoncharacter"> | string | null
  }

  export type inducks_statpersoncharacterOrderByWithRelationInput = {
    personcode?: SortOrder
    charactercode?: SortOrderInput | SortOrder
    total?: SortOrder
    yearrange?: SortOrderInput | SortOrder
  }

  export type inducks_statpersoncharacterWhereUniqueInput = Prisma.AtLeast<{
    personcode_total?: inducks_statpersoncharacterPersoncodeTotalCompoundUniqueInput
    AND?: inducks_statpersoncharacterWhereInput | inducks_statpersoncharacterWhereInput[]
    OR?: inducks_statpersoncharacterWhereInput[]
    NOT?: inducks_statpersoncharacterWhereInput | inducks_statpersoncharacterWhereInput[]
    personcode?: StringFilter<"inducks_statpersoncharacter"> | string
    charactercode?: StringNullableFilter<"inducks_statpersoncharacter"> | string | null
    total?: IntFilter<"inducks_statpersoncharacter"> | number
    yearrange?: StringNullableFilter<"inducks_statpersoncharacter"> | string | null
  }, "personcode_total">

  export type inducks_statpersoncharacterOrderByWithAggregationInput = {
    personcode?: SortOrder
    charactercode?: SortOrderInput | SortOrder
    total?: SortOrder
    yearrange?: SortOrderInput | SortOrder
    _count?: inducks_statpersoncharacterCountOrderByAggregateInput
    _avg?: inducks_statpersoncharacterAvgOrderByAggregateInput
    _max?: inducks_statpersoncharacterMaxOrderByAggregateInput
    _min?: inducks_statpersoncharacterMinOrderByAggregateInput
    _sum?: inducks_statpersoncharacterSumOrderByAggregateInput
  }

  export type inducks_statpersoncharacterScalarWhereWithAggregatesInput = {
    AND?: inducks_statpersoncharacterScalarWhereWithAggregatesInput | inducks_statpersoncharacterScalarWhereWithAggregatesInput[]
    OR?: inducks_statpersoncharacterScalarWhereWithAggregatesInput[]
    NOT?: inducks_statpersoncharacterScalarWhereWithAggregatesInput | inducks_statpersoncharacterScalarWhereWithAggregatesInput[]
    personcode?: StringWithAggregatesFilter<"inducks_statpersoncharacter"> | string
    charactercode?: StringNullableWithAggregatesFilter<"inducks_statpersoncharacter"> | string | null
    total?: IntWithAggregatesFilter<"inducks_statpersoncharacter"> | number
    yearrange?: StringNullableWithAggregatesFilter<"inducks_statpersoncharacter"> | string | null
  }

  export type inducks_statpersoncountryWhereInput = {
    AND?: inducks_statpersoncountryWhereInput | inducks_statpersoncountryWhereInput[]
    OR?: inducks_statpersoncountryWhereInput[]
    NOT?: inducks_statpersoncountryWhereInput | inducks_statpersoncountryWhereInput[]
    personcode?: StringFilter<"inducks_statpersoncountry"> | string
    countrycode?: StringFilter<"inducks_statpersoncountry"> | string
    total?: IntNullableFilter<"inducks_statpersoncountry"> | number | null
  }

  export type inducks_statpersoncountryOrderByWithRelationInput = {
    personcode?: SortOrder
    countrycode?: SortOrder
    total?: SortOrderInput | SortOrder
  }

  export type inducks_statpersoncountryWhereUniqueInput = Prisma.AtLeast<{
    personcode_countrycode?: inducks_statpersoncountryPersoncodeCountrycodeCompoundUniqueInput
    AND?: inducks_statpersoncountryWhereInput | inducks_statpersoncountryWhereInput[]
    OR?: inducks_statpersoncountryWhereInput[]
    NOT?: inducks_statpersoncountryWhereInput | inducks_statpersoncountryWhereInput[]
    personcode?: StringFilter<"inducks_statpersoncountry"> | string
    countrycode?: StringFilter<"inducks_statpersoncountry"> | string
    total?: IntNullableFilter<"inducks_statpersoncountry"> | number | null
  }, "personcode_countrycode">

  export type inducks_statpersoncountryOrderByWithAggregationInput = {
    personcode?: SortOrder
    countrycode?: SortOrder
    total?: SortOrderInput | SortOrder
    _count?: inducks_statpersoncountryCountOrderByAggregateInput
    _avg?: inducks_statpersoncountryAvgOrderByAggregateInput
    _max?: inducks_statpersoncountryMaxOrderByAggregateInput
    _min?: inducks_statpersoncountryMinOrderByAggregateInput
    _sum?: inducks_statpersoncountrySumOrderByAggregateInput
  }

  export type inducks_statpersoncountryScalarWhereWithAggregatesInput = {
    AND?: inducks_statpersoncountryScalarWhereWithAggregatesInput | inducks_statpersoncountryScalarWhereWithAggregatesInput[]
    OR?: inducks_statpersoncountryScalarWhereWithAggregatesInput[]
    NOT?: inducks_statpersoncountryScalarWhereWithAggregatesInput | inducks_statpersoncountryScalarWhereWithAggregatesInput[]
    personcode?: StringWithAggregatesFilter<"inducks_statpersoncountry"> | string
    countrycode?: StringWithAggregatesFilter<"inducks_statpersoncountry"> | string
    total?: IntNullableWithAggregatesFilter<"inducks_statpersoncountry"> | number | null
  }

  export type inducks_statpersonpersonWhereInput = {
    AND?: inducks_statpersonpersonWhereInput | inducks_statpersonpersonWhereInput[]
    OR?: inducks_statpersonpersonWhereInput[]
    NOT?: inducks_statpersonpersonWhereInput | inducks_statpersonpersonWhereInput[]
    personcode?: StringFilter<"inducks_statpersonperson"> | string
    copersoncode?: StringNullableFilter<"inducks_statpersonperson"> | string | null
    total?: IntFilter<"inducks_statpersonperson"> | number
    yearrange?: StringNullableFilter<"inducks_statpersonperson"> | string | null
  }

  export type inducks_statpersonpersonOrderByWithRelationInput = {
    personcode?: SortOrder
    copersoncode?: SortOrderInput | SortOrder
    total?: SortOrder
    yearrange?: SortOrderInput | SortOrder
  }

  export type inducks_statpersonpersonWhereUniqueInput = Prisma.AtLeast<{
    personcode_total?: inducks_statpersonpersonPersoncodeTotalCompoundUniqueInput
    AND?: inducks_statpersonpersonWhereInput | inducks_statpersonpersonWhereInput[]
    OR?: inducks_statpersonpersonWhereInput[]
    NOT?: inducks_statpersonpersonWhereInput | inducks_statpersonpersonWhereInput[]
    personcode?: StringFilter<"inducks_statpersonperson"> | string
    copersoncode?: StringNullableFilter<"inducks_statpersonperson"> | string | null
    total?: IntFilter<"inducks_statpersonperson"> | number
    yearrange?: StringNullableFilter<"inducks_statpersonperson"> | string | null
  }, "personcode_total">

  export type inducks_statpersonpersonOrderByWithAggregationInput = {
    personcode?: SortOrder
    copersoncode?: SortOrderInput | SortOrder
    total?: SortOrder
    yearrange?: SortOrderInput | SortOrder
    _count?: inducks_statpersonpersonCountOrderByAggregateInput
    _avg?: inducks_statpersonpersonAvgOrderByAggregateInput
    _max?: inducks_statpersonpersonMaxOrderByAggregateInput
    _min?: inducks_statpersonpersonMinOrderByAggregateInput
    _sum?: inducks_statpersonpersonSumOrderByAggregateInput
  }

  export type inducks_statpersonpersonScalarWhereWithAggregatesInput = {
    AND?: inducks_statpersonpersonScalarWhereWithAggregatesInput | inducks_statpersonpersonScalarWhereWithAggregatesInput[]
    OR?: inducks_statpersonpersonScalarWhereWithAggregatesInput[]
    NOT?: inducks_statpersonpersonScalarWhereWithAggregatesInput | inducks_statpersonpersonScalarWhereWithAggregatesInput[]
    personcode?: StringWithAggregatesFilter<"inducks_statpersonperson"> | string
    copersoncode?: StringNullableWithAggregatesFilter<"inducks_statpersonperson"> | string | null
    total?: IntWithAggregatesFilter<"inducks_statpersonperson"> | number
    yearrange?: StringNullableWithAggregatesFilter<"inducks_statpersonperson"> | string | null
  }

  export type inducks_statpersonstoryWhereInput = {
    AND?: inducks_statpersonstoryWhereInput | inducks_statpersonstoryWhereInput[]
    OR?: inducks_statpersonstoryWhereInput[]
    NOT?: inducks_statpersonstoryWhereInput | inducks_statpersonstoryWhereInput[]
    personcode?: StringFilter<"inducks_statpersonstory"> | string
    storyheadercode?: StringFilter<"inducks_statpersonstory"> | string
    total?: IntNullableFilter<"inducks_statpersonstory"> | number | null
    yearrange?: StringNullableFilter<"inducks_statpersonstory"> | string | null
  }

  export type inducks_statpersonstoryOrderByWithRelationInput = {
    personcode?: SortOrder
    storyheadercode?: SortOrder
    total?: SortOrderInput | SortOrder
    yearrange?: SortOrderInput | SortOrder
  }

  export type inducks_statpersonstoryWhereUniqueInput = Prisma.AtLeast<{
    personcode_storyheadercode?: inducks_statpersonstoryPersoncodeStoryheadercodeCompoundUniqueInput
    AND?: inducks_statpersonstoryWhereInput | inducks_statpersonstoryWhereInput[]
    OR?: inducks_statpersonstoryWhereInput[]
    NOT?: inducks_statpersonstoryWhereInput | inducks_statpersonstoryWhereInput[]
    personcode?: StringFilter<"inducks_statpersonstory"> | string
    storyheadercode?: StringFilter<"inducks_statpersonstory"> | string
    total?: IntNullableFilter<"inducks_statpersonstory"> | number | null
    yearrange?: StringNullableFilter<"inducks_statpersonstory"> | string | null
  }, "personcode_storyheadercode">

  export type inducks_statpersonstoryOrderByWithAggregationInput = {
    personcode?: SortOrder
    storyheadercode?: SortOrder
    total?: SortOrderInput | SortOrder
    yearrange?: SortOrderInput | SortOrder
    _count?: inducks_statpersonstoryCountOrderByAggregateInput
    _avg?: inducks_statpersonstoryAvgOrderByAggregateInput
    _max?: inducks_statpersonstoryMaxOrderByAggregateInput
    _min?: inducks_statpersonstoryMinOrderByAggregateInput
    _sum?: inducks_statpersonstorySumOrderByAggregateInput
  }

  export type inducks_statpersonstoryScalarWhereWithAggregatesInput = {
    AND?: inducks_statpersonstoryScalarWhereWithAggregatesInput | inducks_statpersonstoryScalarWhereWithAggregatesInput[]
    OR?: inducks_statpersonstoryScalarWhereWithAggregatesInput[]
    NOT?: inducks_statpersonstoryScalarWhereWithAggregatesInput | inducks_statpersonstoryScalarWhereWithAggregatesInput[]
    personcode?: StringWithAggregatesFilter<"inducks_statpersonstory"> | string
    storyheadercode?: StringWithAggregatesFilter<"inducks_statpersonstory"> | string
    total?: IntNullableWithAggregatesFilter<"inducks_statpersonstory"> | number | null
    yearrange?: StringNullableWithAggregatesFilter<"inducks_statpersonstory"> | string | null
  }

  export type inducks_storyWhereInput = {
    AND?: inducks_storyWhereInput | inducks_storyWhereInput[]
    OR?: inducks_storyWhereInput[]
    NOT?: inducks_storyWhereInput | inducks_storyWhereInput[]
    storycode?: StringFilter<"inducks_story"> | string
    originalstoryversioncode?: StringNullableFilter<"inducks_story"> | string | null
    creationdate?: StringNullableFilter<"inducks_story"> | string | null
    firstpublicationdate?: StringNullableFilter<"inducks_story"> | string | null
    endpublicationdate?: StringNullableFilter<"inducks_story"> | string | null
    title?: StringNullableFilter<"inducks_story"> | string | null
    usedifferentcode?: StringNullableFilter<"inducks_story"> | string | null
    storycomment?: StringNullableFilter<"inducks_story"> | string | null
    error?: Enuminducks_story_errorNullableFilter<"inducks_story"> | $Enums.inducks_story_error | null
    repcountrysummary?: StringNullableFilter<"inducks_story"> | string | null
    storyparts?: IntNullableFilter<"inducks_story"> | number | null
    locked?: Enuminducks_story_lockedNullableFilter<"inducks_story"> | $Enums.inducks_story_locked | null
    inputfilecode?: IntNullableFilter<"inducks_story"> | number | null
    issuecodeofstoryitem?: StringNullableFilter<"inducks_story"> | string | null
    maintenanceteamcode?: StringNullableFilter<"inducks_story"> | string | null
    storyheadercode?: StringNullableFilter<"inducks_story"> | string | null
  }

  export type inducks_storyOrderByWithRelationInput = {
    storycode?: SortOrder
    originalstoryversioncode?: SortOrderInput | SortOrder
    creationdate?: SortOrderInput | SortOrder
    firstpublicationdate?: SortOrderInput | SortOrder
    endpublicationdate?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    usedifferentcode?: SortOrderInput | SortOrder
    storycomment?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    repcountrysummary?: SortOrderInput | SortOrder
    storyparts?: SortOrderInput | SortOrder
    locked?: SortOrderInput | SortOrder
    inputfilecode?: SortOrderInput | SortOrder
    issuecodeofstoryitem?: SortOrderInput | SortOrder
    maintenanceteamcode?: SortOrderInput | SortOrder
    storyheadercode?: SortOrderInput | SortOrder
  }

  export type inducks_storyWhereUniqueInput = Prisma.AtLeast<{
    storycode?: string
    AND?: inducks_storyWhereInput | inducks_storyWhereInput[]
    OR?: inducks_storyWhereInput[]
    NOT?: inducks_storyWhereInput | inducks_storyWhereInput[]
    originalstoryversioncode?: StringNullableFilter<"inducks_story"> | string | null
    creationdate?: StringNullableFilter<"inducks_story"> | string | null
    firstpublicationdate?: StringNullableFilter<"inducks_story"> | string | null
    endpublicationdate?: StringNullableFilter<"inducks_story"> | string | null
    title?: StringNullableFilter<"inducks_story"> | string | null
    usedifferentcode?: StringNullableFilter<"inducks_story"> | string | null
    storycomment?: StringNullableFilter<"inducks_story"> | string | null
    error?: Enuminducks_story_errorNullableFilter<"inducks_story"> | $Enums.inducks_story_error | null
    repcountrysummary?: StringNullableFilter<"inducks_story"> | string | null
    storyparts?: IntNullableFilter<"inducks_story"> | number | null
    locked?: Enuminducks_story_lockedNullableFilter<"inducks_story"> | $Enums.inducks_story_locked | null
    inputfilecode?: IntNullableFilter<"inducks_story"> | number | null
    issuecodeofstoryitem?: StringNullableFilter<"inducks_story"> | string | null
    maintenanceteamcode?: StringNullableFilter<"inducks_story"> | string | null
    storyheadercode?: StringNullableFilter<"inducks_story"> | string | null
  }, "storycode">

  export type inducks_storyOrderByWithAggregationInput = {
    storycode?: SortOrder
    originalstoryversioncode?: SortOrderInput | SortOrder
    creationdate?: SortOrderInput | SortOrder
    firstpublicationdate?: SortOrderInput | SortOrder
    endpublicationdate?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    usedifferentcode?: SortOrderInput | SortOrder
    storycomment?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    repcountrysummary?: SortOrderInput | SortOrder
    storyparts?: SortOrderInput | SortOrder
    locked?: SortOrderInput | SortOrder
    inputfilecode?: SortOrderInput | SortOrder
    issuecodeofstoryitem?: SortOrderInput | SortOrder
    maintenanceteamcode?: SortOrderInput | SortOrder
    storyheadercode?: SortOrderInput | SortOrder
    _count?: inducks_storyCountOrderByAggregateInput
    _avg?: inducks_storyAvgOrderByAggregateInput
    _max?: inducks_storyMaxOrderByAggregateInput
    _min?: inducks_storyMinOrderByAggregateInput
    _sum?: inducks_storySumOrderByAggregateInput
  }

  export type inducks_storyScalarWhereWithAggregatesInput = {
    AND?: inducks_storyScalarWhereWithAggregatesInput | inducks_storyScalarWhereWithAggregatesInput[]
    OR?: inducks_storyScalarWhereWithAggregatesInput[]
    NOT?: inducks_storyScalarWhereWithAggregatesInput | inducks_storyScalarWhereWithAggregatesInput[]
    storycode?: StringWithAggregatesFilter<"inducks_story"> | string
    originalstoryversioncode?: StringNullableWithAggregatesFilter<"inducks_story"> | string | null
    creationdate?: StringNullableWithAggregatesFilter<"inducks_story"> | string | null
    firstpublicationdate?: StringNullableWithAggregatesFilter<"inducks_story"> | string | null
    endpublicationdate?: StringNullableWithAggregatesFilter<"inducks_story"> | string | null
    title?: StringNullableWithAggregatesFilter<"inducks_story"> | string | null
    usedifferentcode?: StringNullableWithAggregatesFilter<"inducks_story"> | string | null
    storycomment?: StringNullableWithAggregatesFilter<"inducks_story"> | string | null
    error?: Enuminducks_story_errorNullableWithAggregatesFilter<"inducks_story"> | $Enums.inducks_story_error | null
    repcountrysummary?: StringNullableWithAggregatesFilter<"inducks_story"> | string | null
    storyparts?: IntNullableWithAggregatesFilter<"inducks_story"> | number | null
    locked?: Enuminducks_story_lockedNullableWithAggregatesFilter<"inducks_story"> | $Enums.inducks_story_locked | null
    inputfilecode?: IntNullableWithAggregatesFilter<"inducks_story"> | number | null
    issuecodeofstoryitem?: StringNullableWithAggregatesFilter<"inducks_story"> | string | null
    maintenanceteamcode?: StringNullableWithAggregatesFilter<"inducks_story"> | string | null
    storyheadercode?: StringNullableWithAggregatesFilter<"inducks_story"> | string | null
  }

  export type inducks_storycodesWhereInput = {
    AND?: inducks_storycodesWhereInput | inducks_storycodesWhereInput[]
    OR?: inducks_storycodesWhereInput[]
    NOT?: inducks_storycodesWhereInput | inducks_storycodesWhereInput[]
    storycode?: StringFilter<"inducks_storycodes"> | string
    alternativecode?: StringFilter<"inducks_storycodes"> | string
    unpackedcode?: StringNullableFilter<"inducks_storycodes"> | string | null
    codecomment?: StringNullableFilter<"inducks_storycodes"> | string | null
  }

  export type inducks_storycodesOrderByWithRelationInput = {
    storycode?: SortOrder
    alternativecode?: SortOrder
    unpackedcode?: SortOrderInput | SortOrder
    codecomment?: SortOrderInput | SortOrder
  }

  export type inducks_storycodesWhereUniqueInput = Prisma.AtLeast<{
    storycode_alternativecode?: inducks_storycodesStorycodeAlternativecodeCompoundUniqueInput
    AND?: inducks_storycodesWhereInput | inducks_storycodesWhereInput[]
    OR?: inducks_storycodesWhereInput[]
    NOT?: inducks_storycodesWhereInput | inducks_storycodesWhereInput[]
    storycode?: StringFilter<"inducks_storycodes"> | string
    alternativecode?: StringFilter<"inducks_storycodes"> | string
    unpackedcode?: StringNullableFilter<"inducks_storycodes"> | string | null
    codecomment?: StringNullableFilter<"inducks_storycodes"> | string | null
  }, "storycode_alternativecode">

  export type inducks_storycodesOrderByWithAggregationInput = {
    storycode?: SortOrder
    alternativecode?: SortOrder
    unpackedcode?: SortOrderInput | SortOrder
    codecomment?: SortOrderInput | SortOrder
    _count?: inducks_storycodesCountOrderByAggregateInput
    _max?: inducks_storycodesMaxOrderByAggregateInput
    _min?: inducks_storycodesMinOrderByAggregateInput
  }

  export type inducks_storycodesScalarWhereWithAggregatesInput = {
    AND?: inducks_storycodesScalarWhereWithAggregatesInput | inducks_storycodesScalarWhereWithAggregatesInput[]
    OR?: inducks_storycodesScalarWhereWithAggregatesInput[]
    NOT?: inducks_storycodesScalarWhereWithAggregatesInput | inducks_storycodesScalarWhereWithAggregatesInput[]
    storycode?: StringWithAggregatesFilter<"inducks_storycodes"> | string
    alternativecode?: StringWithAggregatesFilter<"inducks_storycodes"> | string
    unpackedcode?: StringNullableWithAggregatesFilter<"inducks_storycodes"> | string | null
    codecomment?: StringNullableWithAggregatesFilter<"inducks_storycodes"> | string | null
  }

  export type inducks_storydescriptionWhereInput = {
    AND?: inducks_storydescriptionWhereInput | inducks_storydescriptionWhereInput[]
    OR?: inducks_storydescriptionWhereInput[]
    NOT?: inducks_storydescriptionWhereInput | inducks_storydescriptionWhereInput[]
    storyversioncode?: StringFilter<"inducks_storydescription"> | string
    languagecode?: StringFilter<"inducks_storydescription"> | string
    desctext?: StringNullableFilter<"inducks_storydescription"> | string | null
  }

  export type inducks_storydescriptionOrderByWithRelationInput = {
    storyversioncode?: SortOrder
    languagecode?: SortOrder
    desctext?: SortOrderInput | SortOrder
  }

  export type inducks_storydescriptionWhereUniqueInput = Prisma.AtLeast<{
    storyversioncode_languagecode?: inducks_storydescriptionStoryversioncodeLanguagecodeCompoundUniqueInput
    AND?: inducks_storydescriptionWhereInput | inducks_storydescriptionWhereInput[]
    OR?: inducks_storydescriptionWhereInput[]
    NOT?: inducks_storydescriptionWhereInput | inducks_storydescriptionWhereInput[]
    storyversioncode?: StringFilter<"inducks_storydescription"> | string
    languagecode?: StringFilter<"inducks_storydescription"> | string
    desctext?: StringNullableFilter<"inducks_storydescription"> | string | null
  }, "storyversioncode_languagecode">

  export type inducks_storydescriptionOrderByWithAggregationInput = {
    storyversioncode?: SortOrder
    languagecode?: SortOrder
    desctext?: SortOrderInput | SortOrder
    _count?: inducks_storydescriptionCountOrderByAggregateInput
    _max?: inducks_storydescriptionMaxOrderByAggregateInput
    _min?: inducks_storydescriptionMinOrderByAggregateInput
  }

  export type inducks_storydescriptionScalarWhereWithAggregatesInput = {
    AND?: inducks_storydescriptionScalarWhereWithAggregatesInput | inducks_storydescriptionScalarWhereWithAggregatesInput[]
    OR?: inducks_storydescriptionScalarWhereWithAggregatesInput[]
    NOT?: inducks_storydescriptionScalarWhereWithAggregatesInput | inducks_storydescriptionScalarWhereWithAggregatesInput[]
    storyversioncode?: StringWithAggregatesFilter<"inducks_storydescription"> | string
    languagecode?: StringWithAggregatesFilter<"inducks_storydescription"> | string
    desctext?: StringNullableWithAggregatesFilter<"inducks_storydescription"> | string | null
  }

  export type inducks_storyheaderWhereInput = {
    AND?: inducks_storyheaderWhereInput | inducks_storyheaderWhereInput[]
    OR?: inducks_storyheaderWhereInput[]
    NOT?: inducks_storyheaderWhereInput | inducks_storyheaderWhereInput[]
    storyheadercode?: StringFilter<"inducks_storyheader"> | string
    level?: StringFilter<"inducks_storyheader"> | string
    title?: StringNullableFilter<"inducks_storyheader"> | string | null
    storyheadercomment?: StringNullableFilter<"inducks_storyheader"> | string | null
    countrycode?: StringNullableFilter<"inducks_storyheader"> | string | null
  }

  export type inducks_storyheaderOrderByWithRelationInput = {
    storyheadercode?: SortOrder
    level?: SortOrder
    title?: SortOrderInput | SortOrder
    storyheadercomment?: SortOrderInput | SortOrder
    countrycode?: SortOrderInput | SortOrder
  }

  export type inducks_storyheaderWhereUniqueInput = Prisma.AtLeast<{
    storyheadercode_level?: inducks_storyheaderStoryheadercodeLevelCompoundUniqueInput
    AND?: inducks_storyheaderWhereInput | inducks_storyheaderWhereInput[]
    OR?: inducks_storyheaderWhereInput[]
    NOT?: inducks_storyheaderWhereInput | inducks_storyheaderWhereInput[]
    storyheadercode?: StringFilter<"inducks_storyheader"> | string
    level?: StringFilter<"inducks_storyheader"> | string
    title?: StringNullableFilter<"inducks_storyheader"> | string | null
    storyheadercomment?: StringNullableFilter<"inducks_storyheader"> | string | null
    countrycode?: StringNullableFilter<"inducks_storyheader"> | string | null
  }, "storyheadercode_level">

  export type inducks_storyheaderOrderByWithAggregationInput = {
    storyheadercode?: SortOrder
    level?: SortOrder
    title?: SortOrderInput | SortOrder
    storyheadercomment?: SortOrderInput | SortOrder
    countrycode?: SortOrderInput | SortOrder
    _count?: inducks_storyheaderCountOrderByAggregateInput
    _max?: inducks_storyheaderMaxOrderByAggregateInput
    _min?: inducks_storyheaderMinOrderByAggregateInput
  }

  export type inducks_storyheaderScalarWhereWithAggregatesInput = {
    AND?: inducks_storyheaderScalarWhereWithAggregatesInput | inducks_storyheaderScalarWhereWithAggregatesInput[]
    OR?: inducks_storyheaderScalarWhereWithAggregatesInput[]
    NOT?: inducks_storyheaderScalarWhereWithAggregatesInput | inducks_storyheaderScalarWhereWithAggregatesInput[]
    storyheadercode?: StringWithAggregatesFilter<"inducks_storyheader"> | string
    level?: StringWithAggregatesFilter<"inducks_storyheader"> | string
    title?: StringNullableWithAggregatesFilter<"inducks_storyheader"> | string | null
    storyheadercomment?: StringNullableWithAggregatesFilter<"inducks_storyheader"> | string | null
    countrycode?: StringNullableWithAggregatesFilter<"inducks_storyheader"> | string | null
  }

  export type inducks_storyjobWhereInput = {
    AND?: inducks_storyjobWhereInput | inducks_storyjobWhereInput[]
    OR?: inducks_storyjobWhereInput[]
    NOT?: inducks_storyjobWhereInput | inducks_storyjobWhereInput[]
    storyversioncode?: StringFilter<"inducks_storyjob"> | string
    personcode?: StringFilter<"inducks_storyjob"> | string
    plotwritartink?: StringFilter<"inducks_storyjob"> | string
    storyjobcomment?: StringNullableFilter<"inducks_storyjob"> | string | null
    indirect?: Enuminducks_storyjob_indirectNullableFilter<"inducks_storyjob"> | $Enums.inducks_storyjob_indirect | null
    doubt?: Enuminducks_storyjob_doubtNullableFilter<"inducks_storyjob"> | $Enums.inducks_storyjob_doubt | null
  }

  export type inducks_storyjobOrderByWithRelationInput = {
    storyversioncode?: SortOrder
    personcode?: SortOrder
    plotwritartink?: SortOrder
    storyjobcomment?: SortOrderInput | SortOrder
    indirect?: SortOrderInput | SortOrder
    doubt?: SortOrderInput | SortOrder
  }

  export type inducks_storyjobWhereUniqueInput = Prisma.AtLeast<{
    storyversioncode_personcode_plotwritartink?: inducks_storyjobStoryversioncodePersoncodePlotwritartinkCompoundUniqueInput
    AND?: inducks_storyjobWhereInput | inducks_storyjobWhereInput[]
    OR?: inducks_storyjobWhereInput[]
    NOT?: inducks_storyjobWhereInput | inducks_storyjobWhereInput[]
    storyversioncode?: StringFilter<"inducks_storyjob"> | string
    personcode?: StringFilter<"inducks_storyjob"> | string
    plotwritartink?: StringFilter<"inducks_storyjob"> | string
    storyjobcomment?: StringNullableFilter<"inducks_storyjob"> | string | null
    indirect?: Enuminducks_storyjob_indirectNullableFilter<"inducks_storyjob"> | $Enums.inducks_storyjob_indirect | null
    doubt?: Enuminducks_storyjob_doubtNullableFilter<"inducks_storyjob"> | $Enums.inducks_storyjob_doubt | null
  }, "storyversioncode_personcode_plotwritartink">

  export type inducks_storyjobOrderByWithAggregationInput = {
    storyversioncode?: SortOrder
    personcode?: SortOrder
    plotwritartink?: SortOrder
    storyjobcomment?: SortOrderInput | SortOrder
    indirect?: SortOrderInput | SortOrder
    doubt?: SortOrderInput | SortOrder
    _count?: inducks_storyjobCountOrderByAggregateInput
    _max?: inducks_storyjobMaxOrderByAggregateInput
    _min?: inducks_storyjobMinOrderByAggregateInput
  }

  export type inducks_storyjobScalarWhereWithAggregatesInput = {
    AND?: inducks_storyjobScalarWhereWithAggregatesInput | inducks_storyjobScalarWhereWithAggregatesInput[]
    OR?: inducks_storyjobScalarWhereWithAggregatesInput[]
    NOT?: inducks_storyjobScalarWhereWithAggregatesInput | inducks_storyjobScalarWhereWithAggregatesInput[]
    storyversioncode?: StringWithAggregatesFilter<"inducks_storyjob"> | string
    personcode?: StringWithAggregatesFilter<"inducks_storyjob"> | string
    plotwritartink?: StringWithAggregatesFilter<"inducks_storyjob"> | string
    storyjobcomment?: StringNullableWithAggregatesFilter<"inducks_storyjob"> | string | null
    indirect?: Enuminducks_storyjob_indirectNullableWithAggregatesFilter<"inducks_storyjob"> | $Enums.inducks_storyjob_indirect | null
    doubt?: Enuminducks_storyjob_doubtNullableWithAggregatesFilter<"inducks_storyjob"> | $Enums.inducks_storyjob_doubt | null
  }

  export type inducks_storyreferenceWhereInput = {
    AND?: inducks_storyreferenceWhereInput | inducks_storyreferenceWhereInput[]
    OR?: inducks_storyreferenceWhereInput[]
    NOT?: inducks_storyreferenceWhereInput | inducks_storyreferenceWhereInput[]
    fromstorycode?: StringFilter<"inducks_storyreference"> | string
    tostorycode?: StringFilter<"inducks_storyreference"> | string
    referencereasonid?: IntNullableFilter<"inducks_storyreference"> | number | null
  }

  export type inducks_storyreferenceOrderByWithRelationInput = {
    fromstorycode?: SortOrder
    tostorycode?: SortOrder
    referencereasonid?: SortOrderInput | SortOrder
  }

  export type inducks_storyreferenceWhereUniqueInput = Prisma.AtLeast<{
    fromstorycode_tostorycode?: inducks_storyreferenceFromstorycodeTostorycodeCompoundUniqueInput
    AND?: inducks_storyreferenceWhereInput | inducks_storyreferenceWhereInput[]
    OR?: inducks_storyreferenceWhereInput[]
    NOT?: inducks_storyreferenceWhereInput | inducks_storyreferenceWhereInput[]
    fromstorycode?: StringFilter<"inducks_storyreference"> | string
    tostorycode?: StringFilter<"inducks_storyreference"> | string
    referencereasonid?: IntNullableFilter<"inducks_storyreference"> | number | null
  }, "fromstorycode_tostorycode">

  export type inducks_storyreferenceOrderByWithAggregationInput = {
    fromstorycode?: SortOrder
    tostorycode?: SortOrder
    referencereasonid?: SortOrderInput | SortOrder
    _count?: inducks_storyreferenceCountOrderByAggregateInput
    _avg?: inducks_storyreferenceAvgOrderByAggregateInput
    _max?: inducks_storyreferenceMaxOrderByAggregateInput
    _min?: inducks_storyreferenceMinOrderByAggregateInput
    _sum?: inducks_storyreferenceSumOrderByAggregateInput
  }

  export type inducks_storyreferenceScalarWhereWithAggregatesInput = {
    AND?: inducks_storyreferenceScalarWhereWithAggregatesInput | inducks_storyreferenceScalarWhereWithAggregatesInput[]
    OR?: inducks_storyreferenceScalarWhereWithAggregatesInput[]
    NOT?: inducks_storyreferenceScalarWhereWithAggregatesInput | inducks_storyreferenceScalarWhereWithAggregatesInput[]
    fromstorycode?: StringWithAggregatesFilter<"inducks_storyreference"> | string
    tostorycode?: StringWithAggregatesFilter<"inducks_storyreference"> | string
    referencereasonid?: IntNullableWithAggregatesFilter<"inducks_storyreference"> | number | null
  }

  export type inducks_storysubseriesWhereInput = {
    AND?: inducks_storysubseriesWhereInput | inducks_storysubseriesWhereInput[]
    OR?: inducks_storysubseriesWhereInput[]
    NOT?: inducks_storysubseriesWhereInput | inducks_storysubseriesWhereInput[]
    storycode?: StringFilter<"inducks_storysubseries"> | string
    subseriescode?: StringFilter<"inducks_storysubseries"> | string
    storysubseriescomment?: StringNullableFilter<"inducks_storysubseries"> | string | null
  }

  export type inducks_storysubseriesOrderByWithRelationInput = {
    storycode?: SortOrder
    subseriescode?: SortOrder
    storysubseriescomment?: SortOrderInput | SortOrder
  }

  export type inducks_storysubseriesWhereUniqueInput = Prisma.AtLeast<{
    storycode_subseriescode?: inducks_storysubseriesStorycodeSubseriescodeCompoundUniqueInput
    AND?: inducks_storysubseriesWhereInput | inducks_storysubseriesWhereInput[]
    OR?: inducks_storysubseriesWhereInput[]
    NOT?: inducks_storysubseriesWhereInput | inducks_storysubseriesWhereInput[]
    storycode?: StringFilter<"inducks_storysubseries"> | string
    subseriescode?: StringFilter<"inducks_storysubseries"> | string
    storysubseriescomment?: StringNullableFilter<"inducks_storysubseries"> | string | null
  }, "storycode_subseriescode">

  export type inducks_storysubseriesOrderByWithAggregationInput = {
    storycode?: SortOrder
    subseriescode?: SortOrder
    storysubseriescomment?: SortOrderInput | SortOrder
    _count?: inducks_storysubseriesCountOrderByAggregateInput
    _max?: inducks_storysubseriesMaxOrderByAggregateInput
    _min?: inducks_storysubseriesMinOrderByAggregateInput
  }

  export type inducks_storysubseriesScalarWhereWithAggregatesInput = {
    AND?: inducks_storysubseriesScalarWhereWithAggregatesInput | inducks_storysubseriesScalarWhereWithAggregatesInput[]
    OR?: inducks_storysubseriesScalarWhereWithAggregatesInput[]
    NOT?: inducks_storysubseriesScalarWhereWithAggregatesInput | inducks_storysubseriesScalarWhereWithAggregatesInput[]
    storycode?: StringWithAggregatesFilter<"inducks_storysubseries"> | string
    subseriescode?: StringWithAggregatesFilter<"inducks_storysubseries"> | string
    storysubseriescomment?: StringNullableWithAggregatesFilter<"inducks_storysubseries"> | string | null
  }

  export type inducks_storyurlWhereInput = {
    AND?: inducks_storyurlWhereInput | inducks_storyurlWhereInput[]
    OR?: inducks_storyurlWhereInput[]
    NOT?: inducks_storyurlWhereInput | inducks_storyurlWhereInput[]
    storycode?: StringFilter<"inducks_storyurl"> | string
    sitecode?: StringFilter<"inducks_storyurl"> | string
    url?: StringNullableFilter<"inducks_storyurl"> | string | null
  }

  export type inducks_storyurlOrderByWithRelationInput = {
    storycode?: SortOrder
    sitecode?: SortOrder
    url?: SortOrderInput | SortOrder
  }

  export type inducks_storyurlWhereUniqueInput = Prisma.AtLeast<{
    storycode_sitecode?: inducks_storyurlStorycodeSitecodeCompoundUniqueInput
    AND?: inducks_storyurlWhereInput | inducks_storyurlWhereInput[]
    OR?: inducks_storyurlWhereInput[]
    NOT?: inducks_storyurlWhereInput | inducks_storyurlWhereInput[]
    storycode?: StringFilter<"inducks_storyurl"> | string
    sitecode?: StringFilter<"inducks_storyurl"> | string
    url?: StringNullableFilter<"inducks_storyurl"> | string | null
  }, "storycode_sitecode">

  export type inducks_storyurlOrderByWithAggregationInput = {
    storycode?: SortOrder
    sitecode?: SortOrder
    url?: SortOrderInput | SortOrder
    _count?: inducks_storyurlCountOrderByAggregateInput
    _max?: inducks_storyurlMaxOrderByAggregateInput
    _min?: inducks_storyurlMinOrderByAggregateInput
  }

  export type inducks_storyurlScalarWhereWithAggregatesInput = {
    AND?: inducks_storyurlScalarWhereWithAggregatesInput | inducks_storyurlScalarWhereWithAggregatesInput[]
    OR?: inducks_storyurlScalarWhereWithAggregatesInput[]
    NOT?: inducks_storyurlScalarWhereWithAggregatesInput | inducks_storyurlScalarWhereWithAggregatesInput[]
    storycode?: StringWithAggregatesFilter<"inducks_storyurl"> | string
    sitecode?: StringWithAggregatesFilter<"inducks_storyurl"> | string
    url?: StringNullableWithAggregatesFilter<"inducks_storyurl"> | string | null
  }

  export type inducks_storyversionWhereInput = {
    AND?: inducks_storyversionWhereInput | inducks_storyversionWhereInput[]
    OR?: inducks_storyversionWhereInput[]
    NOT?: inducks_storyversionWhereInput | inducks_storyversionWhereInput[]
    storyversioncode?: StringFilter<"inducks_storyversion"> | string
    storycode?: StringNullableFilter<"inducks_storyversion"> | string | null
    entirepages?: IntNullableFilter<"inducks_storyversion"> | number | null
    brokenpagenumerator?: IntNullableFilter<"inducks_storyversion"> | number | null
    brokenpagedenominator?: IntNullableFilter<"inducks_storyversion"> | number | null
    brokenpageunspecified?: Enuminducks_storyversion_brokenpageunspecifiedNullableFilter<"inducks_storyversion"> | $Enums.inducks_storyversion_brokenpageunspecified | null
    kind?: StringNullableFilter<"inducks_storyversion"> | string | null
    rowsperpage?: IntNullableFilter<"inducks_storyversion"> | number | null
    columnsperpage?: IntNullableFilter<"inducks_storyversion"> | number | null
    appisxapp?: Enuminducks_storyversion_appisxappNullableFilter<"inducks_storyversion"> | $Enums.inducks_storyversion_appisxapp | null
    what?: StringNullableFilter<"inducks_storyversion"> | string | null
    appsummary?: StringNullableFilter<"inducks_storyversion"> | string | null
    plotsummary?: StringNullableFilter<"inducks_storyversion"> | string | null
    writsummary?: StringNullableFilter<"inducks_storyversion"> | string | null
    artsummary?: StringNullableFilter<"inducks_storyversion"> | string | null
    inksummary?: StringNullableFilter<"inducks_storyversion"> | string | null
    creatorrefsummary?: StringNullableFilter<"inducks_storyversion"> | string | null
    keywordsummary?: StringNullableFilter<"inducks_storyversion"> | string | null
    estimatedpanels?: IntNullableFilter<"inducks_storyversion"> | number | null
  }

  export type inducks_storyversionOrderByWithRelationInput = {
    storyversioncode?: SortOrder
    storycode?: SortOrderInput | SortOrder
    entirepages?: SortOrderInput | SortOrder
    brokenpagenumerator?: SortOrderInput | SortOrder
    brokenpagedenominator?: SortOrderInput | SortOrder
    brokenpageunspecified?: SortOrderInput | SortOrder
    kind?: SortOrderInput | SortOrder
    rowsperpage?: SortOrderInput | SortOrder
    columnsperpage?: SortOrderInput | SortOrder
    appisxapp?: SortOrderInput | SortOrder
    what?: SortOrderInput | SortOrder
    appsummary?: SortOrderInput | SortOrder
    plotsummary?: SortOrderInput | SortOrder
    writsummary?: SortOrderInput | SortOrder
    artsummary?: SortOrderInput | SortOrder
    inksummary?: SortOrderInput | SortOrder
    creatorrefsummary?: SortOrderInput | SortOrder
    keywordsummary?: SortOrderInput | SortOrder
    estimatedpanels?: SortOrderInput | SortOrder
  }

  export type inducks_storyversionWhereUniqueInput = Prisma.AtLeast<{
    storyversioncode?: string
    AND?: inducks_storyversionWhereInput | inducks_storyversionWhereInput[]
    OR?: inducks_storyversionWhereInput[]
    NOT?: inducks_storyversionWhereInput | inducks_storyversionWhereInput[]
    storycode?: StringNullableFilter<"inducks_storyversion"> | string | null
    entirepages?: IntNullableFilter<"inducks_storyversion"> | number | null
    brokenpagenumerator?: IntNullableFilter<"inducks_storyversion"> | number | null
    brokenpagedenominator?: IntNullableFilter<"inducks_storyversion"> | number | null
    brokenpageunspecified?: Enuminducks_storyversion_brokenpageunspecifiedNullableFilter<"inducks_storyversion"> | $Enums.inducks_storyversion_brokenpageunspecified | null
    kind?: StringNullableFilter<"inducks_storyversion"> | string | null
    rowsperpage?: IntNullableFilter<"inducks_storyversion"> | number | null
    columnsperpage?: IntNullableFilter<"inducks_storyversion"> | number | null
    appisxapp?: Enuminducks_storyversion_appisxappNullableFilter<"inducks_storyversion"> | $Enums.inducks_storyversion_appisxapp | null
    what?: StringNullableFilter<"inducks_storyversion"> | string | null
    appsummary?: StringNullableFilter<"inducks_storyversion"> | string | null
    plotsummary?: StringNullableFilter<"inducks_storyversion"> | string | null
    writsummary?: StringNullableFilter<"inducks_storyversion"> | string | null
    artsummary?: StringNullableFilter<"inducks_storyversion"> | string | null
    inksummary?: StringNullableFilter<"inducks_storyversion"> | string | null
    creatorrefsummary?: StringNullableFilter<"inducks_storyversion"> | string | null
    keywordsummary?: StringNullableFilter<"inducks_storyversion"> | string | null
    estimatedpanels?: IntNullableFilter<"inducks_storyversion"> | number | null
  }, "storyversioncode">

  export type inducks_storyversionOrderByWithAggregationInput = {
    storyversioncode?: SortOrder
    storycode?: SortOrderInput | SortOrder
    entirepages?: SortOrderInput | SortOrder
    brokenpagenumerator?: SortOrderInput | SortOrder
    brokenpagedenominator?: SortOrderInput | SortOrder
    brokenpageunspecified?: SortOrderInput | SortOrder
    kind?: SortOrderInput | SortOrder
    rowsperpage?: SortOrderInput | SortOrder
    columnsperpage?: SortOrderInput | SortOrder
    appisxapp?: SortOrderInput | SortOrder
    what?: SortOrderInput | SortOrder
    appsummary?: SortOrderInput | SortOrder
    plotsummary?: SortOrderInput | SortOrder
    writsummary?: SortOrderInput | SortOrder
    artsummary?: SortOrderInput | SortOrder
    inksummary?: SortOrderInput | SortOrder
    creatorrefsummary?: SortOrderInput | SortOrder
    keywordsummary?: SortOrderInput | SortOrder
    estimatedpanels?: SortOrderInput | SortOrder
    _count?: inducks_storyversionCountOrderByAggregateInput
    _avg?: inducks_storyversionAvgOrderByAggregateInput
    _max?: inducks_storyversionMaxOrderByAggregateInput
    _min?: inducks_storyversionMinOrderByAggregateInput
    _sum?: inducks_storyversionSumOrderByAggregateInput
  }

  export type inducks_storyversionScalarWhereWithAggregatesInput = {
    AND?: inducks_storyversionScalarWhereWithAggregatesInput | inducks_storyversionScalarWhereWithAggregatesInput[]
    OR?: inducks_storyversionScalarWhereWithAggregatesInput[]
    NOT?: inducks_storyversionScalarWhereWithAggregatesInput | inducks_storyversionScalarWhereWithAggregatesInput[]
    storyversioncode?: StringWithAggregatesFilter<"inducks_storyversion"> | string
    storycode?: StringNullableWithAggregatesFilter<"inducks_storyversion"> | string | null
    entirepages?: IntNullableWithAggregatesFilter<"inducks_storyversion"> | number | null
    brokenpagenumerator?: IntNullableWithAggregatesFilter<"inducks_storyversion"> | number | null
    brokenpagedenominator?: IntNullableWithAggregatesFilter<"inducks_storyversion"> | number | null
    brokenpageunspecified?: Enuminducks_storyversion_brokenpageunspecifiedNullableWithAggregatesFilter<"inducks_storyversion"> | $Enums.inducks_storyversion_brokenpageunspecified | null
    kind?: StringNullableWithAggregatesFilter<"inducks_storyversion"> | string | null
    rowsperpage?: IntNullableWithAggregatesFilter<"inducks_storyversion"> | number | null
    columnsperpage?: IntNullableWithAggregatesFilter<"inducks_storyversion"> | number | null
    appisxapp?: Enuminducks_storyversion_appisxappNullableWithAggregatesFilter<"inducks_storyversion"> | $Enums.inducks_storyversion_appisxapp | null
    what?: StringNullableWithAggregatesFilter<"inducks_storyversion"> | string | null
    appsummary?: StringNullableWithAggregatesFilter<"inducks_storyversion"> | string | null
    plotsummary?: StringNullableWithAggregatesFilter<"inducks_storyversion"> | string | null
    writsummary?: StringNullableWithAggregatesFilter<"inducks_storyversion"> | string | null
    artsummary?: StringNullableWithAggregatesFilter<"inducks_storyversion"> | string | null
    inksummary?: StringNullableWithAggregatesFilter<"inducks_storyversion"> | string | null
    creatorrefsummary?: StringNullableWithAggregatesFilter<"inducks_storyversion"> | string | null
    keywordsummary?: StringNullableWithAggregatesFilter<"inducks_storyversion"> | string | null
    estimatedpanels?: IntNullableWithAggregatesFilter<"inducks_storyversion"> | number | null
  }

  export type inducks_storyversion_nofulltextWhereInput = {
    AND?: inducks_storyversion_nofulltextWhereInput | inducks_storyversion_nofulltextWhereInput[]
    OR?: inducks_storyversion_nofulltextWhereInput[]
    NOT?: inducks_storyversion_nofulltextWhereInput | inducks_storyversion_nofulltextWhereInput[]
    storyversioncode?: StringFilter<"inducks_storyversion_nofulltext"> | string
    storycode?: StringNullableFilter<"inducks_storyversion_nofulltext"> | string | null
    entirepages?: IntNullableFilter<"inducks_storyversion_nofulltext"> | number | null
    brokenpagenumerator?: IntNullableFilter<"inducks_storyversion_nofulltext"> | number | null
    brokenpagedenominator?: IntNullableFilter<"inducks_storyversion_nofulltext"> | number | null
    brokenpageunspecified?: Enuminducks_storyversion_nofulltext_brokenpageunspecifiedNullableFilter<"inducks_storyversion_nofulltext"> | $Enums.inducks_storyversion_nofulltext_brokenpageunspecified | null
    kind?: StringNullableFilter<"inducks_storyversion_nofulltext"> | string | null
    rowsperpage?: IntNullableFilter<"inducks_storyversion_nofulltext"> | number | null
    columnsperpage?: IntNullableFilter<"inducks_storyversion_nofulltext"> | number | null
    appisxapp?: Enuminducks_storyversion_nofulltext_appisxappNullableFilter<"inducks_storyversion_nofulltext"> | $Enums.inducks_storyversion_nofulltext_appisxapp | null
    what?: StringNullableFilter<"inducks_storyversion_nofulltext"> | string | null
    appsummary?: StringNullableFilter<"inducks_storyversion_nofulltext"> | string | null
    plotsummary?: StringNullableFilter<"inducks_storyversion_nofulltext"> | string | null
    writsummary?: StringNullableFilter<"inducks_storyversion_nofulltext"> | string | null
    artsummary?: StringNullableFilter<"inducks_storyversion_nofulltext"> | string | null
    inksummary?: StringNullableFilter<"inducks_storyversion_nofulltext"> | string | null
    creatorrefsummary?: StringNullableFilter<"inducks_storyversion_nofulltext"> | string | null
    keywordsummary?: StringNullableFilter<"inducks_storyversion_nofulltext"> | string | null
    estimatedpanels?: IntNullableFilter<"inducks_storyversion_nofulltext"> | number | null
  }

  export type inducks_storyversion_nofulltextOrderByWithRelationInput = {
    storyversioncode?: SortOrder
    storycode?: SortOrderInput | SortOrder
    entirepages?: SortOrderInput | SortOrder
    brokenpagenumerator?: SortOrderInput | SortOrder
    brokenpagedenominator?: SortOrderInput | SortOrder
    brokenpageunspecified?: SortOrderInput | SortOrder
    kind?: SortOrderInput | SortOrder
    rowsperpage?: SortOrderInput | SortOrder
    columnsperpage?: SortOrderInput | SortOrder
    appisxapp?: SortOrderInput | SortOrder
    what?: SortOrderInput | SortOrder
    appsummary?: SortOrderInput | SortOrder
    plotsummary?: SortOrderInput | SortOrder
    writsummary?: SortOrderInput | SortOrder
    artsummary?: SortOrderInput | SortOrder
    inksummary?: SortOrderInput | SortOrder
    creatorrefsummary?: SortOrderInput | SortOrder
    keywordsummary?: SortOrderInput | SortOrder
    estimatedpanels?: SortOrderInput | SortOrder
  }

  export type inducks_storyversion_nofulltextWhereUniqueInput = Prisma.AtLeast<{
    storyversioncode?: string
    AND?: inducks_storyversion_nofulltextWhereInput | inducks_storyversion_nofulltextWhereInput[]
    OR?: inducks_storyversion_nofulltextWhereInput[]
    NOT?: inducks_storyversion_nofulltextWhereInput | inducks_storyversion_nofulltextWhereInput[]
    storycode?: StringNullableFilter<"inducks_storyversion_nofulltext"> | string | null
    entirepages?: IntNullableFilter<"inducks_storyversion_nofulltext"> | number | null
    brokenpagenumerator?: IntNullableFilter<"inducks_storyversion_nofulltext"> | number | null
    brokenpagedenominator?: IntNullableFilter<"inducks_storyversion_nofulltext"> | number | null
    brokenpageunspecified?: Enuminducks_storyversion_nofulltext_brokenpageunspecifiedNullableFilter<"inducks_storyversion_nofulltext"> | $Enums.inducks_storyversion_nofulltext_brokenpageunspecified | null
    kind?: StringNullableFilter<"inducks_storyversion_nofulltext"> | string | null
    rowsperpage?: IntNullableFilter<"inducks_storyversion_nofulltext"> | number | null
    columnsperpage?: IntNullableFilter<"inducks_storyversion_nofulltext"> | number | null
    appisxapp?: Enuminducks_storyversion_nofulltext_appisxappNullableFilter<"inducks_storyversion_nofulltext"> | $Enums.inducks_storyversion_nofulltext_appisxapp | null
    what?: StringNullableFilter<"inducks_storyversion_nofulltext"> | string | null
    appsummary?: StringNullableFilter<"inducks_storyversion_nofulltext"> | string | null
    plotsummary?: StringNullableFilter<"inducks_storyversion_nofulltext"> | string | null
    writsummary?: StringNullableFilter<"inducks_storyversion_nofulltext"> | string | null
    artsummary?: StringNullableFilter<"inducks_storyversion_nofulltext"> | string | null
    inksummary?: StringNullableFilter<"inducks_storyversion_nofulltext"> | string | null
    creatorrefsummary?: StringNullableFilter<"inducks_storyversion_nofulltext"> | string | null
    keywordsummary?: StringNullableFilter<"inducks_storyversion_nofulltext"> | string | null
    estimatedpanels?: IntNullableFilter<"inducks_storyversion_nofulltext"> | number | null
  }, "storyversioncode">

  export type inducks_storyversion_nofulltextOrderByWithAggregationInput = {
    storyversioncode?: SortOrder
    storycode?: SortOrderInput | SortOrder
    entirepages?: SortOrderInput | SortOrder
    brokenpagenumerator?: SortOrderInput | SortOrder
    brokenpagedenominator?: SortOrderInput | SortOrder
    brokenpageunspecified?: SortOrderInput | SortOrder
    kind?: SortOrderInput | SortOrder
    rowsperpage?: SortOrderInput | SortOrder
    columnsperpage?: SortOrderInput | SortOrder
    appisxapp?: SortOrderInput | SortOrder
    what?: SortOrderInput | SortOrder
    appsummary?: SortOrderInput | SortOrder
    plotsummary?: SortOrderInput | SortOrder
    writsummary?: SortOrderInput | SortOrder
    artsummary?: SortOrderInput | SortOrder
    inksummary?: SortOrderInput | SortOrder
    creatorrefsummary?: SortOrderInput | SortOrder
    keywordsummary?: SortOrderInput | SortOrder
    estimatedpanels?: SortOrderInput | SortOrder
    _count?: inducks_storyversion_nofulltextCountOrderByAggregateInput
    _avg?: inducks_storyversion_nofulltextAvgOrderByAggregateInput
    _max?: inducks_storyversion_nofulltextMaxOrderByAggregateInput
    _min?: inducks_storyversion_nofulltextMinOrderByAggregateInput
    _sum?: inducks_storyversion_nofulltextSumOrderByAggregateInput
  }

  export type inducks_storyversion_nofulltextScalarWhereWithAggregatesInput = {
    AND?: inducks_storyversion_nofulltextScalarWhereWithAggregatesInput | inducks_storyversion_nofulltextScalarWhereWithAggregatesInput[]
    OR?: inducks_storyversion_nofulltextScalarWhereWithAggregatesInput[]
    NOT?: inducks_storyversion_nofulltextScalarWhereWithAggregatesInput | inducks_storyversion_nofulltextScalarWhereWithAggregatesInput[]
    storyversioncode?: StringWithAggregatesFilter<"inducks_storyversion_nofulltext"> | string
    storycode?: StringNullableWithAggregatesFilter<"inducks_storyversion_nofulltext"> | string | null
    entirepages?: IntNullableWithAggregatesFilter<"inducks_storyversion_nofulltext"> | number | null
    brokenpagenumerator?: IntNullableWithAggregatesFilter<"inducks_storyversion_nofulltext"> | number | null
    brokenpagedenominator?: IntNullableWithAggregatesFilter<"inducks_storyversion_nofulltext"> | number | null
    brokenpageunspecified?: Enuminducks_storyversion_nofulltext_brokenpageunspecifiedNullableWithAggregatesFilter<"inducks_storyversion_nofulltext"> | $Enums.inducks_storyversion_nofulltext_brokenpageunspecified | null
    kind?: StringNullableWithAggregatesFilter<"inducks_storyversion_nofulltext"> | string | null
    rowsperpage?: IntNullableWithAggregatesFilter<"inducks_storyversion_nofulltext"> | number | null
    columnsperpage?: IntNullableWithAggregatesFilter<"inducks_storyversion_nofulltext"> | number | null
    appisxapp?: Enuminducks_storyversion_nofulltext_appisxappNullableWithAggregatesFilter<"inducks_storyversion_nofulltext"> | $Enums.inducks_storyversion_nofulltext_appisxapp | null
    what?: StringNullableWithAggregatesFilter<"inducks_storyversion_nofulltext"> | string | null
    appsummary?: StringNullableWithAggregatesFilter<"inducks_storyversion_nofulltext"> | string | null
    plotsummary?: StringNullableWithAggregatesFilter<"inducks_storyversion_nofulltext"> | string | null
    writsummary?: StringNullableWithAggregatesFilter<"inducks_storyversion_nofulltext"> | string | null
    artsummary?: StringNullableWithAggregatesFilter<"inducks_storyversion_nofulltext"> | string | null
    inksummary?: StringNullableWithAggregatesFilter<"inducks_storyversion_nofulltext"> | string | null
    creatorrefsummary?: StringNullableWithAggregatesFilter<"inducks_storyversion_nofulltext"> | string | null
    keywordsummary?: StringNullableWithAggregatesFilter<"inducks_storyversion_nofulltext"> | string | null
    estimatedpanels?: IntNullableWithAggregatesFilter<"inducks_storyversion_nofulltext"> | number | null
  }

  export type inducks_studioWhereInput = {
    AND?: inducks_studioWhereInput | inducks_studioWhereInput[]
    OR?: inducks_studioWhereInput[]
    NOT?: inducks_studioWhereInput | inducks_studioWhereInput[]
    studiocode?: StringFilter<"inducks_studio"> | string
    countrycode?: StringNullableFilter<"inducks_studio"> | string | null
    studioname?: StringNullableFilter<"inducks_studio"> | string | null
    city?: StringNullableFilter<"inducks_studio"> | string | null
    description?: StringNullableFilter<"inducks_studio"> | string | null
    othertext?: StringNullableFilter<"inducks_studio"> | string | null
    photofilename?: StringNullableFilter<"inducks_studio"> | string | null
    photocomment?: StringNullableFilter<"inducks_studio"> | string | null
    photosource?: StringNullableFilter<"inducks_studio"> | string | null
    studiorefs?: StringNullableFilter<"inducks_studio"> | string | null
  }

  export type inducks_studioOrderByWithRelationInput = {
    studiocode?: SortOrder
    countrycode?: SortOrderInput | SortOrder
    studioname?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    othertext?: SortOrderInput | SortOrder
    photofilename?: SortOrderInput | SortOrder
    photocomment?: SortOrderInput | SortOrder
    photosource?: SortOrderInput | SortOrder
    studiorefs?: SortOrderInput | SortOrder
  }

  export type inducks_studioWhereUniqueInput = Prisma.AtLeast<{
    studiocode?: string
    AND?: inducks_studioWhereInput | inducks_studioWhereInput[]
    OR?: inducks_studioWhereInput[]
    NOT?: inducks_studioWhereInput | inducks_studioWhereInput[]
    countrycode?: StringNullableFilter<"inducks_studio"> | string | null
    studioname?: StringNullableFilter<"inducks_studio"> | string | null
    city?: StringNullableFilter<"inducks_studio"> | string | null
    description?: StringNullableFilter<"inducks_studio"> | string | null
    othertext?: StringNullableFilter<"inducks_studio"> | string | null
    photofilename?: StringNullableFilter<"inducks_studio"> | string | null
    photocomment?: StringNullableFilter<"inducks_studio"> | string | null
    photosource?: StringNullableFilter<"inducks_studio"> | string | null
    studiorefs?: StringNullableFilter<"inducks_studio"> | string | null
  }, "studiocode">

  export type inducks_studioOrderByWithAggregationInput = {
    studiocode?: SortOrder
    countrycode?: SortOrderInput | SortOrder
    studioname?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    othertext?: SortOrderInput | SortOrder
    photofilename?: SortOrderInput | SortOrder
    photocomment?: SortOrderInput | SortOrder
    photosource?: SortOrderInput | SortOrder
    studiorefs?: SortOrderInput | SortOrder
    _count?: inducks_studioCountOrderByAggregateInput
    _max?: inducks_studioMaxOrderByAggregateInput
    _min?: inducks_studioMinOrderByAggregateInput
  }

  export type inducks_studioScalarWhereWithAggregatesInput = {
    AND?: inducks_studioScalarWhereWithAggregatesInput | inducks_studioScalarWhereWithAggregatesInput[]
    OR?: inducks_studioScalarWhereWithAggregatesInput[]
    NOT?: inducks_studioScalarWhereWithAggregatesInput | inducks_studioScalarWhereWithAggregatesInput[]
    studiocode?: StringWithAggregatesFilter<"inducks_studio"> | string
    countrycode?: StringNullableWithAggregatesFilter<"inducks_studio"> | string | null
    studioname?: StringNullableWithAggregatesFilter<"inducks_studio"> | string | null
    city?: StringNullableWithAggregatesFilter<"inducks_studio"> | string | null
    description?: StringNullableWithAggregatesFilter<"inducks_studio"> | string | null
    othertext?: StringNullableWithAggregatesFilter<"inducks_studio"> | string | null
    photofilename?: StringNullableWithAggregatesFilter<"inducks_studio"> | string | null
    photocomment?: StringNullableWithAggregatesFilter<"inducks_studio"> | string | null
    photosource?: StringNullableWithAggregatesFilter<"inducks_studio"> | string | null
    studiorefs?: StringNullableWithAggregatesFilter<"inducks_studio"> | string | null
  }

  export type inducks_studioworkWhereInput = {
    AND?: inducks_studioworkWhereInput | inducks_studioworkWhereInput[]
    OR?: inducks_studioworkWhereInput[]
    NOT?: inducks_studioworkWhereInput | inducks_studioworkWhereInput[]
    studiocode?: StringFilter<"inducks_studiowork"> | string
    personcode?: StringFilter<"inducks_studiowork"> | string
  }

  export type inducks_studioworkOrderByWithRelationInput = {
    studiocode?: SortOrder
    personcode?: SortOrder
  }

  export type inducks_studioworkWhereUniqueInput = Prisma.AtLeast<{
    studiocode_personcode?: inducks_studioworkStudiocodePersoncodeCompoundUniqueInput
    AND?: inducks_studioworkWhereInput | inducks_studioworkWhereInput[]
    OR?: inducks_studioworkWhereInput[]
    NOT?: inducks_studioworkWhereInput | inducks_studioworkWhereInput[]
    studiocode?: StringFilter<"inducks_studiowork"> | string
    personcode?: StringFilter<"inducks_studiowork"> | string
  }, "studiocode_personcode">

  export type inducks_studioworkOrderByWithAggregationInput = {
    studiocode?: SortOrder
    personcode?: SortOrder
    _count?: inducks_studioworkCountOrderByAggregateInput
    _max?: inducks_studioworkMaxOrderByAggregateInput
    _min?: inducks_studioworkMinOrderByAggregateInput
  }

  export type inducks_studioworkScalarWhereWithAggregatesInput = {
    AND?: inducks_studioworkScalarWhereWithAggregatesInput | inducks_studioworkScalarWhereWithAggregatesInput[]
    OR?: inducks_studioworkScalarWhereWithAggregatesInput[]
    NOT?: inducks_studioworkScalarWhereWithAggregatesInput | inducks_studioworkScalarWhereWithAggregatesInput[]
    studiocode?: StringWithAggregatesFilter<"inducks_studiowork"> | string
    personcode?: StringWithAggregatesFilter<"inducks_studiowork"> | string
  }

  export type inducks_subseriesWhereInput = {
    AND?: inducks_subseriesWhereInput | inducks_subseriesWhereInput[]
    OR?: inducks_subseriesWhereInput[]
    NOT?: inducks_subseriesWhereInput | inducks_subseriesWhereInput[]
    subseriescode?: StringFilter<"inducks_subseries"> | string
    subseriesname?: StringNullableFilter<"inducks_subseries"> | string | null
    official?: Enuminducks_subseries_officialNullableFilter<"inducks_subseries"> | $Enums.inducks_subseries_official | null
    subseriescomment?: StringNullableFilter<"inducks_subseries"> | string | null
    subseriescategory?: StringNullableFilter<"inducks_subseries"> | string | null
  }

  export type inducks_subseriesOrderByWithRelationInput = {
    subseriescode?: SortOrder
    subseriesname?: SortOrderInput | SortOrder
    official?: SortOrderInput | SortOrder
    subseriescomment?: SortOrderInput | SortOrder
    subseriescategory?: SortOrderInput | SortOrder
  }

  export type inducks_subseriesWhereUniqueInput = Prisma.AtLeast<{
    subseriescode?: string
    AND?: inducks_subseriesWhereInput | inducks_subseriesWhereInput[]
    OR?: inducks_subseriesWhereInput[]
    NOT?: inducks_subseriesWhereInput | inducks_subseriesWhereInput[]
    subseriesname?: StringNullableFilter<"inducks_subseries"> | string | null
    official?: Enuminducks_subseries_officialNullableFilter<"inducks_subseries"> | $Enums.inducks_subseries_official | null
    subseriescomment?: StringNullableFilter<"inducks_subseries"> | string | null
    subseriescategory?: StringNullableFilter<"inducks_subseries"> | string | null
  }, "subseriescode">

  export type inducks_subseriesOrderByWithAggregationInput = {
    subseriescode?: SortOrder
    subseriesname?: SortOrderInput | SortOrder
    official?: SortOrderInput | SortOrder
    subseriescomment?: SortOrderInput | SortOrder
    subseriescategory?: SortOrderInput | SortOrder
    _count?: inducks_subseriesCountOrderByAggregateInput
    _max?: inducks_subseriesMaxOrderByAggregateInput
    _min?: inducks_subseriesMinOrderByAggregateInput
  }

  export type inducks_subseriesScalarWhereWithAggregatesInput = {
    AND?: inducks_subseriesScalarWhereWithAggregatesInput | inducks_subseriesScalarWhereWithAggregatesInput[]
    OR?: inducks_subseriesScalarWhereWithAggregatesInput[]
    NOT?: inducks_subseriesScalarWhereWithAggregatesInput | inducks_subseriesScalarWhereWithAggregatesInput[]
    subseriescode?: StringWithAggregatesFilter<"inducks_subseries"> | string
    subseriesname?: StringNullableWithAggregatesFilter<"inducks_subseries"> | string | null
    official?: Enuminducks_subseries_officialNullableWithAggregatesFilter<"inducks_subseries"> | $Enums.inducks_subseries_official | null
    subseriescomment?: StringNullableWithAggregatesFilter<"inducks_subseries"> | string | null
    subseriescategory?: StringNullableWithAggregatesFilter<"inducks_subseries"> | string | null
  }

  export type inducks_subseriesnameWhereInput = {
    AND?: inducks_subseriesnameWhereInput | inducks_subseriesnameWhereInput[]
    OR?: inducks_subseriesnameWhereInput[]
    NOT?: inducks_subseriesnameWhereInput | inducks_subseriesnameWhereInput[]
    subseriescode?: StringFilter<"inducks_subseriesname"> | string
    languagecode?: StringFilter<"inducks_subseriesname"> | string
    subseriesname?: StringNullableFilter<"inducks_subseriesname"> | string | null
    preferred?: Enuminducks_subseriesname_preferredNullableFilter<"inducks_subseriesname"> | $Enums.inducks_subseriesname_preferred | null
    subseriesnamecomment?: StringNullableFilter<"inducks_subseriesname"> | string | null
  }

  export type inducks_subseriesnameOrderByWithRelationInput = {
    subseriescode?: SortOrder
    languagecode?: SortOrder
    subseriesname?: SortOrderInput | SortOrder
    preferred?: SortOrderInput | SortOrder
    subseriesnamecomment?: SortOrderInput | SortOrder
  }

  export type inducks_subseriesnameWhereUniqueInput = Prisma.AtLeast<{
    subseriescode_languagecode?: inducks_subseriesnameSubseriescodeLanguagecodeCompoundUniqueInput
    AND?: inducks_subseriesnameWhereInput | inducks_subseriesnameWhereInput[]
    OR?: inducks_subseriesnameWhereInput[]
    NOT?: inducks_subseriesnameWhereInput | inducks_subseriesnameWhereInput[]
    subseriescode?: StringFilter<"inducks_subseriesname"> | string
    languagecode?: StringFilter<"inducks_subseriesname"> | string
    subseriesname?: StringNullableFilter<"inducks_subseriesname"> | string | null
    preferred?: Enuminducks_subseriesname_preferredNullableFilter<"inducks_subseriesname"> | $Enums.inducks_subseriesname_preferred | null
    subseriesnamecomment?: StringNullableFilter<"inducks_subseriesname"> | string | null
  }, "subseriescode_languagecode">

  export type inducks_subseriesnameOrderByWithAggregationInput = {
    subseriescode?: SortOrder
    languagecode?: SortOrder
    subseriesname?: SortOrderInput | SortOrder
    preferred?: SortOrderInput | SortOrder
    subseriesnamecomment?: SortOrderInput | SortOrder
    _count?: inducks_subseriesnameCountOrderByAggregateInput
    _max?: inducks_subseriesnameMaxOrderByAggregateInput
    _min?: inducks_subseriesnameMinOrderByAggregateInput
  }

  export type inducks_subseriesnameScalarWhereWithAggregatesInput = {
    AND?: inducks_subseriesnameScalarWhereWithAggregatesInput | inducks_subseriesnameScalarWhereWithAggregatesInput[]
    OR?: inducks_subseriesnameScalarWhereWithAggregatesInput[]
    NOT?: inducks_subseriesnameScalarWhereWithAggregatesInput | inducks_subseriesnameScalarWhereWithAggregatesInput[]
    subseriescode?: StringWithAggregatesFilter<"inducks_subseriesname"> | string
    languagecode?: StringWithAggregatesFilter<"inducks_subseriesname"> | string
    subseriesname?: StringNullableWithAggregatesFilter<"inducks_subseriesname"> | string | null
    preferred?: Enuminducks_subseriesname_preferredNullableWithAggregatesFilter<"inducks_subseriesname"> | $Enums.inducks_subseriesname_preferred | null
    subseriesnamecomment?: StringNullableWithAggregatesFilter<"inducks_subseriesname"> | string | null
  }

  export type inducks_substoryWhereInput = {
    AND?: inducks_substoryWhereInput | inducks_substoryWhereInput[]
    OR?: inducks_substoryWhereInput[]
    NOT?: inducks_substoryWhereInput | inducks_substoryWhereInput[]
    storycode?: StringFilter<"inducks_substory"> | string
    originalstoryversioncode?: StringNullableFilter<"inducks_substory"> | string | null
    superstorycode?: StringNullableFilter<"inducks_substory"> | string | null
    part?: StringNullableFilter<"inducks_substory"> | string | null
    firstpublicationdate?: StringNullableFilter<"inducks_substory"> | string | null
    title?: StringNullableFilter<"inducks_substory"> | string | null
    substorycomment?: StringNullableFilter<"inducks_substory"> | string | null
    error?: Enuminducks_substory_errorNullableFilter<"inducks_substory"> | $Enums.inducks_substory_error | null
    locked?: Enuminducks_substory_lockedNullableFilter<"inducks_substory"> | $Enums.inducks_substory_locked | null
    inputfilecode?: IntNullableFilter<"inducks_substory"> | number | null
    maintenanceteamcode?: StringNullableFilter<"inducks_substory"> | string | null
  }

  export type inducks_substoryOrderByWithRelationInput = {
    storycode?: SortOrder
    originalstoryversioncode?: SortOrderInput | SortOrder
    superstorycode?: SortOrderInput | SortOrder
    part?: SortOrderInput | SortOrder
    firstpublicationdate?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    substorycomment?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    locked?: SortOrderInput | SortOrder
    inputfilecode?: SortOrderInput | SortOrder
    maintenanceteamcode?: SortOrderInput | SortOrder
  }

  export type inducks_substoryWhereUniqueInput = Prisma.AtLeast<{
    storycode?: string
    AND?: inducks_substoryWhereInput | inducks_substoryWhereInput[]
    OR?: inducks_substoryWhereInput[]
    NOT?: inducks_substoryWhereInput | inducks_substoryWhereInput[]
    originalstoryversioncode?: StringNullableFilter<"inducks_substory"> | string | null
    superstorycode?: StringNullableFilter<"inducks_substory"> | string | null
    part?: StringNullableFilter<"inducks_substory"> | string | null
    firstpublicationdate?: StringNullableFilter<"inducks_substory"> | string | null
    title?: StringNullableFilter<"inducks_substory"> | string | null
    substorycomment?: StringNullableFilter<"inducks_substory"> | string | null
    error?: Enuminducks_substory_errorNullableFilter<"inducks_substory"> | $Enums.inducks_substory_error | null
    locked?: Enuminducks_substory_lockedNullableFilter<"inducks_substory"> | $Enums.inducks_substory_locked | null
    inputfilecode?: IntNullableFilter<"inducks_substory"> | number | null
    maintenanceteamcode?: StringNullableFilter<"inducks_substory"> | string | null
  }, "storycode">

  export type inducks_substoryOrderByWithAggregationInput = {
    storycode?: SortOrder
    originalstoryversioncode?: SortOrderInput | SortOrder
    superstorycode?: SortOrderInput | SortOrder
    part?: SortOrderInput | SortOrder
    firstpublicationdate?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    substorycomment?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    locked?: SortOrderInput | SortOrder
    inputfilecode?: SortOrderInput | SortOrder
    maintenanceteamcode?: SortOrderInput | SortOrder
    _count?: inducks_substoryCountOrderByAggregateInput
    _avg?: inducks_substoryAvgOrderByAggregateInput
    _max?: inducks_substoryMaxOrderByAggregateInput
    _min?: inducks_substoryMinOrderByAggregateInput
    _sum?: inducks_substorySumOrderByAggregateInput
  }

  export type inducks_substoryScalarWhereWithAggregatesInput = {
    AND?: inducks_substoryScalarWhereWithAggregatesInput | inducks_substoryScalarWhereWithAggregatesInput[]
    OR?: inducks_substoryScalarWhereWithAggregatesInput[]
    NOT?: inducks_substoryScalarWhereWithAggregatesInput | inducks_substoryScalarWhereWithAggregatesInput[]
    storycode?: StringWithAggregatesFilter<"inducks_substory"> | string
    originalstoryversioncode?: StringNullableWithAggregatesFilter<"inducks_substory"> | string | null
    superstorycode?: StringNullableWithAggregatesFilter<"inducks_substory"> | string | null
    part?: StringNullableWithAggregatesFilter<"inducks_substory"> | string | null
    firstpublicationdate?: StringNullableWithAggregatesFilter<"inducks_substory"> | string | null
    title?: StringNullableWithAggregatesFilter<"inducks_substory"> | string | null
    substorycomment?: StringNullableWithAggregatesFilter<"inducks_substory"> | string | null
    error?: Enuminducks_substory_errorNullableWithAggregatesFilter<"inducks_substory"> | $Enums.inducks_substory_error | null
    locked?: Enuminducks_substory_lockedNullableWithAggregatesFilter<"inducks_substory"> | $Enums.inducks_substory_locked | null
    inputfilecode?: IntNullableWithAggregatesFilter<"inducks_substory"> | number | null
    maintenanceteamcode?: StringNullableWithAggregatesFilter<"inducks_substory"> | string | null
  }

  export type inducks_teamWhereInput = {
    AND?: inducks_teamWhereInput | inducks_teamWhereInput[]
    OR?: inducks_teamWhereInput[]
    NOT?: inducks_teamWhereInput | inducks_teamWhereInput[]
    teamcode?: StringFilter<"inducks_team"> | string
    teamdescriptionname?: StringNullableFilter<"inducks_team"> | string | null
    teamshortname?: StringNullableFilter<"inducks_team"> | string | null
  }

  export type inducks_teamOrderByWithRelationInput = {
    teamcode?: SortOrder
    teamdescriptionname?: SortOrderInput | SortOrder
    teamshortname?: SortOrderInput | SortOrder
  }

  export type inducks_teamWhereUniqueInput = Prisma.AtLeast<{
    teamcode?: string
    AND?: inducks_teamWhereInput | inducks_teamWhereInput[]
    OR?: inducks_teamWhereInput[]
    NOT?: inducks_teamWhereInput | inducks_teamWhereInput[]
    teamdescriptionname?: StringNullableFilter<"inducks_team"> | string | null
    teamshortname?: StringNullableFilter<"inducks_team"> | string | null
  }, "teamcode">

  export type inducks_teamOrderByWithAggregationInput = {
    teamcode?: SortOrder
    teamdescriptionname?: SortOrderInput | SortOrder
    teamshortname?: SortOrderInput | SortOrder
    _count?: inducks_teamCountOrderByAggregateInput
    _max?: inducks_teamMaxOrderByAggregateInput
    _min?: inducks_teamMinOrderByAggregateInput
  }

  export type inducks_teamScalarWhereWithAggregatesInput = {
    AND?: inducks_teamScalarWhereWithAggregatesInput | inducks_teamScalarWhereWithAggregatesInput[]
    OR?: inducks_teamScalarWhereWithAggregatesInput[]
    NOT?: inducks_teamScalarWhereWithAggregatesInput | inducks_teamScalarWhereWithAggregatesInput[]
    teamcode?: StringWithAggregatesFilter<"inducks_team"> | string
    teamdescriptionname?: StringNullableWithAggregatesFilter<"inducks_team"> | string | null
    teamshortname?: StringNullableWithAggregatesFilter<"inducks_team"> | string | null
  }

  export type inducks_teammemberWhereInput = {
    AND?: inducks_teammemberWhereInput | inducks_teammemberWhereInput[]
    OR?: inducks_teammemberWhereInput[]
    NOT?: inducks_teammemberWhereInput | inducks_teammemberWhereInput[]
    teamcode?: StringFilter<"inducks_teammember"> | string
    personcode?: StringNullableFilter<"inducks_teammember"> | string | null
  }

  export type inducks_teammemberOrderByWithRelationInput = {
    teamcode?: SortOrder
    personcode?: SortOrderInput | SortOrder
  }

  export type inducks_teammemberWhereUniqueInput = Prisma.AtLeast<{
    teamcode?: string
    AND?: inducks_teammemberWhereInput | inducks_teammemberWhereInput[]
    OR?: inducks_teammemberWhereInput[]
    NOT?: inducks_teammemberWhereInput | inducks_teammemberWhereInput[]
    personcode?: StringNullableFilter<"inducks_teammember"> | string | null
  }, "teamcode">

  export type inducks_teammemberOrderByWithAggregationInput = {
    teamcode?: SortOrder
    personcode?: SortOrderInput | SortOrder
    _count?: inducks_teammemberCountOrderByAggregateInput
    _max?: inducks_teammemberMaxOrderByAggregateInput
    _min?: inducks_teammemberMinOrderByAggregateInput
  }

  export type inducks_teammemberScalarWhereWithAggregatesInput = {
    AND?: inducks_teammemberScalarWhereWithAggregatesInput | inducks_teammemberScalarWhereWithAggregatesInput[]
    OR?: inducks_teammemberScalarWhereWithAggregatesInput[]
    NOT?: inducks_teammemberScalarWhereWithAggregatesInput | inducks_teammemberScalarWhereWithAggregatesInput[]
    teamcode?: StringWithAggregatesFilter<"inducks_teammember"> | string
    personcode?: StringNullableWithAggregatesFilter<"inducks_teammember"> | string | null
  }

  export type inducks_ucrelationWhereInput = {
    AND?: inducks_ucrelationWhereInput | inducks_ucrelationWhereInput[]
    OR?: inducks_ucrelationWhereInput[]
    NOT?: inducks_ucrelationWhereInput | inducks_ucrelationWhereInput[]
    universecode?: StringFilter<"inducks_ucrelation"> | string
    charactercode?: StringFilter<"inducks_ucrelation"> | string
  }

  export type inducks_ucrelationOrderByWithRelationInput = {
    universecode?: SortOrder
    charactercode?: SortOrder
  }

  export type inducks_ucrelationWhereUniqueInput = Prisma.AtLeast<{
    universecode_charactercode?: inducks_ucrelationUniversecodeCharactercodeCompoundUniqueInput
    AND?: inducks_ucrelationWhereInput | inducks_ucrelationWhereInput[]
    OR?: inducks_ucrelationWhereInput[]
    NOT?: inducks_ucrelationWhereInput | inducks_ucrelationWhereInput[]
    universecode?: StringFilter<"inducks_ucrelation"> | string
    charactercode?: StringFilter<"inducks_ucrelation"> | string
  }, "universecode_charactercode">

  export type inducks_ucrelationOrderByWithAggregationInput = {
    universecode?: SortOrder
    charactercode?: SortOrder
    _count?: inducks_ucrelationCountOrderByAggregateInput
    _max?: inducks_ucrelationMaxOrderByAggregateInput
    _min?: inducks_ucrelationMinOrderByAggregateInput
  }

  export type inducks_ucrelationScalarWhereWithAggregatesInput = {
    AND?: inducks_ucrelationScalarWhereWithAggregatesInput | inducks_ucrelationScalarWhereWithAggregatesInput[]
    OR?: inducks_ucrelationScalarWhereWithAggregatesInput[]
    NOT?: inducks_ucrelationScalarWhereWithAggregatesInput | inducks_ucrelationScalarWhereWithAggregatesInput[]
    universecode?: StringWithAggregatesFilter<"inducks_ucrelation"> | string
    charactercode?: StringWithAggregatesFilter<"inducks_ucrelation"> | string
  }

  export type inducks_universeWhereInput = {
    AND?: inducks_universeWhereInput | inducks_universeWhereInput[]
    OR?: inducks_universeWhereInput[]
    NOT?: inducks_universeWhereInput | inducks_universeWhereInput[]
    universecode?: StringFilter<"inducks_universe"> | string
    universecomment?: StringNullableFilter<"inducks_universe"> | string | null
  }

  export type inducks_universeOrderByWithRelationInput = {
    universecode?: SortOrder
    universecomment?: SortOrderInput | SortOrder
  }

  export type inducks_universeWhereUniqueInput = Prisma.AtLeast<{
    universecode?: string
    AND?: inducks_universeWhereInput | inducks_universeWhereInput[]
    OR?: inducks_universeWhereInput[]
    NOT?: inducks_universeWhereInput | inducks_universeWhereInput[]
    universecomment?: StringNullableFilter<"inducks_universe"> | string | null
  }, "universecode">

  export type inducks_universeOrderByWithAggregationInput = {
    universecode?: SortOrder
    universecomment?: SortOrderInput | SortOrder
    _count?: inducks_universeCountOrderByAggregateInput
    _max?: inducks_universeMaxOrderByAggregateInput
    _min?: inducks_universeMinOrderByAggregateInput
  }

  export type inducks_universeScalarWhereWithAggregatesInput = {
    AND?: inducks_universeScalarWhereWithAggregatesInput | inducks_universeScalarWhereWithAggregatesInput[]
    OR?: inducks_universeScalarWhereWithAggregatesInput[]
    NOT?: inducks_universeScalarWhereWithAggregatesInput | inducks_universeScalarWhereWithAggregatesInput[]
    universecode?: StringWithAggregatesFilter<"inducks_universe"> | string
    universecomment?: StringNullableWithAggregatesFilter<"inducks_universe"> | string | null
  }

  export type inducks_universenameWhereInput = {
    AND?: inducks_universenameWhereInput | inducks_universenameWhereInput[]
    OR?: inducks_universenameWhereInput[]
    NOT?: inducks_universenameWhereInput | inducks_universenameWhereInput[]
    universecode?: StringFilter<"inducks_universename"> | string
    languagecode?: StringFilter<"inducks_universename"> | string
    universename?: StringNullableFilter<"inducks_universename"> | string | null
  }

  export type inducks_universenameOrderByWithRelationInput = {
    universecode?: SortOrder
    languagecode?: SortOrder
    universename?: SortOrderInput | SortOrder
  }

  export type inducks_universenameWhereUniqueInput = Prisma.AtLeast<{
    universecode_languagecode?: inducks_universenameUniversecodeLanguagecodeCompoundUniqueInput
    AND?: inducks_universenameWhereInput | inducks_universenameWhereInput[]
    OR?: inducks_universenameWhereInput[]
    NOT?: inducks_universenameWhereInput | inducks_universenameWhereInput[]
    universecode?: StringFilter<"inducks_universename"> | string
    languagecode?: StringFilter<"inducks_universename"> | string
    universename?: StringNullableFilter<"inducks_universename"> | string | null
  }, "universecode_languagecode">

  export type inducks_universenameOrderByWithAggregationInput = {
    universecode?: SortOrder
    languagecode?: SortOrder
    universename?: SortOrderInput | SortOrder
    _count?: inducks_universenameCountOrderByAggregateInput
    _max?: inducks_universenameMaxOrderByAggregateInput
    _min?: inducks_universenameMinOrderByAggregateInput
  }

  export type inducks_universenameScalarWhereWithAggregatesInput = {
    AND?: inducks_universenameScalarWhereWithAggregatesInput | inducks_universenameScalarWhereWithAggregatesInput[]
    OR?: inducks_universenameScalarWhereWithAggregatesInput[]
    NOT?: inducks_universenameScalarWhereWithAggregatesInput | inducks_universenameScalarWhereWithAggregatesInput[]
    universecode?: StringWithAggregatesFilter<"inducks_universename"> | string
    languagecode?: StringWithAggregatesFilter<"inducks_universename"> | string
    universename?: StringNullableWithAggregatesFilter<"inducks_universename"> | string | null
  }

  export type numeros_cptWhereInput = {
    AND?: numeros_cptWhereInput | numeros_cptWhereInput[]
    OR?: numeros_cptWhereInput[]
    NOT?: numeros_cptWhereInput | numeros_cptWhereInput[]
    Pays?: StringFilter<"numeros_cpt"> | string
    Magazine?: StringFilter<"numeros_cpt"> | string
    publicationcode?: StringFilter<"numeros_cpt"> | string
    Numero?: StringFilter<"numeros_cpt"> | string
    Cpt?: IntNullableFilter<"numeros_cpt"> | number | null
  }

  export type numeros_cptOrderByWithRelationInput = {
    Pays?: SortOrder
    Magazine?: SortOrder
    publicationcode?: SortOrder
    Numero?: SortOrder
    Cpt?: SortOrderInput | SortOrder
  }

  export type numeros_cptWhereUniqueInput = Prisma.AtLeast<{
    publicationcode_Numero?: numeros_cptPublicationcodeNumeroCompoundUniqueInput
    AND?: numeros_cptWhereInput | numeros_cptWhereInput[]
    OR?: numeros_cptWhereInput[]
    NOT?: numeros_cptWhereInput | numeros_cptWhereInput[]
    Pays?: StringFilter<"numeros_cpt"> | string
    Magazine?: StringFilter<"numeros_cpt"> | string
    publicationcode?: StringFilter<"numeros_cpt"> | string
    Numero?: StringFilter<"numeros_cpt"> | string
    Cpt?: IntNullableFilter<"numeros_cpt"> | number | null
  }, "publicationcode_Numero">

  export type numeros_cptOrderByWithAggregationInput = {
    Pays?: SortOrder
    Magazine?: SortOrder
    publicationcode?: SortOrder
    Numero?: SortOrder
    Cpt?: SortOrderInput | SortOrder
    _count?: numeros_cptCountOrderByAggregateInput
    _avg?: numeros_cptAvgOrderByAggregateInput
    _max?: numeros_cptMaxOrderByAggregateInput
    _min?: numeros_cptMinOrderByAggregateInput
    _sum?: numeros_cptSumOrderByAggregateInput
  }

  export type numeros_cptScalarWhereWithAggregatesInput = {
    AND?: numeros_cptScalarWhereWithAggregatesInput | numeros_cptScalarWhereWithAggregatesInput[]
    OR?: numeros_cptScalarWhereWithAggregatesInput[]
    NOT?: numeros_cptScalarWhereWithAggregatesInput | numeros_cptScalarWhereWithAggregatesInput[]
    Pays?: StringWithAggregatesFilter<"numeros_cpt"> | string
    Magazine?: StringWithAggregatesFilter<"numeros_cpt"> | string
    publicationcode?: StringWithAggregatesFilter<"numeros_cpt"> | string
    Numero?: StringWithAggregatesFilter<"numeros_cpt"> | string
    Cpt?: IntNullableWithAggregatesFilter<"numeros_cpt"> | number | null
  }

  export type datasets_entryurlsCreateInput = {
    dataset_id: number
    sitecode_url: string
  }

  export type datasets_entryurlsUncheckedCreateInput = {
    id?: number
    dataset_id: number
    sitecode_url: string
  }

  export type datasets_entryurlsUpdateInput = {
    dataset_id?: IntFieldUpdateOperationsInput | number
    sitecode_url?: StringFieldUpdateOperationsInput | string
  }

  export type datasets_entryurlsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dataset_id?: IntFieldUpdateOperationsInput | number
    sitecode_url?: StringFieldUpdateOperationsInput | string
  }

  export type datasets_entryurlsCreateManyInput = {
    id?: number
    dataset_id: number
    sitecode_url: string
  }

  export type datasets_entryurlsUpdateManyMutationInput = {
    dataset_id?: IntFieldUpdateOperationsInput | number
    sitecode_url?: StringFieldUpdateOperationsInput | string
  }

  export type datasets_entryurlsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dataset_id?: IntFieldUpdateOperationsInput | number
    sitecode_url?: StringFieldUpdateOperationsInput | string
  }

  export type inducks_appearanceCreateInput = {
    storyversioncode: string
    charactercode: string
    number?: number | null
    appearancecomment?: string | null
    doubt?: $Enums.inducks_appearance_doubt | null
  }

  export type inducks_appearanceUncheckedCreateInput = {
    storyversioncode: string
    charactercode: string
    number?: number | null
    appearancecomment?: string | null
    doubt?: $Enums.inducks_appearance_doubt | null
  }

  export type inducks_appearanceUpdateInput = {
    storyversioncode?: StringFieldUpdateOperationsInput | string
    charactercode?: StringFieldUpdateOperationsInput | string
    number?: NullableIntFieldUpdateOperationsInput | number | null
    appearancecomment?: NullableStringFieldUpdateOperationsInput | string | null
    doubt?: NullableEnuminducks_appearance_doubtFieldUpdateOperationsInput | $Enums.inducks_appearance_doubt | null
  }

  export type inducks_appearanceUncheckedUpdateInput = {
    storyversioncode?: StringFieldUpdateOperationsInput | string
    charactercode?: StringFieldUpdateOperationsInput | string
    number?: NullableIntFieldUpdateOperationsInput | number | null
    appearancecomment?: NullableStringFieldUpdateOperationsInput | string | null
    doubt?: NullableEnuminducks_appearance_doubtFieldUpdateOperationsInput | $Enums.inducks_appearance_doubt | null
  }

  export type inducks_appearanceCreateManyInput = {
    storyversioncode: string
    charactercode: string
    number?: number | null
    appearancecomment?: string | null
    doubt?: $Enums.inducks_appearance_doubt | null
  }

  export type inducks_appearanceUpdateManyMutationInput = {
    storyversioncode?: StringFieldUpdateOperationsInput | string
    charactercode?: StringFieldUpdateOperationsInput | string
    number?: NullableIntFieldUpdateOperationsInput | number | null
    appearancecomment?: NullableStringFieldUpdateOperationsInput | string | null
    doubt?: NullableEnuminducks_appearance_doubtFieldUpdateOperationsInput | $Enums.inducks_appearance_doubt | null
  }

  export type inducks_appearanceUncheckedUpdateManyInput = {
    storyversioncode?: StringFieldUpdateOperationsInput | string
    charactercode?: StringFieldUpdateOperationsInput | string
    number?: NullableIntFieldUpdateOperationsInput | number | null
    appearancecomment?: NullableStringFieldUpdateOperationsInput | string | null
    doubt?: NullableEnuminducks_appearance_doubtFieldUpdateOperationsInput | $Enums.inducks_appearance_doubt | null
  }

  export type inducks_characterCreateInput = {
    charactercode: string
    charactername?: string | null
    official?: $Enums.inducks_character_official | null
    onetime?: $Enums.inducks_character_onetime | null
    heroonly?: $Enums.inducks_character_heroonly | null
    charactercomment?: string | null
  }

  export type inducks_characterUncheckedCreateInput = {
    charactercode: string
    charactername?: string | null
    official?: $Enums.inducks_character_official | null
    onetime?: $Enums.inducks_character_onetime | null
    heroonly?: $Enums.inducks_character_heroonly | null
    charactercomment?: string | null
  }

  export type inducks_characterUpdateInput = {
    charactercode?: StringFieldUpdateOperationsInput | string
    charactername?: NullableStringFieldUpdateOperationsInput | string | null
    official?: NullableEnuminducks_character_officialFieldUpdateOperationsInput | $Enums.inducks_character_official | null
    onetime?: NullableEnuminducks_character_onetimeFieldUpdateOperationsInput | $Enums.inducks_character_onetime | null
    heroonly?: NullableEnuminducks_character_heroonlyFieldUpdateOperationsInput | $Enums.inducks_character_heroonly | null
    charactercomment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_characterUncheckedUpdateInput = {
    charactercode?: StringFieldUpdateOperationsInput | string
    charactername?: NullableStringFieldUpdateOperationsInput | string | null
    official?: NullableEnuminducks_character_officialFieldUpdateOperationsInput | $Enums.inducks_character_official | null
    onetime?: NullableEnuminducks_character_onetimeFieldUpdateOperationsInput | $Enums.inducks_character_onetime | null
    heroonly?: NullableEnuminducks_character_heroonlyFieldUpdateOperationsInput | $Enums.inducks_character_heroonly | null
    charactercomment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_characterCreateManyInput = {
    charactercode: string
    charactername?: string | null
    official?: $Enums.inducks_character_official | null
    onetime?: $Enums.inducks_character_onetime | null
    heroonly?: $Enums.inducks_character_heroonly | null
    charactercomment?: string | null
  }

  export type inducks_characterUpdateManyMutationInput = {
    charactercode?: StringFieldUpdateOperationsInput | string
    charactername?: NullableStringFieldUpdateOperationsInput | string | null
    official?: NullableEnuminducks_character_officialFieldUpdateOperationsInput | $Enums.inducks_character_official | null
    onetime?: NullableEnuminducks_character_onetimeFieldUpdateOperationsInput | $Enums.inducks_character_onetime | null
    heroonly?: NullableEnuminducks_character_heroonlyFieldUpdateOperationsInput | $Enums.inducks_character_heroonly | null
    charactercomment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_characterUncheckedUpdateManyInput = {
    charactercode?: StringFieldUpdateOperationsInput | string
    charactername?: NullableStringFieldUpdateOperationsInput | string | null
    official?: NullableEnuminducks_character_officialFieldUpdateOperationsInput | $Enums.inducks_character_official | null
    onetime?: NullableEnuminducks_character_onetimeFieldUpdateOperationsInput | $Enums.inducks_character_onetime | null
    heroonly?: NullableEnuminducks_character_heroonlyFieldUpdateOperationsInput | $Enums.inducks_character_heroonly | null
    charactercomment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_characteraliasCreateInput = {
    charactercode?: string | null
    charactername: string
  }

  export type inducks_characteraliasUncheckedCreateInput = {
    charactercode?: string | null
    charactername: string
  }

  export type inducks_characteraliasUpdateInput = {
    charactercode?: NullableStringFieldUpdateOperationsInput | string | null
    charactername?: StringFieldUpdateOperationsInput | string
  }

  export type inducks_characteraliasUncheckedUpdateInput = {
    charactercode?: NullableStringFieldUpdateOperationsInput | string | null
    charactername?: StringFieldUpdateOperationsInput | string
  }

  export type inducks_characteraliasCreateManyInput = {
    charactercode?: string | null
    charactername: string
  }

  export type inducks_characteraliasUpdateManyMutationInput = {
    charactercode?: NullableStringFieldUpdateOperationsInput | string | null
    charactername?: StringFieldUpdateOperationsInput | string
  }

  export type inducks_characteraliasUncheckedUpdateManyInput = {
    charactercode?: NullableStringFieldUpdateOperationsInput | string | null
    charactername?: StringFieldUpdateOperationsInput | string
  }

  export type inducks_characterdetailCreateInput = {
    charactername?: string | null
    charactercode: string
    number?: number | null
  }

  export type inducks_characterdetailUncheckedCreateInput = {
    charactername?: string | null
    charactercode: string
    number?: number | null
  }

  export type inducks_characterdetailUpdateInput = {
    charactername?: NullableStringFieldUpdateOperationsInput | string | null
    charactercode?: StringFieldUpdateOperationsInput | string
    number?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type inducks_characterdetailUncheckedUpdateInput = {
    charactername?: NullableStringFieldUpdateOperationsInput | string | null
    charactercode?: StringFieldUpdateOperationsInput | string
    number?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type inducks_characterdetailCreateManyInput = {
    charactername?: string | null
    charactercode: string
    number?: number | null
  }

  export type inducks_characterdetailUpdateManyMutationInput = {
    charactername?: NullableStringFieldUpdateOperationsInput | string | null
    charactercode?: StringFieldUpdateOperationsInput | string
    number?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type inducks_characterdetailUncheckedUpdateManyInput = {
    charactername?: NullableStringFieldUpdateOperationsInput | string | null
    charactercode?: StringFieldUpdateOperationsInput | string
    number?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type inducks_characternameCreateInput = {
    charactercode: string
    languagecode: string
    charactername: string
    preferred?: $Enums.inducks_charactername_preferred | null
    characternamecomment?: string | null
  }

  export type inducks_characternameUncheckedCreateInput = {
    charactercode: string
    languagecode: string
    charactername: string
    preferred?: $Enums.inducks_charactername_preferred | null
    characternamecomment?: string | null
  }

  export type inducks_characternameUpdateInput = {
    charactercode?: StringFieldUpdateOperationsInput | string
    languagecode?: StringFieldUpdateOperationsInput | string
    charactername?: StringFieldUpdateOperationsInput | string
    preferred?: NullableEnuminducks_charactername_preferredFieldUpdateOperationsInput | $Enums.inducks_charactername_preferred | null
    characternamecomment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_characternameUncheckedUpdateInput = {
    charactercode?: StringFieldUpdateOperationsInput | string
    languagecode?: StringFieldUpdateOperationsInput | string
    charactername?: StringFieldUpdateOperationsInput | string
    preferred?: NullableEnuminducks_charactername_preferredFieldUpdateOperationsInput | $Enums.inducks_charactername_preferred | null
    characternamecomment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_characternameCreateManyInput = {
    charactercode: string
    languagecode: string
    charactername: string
    preferred?: $Enums.inducks_charactername_preferred | null
    characternamecomment?: string | null
  }

  export type inducks_characternameUpdateManyMutationInput = {
    charactercode?: StringFieldUpdateOperationsInput | string
    languagecode?: StringFieldUpdateOperationsInput | string
    charactername?: StringFieldUpdateOperationsInput | string
    preferred?: NullableEnuminducks_charactername_preferredFieldUpdateOperationsInput | $Enums.inducks_charactername_preferred | null
    characternamecomment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_characternameUncheckedUpdateManyInput = {
    charactercode?: StringFieldUpdateOperationsInput | string
    languagecode?: StringFieldUpdateOperationsInput | string
    charactername?: StringFieldUpdateOperationsInput | string
    preferred?: NullableEnuminducks_charactername_preferredFieldUpdateOperationsInput | $Enums.inducks_charactername_preferred | null
    characternamecomment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_characterreferenceCreateInput = {
    fromcharactercode: string
    tocharactercode: string
    isgroupofcharacters?: $Enums.inducks_characterreference_isgroupofcharacters | null
  }

  export type inducks_characterreferenceUncheckedCreateInput = {
    fromcharactercode: string
    tocharactercode: string
    isgroupofcharacters?: $Enums.inducks_characterreference_isgroupofcharacters | null
  }

  export type inducks_characterreferenceUpdateInput = {
    fromcharactercode?: StringFieldUpdateOperationsInput | string
    tocharactercode?: StringFieldUpdateOperationsInput | string
    isgroupofcharacters?: NullableEnuminducks_characterreference_isgroupofcharactersFieldUpdateOperationsInput | $Enums.inducks_characterreference_isgroupofcharacters | null
  }

  export type inducks_characterreferenceUncheckedUpdateInput = {
    fromcharactercode?: StringFieldUpdateOperationsInput | string
    tocharactercode?: StringFieldUpdateOperationsInput | string
    isgroupofcharacters?: NullableEnuminducks_characterreference_isgroupofcharactersFieldUpdateOperationsInput | $Enums.inducks_characterreference_isgroupofcharacters | null
  }

  export type inducks_characterreferenceCreateManyInput = {
    fromcharactercode: string
    tocharactercode: string
    isgroupofcharacters?: $Enums.inducks_characterreference_isgroupofcharacters | null
  }

  export type inducks_characterreferenceUpdateManyMutationInput = {
    fromcharactercode?: StringFieldUpdateOperationsInput | string
    tocharactercode?: StringFieldUpdateOperationsInput | string
    isgroupofcharacters?: NullableEnuminducks_characterreference_isgroupofcharactersFieldUpdateOperationsInput | $Enums.inducks_characterreference_isgroupofcharacters | null
  }

  export type inducks_characterreferenceUncheckedUpdateManyInput = {
    fromcharactercode?: StringFieldUpdateOperationsInput | string
    tocharactercode?: StringFieldUpdateOperationsInput | string
    isgroupofcharacters?: NullableEnuminducks_characterreference_isgroupofcharactersFieldUpdateOperationsInput | $Enums.inducks_characterreference_isgroupofcharacters | null
  }

  export type inducks_characterurlCreateInput = {
    charactercode: string
    sitecode: string
    url?: string | null
  }

  export type inducks_characterurlUncheckedCreateInput = {
    charactercode: string
    sitecode: string
    url?: string | null
  }

  export type inducks_characterurlUpdateInput = {
    charactercode?: StringFieldUpdateOperationsInput | string
    sitecode?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_characterurlUncheckedUpdateInput = {
    charactercode?: StringFieldUpdateOperationsInput | string
    sitecode?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_characterurlCreateManyInput = {
    charactercode: string
    sitecode: string
    url?: string | null
  }

  export type inducks_characterurlUpdateManyMutationInput = {
    charactercode?: StringFieldUpdateOperationsInput | string
    sitecode?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_characterurlUncheckedUpdateManyInput = {
    charactercode?: StringFieldUpdateOperationsInput | string
    sitecode?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_countryCreateInput = {
    countrycode: string
    countryname?: string | null
    defaultlanguage?: string | null
    defaultmaintenanceteam?: string | null
  }

  export type inducks_countryUncheckedCreateInput = {
    countrycode: string
    countryname?: string | null
    defaultlanguage?: string | null
    defaultmaintenanceteam?: string | null
  }

  export type inducks_countryUpdateInput = {
    countrycode?: StringFieldUpdateOperationsInput | string
    countryname?: NullableStringFieldUpdateOperationsInput | string | null
    defaultlanguage?: NullableStringFieldUpdateOperationsInput | string | null
    defaultmaintenanceteam?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_countryUncheckedUpdateInput = {
    countrycode?: StringFieldUpdateOperationsInput | string
    countryname?: NullableStringFieldUpdateOperationsInput | string | null
    defaultlanguage?: NullableStringFieldUpdateOperationsInput | string | null
    defaultmaintenanceteam?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_countryCreateManyInput = {
    countrycode: string
    countryname?: string | null
    defaultlanguage?: string | null
    defaultmaintenanceteam?: string | null
  }

  export type inducks_countryUpdateManyMutationInput = {
    countrycode?: StringFieldUpdateOperationsInput | string
    countryname?: NullableStringFieldUpdateOperationsInput | string | null
    defaultlanguage?: NullableStringFieldUpdateOperationsInput | string | null
    defaultmaintenanceteam?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_countryUncheckedUpdateManyInput = {
    countrycode?: StringFieldUpdateOperationsInput | string
    countryname?: NullableStringFieldUpdateOperationsInput | string | null
    defaultlanguage?: NullableStringFieldUpdateOperationsInput | string | null
    defaultmaintenanceteam?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_countrynameCreateInput = {
    countrycode: string
    languagecode: string
    countryname?: string | null
  }

  export type inducks_countrynameUncheckedCreateInput = {
    countrycode: string
    languagecode: string
    countryname?: string | null
  }

  export type inducks_countrynameUpdateInput = {
    countrycode?: StringFieldUpdateOperationsInput | string
    languagecode?: StringFieldUpdateOperationsInput | string
    countryname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_countrynameUncheckedUpdateInput = {
    countrycode?: StringFieldUpdateOperationsInput | string
    languagecode?: StringFieldUpdateOperationsInput | string
    countryname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_countrynameCreateManyInput = {
    countrycode: string
    languagecode: string
    countryname?: string | null
  }

  export type inducks_countrynameUpdateManyMutationInput = {
    countrycode?: StringFieldUpdateOperationsInput | string
    languagecode?: StringFieldUpdateOperationsInput | string
    countryname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_countrynameUncheckedUpdateManyInput = {
    countrycode?: StringFieldUpdateOperationsInput | string
    languagecode?: StringFieldUpdateOperationsInput | string
    countryname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_currencyCreateInput = {
    currencycode: string
    currencyname?: string | null
  }

  export type inducks_currencyUncheckedCreateInput = {
    currencycode: string
    currencyname?: string | null
  }

  export type inducks_currencyUpdateInput = {
    currencycode?: StringFieldUpdateOperationsInput | string
    currencyname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_currencyUncheckedUpdateInput = {
    currencycode?: StringFieldUpdateOperationsInput | string
    currencyname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_currencyCreateManyInput = {
    currencycode: string
    currencyname?: string | null
  }

  export type inducks_currencyUpdateManyMutationInput = {
    currencycode?: StringFieldUpdateOperationsInput | string
    currencyname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_currencyUncheckedUpdateManyInput = {
    currencycode?: StringFieldUpdateOperationsInput | string
    currencyname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_currencynameCreateInput = {
    currencycode: string
    languagecode: string
    shortcurrencyname?: string | null
    longcurrencyname?: string | null
  }

  export type inducks_currencynameUncheckedCreateInput = {
    currencycode: string
    languagecode: string
    shortcurrencyname?: string | null
    longcurrencyname?: string | null
  }

  export type inducks_currencynameUpdateInput = {
    currencycode?: StringFieldUpdateOperationsInput | string
    languagecode?: StringFieldUpdateOperationsInput | string
    shortcurrencyname?: NullableStringFieldUpdateOperationsInput | string | null
    longcurrencyname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_currencynameUncheckedUpdateInput = {
    currencycode?: StringFieldUpdateOperationsInput | string
    languagecode?: StringFieldUpdateOperationsInput | string
    shortcurrencyname?: NullableStringFieldUpdateOperationsInput | string | null
    longcurrencyname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_currencynameCreateManyInput = {
    currencycode: string
    languagecode: string
    shortcurrencyname?: string | null
    longcurrencyname?: string | null
  }

  export type inducks_currencynameUpdateManyMutationInput = {
    currencycode?: StringFieldUpdateOperationsInput | string
    languagecode?: StringFieldUpdateOperationsInput | string
    shortcurrencyname?: NullableStringFieldUpdateOperationsInput | string | null
    longcurrencyname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_currencynameUncheckedUpdateManyInput = {
    currencycode?: StringFieldUpdateOperationsInput | string
    languagecode?: StringFieldUpdateOperationsInput | string
    shortcurrencyname?: NullableStringFieldUpdateOperationsInput | string | null
    longcurrencyname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_entryCreateInput = {
    entrycode: string
    issuecode?: string | null
    storyversioncode?: string | null
    languagecode?: string | null
    includedinentrycode?: string | null
    position?: string | null
    printedcode?: string | null
    guessedcode?: string | null
    title?: string | null
    reallytitle?: $Enums.inducks_entry_reallytitle | null
    printedhero?: string | null
    changes?: string | null
    cut?: string | null
    minorchanges?: string | null
    missingpanels?: string | null
    mirrored?: $Enums.inducks_entry_mirrored | null
    sideways?: $Enums.inducks_entry_sideways | null
    startdate?: string | null
    enddate?: string | null
    identificationuncertain?: $Enums.inducks_entry_identificationuncertain | null
    alsoreprint?: string | null
    part?: string | null
    entrycomment?: string | null
    error?: $Enums.inducks_entry_error | null
  }

  export type inducks_entryUncheckedCreateInput = {
    entrycode: string
    issuecode?: string | null
    storyversioncode?: string | null
    languagecode?: string | null
    includedinentrycode?: string | null
    position?: string | null
    printedcode?: string | null
    guessedcode?: string | null
    title?: string | null
    reallytitle?: $Enums.inducks_entry_reallytitle | null
    printedhero?: string | null
    changes?: string | null
    cut?: string | null
    minorchanges?: string | null
    missingpanels?: string | null
    mirrored?: $Enums.inducks_entry_mirrored | null
    sideways?: $Enums.inducks_entry_sideways | null
    startdate?: string | null
    enddate?: string | null
    identificationuncertain?: $Enums.inducks_entry_identificationuncertain | null
    alsoreprint?: string | null
    part?: string | null
    entrycomment?: string | null
    error?: $Enums.inducks_entry_error | null
  }

  export type inducks_entryUpdateInput = {
    entrycode?: StringFieldUpdateOperationsInput | string
    issuecode?: NullableStringFieldUpdateOperationsInput | string | null
    storyversioncode?: NullableStringFieldUpdateOperationsInput | string | null
    languagecode?: NullableStringFieldUpdateOperationsInput | string | null
    includedinentrycode?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    printedcode?: NullableStringFieldUpdateOperationsInput | string | null
    guessedcode?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    reallytitle?: NullableEnuminducks_entry_reallytitleFieldUpdateOperationsInput | $Enums.inducks_entry_reallytitle | null
    printedhero?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableStringFieldUpdateOperationsInput | string | null
    cut?: NullableStringFieldUpdateOperationsInput | string | null
    minorchanges?: NullableStringFieldUpdateOperationsInput | string | null
    missingpanels?: NullableStringFieldUpdateOperationsInput | string | null
    mirrored?: NullableEnuminducks_entry_mirroredFieldUpdateOperationsInput | $Enums.inducks_entry_mirrored | null
    sideways?: NullableEnuminducks_entry_sidewaysFieldUpdateOperationsInput | $Enums.inducks_entry_sideways | null
    startdate?: NullableStringFieldUpdateOperationsInput | string | null
    enddate?: NullableStringFieldUpdateOperationsInput | string | null
    identificationuncertain?: NullableEnuminducks_entry_identificationuncertainFieldUpdateOperationsInput | $Enums.inducks_entry_identificationuncertain | null
    alsoreprint?: NullableStringFieldUpdateOperationsInput | string | null
    part?: NullableStringFieldUpdateOperationsInput | string | null
    entrycomment?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableEnuminducks_entry_errorFieldUpdateOperationsInput | $Enums.inducks_entry_error | null
  }

  export type inducks_entryUncheckedUpdateInput = {
    entrycode?: StringFieldUpdateOperationsInput | string
    issuecode?: NullableStringFieldUpdateOperationsInput | string | null
    storyversioncode?: NullableStringFieldUpdateOperationsInput | string | null
    languagecode?: NullableStringFieldUpdateOperationsInput | string | null
    includedinentrycode?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    printedcode?: NullableStringFieldUpdateOperationsInput | string | null
    guessedcode?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    reallytitle?: NullableEnuminducks_entry_reallytitleFieldUpdateOperationsInput | $Enums.inducks_entry_reallytitle | null
    printedhero?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableStringFieldUpdateOperationsInput | string | null
    cut?: NullableStringFieldUpdateOperationsInput | string | null
    minorchanges?: NullableStringFieldUpdateOperationsInput | string | null
    missingpanels?: NullableStringFieldUpdateOperationsInput | string | null
    mirrored?: NullableEnuminducks_entry_mirroredFieldUpdateOperationsInput | $Enums.inducks_entry_mirrored | null
    sideways?: NullableEnuminducks_entry_sidewaysFieldUpdateOperationsInput | $Enums.inducks_entry_sideways | null
    startdate?: NullableStringFieldUpdateOperationsInput | string | null
    enddate?: NullableStringFieldUpdateOperationsInput | string | null
    identificationuncertain?: NullableEnuminducks_entry_identificationuncertainFieldUpdateOperationsInput | $Enums.inducks_entry_identificationuncertain | null
    alsoreprint?: NullableStringFieldUpdateOperationsInput | string | null
    part?: NullableStringFieldUpdateOperationsInput | string | null
    entrycomment?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableEnuminducks_entry_errorFieldUpdateOperationsInput | $Enums.inducks_entry_error | null
  }

  export type inducks_entryCreateManyInput = {
    entrycode: string
    issuecode?: string | null
    storyversioncode?: string | null
    languagecode?: string | null
    includedinentrycode?: string | null
    position?: string | null
    printedcode?: string | null
    guessedcode?: string | null
    title?: string | null
    reallytitle?: $Enums.inducks_entry_reallytitle | null
    printedhero?: string | null
    changes?: string | null
    cut?: string | null
    minorchanges?: string | null
    missingpanels?: string | null
    mirrored?: $Enums.inducks_entry_mirrored | null
    sideways?: $Enums.inducks_entry_sideways | null
    startdate?: string | null
    enddate?: string | null
    identificationuncertain?: $Enums.inducks_entry_identificationuncertain | null
    alsoreprint?: string | null
    part?: string | null
    entrycomment?: string | null
    error?: $Enums.inducks_entry_error | null
  }

  export type inducks_entryUpdateManyMutationInput = {
    entrycode?: StringFieldUpdateOperationsInput | string
    issuecode?: NullableStringFieldUpdateOperationsInput | string | null
    storyversioncode?: NullableStringFieldUpdateOperationsInput | string | null
    languagecode?: NullableStringFieldUpdateOperationsInput | string | null
    includedinentrycode?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    printedcode?: NullableStringFieldUpdateOperationsInput | string | null
    guessedcode?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    reallytitle?: NullableEnuminducks_entry_reallytitleFieldUpdateOperationsInput | $Enums.inducks_entry_reallytitle | null
    printedhero?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableStringFieldUpdateOperationsInput | string | null
    cut?: NullableStringFieldUpdateOperationsInput | string | null
    minorchanges?: NullableStringFieldUpdateOperationsInput | string | null
    missingpanels?: NullableStringFieldUpdateOperationsInput | string | null
    mirrored?: NullableEnuminducks_entry_mirroredFieldUpdateOperationsInput | $Enums.inducks_entry_mirrored | null
    sideways?: NullableEnuminducks_entry_sidewaysFieldUpdateOperationsInput | $Enums.inducks_entry_sideways | null
    startdate?: NullableStringFieldUpdateOperationsInput | string | null
    enddate?: NullableStringFieldUpdateOperationsInput | string | null
    identificationuncertain?: NullableEnuminducks_entry_identificationuncertainFieldUpdateOperationsInput | $Enums.inducks_entry_identificationuncertain | null
    alsoreprint?: NullableStringFieldUpdateOperationsInput | string | null
    part?: NullableStringFieldUpdateOperationsInput | string | null
    entrycomment?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableEnuminducks_entry_errorFieldUpdateOperationsInput | $Enums.inducks_entry_error | null
  }

  export type inducks_entryUncheckedUpdateManyInput = {
    entrycode?: StringFieldUpdateOperationsInput | string
    issuecode?: NullableStringFieldUpdateOperationsInput | string | null
    storyversioncode?: NullableStringFieldUpdateOperationsInput | string | null
    languagecode?: NullableStringFieldUpdateOperationsInput | string | null
    includedinentrycode?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    printedcode?: NullableStringFieldUpdateOperationsInput | string | null
    guessedcode?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    reallytitle?: NullableEnuminducks_entry_reallytitleFieldUpdateOperationsInput | $Enums.inducks_entry_reallytitle | null
    printedhero?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableStringFieldUpdateOperationsInput | string | null
    cut?: NullableStringFieldUpdateOperationsInput | string | null
    minorchanges?: NullableStringFieldUpdateOperationsInput | string | null
    missingpanels?: NullableStringFieldUpdateOperationsInput | string | null
    mirrored?: NullableEnuminducks_entry_mirroredFieldUpdateOperationsInput | $Enums.inducks_entry_mirrored | null
    sideways?: NullableEnuminducks_entry_sidewaysFieldUpdateOperationsInput | $Enums.inducks_entry_sideways | null
    startdate?: NullableStringFieldUpdateOperationsInput | string | null
    enddate?: NullableStringFieldUpdateOperationsInput | string | null
    identificationuncertain?: NullableEnuminducks_entry_identificationuncertainFieldUpdateOperationsInput | $Enums.inducks_entry_identificationuncertain | null
    alsoreprint?: NullableStringFieldUpdateOperationsInput | string | null
    part?: NullableStringFieldUpdateOperationsInput | string | null
    entrycomment?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableEnuminducks_entry_errorFieldUpdateOperationsInput | $Enums.inducks_entry_error | null
  }

  export type inducks_entry_nofulltextCreateInput = {
    entrycode: string
    issuecode?: string | null
    storyversioncode?: string | null
    languagecode?: string | null
    includedinentrycode?: string | null
    position?: string | null
    printedcode?: string | null
    guessedcode?: string | null
    title?: string | null
    reallytitle?: $Enums.inducks_entry_nofulltext_reallytitle | null
    printedhero?: string | null
    changes?: string | null
    cut?: string | null
    minorchanges?: string | null
    missingpanels?: string | null
    mirrored?: $Enums.inducks_entry_nofulltext_mirrored | null
    sideways?: $Enums.inducks_entry_nofulltext_sideways | null
    startdate?: string | null
    enddate?: string | null
    identificationuncertain?: $Enums.inducks_entry_nofulltext_identificationuncertain | null
    alsoreprint?: string | null
    part?: string | null
    entrycomment?: string | null
    error?: $Enums.inducks_entry_nofulltext_error | null
  }

  export type inducks_entry_nofulltextUncheckedCreateInput = {
    entrycode: string
    issuecode?: string | null
    storyversioncode?: string | null
    languagecode?: string | null
    includedinentrycode?: string | null
    position?: string | null
    printedcode?: string | null
    guessedcode?: string | null
    title?: string | null
    reallytitle?: $Enums.inducks_entry_nofulltext_reallytitle | null
    printedhero?: string | null
    changes?: string | null
    cut?: string | null
    minorchanges?: string | null
    missingpanels?: string | null
    mirrored?: $Enums.inducks_entry_nofulltext_mirrored | null
    sideways?: $Enums.inducks_entry_nofulltext_sideways | null
    startdate?: string | null
    enddate?: string | null
    identificationuncertain?: $Enums.inducks_entry_nofulltext_identificationuncertain | null
    alsoreprint?: string | null
    part?: string | null
    entrycomment?: string | null
    error?: $Enums.inducks_entry_nofulltext_error | null
  }

  export type inducks_entry_nofulltextUpdateInput = {
    entrycode?: StringFieldUpdateOperationsInput | string
    issuecode?: NullableStringFieldUpdateOperationsInput | string | null
    storyversioncode?: NullableStringFieldUpdateOperationsInput | string | null
    languagecode?: NullableStringFieldUpdateOperationsInput | string | null
    includedinentrycode?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    printedcode?: NullableStringFieldUpdateOperationsInput | string | null
    guessedcode?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    reallytitle?: NullableEnuminducks_entry_nofulltext_reallytitleFieldUpdateOperationsInput | $Enums.inducks_entry_nofulltext_reallytitle | null
    printedhero?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableStringFieldUpdateOperationsInput | string | null
    cut?: NullableStringFieldUpdateOperationsInput | string | null
    minorchanges?: NullableStringFieldUpdateOperationsInput | string | null
    missingpanels?: NullableStringFieldUpdateOperationsInput | string | null
    mirrored?: NullableEnuminducks_entry_nofulltext_mirroredFieldUpdateOperationsInput | $Enums.inducks_entry_nofulltext_mirrored | null
    sideways?: NullableEnuminducks_entry_nofulltext_sidewaysFieldUpdateOperationsInput | $Enums.inducks_entry_nofulltext_sideways | null
    startdate?: NullableStringFieldUpdateOperationsInput | string | null
    enddate?: NullableStringFieldUpdateOperationsInput | string | null
    identificationuncertain?: NullableEnuminducks_entry_nofulltext_identificationuncertainFieldUpdateOperationsInput | $Enums.inducks_entry_nofulltext_identificationuncertain | null
    alsoreprint?: NullableStringFieldUpdateOperationsInput | string | null
    part?: NullableStringFieldUpdateOperationsInput | string | null
    entrycomment?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableEnuminducks_entry_nofulltext_errorFieldUpdateOperationsInput | $Enums.inducks_entry_nofulltext_error | null
  }

  export type inducks_entry_nofulltextUncheckedUpdateInput = {
    entrycode?: StringFieldUpdateOperationsInput | string
    issuecode?: NullableStringFieldUpdateOperationsInput | string | null
    storyversioncode?: NullableStringFieldUpdateOperationsInput | string | null
    languagecode?: NullableStringFieldUpdateOperationsInput | string | null
    includedinentrycode?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    printedcode?: NullableStringFieldUpdateOperationsInput | string | null
    guessedcode?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    reallytitle?: NullableEnuminducks_entry_nofulltext_reallytitleFieldUpdateOperationsInput | $Enums.inducks_entry_nofulltext_reallytitle | null
    printedhero?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableStringFieldUpdateOperationsInput | string | null
    cut?: NullableStringFieldUpdateOperationsInput | string | null
    minorchanges?: NullableStringFieldUpdateOperationsInput | string | null
    missingpanels?: NullableStringFieldUpdateOperationsInput | string | null
    mirrored?: NullableEnuminducks_entry_nofulltext_mirroredFieldUpdateOperationsInput | $Enums.inducks_entry_nofulltext_mirrored | null
    sideways?: NullableEnuminducks_entry_nofulltext_sidewaysFieldUpdateOperationsInput | $Enums.inducks_entry_nofulltext_sideways | null
    startdate?: NullableStringFieldUpdateOperationsInput | string | null
    enddate?: NullableStringFieldUpdateOperationsInput | string | null
    identificationuncertain?: NullableEnuminducks_entry_nofulltext_identificationuncertainFieldUpdateOperationsInput | $Enums.inducks_entry_nofulltext_identificationuncertain | null
    alsoreprint?: NullableStringFieldUpdateOperationsInput | string | null
    part?: NullableStringFieldUpdateOperationsInput | string | null
    entrycomment?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableEnuminducks_entry_nofulltext_errorFieldUpdateOperationsInput | $Enums.inducks_entry_nofulltext_error | null
  }

  export type inducks_entry_nofulltextCreateManyInput = {
    entrycode: string
    issuecode?: string | null
    storyversioncode?: string | null
    languagecode?: string | null
    includedinentrycode?: string | null
    position?: string | null
    printedcode?: string | null
    guessedcode?: string | null
    title?: string | null
    reallytitle?: $Enums.inducks_entry_nofulltext_reallytitle | null
    printedhero?: string | null
    changes?: string | null
    cut?: string | null
    minorchanges?: string | null
    missingpanels?: string | null
    mirrored?: $Enums.inducks_entry_nofulltext_mirrored | null
    sideways?: $Enums.inducks_entry_nofulltext_sideways | null
    startdate?: string | null
    enddate?: string | null
    identificationuncertain?: $Enums.inducks_entry_nofulltext_identificationuncertain | null
    alsoreprint?: string | null
    part?: string | null
    entrycomment?: string | null
    error?: $Enums.inducks_entry_nofulltext_error | null
  }

  export type inducks_entry_nofulltextUpdateManyMutationInput = {
    entrycode?: StringFieldUpdateOperationsInput | string
    issuecode?: NullableStringFieldUpdateOperationsInput | string | null
    storyversioncode?: NullableStringFieldUpdateOperationsInput | string | null
    languagecode?: NullableStringFieldUpdateOperationsInput | string | null
    includedinentrycode?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    printedcode?: NullableStringFieldUpdateOperationsInput | string | null
    guessedcode?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    reallytitle?: NullableEnuminducks_entry_nofulltext_reallytitleFieldUpdateOperationsInput | $Enums.inducks_entry_nofulltext_reallytitle | null
    printedhero?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableStringFieldUpdateOperationsInput | string | null
    cut?: NullableStringFieldUpdateOperationsInput | string | null
    minorchanges?: NullableStringFieldUpdateOperationsInput | string | null
    missingpanels?: NullableStringFieldUpdateOperationsInput | string | null
    mirrored?: NullableEnuminducks_entry_nofulltext_mirroredFieldUpdateOperationsInput | $Enums.inducks_entry_nofulltext_mirrored | null
    sideways?: NullableEnuminducks_entry_nofulltext_sidewaysFieldUpdateOperationsInput | $Enums.inducks_entry_nofulltext_sideways | null
    startdate?: NullableStringFieldUpdateOperationsInput | string | null
    enddate?: NullableStringFieldUpdateOperationsInput | string | null
    identificationuncertain?: NullableEnuminducks_entry_nofulltext_identificationuncertainFieldUpdateOperationsInput | $Enums.inducks_entry_nofulltext_identificationuncertain | null
    alsoreprint?: NullableStringFieldUpdateOperationsInput | string | null
    part?: NullableStringFieldUpdateOperationsInput | string | null
    entrycomment?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableEnuminducks_entry_nofulltext_errorFieldUpdateOperationsInput | $Enums.inducks_entry_nofulltext_error | null
  }

  export type inducks_entry_nofulltextUncheckedUpdateManyInput = {
    entrycode?: StringFieldUpdateOperationsInput | string
    issuecode?: NullableStringFieldUpdateOperationsInput | string | null
    storyversioncode?: NullableStringFieldUpdateOperationsInput | string | null
    languagecode?: NullableStringFieldUpdateOperationsInput | string | null
    includedinentrycode?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    printedcode?: NullableStringFieldUpdateOperationsInput | string | null
    guessedcode?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    reallytitle?: NullableEnuminducks_entry_nofulltext_reallytitleFieldUpdateOperationsInput | $Enums.inducks_entry_nofulltext_reallytitle | null
    printedhero?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableStringFieldUpdateOperationsInput | string | null
    cut?: NullableStringFieldUpdateOperationsInput | string | null
    minorchanges?: NullableStringFieldUpdateOperationsInput | string | null
    missingpanels?: NullableStringFieldUpdateOperationsInput | string | null
    mirrored?: NullableEnuminducks_entry_nofulltext_mirroredFieldUpdateOperationsInput | $Enums.inducks_entry_nofulltext_mirrored | null
    sideways?: NullableEnuminducks_entry_nofulltext_sidewaysFieldUpdateOperationsInput | $Enums.inducks_entry_nofulltext_sideways | null
    startdate?: NullableStringFieldUpdateOperationsInput | string | null
    enddate?: NullableStringFieldUpdateOperationsInput | string | null
    identificationuncertain?: NullableEnuminducks_entry_nofulltext_identificationuncertainFieldUpdateOperationsInput | $Enums.inducks_entry_nofulltext_identificationuncertain | null
    alsoreprint?: NullableStringFieldUpdateOperationsInput | string | null
    part?: NullableStringFieldUpdateOperationsInput | string | null
    entrycomment?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableEnuminducks_entry_nofulltext_errorFieldUpdateOperationsInput | $Enums.inducks_entry_nofulltext_error | null
  }

  export type inducks_entrycharacternameCreateInput = {
    entrycode: string
    charactercode: string
    charactername?: string | null
  }

  export type inducks_entrycharacternameUncheckedCreateInput = {
    entrycode: string
    charactercode: string
    charactername?: string | null
  }

  export type inducks_entrycharacternameUpdateInput = {
    entrycode?: StringFieldUpdateOperationsInput | string
    charactercode?: StringFieldUpdateOperationsInput | string
    charactername?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_entrycharacternameUncheckedUpdateInput = {
    entrycode?: StringFieldUpdateOperationsInput | string
    charactercode?: StringFieldUpdateOperationsInput | string
    charactername?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_entrycharacternameCreateManyInput = {
    entrycode: string
    charactercode: string
    charactername?: string | null
  }

  export type inducks_entrycharacternameUpdateManyMutationInput = {
    entrycode?: StringFieldUpdateOperationsInput | string
    charactercode?: StringFieldUpdateOperationsInput | string
    charactername?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_entrycharacternameUncheckedUpdateManyInput = {
    entrycode?: StringFieldUpdateOperationsInput | string
    charactercode?: StringFieldUpdateOperationsInput | string
    charactername?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_entryjobCreateInput = {
    entrycode: string
    personcode: string
    transletcol: string
    entryjobcomment?: string | null
    doubt?: $Enums.inducks_entryjob_doubt | null
  }

  export type inducks_entryjobUncheckedCreateInput = {
    entrycode: string
    personcode: string
    transletcol: string
    entryjobcomment?: string | null
    doubt?: $Enums.inducks_entryjob_doubt | null
  }

  export type inducks_entryjobUpdateInput = {
    entrycode?: StringFieldUpdateOperationsInput | string
    personcode?: StringFieldUpdateOperationsInput | string
    transletcol?: StringFieldUpdateOperationsInput | string
    entryjobcomment?: NullableStringFieldUpdateOperationsInput | string | null
    doubt?: NullableEnuminducks_entryjob_doubtFieldUpdateOperationsInput | $Enums.inducks_entryjob_doubt | null
  }

  export type inducks_entryjobUncheckedUpdateInput = {
    entrycode?: StringFieldUpdateOperationsInput | string
    personcode?: StringFieldUpdateOperationsInput | string
    transletcol?: StringFieldUpdateOperationsInput | string
    entryjobcomment?: NullableStringFieldUpdateOperationsInput | string | null
    doubt?: NullableEnuminducks_entryjob_doubtFieldUpdateOperationsInput | $Enums.inducks_entryjob_doubt | null
  }

  export type inducks_entryjobCreateManyInput = {
    entrycode: string
    personcode: string
    transletcol: string
    entryjobcomment?: string | null
    doubt?: $Enums.inducks_entryjob_doubt | null
  }

  export type inducks_entryjobUpdateManyMutationInput = {
    entrycode?: StringFieldUpdateOperationsInput | string
    personcode?: StringFieldUpdateOperationsInput | string
    transletcol?: StringFieldUpdateOperationsInput | string
    entryjobcomment?: NullableStringFieldUpdateOperationsInput | string | null
    doubt?: NullableEnuminducks_entryjob_doubtFieldUpdateOperationsInput | $Enums.inducks_entryjob_doubt | null
  }

  export type inducks_entryjobUncheckedUpdateManyInput = {
    entrycode?: StringFieldUpdateOperationsInput | string
    personcode?: StringFieldUpdateOperationsInput | string
    transletcol?: StringFieldUpdateOperationsInput | string
    entryjobcomment?: NullableStringFieldUpdateOperationsInput | string | null
    doubt?: NullableEnuminducks_entryjob_doubtFieldUpdateOperationsInput | $Enums.inducks_entryjob_doubt | null
  }

  export type inducks_entryurlCreateInput = {
    entrycode?: string | null
    sitecode?: string | null
    pagenumber?: number | null
    url?: string | null
    storycode?: string | null
    public?: $Enums.inducks_entryurl_public | null
  }

  export type inducks_entryurlUncheckedCreateInput = {
    entrycode?: string | null
    sitecode?: string | null
    pagenumber?: number | null
    url?: string | null
    storycode?: string | null
    public?: $Enums.inducks_entryurl_public | null
    id?: number
  }

  export type inducks_entryurlUpdateInput = {
    entrycode?: NullableStringFieldUpdateOperationsInput | string | null
    sitecode?: NullableStringFieldUpdateOperationsInput | string | null
    pagenumber?: NullableIntFieldUpdateOperationsInput | number | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    storycode?: NullableStringFieldUpdateOperationsInput | string | null
    public?: NullableEnuminducks_entryurl_publicFieldUpdateOperationsInput | $Enums.inducks_entryurl_public | null
  }

  export type inducks_entryurlUncheckedUpdateInput = {
    entrycode?: NullableStringFieldUpdateOperationsInput | string | null
    sitecode?: NullableStringFieldUpdateOperationsInput | string | null
    pagenumber?: NullableIntFieldUpdateOperationsInput | number | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    storycode?: NullableStringFieldUpdateOperationsInput | string | null
    public?: NullableEnuminducks_entryurl_publicFieldUpdateOperationsInput | $Enums.inducks_entryurl_public | null
    id?: IntFieldUpdateOperationsInput | number
  }

  export type inducks_entryurlCreateManyInput = {
    entrycode?: string | null
    sitecode?: string | null
    pagenumber?: number | null
    url?: string | null
    storycode?: string | null
    public?: $Enums.inducks_entryurl_public | null
    id?: number
  }

  export type inducks_entryurlUpdateManyMutationInput = {
    entrycode?: NullableStringFieldUpdateOperationsInput | string | null
    sitecode?: NullableStringFieldUpdateOperationsInput | string | null
    pagenumber?: NullableIntFieldUpdateOperationsInput | number | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    storycode?: NullableStringFieldUpdateOperationsInput | string | null
    public?: NullableEnuminducks_entryurl_publicFieldUpdateOperationsInput | $Enums.inducks_entryurl_public | null
  }

  export type inducks_entryurlUncheckedUpdateManyInput = {
    entrycode?: NullableStringFieldUpdateOperationsInput | string | null
    sitecode?: NullableStringFieldUpdateOperationsInput | string | null
    pagenumber?: NullableIntFieldUpdateOperationsInput | number | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    storycode?: NullableStringFieldUpdateOperationsInput | string | null
    public?: NullableEnuminducks_entryurl_publicFieldUpdateOperationsInput | $Enums.inducks_entryurl_public | null
    id?: IntFieldUpdateOperationsInput | number
  }

  export type inducks_equivCreateInput = {
    issuecode: string
    equivid: number
    equivcomment?: string | null
  }

  export type inducks_equivUncheckedCreateInput = {
    issuecode: string
    equivid: number
    equivcomment?: string | null
  }

  export type inducks_equivUpdateInput = {
    issuecode?: StringFieldUpdateOperationsInput | string
    equivid?: IntFieldUpdateOperationsInput | number
    equivcomment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_equivUncheckedUpdateInput = {
    issuecode?: StringFieldUpdateOperationsInput | string
    equivid?: IntFieldUpdateOperationsInput | number
    equivcomment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_equivCreateManyInput = {
    issuecode: string
    equivid: number
    equivcomment?: string | null
  }

  export type inducks_equivUpdateManyMutationInput = {
    issuecode?: StringFieldUpdateOperationsInput | string
    equivid?: IntFieldUpdateOperationsInput | number
    equivcomment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_equivUncheckedUpdateManyInput = {
    issuecode?: StringFieldUpdateOperationsInput | string
    equivid?: IntFieldUpdateOperationsInput | number
    equivcomment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_herocharacterCreateInput = {
    storycode: string
    charactercode: string
    number?: number | null
    doubt?: $Enums.inducks_herocharacter_doubt | null
  }

  export type inducks_herocharacterUncheckedCreateInput = {
    storycode: string
    charactercode: string
    number?: number | null
    doubt?: $Enums.inducks_herocharacter_doubt | null
  }

  export type inducks_herocharacterUpdateInput = {
    storycode?: StringFieldUpdateOperationsInput | string
    charactercode?: StringFieldUpdateOperationsInput | string
    number?: NullableIntFieldUpdateOperationsInput | number | null
    doubt?: NullableEnuminducks_herocharacter_doubtFieldUpdateOperationsInput | $Enums.inducks_herocharacter_doubt | null
  }

  export type inducks_herocharacterUncheckedUpdateInput = {
    storycode?: StringFieldUpdateOperationsInput | string
    charactercode?: StringFieldUpdateOperationsInput | string
    number?: NullableIntFieldUpdateOperationsInput | number | null
    doubt?: NullableEnuminducks_herocharacter_doubtFieldUpdateOperationsInput | $Enums.inducks_herocharacter_doubt | null
  }

  export type inducks_herocharacterCreateManyInput = {
    storycode: string
    charactercode: string
    number?: number | null
    doubt?: $Enums.inducks_herocharacter_doubt | null
  }

  export type inducks_herocharacterUpdateManyMutationInput = {
    storycode?: StringFieldUpdateOperationsInput | string
    charactercode?: StringFieldUpdateOperationsInput | string
    number?: NullableIntFieldUpdateOperationsInput | number | null
    doubt?: NullableEnuminducks_herocharacter_doubtFieldUpdateOperationsInput | $Enums.inducks_herocharacter_doubt | null
  }

  export type inducks_herocharacterUncheckedUpdateManyInput = {
    storycode?: StringFieldUpdateOperationsInput | string
    charactercode?: StringFieldUpdateOperationsInput | string
    number?: NullableIntFieldUpdateOperationsInput | number | null
    doubt?: NullableEnuminducks_herocharacter_doubtFieldUpdateOperationsInput | $Enums.inducks_herocharacter_doubt | null
  }

  export type inducks_inputfileCreateInput = {
    inputfilecode: number
    path?: string | null
    filename?: string | null
    layout?: string | null
    locked?: $Enums.inducks_inputfile_locked | null
    maintenanceteamcode?: string | null
    countrycode?: string | null
    languagecode?: string | null
    producercode?: string | null
    secundary?: $Enums.inducks_inputfile_secundary | null
  }

  export type inducks_inputfileUncheckedCreateInput = {
    inputfilecode: number
    path?: string | null
    filename?: string | null
    layout?: string | null
    locked?: $Enums.inducks_inputfile_locked | null
    maintenanceteamcode?: string | null
    countrycode?: string | null
    languagecode?: string | null
    producercode?: string | null
    secundary?: $Enums.inducks_inputfile_secundary | null
  }

  export type inducks_inputfileUpdateInput = {
    inputfilecode?: IntFieldUpdateOperationsInput | number
    path?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    layout?: NullableStringFieldUpdateOperationsInput | string | null
    locked?: NullableEnuminducks_inputfile_lockedFieldUpdateOperationsInput | $Enums.inducks_inputfile_locked | null
    maintenanceteamcode?: NullableStringFieldUpdateOperationsInput | string | null
    countrycode?: NullableStringFieldUpdateOperationsInput | string | null
    languagecode?: NullableStringFieldUpdateOperationsInput | string | null
    producercode?: NullableStringFieldUpdateOperationsInput | string | null
    secundary?: NullableEnuminducks_inputfile_secundaryFieldUpdateOperationsInput | $Enums.inducks_inputfile_secundary | null
  }

  export type inducks_inputfileUncheckedUpdateInput = {
    inputfilecode?: IntFieldUpdateOperationsInput | number
    path?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    layout?: NullableStringFieldUpdateOperationsInput | string | null
    locked?: NullableEnuminducks_inputfile_lockedFieldUpdateOperationsInput | $Enums.inducks_inputfile_locked | null
    maintenanceteamcode?: NullableStringFieldUpdateOperationsInput | string | null
    countrycode?: NullableStringFieldUpdateOperationsInput | string | null
    languagecode?: NullableStringFieldUpdateOperationsInput | string | null
    producercode?: NullableStringFieldUpdateOperationsInput | string | null
    secundary?: NullableEnuminducks_inputfile_secundaryFieldUpdateOperationsInput | $Enums.inducks_inputfile_secundary | null
  }

  export type inducks_inputfileCreateManyInput = {
    inputfilecode: number
    path?: string | null
    filename?: string | null
    layout?: string | null
    locked?: $Enums.inducks_inputfile_locked | null
    maintenanceteamcode?: string | null
    countrycode?: string | null
    languagecode?: string | null
    producercode?: string | null
    secundary?: $Enums.inducks_inputfile_secundary | null
  }

  export type inducks_inputfileUpdateManyMutationInput = {
    inputfilecode?: IntFieldUpdateOperationsInput | number
    path?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    layout?: NullableStringFieldUpdateOperationsInput | string | null
    locked?: NullableEnuminducks_inputfile_lockedFieldUpdateOperationsInput | $Enums.inducks_inputfile_locked | null
    maintenanceteamcode?: NullableStringFieldUpdateOperationsInput | string | null
    countrycode?: NullableStringFieldUpdateOperationsInput | string | null
    languagecode?: NullableStringFieldUpdateOperationsInput | string | null
    producercode?: NullableStringFieldUpdateOperationsInput | string | null
    secundary?: NullableEnuminducks_inputfile_secundaryFieldUpdateOperationsInput | $Enums.inducks_inputfile_secundary | null
  }

  export type inducks_inputfileUncheckedUpdateManyInput = {
    inputfilecode?: IntFieldUpdateOperationsInput | number
    path?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    layout?: NullableStringFieldUpdateOperationsInput | string | null
    locked?: NullableEnuminducks_inputfile_lockedFieldUpdateOperationsInput | $Enums.inducks_inputfile_locked | null
    maintenanceteamcode?: NullableStringFieldUpdateOperationsInput | string | null
    countrycode?: NullableStringFieldUpdateOperationsInput | string | null
    languagecode?: NullableStringFieldUpdateOperationsInput | string | null
    producercode?: NullableStringFieldUpdateOperationsInput | string | null
    secundary?: NullableEnuminducks_inputfile_secundaryFieldUpdateOperationsInput | $Enums.inducks_inputfile_secundary | null
  }

  export type inducks_issueCreateInput = {
    issuecode: string
    issuerangecode?: string | null
    publicationcode?: string | null
    issuenumber?: string | null
    title?: string | null
    size?: string | null
    pages?: string | null
    price?: string | null
    printrun?: string | null
    attached?: string | null
    oldestdate?: string | null
    fullyindexed?: $Enums.inducks_issue_fullyindexed | null
    issuecomment?: string | null
    error?: $Enums.inducks_issue_error | null
    filledoldestdate?: string | null
    locked?: $Enums.inducks_issue_locked | null
    inxforbidden?: $Enums.inducks_issue_inxforbidden | null
    inputfilecode?: number | null
    maintenanceteamcode?: string | null
  }

  export type inducks_issueUncheckedCreateInput = {
    issuecode: string
    issuerangecode?: string | null
    publicationcode?: string | null
    issuenumber?: string | null
    title?: string | null
    size?: string | null
    pages?: string | null
    price?: string | null
    printrun?: string | null
    attached?: string | null
    oldestdate?: string | null
    fullyindexed?: $Enums.inducks_issue_fullyindexed | null
    issuecomment?: string | null
    error?: $Enums.inducks_issue_error | null
    filledoldestdate?: string | null
    locked?: $Enums.inducks_issue_locked | null
    inxforbidden?: $Enums.inducks_issue_inxforbidden | null
    inputfilecode?: number | null
    maintenanceteamcode?: string | null
  }

  export type inducks_issueUpdateInput = {
    issuecode?: StringFieldUpdateOperationsInput | string
    issuerangecode?: NullableStringFieldUpdateOperationsInput | string | null
    publicationcode?: NullableStringFieldUpdateOperationsInput | string | null
    issuenumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    printrun?: NullableStringFieldUpdateOperationsInput | string | null
    attached?: NullableStringFieldUpdateOperationsInput | string | null
    oldestdate?: NullableStringFieldUpdateOperationsInput | string | null
    fullyindexed?: NullableEnuminducks_issue_fullyindexedFieldUpdateOperationsInput | $Enums.inducks_issue_fullyindexed | null
    issuecomment?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableEnuminducks_issue_errorFieldUpdateOperationsInput | $Enums.inducks_issue_error | null
    filledoldestdate?: NullableStringFieldUpdateOperationsInput | string | null
    locked?: NullableEnuminducks_issue_lockedFieldUpdateOperationsInput | $Enums.inducks_issue_locked | null
    inxforbidden?: NullableEnuminducks_issue_inxforbiddenFieldUpdateOperationsInput | $Enums.inducks_issue_inxforbidden | null
    inputfilecode?: NullableIntFieldUpdateOperationsInput | number | null
    maintenanceteamcode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_issueUncheckedUpdateInput = {
    issuecode?: StringFieldUpdateOperationsInput | string
    issuerangecode?: NullableStringFieldUpdateOperationsInput | string | null
    publicationcode?: NullableStringFieldUpdateOperationsInput | string | null
    issuenumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    printrun?: NullableStringFieldUpdateOperationsInput | string | null
    attached?: NullableStringFieldUpdateOperationsInput | string | null
    oldestdate?: NullableStringFieldUpdateOperationsInput | string | null
    fullyindexed?: NullableEnuminducks_issue_fullyindexedFieldUpdateOperationsInput | $Enums.inducks_issue_fullyindexed | null
    issuecomment?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableEnuminducks_issue_errorFieldUpdateOperationsInput | $Enums.inducks_issue_error | null
    filledoldestdate?: NullableStringFieldUpdateOperationsInput | string | null
    locked?: NullableEnuminducks_issue_lockedFieldUpdateOperationsInput | $Enums.inducks_issue_locked | null
    inxforbidden?: NullableEnuminducks_issue_inxforbiddenFieldUpdateOperationsInput | $Enums.inducks_issue_inxforbidden | null
    inputfilecode?: NullableIntFieldUpdateOperationsInput | number | null
    maintenanceteamcode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_issueCreateManyInput = {
    issuecode: string
    issuerangecode?: string | null
    publicationcode?: string | null
    issuenumber?: string | null
    title?: string | null
    size?: string | null
    pages?: string | null
    price?: string | null
    printrun?: string | null
    attached?: string | null
    oldestdate?: string | null
    fullyindexed?: $Enums.inducks_issue_fullyindexed | null
    issuecomment?: string | null
    error?: $Enums.inducks_issue_error | null
    filledoldestdate?: string | null
    locked?: $Enums.inducks_issue_locked | null
    inxforbidden?: $Enums.inducks_issue_inxforbidden | null
    inputfilecode?: number | null
    maintenanceteamcode?: string | null
  }

  export type inducks_issueUpdateManyMutationInput = {
    issuecode?: StringFieldUpdateOperationsInput | string
    issuerangecode?: NullableStringFieldUpdateOperationsInput | string | null
    publicationcode?: NullableStringFieldUpdateOperationsInput | string | null
    issuenumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    printrun?: NullableStringFieldUpdateOperationsInput | string | null
    attached?: NullableStringFieldUpdateOperationsInput | string | null
    oldestdate?: NullableStringFieldUpdateOperationsInput | string | null
    fullyindexed?: NullableEnuminducks_issue_fullyindexedFieldUpdateOperationsInput | $Enums.inducks_issue_fullyindexed | null
    issuecomment?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableEnuminducks_issue_errorFieldUpdateOperationsInput | $Enums.inducks_issue_error | null
    filledoldestdate?: NullableStringFieldUpdateOperationsInput | string | null
    locked?: NullableEnuminducks_issue_lockedFieldUpdateOperationsInput | $Enums.inducks_issue_locked | null
    inxforbidden?: NullableEnuminducks_issue_inxforbiddenFieldUpdateOperationsInput | $Enums.inducks_issue_inxforbidden | null
    inputfilecode?: NullableIntFieldUpdateOperationsInput | number | null
    maintenanceteamcode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_issueUncheckedUpdateManyInput = {
    issuecode?: StringFieldUpdateOperationsInput | string
    issuerangecode?: NullableStringFieldUpdateOperationsInput | string | null
    publicationcode?: NullableStringFieldUpdateOperationsInput | string | null
    issuenumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    pages?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    printrun?: NullableStringFieldUpdateOperationsInput | string | null
    attached?: NullableStringFieldUpdateOperationsInput | string | null
    oldestdate?: NullableStringFieldUpdateOperationsInput | string | null
    fullyindexed?: NullableEnuminducks_issue_fullyindexedFieldUpdateOperationsInput | $Enums.inducks_issue_fullyindexed | null
    issuecomment?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableEnuminducks_issue_errorFieldUpdateOperationsInput | $Enums.inducks_issue_error | null
    filledoldestdate?: NullableStringFieldUpdateOperationsInput | string | null
    locked?: NullableEnuminducks_issue_lockedFieldUpdateOperationsInput | $Enums.inducks_issue_locked | null
    inxforbidden?: NullableEnuminducks_issue_inxforbiddenFieldUpdateOperationsInput | $Enums.inducks_issue_inxforbidden | null
    inputfilecode?: NullableIntFieldUpdateOperationsInput | number | null
    maintenanceteamcode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_issuecollectingCreateInput = {
    collectingissuecode: string
    collectedissuecode: string
  }

  export type inducks_issuecollectingUncheckedCreateInput = {
    collectingissuecode: string
    collectedissuecode: string
  }

  export type inducks_issuecollectingUpdateInput = {
    collectingissuecode?: StringFieldUpdateOperationsInput | string
    collectedissuecode?: StringFieldUpdateOperationsInput | string
  }

  export type inducks_issuecollectingUncheckedUpdateInput = {
    collectingissuecode?: StringFieldUpdateOperationsInput | string
    collectedissuecode?: StringFieldUpdateOperationsInput | string
  }

  export type inducks_issuecollectingCreateManyInput = {
    collectingissuecode: string
    collectedissuecode: string
  }

  export type inducks_issuecollectingUpdateManyMutationInput = {
    collectingissuecode?: StringFieldUpdateOperationsInput | string
    collectedissuecode?: StringFieldUpdateOperationsInput | string
  }

  export type inducks_issuecollectingUncheckedUpdateManyInput = {
    collectingissuecode?: StringFieldUpdateOperationsInput | string
    collectedissuecode?: StringFieldUpdateOperationsInput | string
  }

  export type inducks_issuedateCreateInput = {
    issuecode: string
    date: string
    kindofdate?: string | null
    doubt?: $Enums.inducks_issuedate_doubt | null
  }

  export type inducks_issuedateUncheckedCreateInput = {
    issuecode: string
    date: string
    kindofdate?: string | null
    doubt?: $Enums.inducks_issuedate_doubt | null
  }

  export type inducks_issuedateUpdateInput = {
    issuecode?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    kindofdate?: NullableStringFieldUpdateOperationsInput | string | null
    doubt?: NullableEnuminducks_issuedate_doubtFieldUpdateOperationsInput | $Enums.inducks_issuedate_doubt | null
  }

  export type inducks_issuedateUncheckedUpdateInput = {
    issuecode?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    kindofdate?: NullableStringFieldUpdateOperationsInput | string | null
    doubt?: NullableEnuminducks_issuedate_doubtFieldUpdateOperationsInput | $Enums.inducks_issuedate_doubt | null
  }

  export type inducks_issuedateCreateManyInput = {
    issuecode: string
    date: string
    kindofdate?: string | null
    doubt?: $Enums.inducks_issuedate_doubt | null
  }

  export type inducks_issuedateUpdateManyMutationInput = {
    issuecode?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    kindofdate?: NullableStringFieldUpdateOperationsInput | string | null
    doubt?: NullableEnuminducks_issuedate_doubtFieldUpdateOperationsInput | $Enums.inducks_issuedate_doubt | null
  }

  export type inducks_issuedateUncheckedUpdateManyInput = {
    issuecode?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    kindofdate?: NullableStringFieldUpdateOperationsInput | string | null
    doubt?: NullableEnuminducks_issuedate_doubtFieldUpdateOperationsInput | $Enums.inducks_issuedate_doubt | null
  }

  export type inducks_issuejobCreateInput = {
    issuecode: string
    personcode: string
    inxtransletcol: string
    issuejobcomment?: string | null
    doubt?: $Enums.inducks_issuejob_doubt | null
  }

  export type inducks_issuejobUncheckedCreateInput = {
    issuecode: string
    personcode: string
    inxtransletcol: string
    issuejobcomment?: string | null
    doubt?: $Enums.inducks_issuejob_doubt | null
  }

  export type inducks_issuejobUpdateInput = {
    issuecode?: StringFieldUpdateOperationsInput | string
    personcode?: StringFieldUpdateOperationsInput | string
    inxtransletcol?: StringFieldUpdateOperationsInput | string
    issuejobcomment?: NullableStringFieldUpdateOperationsInput | string | null
    doubt?: NullableEnuminducks_issuejob_doubtFieldUpdateOperationsInput | $Enums.inducks_issuejob_doubt | null
  }

  export type inducks_issuejobUncheckedUpdateInput = {
    issuecode?: StringFieldUpdateOperationsInput | string
    personcode?: StringFieldUpdateOperationsInput | string
    inxtransletcol?: StringFieldUpdateOperationsInput | string
    issuejobcomment?: NullableStringFieldUpdateOperationsInput | string | null
    doubt?: NullableEnuminducks_issuejob_doubtFieldUpdateOperationsInput | $Enums.inducks_issuejob_doubt | null
  }

  export type inducks_issuejobCreateManyInput = {
    issuecode: string
    personcode: string
    inxtransletcol: string
    issuejobcomment?: string | null
    doubt?: $Enums.inducks_issuejob_doubt | null
  }

  export type inducks_issuejobUpdateManyMutationInput = {
    issuecode?: StringFieldUpdateOperationsInput | string
    personcode?: StringFieldUpdateOperationsInput | string
    inxtransletcol?: StringFieldUpdateOperationsInput | string
    issuejobcomment?: NullableStringFieldUpdateOperationsInput | string | null
    doubt?: NullableEnuminducks_issuejob_doubtFieldUpdateOperationsInput | $Enums.inducks_issuejob_doubt | null
  }

  export type inducks_issuejobUncheckedUpdateManyInput = {
    issuecode?: StringFieldUpdateOperationsInput | string
    personcode?: StringFieldUpdateOperationsInput | string
    inxtransletcol?: StringFieldUpdateOperationsInput | string
    issuejobcomment?: NullableStringFieldUpdateOperationsInput | string | null
    doubt?: NullableEnuminducks_issuejob_doubtFieldUpdateOperationsInput | $Enums.inducks_issuejob_doubt | null
  }

  export type inducks_issuepriceCreateInput = {
    issuecode: string
    amount: string
    currency?: string | null
    comment?: string | null
    sequencenumber?: number | null
  }

  export type inducks_issuepriceUncheckedCreateInput = {
    issuecode: string
    amount: string
    currency?: string | null
    comment?: string | null
    sequencenumber?: number | null
  }

  export type inducks_issuepriceUpdateInput = {
    issuecode?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    sequencenumber?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type inducks_issuepriceUncheckedUpdateInput = {
    issuecode?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    sequencenumber?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type inducks_issuepriceCreateManyInput = {
    issuecode: string
    amount: string
    currency?: string | null
    comment?: string | null
    sequencenumber?: number | null
  }

  export type inducks_issuepriceUpdateManyMutationInput = {
    issuecode?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    sequencenumber?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type inducks_issuepriceUncheckedUpdateManyInput = {
    issuecode?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    sequencenumber?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type inducks_issuequotationCreateInput = {
    publicationcode: string
    issuenumber: string
    estimationmin?: number | null
    estimationmax?: number | null
    scrapedate?: Date | string | null
    source: string
    issuecode?: string | null
  }

  export type inducks_issuequotationUncheckedCreateInput = {
    ID?: number
    publicationcode: string
    issuenumber: string
    estimationmin?: number | null
    estimationmax?: number | null
    scrapedate?: Date | string | null
    source: string
    issuecode?: string | null
  }

  export type inducks_issuequotationUpdateInput = {
    publicationcode?: StringFieldUpdateOperationsInput | string
    issuenumber?: StringFieldUpdateOperationsInput | string
    estimationmin?: NullableFloatFieldUpdateOperationsInput | number | null
    estimationmax?: NullableFloatFieldUpdateOperationsInput | number | null
    scrapedate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: StringFieldUpdateOperationsInput | string
    issuecode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_issuequotationUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    publicationcode?: StringFieldUpdateOperationsInput | string
    issuenumber?: StringFieldUpdateOperationsInput | string
    estimationmin?: NullableFloatFieldUpdateOperationsInput | number | null
    estimationmax?: NullableFloatFieldUpdateOperationsInput | number | null
    scrapedate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: StringFieldUpdateOperationsInput | string
    issuecode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_issuequotationCreateManyInput = {
    ID?: number
    publicationcode: string
    issuenumber: string
    estimationmin?: number | null
    estimationmax?: number | null
    scrapedate?: Date | string | null
    source: string
    issuecode?: string | null
  }

  export type inducks_issuequotationUpdateManyMutationInput = {
    publicationcode?: StringFieldUpdateOperationsInput | string
    issuenumber?: StringFieldUpdateOperationsInput | string
    estimationmin?: NullableFloatFieldUpdateOperationsInput | number | null
    estimationmax?: NullableFloatFieldUpdateOperationsInput | number | null
    scrapedate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: StringFieldUpdateOperationsInput | string
    issuecode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_issuequotationUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    publicationcode?: StringFieldUpdateOperationsInput | string
    issuenumber?: StringFieldUpdateOperationsInput | string
    estimationmin?: NullableFloatFieldUpdateOperationsInput | number | null
    estimationmax?: NullableFloatFieldUpdateOperationsInput | number | null
    scrapedate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: StringFieldUpdateOperationsInput | string
    issuecode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_issuerangeCreateInput = {
    issuerangecode: string
    publicationcode?: string | null
    title?: string | null
    circulation?: string | null
    issuerangecomment?: string | null
    numbersarefake?: $Enums.inducks_issuerange_numbersarefake | null
    error?: $Enums.inducks_issuerange_error | null
  }

  export type inducks_issuerangeUncheckedCreateInput = {
    issuerangecode: string
    publicationcode?: string | null
    title?: string | null
    circulation?: string | null
    issuerangecomment?: string | null
    numbersarefake?: $Enums.inducks_issuerange_numbersarefake | null
    error?: $Enums.inducks_issuerange_error | null
  }

  export type inducks_issuerangeUpdateInput = {
    issuerangecode?: StringFieldUpdateOperationsInput | string
    publicationcode?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    circulation?: NullableStringFieldUpdateOperationsInput | string | null
    issuerangecomment?: NullableStringFieldUpdateOperationsInput | string | null
    numbersarefake?: NullableEnuminducks_issuerange_numbersarefakeFieldUpdateOperationsInput | $Enums.inducks_issuerange_numbersarefake | null
    error?: NullableEnuminducks_issuerange_errorFieldUpdateOperationsInput | $Enums.inducks_issuerange_error | null
  }

  export type inducks_issuerangeUncheckedUpdateInput = {
    issuerangecode?: StringFieldUpdateOperationsInput | string
    publicationcode?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    circulation?: NullableStringFieldUpdateOperationsInput | string | null
    issuerangecomment?: NullableStringFieldUpdateOperationsInput | string | null
    numbersarefake?: NullableEnuminducks_issuerange_numbersarefakeFieldUpdateOperationsInput | $Enums.inducks_issuerange_numbersarefake | null
    error?: NullableEnuminducks_issuerange_errorFieldUpdateOperationsInput | $Enums.inducks_issuerange_error | null
  }

  export type inducks_issuerangeCreateManyInput = {
    issuerangecode: string
    publicationcode?: string | null
    title?: string | null
    circulation?: string | null
    issuerangecomment?: string | null
    numbersarefake?: $Enums.inducks_issuerange_numbersarefake | null
    error?: $Enums.inducks_issuerange_error | null
  }

  export type inducks_issuerangeUpdateManyMutationInput = {
    issuerangecode?: StringFieldUpdateOperationsInput | string
    publicationcode?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    circulation?: NullableStringFieldUpdateOperationsInput | string | null
    issuerangecomment?: NullableStringFieldUpdateOperationsInput | string | null
    numbersarefake?: NullableEnuminducks_issuerange_numbersarefakeFieldUpdateOperationsInput | $Enums.inducks_issuerange_numbersarefake | null
    error?: NullableEnuminducks_issuerange_errorFieldUpdateOperationsInput | $Enums.inducks_issuerange_error | null
  }

  export type inducks_issuerangeUncheckedUpdateManyInput = {
    issuerangecode?: StringFieldUpdateOperationsInput | string
    publicationcode?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    circulation?: NullableStringFieldUpdateOperationsInput | string | null
    issuerangecomment?: NullableStringFieldUpdateOperationsInput | string | null
    numbersarefake?: NullableEnuminducks_issuerange_numbersarefakeFieldUpdateOperationsInput | $Enums.inducks_issuerange_numbersarefake | null
    error?: NullableEnuminducks_issuerange_errorFieldUpdateOperationsInput | $Enums.inducks_issuerange_error | null
  }

  export type inducks_issueurlCreateInput = {
    issuecode: string
    sitecode: string
    url?: string | null
  }

  export type inducks_issueurlUncheckedCreateInput = {
    issuecode: string
    sitecode: string
    url?: string | null
  }

  export type inducks_issueurlUpdateInput = {
    issuecode?: StringFieldUpdateOperationsInput | string
    sitecode?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_issueurlUncheckedUpdateInput = {
    issuecode?: StringFieldUpdateOperationsInput | string
    sitecode?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_issueurlCreateManyInput = {
    issuecode: string
    sitecode: string
    url?: string | null
  }

  export type inducks_issueurlUpdateManyMutationInput = {
    issuecode?: StringFieldUpdateOperationsInput | string
    sitecode?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_issueurlUncheckedUpdateManyInput = {
    issuecode?: StringFieldUpdateOperationsInput | string
    sitecode?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_languageCreateInput = {
    languagecode: string
    defaultlanguagecode?: string | null
    languagename?: string | null
  }

  export type inducks_languageUncheckedCreateInput = {
    languagecode: string
    defaultlanguagecode?: string | null
    languagename?: string | null
  }

  export type inducks_languageUpdateInput = {
    languagecode?: StringFieldUpdateOperationsInput | string
    defaultlanguagecode?: NullableStringFieldUpdateOperationsInput | string | null
    languagename?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_languageUncheckedUpdateInput = {
    languagecode?: StringFieldUpdateOperationsInput | string
    defaultlanguagecode?: NullableStringFieldUpdateOperationsInput | string | null
    languagename?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_languageCreateManyInput = {
    languagecode: string
    defaultlanguagecode?: string | null
    languagename?: string | null
  }

  export type inducks_languageUpdateManyMutationInput = {
    languagecode?: StringFieldUpdateOperationsInput | string
    defaultlanguagecode?: NullableStringFieldUpdateOperationsInput | string | null
    languagename?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_languageUncheckedUpdateManyInput = {
    languagecode?: StringFieldUpdateOperationsInput | string
    defaultlanguagecode?: NullableStringFieldUpdateOperationsInput | string | null
    languagename?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_languagenameCreateInput = {
    desclanguagecode: string
    languagecode: string
    languagename?: string | null
  }

  export type inducks_languagenameUncheckedCreateInput = {
    desclanguagecode: string
    languagecode: string
    languagename?: string | null
  }

  export type inducks_languagenameUpdateInput = {
    desclanguagecode?: StringFieldUpdateOperationsInput | string
    languagecode?: StringFieldUpdateOperationsInput | string
    languagename?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_languagenameUncheckedUpdateInput = {
    desclanguagecode?: StringFieldUpdateOperationsInput | string
    languagecode?: StringFieldUpdateOperationsInput | string
    languagename?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_languagenameCreateManyInput = {
    desclanguagecode: string
    languagecode: string
    languagename?: string | null
  }

  export type inducks_languagenameUpdateManyMutationInput = {
    desclanguagecode?: StringFieldUpdateOperationsInput | string
    languagecode?: StringFieldUpdateOperationsInput | string
    languagename?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_languagenameUncheckedUpdateManyInput = {
    desclanguagecode?: StringFieldUpdateOperationsInput | string
    languagecode?: StringFieldUpdateOperationsInput | string
    languagename?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_logCreateInput = {
    number: number
    logkey?: string | null
    storycode?: string | null
    logid?: string | null
    logtype?: string | null
    par1?: string | null
    par2?: string | null
    par3?: string | null
    marked?: $Enums.inducks_log_marked | null
    inputfilecode?: number | null
    maintenanceteamcode?: string | null
  }

  export type inducks_logUncheckedCreateInput = {
    number: number
    logkey?: string | null
    storycode?: string | null
    logid?: string | null
    logtype?: string | null
    par1?: string | null
    par2?: string | null
    par3?: string | null
    marked?: $Enums.inducks_log_marked | null
    inputfilecode?: number | null
    maintenanceteamcode?: string | null
  }

  export type inducks_logUpdateInput = {
    number?: IntFieldUpdateOperationsInput | number
    logkey?: NullableStringFieldUpdateOperationsInput | string | null
    storycode?: NullableStringFieldUpdateOperationsInput | string | null
    logid?: NullableStringFieldUpdateOperationsInput | string | null
    logtype?: NullableStringFieldUpdateOperationsInput | string | null
    par1?: NullableStringFieldUpdateOperationsInput | string | null
    par2?: NullableStringFieldUpdateOperationsInput | string | null
    par3?: NullableStringFieldUpdateOperationsInput | string | null
    marked?: NullableEnuminducks_log_markedFieldUpdateOperationsInput | $Enums.inducks_log_marked | null
    inputfilecode?: NullableIntFieldUpdateOperationsInput | number | null
    maintenanceteamcode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_logUncheckedUpdateInput = {
    number?: IntFieldUpdateOperationsInput | number
    logkey?: NullableStringFieldUpdateOperationsInput | string | null
    storycode?: NullableStringFieldUpdateOperationsInput | string | null
    logid?: NullableStringFieldUpdateOperationsInput | string | null
    logtype?: NullableStringFieldUpdateOperationsInput | string | null
    par1?: NullableStringFieldUpdateOperationsInput | string | null
    par2?: NullableStringFieldUpdateOperationsInput | string | null
    par3?: NullableStringFieldUpdateOperationsInput | string | null
    marked?: NullableEnuminducks_log_markedFieldUpdateOperationsInput | $Enums.inducks_log_marked | null
    inputfilecode?: NullableIntFieldUpdateOperationsInput | number | null
    maintenanceteamcode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_logCreateManyInput = {
    number: number
    logkey?: string | null
    storycode?: string | null
    logid?: string | null
    logtype?: string | null
    par1?: string | null
    par2?: string | null
    par3?: string | null
    marked?: $Enums.inducks_log_marked | null
    inputfilecode?: number | null
    maintenanceteamcode?: string | null
  }

  export type inducks_logUpdateManyMutationInput = {
    number?: IntFieldUpdateOperationsInput | number
    logkey?: NullableStringFieldUpdateOperationsInput | string | null
    storycode?: NullableStringFieldUpdateOperationsInput | string | null
    logid?: NullableStringFieldUpdateOperationsInput | string | null
    logtype?: NullableStringFieldUpdateOperationsInput | string | null
    par1?: NullableStringFieldUpdateOperationsInput | string | null
    par2?: NullableStringFieldUpdateOperationsInput | string | null
    par3?: NullableStringFieldUpdateOperationsInput | string | null
    marked?: NullableEnuminducks_log_markedFieldUpdateOperationsInput | $Enums.inducks_log_marked | null
    inputfilecode?: NullableIntFieldUpdateOperationsInput | number | null
    maintenanceteamcode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_logUncheckedUpdateManyInput = {
    number?: IntFieldUpdateOperationsInput | number
    logkey?: NullableStringFieldUpdateOperationsInput | string | null
    storycode?: NullableStringFieldUpdateOperationsInput | string | null
    logid?: NullableStringFieldUpdateOperationsInput | string | null
    logtype?: NullableStringFieldUpdateOperationsInput | string | null
    par1?: NullableStringFieldUpdateOperationsInput | string | null
    par2?: NullableStringFieldUpdateOperationsInput | string | null
    par3?: NullableStringFieldUpdateOperationsInput | string | null
    marked?: NullableEnuminducks_log_markedFieldUpdateOperationsInput | $Enums.inducks_log_marked | null
    inputfilecode?: NullableIntFieldUpdateOperationsInput | number | null
    maintenanceteamcode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_logdataCreateInput = {
    logid: string
    category?: number | null
    logtext?: string | null
  }

  export type inducks_logdataUncheckedCreateInput = {
    logid: string
    category?: number | null
    logtext?: string | null
  }

  export type inducks_logdataUpdateInput = {
    logid?: StringFieldUpdateOperationsInput | string
    category?: NullableIntFieldUpdateOperationsInput | number | null
    logtext?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_logdataUncheckedUpdateInput = {
    logid?: StringFieldUpdateOperationsInput | string
    category?: NullableIntFieldUpdateOperationsInput | number | null
    logtext?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_logdataCreateManyInput = {
    logid: string
    category?: number | null
    logtext?: string | null
  }

  export type inducks_logdataUpdateManyMutationInput = {
    logid?: StringFieldUpdateOperationsInput | string
    category?: NullableIntFieldUpdateOperationsInput | number | null
    logtext?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_logdataUncheckedUpdateManyInput = {
    logid?: StringFieldUpdateOperationsInput | string
    category?: NullableIntFieldUpdateOperationsInput | number | null
    logtext?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_logocharacterCreateInput = {
    entrycode: string
    charactercode: string
    reallyintitle?: $Enums.inducks_logocharacter_reallyintitle | null
    number?: number | null
    logocharactercomment?: string | null
  }

  export type inducks_logocharacterUncheckedCreateInput = {
    entrycode: string
    charactercode: string
    reallyintitle?: $Enums.inducks_logocharacter_reallyintitle | null
    number?: number | null
    logocharactercomment?: string | null
  }

  export type inducks_logocharacterUpdateInput = {
    entrycode?: StringFieldUpdateOperationsInput | string
    charactercode?: StringFieldUpdateOperationsInput | string
    reallyintitle?: NullableEnuminducks_logocharacter_reallyintitleFieldUpdateOperationsInput | $Enums.inducks_logocharacter_reallyintitle | null
    number?: NullableIntFieldUpdateOperationsInput | number | null
    logocharactercomment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_logocharacterUncheckedUpdateInput = {
    entrycode?: StringFieldUpdateOperationsInput | string
    charactercode?: StringFieldUpdateOperationsInput | string
    reallyintitle?: NullableEnuminducks_logocharacter_reallyintitleFieldUpdateOperationsInput | $Enums.inducks_logocharacter_reallyintitle | null
    number?: NullableIntFieldUpdateOperationsInput | number | null
    logocharactercomment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_logocharacterCreateManyInput = {
    entrycode: string
    charactercode: string
    reallyintitle?: $Enums.inducks_logocharacter_reallyintitle | null
    number?: number | null
    logocharactercomment?: string | null
  }

  export type inducks_logocharacterUpdateManyMutationInput = {
    entrycode?: StringFieldUpdateOperationsInput | string
    charactercode?: StringFieldUpdateOperationsInput | string
    reallyintitle?: NullableEnuminducks_logocharacter_reallyintitleFieldUpdateOperationsInput | $Enums.inducks_logocharacter_reallyintitle | null
    number?: NullableIntFieldUpdateOperationsInput | number | null
    logocharactercomment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_logocharacterUncheckedUpdateManyInput = {
    entrycode?: StringFieldUpdateOperationsInput | string
    charactercode?: StringFieldUpdateOperationsInput | string
    reallyintitle?: NullableEnuminducks_logocharacter_reallyintitleFieldUpdateOperationsInput | $Enums.inducks_logocharacter_reallyintitle | null
    number?: NullableIntFieldUpdateOperationsInput | number | null
    logocharactercomment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_movieCreateInput = {
    moviecode: string
    title?: string | null
    moviecomment?: string | null
    appsummary?: string | null
    moviejobsummary?: string | null
    locked?: $Enums.inducks_movie_locked | null
    inputfilecode?: number | null
    maintenanceteamcode?: string | null
    aka?: string | null
    creationdate?: string | null
    moviedescription?: string | null
    distributor?: string | null
    genre?: string | null
    orderer?: string | null
    publicationdate?: string | null
    source?: string | null
    tim?: string | null
  }

  export type inducks_movieUncheckedCreateInput = {
    moviecode: string
    title?: string | null
    moviecomment?: string | null
    appsummary?: string | null
    moviejobsummary?: string | null
    locked?: $Enums.inducks_movie_locked | null
    inputfilecode?: number | null
    maintenanceteamcode?: string | null
    aka?: string | null
    creationdate?: string | null
    moviedescription?: string | null
    distributor?: string | null
    genre?: string | null
    orderer?: string | null
    publicationdate?: string | null
    source?: string | null
    tim?: string | null
  }

  export type inducks_movieUpdateInput = {
    moviecode?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    moviecomment?: NullableStringFieldUpdateOperationsInput | string | null
    appsummary?: NullableStringFieldUpdateOperationsInput | string | null
    moviejobsummary?: NullableStringFieldUpdateOperationsInput | string | null
    locked?: NullableEnuminducks_movie_lockedFieldUpdateOperationsInput | $Enums.inducks_movie_locked | null
    inputfilecode?: NullableIntFieldUpdateOperationsInput | number | null
    maintenanceteamcode?: NullableStringFieldUpdateOperationsInput | string | null
    aka?: NullableStringFieldUpdateOperationsInput | string | null
    creationdate?: NullableStringFieldUpdateOperationsInput | string | null
    moviedescription?: NullableStringFieldUpdateOperationsInput | string | null
    distributor?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    orderer?: NullableStringFieldUpdateOperationsInput | string | null
    publicationdate?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    tim?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_movieUncheckedUpdateInput = {
    moviecode?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    moviecomment?: NullableStringFieldUpdateOperationsInput | string | null
    appsummary?: NullableStringFieldUpdateOperationsInput | string | null
    moviejobsummary?: NullableStringFieldUpdateOperationsInput | string | null
    locked?: NullableEnuminducks_movie_lockedFieldUpdateOperationsInput | $Enums.inducks_movie_locked | null
    inputfilecode?: NullableIntFieldUpdateOperationsInput | number | null
    maintenanceteamcode?: NullableStringFieldUpdateOperationsInput | string | null
    aka?: NullableStringFieldUpdateOperationsInput | string | null
    creationdate?: NullableStringFieldUpdateOperationsInput | string | null
    moviedescription?: NullableStringFieldUpdateOperationsInput | string | null
    distributor?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    orderer?: NullableStringFieldUpdateOperationsInput | string | null
    publicationdate?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    tim?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_movieCreateManyInput = {
    moviecode: string
    title?: string | null
    moviecomment?: string | null
    appsummary?: string | null
    moviejobsummary?: string | null
    locked?: $Enums.inducks_movie_locked | null
    inputfilecode?: number | null
    maintenanceteamcode?: string | null
    aka?: string | null
    creationdate?: string | null
    moviedescription?: string | null
    distributor?: string | null
    genre?: string | null
    orderer?: string | null
    publicationdate?: string | null
    source?: string | null
    tim?: string | null
  }

  export type inducks_movieUpdateManyMutationInput = {
    moviecode?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    moviecomment?: NullableStringFieldUpdateOperationsInput | string | null
    appsummary?: NullableStringFieldUpdateOperationsInput | string | null
    moviejobsummary?: NullableStringFieldUpdateOperationsInput | string | null
    locked?: NullableEnuminducks_movie_lockedFieldUpdateOperationsInput | $Enums.inducks_movie_locked | null
    inputfilecode?: NullableIntFieldUpdateOperationsInput | number | null
    maintenanceteamcode?: NullableStringFieldUpdateOperationsInput | string | null
    aka?: NullableStringFieldUpdateOperationsInput | string | null
    creationdate?: NullableStringFieldUpdateOperationsInput | string | null
    moviedescription?: NullableStringFieldUpdateOperationsInput | string | null
    distributor?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    orderer?: NullableStringFieldUpdateOperationsInput | string | null
    publicationdate?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    tim?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_movieUncheckedUpdateManyInput = {
    moviecode?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    moviecomment?: NullableStringFieldUpdateOperationsInput | string | null
    appsummary?: NullableStringFieldUpdateOperationsInput | string | null
    moviejobsummary?: NullableStringFieldUpdateOperationsInput | string | null
    locked?: NullableEnuminducks_movie_lockedFieldUpdateOperationsInput | $Enums.inducks_movie_locked | null
    inputfilecode?: NullableIntFieldUpdateOperationsInput | number | null
    maintenanceteamcode?: NullableStringFieldUpdateOperationsInput | string | null
    aka?: NullableStringFieldUpdateOperationsInput | string | null
    creationdate?: NullableStringFieldUpdateOperationsInput | string | null
    moviedescription?: NullableStringFieldUpdateOperationsInput | string | null
    distributor?: NullableStringFieldUpdateOperationsInput | string | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    orderer?: NullableStringFieldUpdateOperationsInput | string | null
    publicationdate?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    tim?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_moviecharacterCreateInput = {
    moviecode: string
    charactercode: string
    istitlecharacter?: $Enums.inducks_moviecharacter_istitlecharacter | null
  }

  export type inducks_moviecharacterUncheckedCreateInput = {
    moviecode: string
    charactercode: string
    istitlecharacter?: $Enums.inducks_moviecharacter_istitlecharacter | null
  }

  export type inducks_moviecharacterUpdateInput = {
    moviecode?: StringFieldUpdateOperationsInput | string
    charactercode?: StringFieldUpdateOperationsInput | string
    istitlecharacter?: NullableEnuminducks_moviecharacter_istitlecharacterFieldUpdateOperationsInput | $Enums.inducks_moviecharacter_istitlecharacter | null
  }

  export type inducks_moviecharacterUncheckedUpdateInput = {
    moviecode?: StringFieldUpdateOperationsInput | string
    charactercode?: StringFieldUpdateOperationsInput | string
    istitlecharacter?: NullableEnuminducks_moviecharacter_istitlecharacterFieldUpdateOperationsInput | $Enums.inducks_moviecharacter_istitlecharacter | null
  }

  export type inducks_moviecharacterCreateManyInput = {
    moviecode: string
    charactercode: string
    istitlecharacter?: $Enums.inducks_moviecharacter_istitlecharacter | null
  }

  export type inducks_moviecharacterUpdateManyMutationInput = {
    moviecode?: StringFieldUpdateOperationsInput | string
    charactercode?: StringFieldUpdateOperationsInput | string
    istitlecharacter?: NullableEnuminducks_moviecharacter_istitlecharacterFieldUpdateOperationsInput | $Enums.inducks_moviecharacter_istitlecharacter | null
  }

  export type inducks_moviecharacterUncheckedUpdateManyInput = {
    moviecode?: StringFieldUpdateOperationsInput | string
    charactercode?: StringFieldUpdateOperationsInput | string
    istitlecharacter?: NullableEnuminducks_moviecharacter_istitlecharacterFieldUpdateOperationsInput | $Enums.inducks_moviecharacter_istitlecharacter | null
  }

  export type inducks_moviejobCreateInput = {
    moviecode: string
    personcode: string
    role: string
    moviejobcomment?: string | null
    indirect?: $Enums.inducks_moviejob_indirect | null
    doubt?: $Enums.inducks_moviejob_doubt | null
  }

  export type inducks_moviejobUncheckedCreateInput = {
    moviecode: string
    personcode: string
    role: string
    moviejobcomment?: string | null
    indirect?: $Enums.inducks_moviejob_indirect | null
    doubt?: $Enums.inducks_moviejob_doubt | null
  }

  export type inducks_moviejobUpdateInput = {
    moviecode?: StringFieldUpdateOperationsInput | string
    personcode?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    moviejobcomment?: NullableStringFieldUpdateOperationsInput | string | null
    indirect?: NullableEnuminducks_moviejob_indirectFieldUpdateOperationsInput | $Enums.inducks_moviejob_indirect | null
    doubt?: NullableEnuminducks_moviejob_doubtFieldUpdateOperationsInput | $Enums.inducks_moviejob_doubt | null
  }

  export type inducks_moviejobUncheckedUpdateInput = {
    moviecode?: StringFieldUpdateOperationsInput | string
    personcode?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    moviejobcomment?: NullableStringFieldUpdateOperationsInput | string | null
    indirect?: NullableEnuminducks_moviejob_indirectFieldUpdateOperationsInput | $Enums.inducks_moviejob_indirect | null
    doubt?: NullableEnuminducks_moviejob_doubtFieldUpdateOperationsInput | $Enums.inducks_moviejob_doubt | null
  }

  export type inducks_moviejobCreateManyInput = {
    moviecode: string
    personcode: string
    role: string
    moviejobcomment?: string | null
    indirect?: $Enums.inducks_moviejob_indirect | null
    doubt?: $Enums.inducks_moviejob_doubt | null
  }

  export type inducks_moviejobUpdateManyMutationInput = {
    moviecode?: StringFieldUpdateOperationsInput | string
    personcode?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    moviejobcomment?: NullableStringFieldUpdateOperationsInput | string | null
    indirect?: NullableEnuminducks_moviejob_indirectFieldUpdateOperationsInput | $Enums.inducks_moviejob_indirect | null
    doubt?: NullableEnuminducks_moviejob_doubtFieldUpdateOperationsInput | $Enums.inducks_moviejob_doubt | null
  }

  export type inducks_moviejobUncheckedUpdateManyInput = {
    moviecode?: StringFieldUpdateOperationsInput | string
    personcode?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    moviejobcomment?: NullableStringFieldUpdateOperationsInput | string | null
    indirect?: NullableEnuminducks_moviejob_indirectFieldUpdateOperationsInput | $Enums.inducks_moviejob_indirect | null
    doubt?: NullableEnuminducks_moviejob_doubtFieldUpdateOperationsInput | $Enums.inducks_moviejob_doubt | null
  }

  export type inducks_moviereferenceCreateInput = {
    storycode: string
    moviecode: string
    referencereasonid?: number | null
    frommovietostory?: $Enums.inducks_moviereference_frommovietostory | null
  }

  export type inducks_moviereferenceUncheckedCreateInput = {
    storycode: string
    moviecode: string
    referencereasonid?: number | null
    frommovietostory?: $Enums.inducks_moviereference_frommovietostory | null
  }

  export type inducks_moviereferenceUpdateInput = {
    storycode?: StringFieldUpdateOperationsInput | string
    moviecode?: StringFieldUpdateOperationsInput | string
    referencereasonid?: NullableIntFieldUpdateOperationsInput | number | null
    frommovietostory?: NullableEnuminducks_moviereference_frommovietostoryFieldUpdateOperationsInput | $Enums.inducks_moviereference_frommovietostory | null
  }

  export type inducks_moviereferenceUncheckedUpdateInput = {
    storycode?: StringFieldUpdateOperationsInput | string
    moviecode?: StringFieldUpdateOperationsInput | string
    referencereasonid?: NullableIntFieldUpdateOperationsInput | number | null
    frommovietostory?: NullableEnuminducks_moviereference_frommovietostoryFieldUpdateOperationsInput | $Enums.inducks_moviereference_frommovietostory | null
  }

  export type inducks_moviereferenceCreateManyInput = {
    storycode: string
    moviecode: string
    referencereasonid?: number | null
    frommovietostory?: $Enums.inducks_moviereference_frommovietostory | null
  }

  export type inducks_moviereferenceUpdateManyMutationInput = {
    storycode?: StringFieldUpdateOperationsInput | string
    moviecode?: StringFieldUpdateOperationsInput | string
    referencereasonid?: NullableIntFieldUpdateOperationsInput | number | null
    frommovietostory?: NullableEnuminducks_moviereference_frommovietostoryFieldUpdateOperationsInput | $Enums.inducks_moviereference_frommovietostory | null
  }

  export type inducks_moviereferenceUncheckedUpdateManyInput = {
    storycode?: StringFieldUpdateOperationsInput | string
    moviecode?: StringFieldUpdateOperationsInput | string
    referencereasonid?: NullableIntFieldUpdateOperationsInput | number | null
    frommovietostory?: NullableEnuminducks_moviereference_frommovietostoryFieldUpdateOperationsInput | $Enums.inducks_moviereference_frommovietostory | null
  }

  export type inducks_personCreateInput = {
    personcode: string
    nationalitycountrycode?: string | null
    fullname?: string | null
    official?: $Enums.inducks_person_official | null
    personcomment?: string | null
    unknownstudiomember?: $Enums.inducks_person_unknownstudiomember | null
    isfake?: $Enums.inducks_person_isfake | null
    numberofindexedissues?: number | null
    birthname?: string | null
    borndate?: string | null
    bornplace?: string | null
    deceaseddate?: string | null
    deceasedplace?: string | null
    education?: string | null
    moviestext?: string | null
    comicstext?: string | null
    othertext?: string | null
    photofilename?: string | null
    photocomment?: string | null
    photosource?: string | null
    personrefs?: string | null
  }

  export type inducks_personUncheckedCreateInput = {
    personcode: string
    nationalitycountrycode?: string | null
    fullname?: string | null
    official?: $Enums.inducks_person_official | null
    personcomment?: string | null
    unknownstudiomember?: $Enums.inducks_person_unknownstudiomember | null
    isfake?: $Enums.inducks_person_isfake | null
    numberofindexedissues?: number | null
    birthname?: string | null
    borndate?: string | null
    bornplace?: string | null
    deceaseddate?: string | null
    deceasedplace?: string | null
    education?: string | null
    moviestext?: string | null
    comicstext?: string | null
    othertext?: string | null
    photofilename?: string | null
    photocomment?: string | null
    photosource?: string | null
    personrefs?: string | null
  }

  export type inducks_personUpdateInput = {
    personcode?: StringFieldUpdateOperationsInput | string
    nationalitycountrycode?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    official?: NullableEnuminducks_person_officialFieldUpdateOperationsInput | $Enums.inducks_person_official | null
    personcomment?: NullableStringFieldUpdateOperationsInput | string | null
    unknownstudiomember?: NullableEnuminducks_person_unknownstudiomemberFieldUpdateOperationsInput | $Enums.inducks_person_unknownstudiomember | null
    isfake?: NullableEnuminducks_person_isfakeFieldUpdateOperationsInput | $Enums.inducks_person_isfake | null
    numberofindexedissues?: NullableIntFieldUpdateOperationsInput | number | null
    birthname?: NullableStringFieldUpdateOperationsInput | string | null
    borndate?: NullableStringFieldUpdateOperationsInput | string | null
    bornplace?: NullableStringFieldUpdateOperationsInput | string | null
    deceaseddate?: NullableStringFieldUpdateOperationsInput | string | null
    deceasedplace?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    moviestext?: NullableStringFieldUpdateOperationsInput | string | null
    comicstext?: NullableStringFieldUpdateOperationsInput | string | null
    othertext?: NullableStringFieldUpdateOperationsInput | string | null
    photofilename?: NullableStringFieldUpdateOperationsInput | string | null
    photocomment?: NullableStringFieldUpdateOperationsInput | string | null
    photosource?: NullableStringFieldUpdateOperationsInput | string | null
    personrefs?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_personUncheckedUpdateInput = {
    personcode?: StringFieldUpdateOperationsInput | string
    nationalitycountrycode?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    official?: NullableEnuminducks_person_officialFieldUpdateOperationsInput | $Enums.inducks_person_official | null
    personcomment?: NullableStringFieldUpdateOperationsInput | string | null
    unknownstudiomember?: NullableEnuminducks_person_unknownstudiomemberFieldUpdateOperationsInput | $Enums.inducks_person_unknownstudiomember | null
    isfake?: NullableEnuminducks_person_isfakeFieldUpdateOperationsInput | $Enums.inducks_person_isfake | null
    numberofindexedissues?: NullableIntFieldUpdateOperationsInput | number | null
    birthname?: NullableStringFieldUpdateOperationsInput | string | null
    borndate?: NullableStringFieldUpdateOperationsInput | string | null
    bornplace?: NullableStringFieldUpdateOperationsInput | string | null
    deceaseddate?: NullableStringFieldUpdateOperationsInput | string | null
    deceasedplace?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    moviestext?: NullableStringFieldUpdateOperationsInput | string | null
    comicstext?: NullableStringFieldUpdateOperationsInput | string | null
    othertext?: NullableStringFieldUpdateOperationsInput | string | null
    photofilename?: NullableStringFieldUpdateOperationsInput | string | null
    photocomment?: NullableStringFieldUpdateOperationsInput | string | null
    photosource?: NullableStringFieldUpdateOperationsInput | string | null
    personrefs?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_personCreateManyInput = {
    personcode: string
    nationalitycountrycode?: string | null
    fullname?: string | null
    official?: $Enums.inducks_person_official | null
    personcomment?: string | null
    unknownstudiomember?: $Enums.inducks_person_unknownstudiomember | null
    isfake?: $Enums.inducks_person_isfake | null
    numberofindexedissues?: number | null
    birthname?: string | null
    borndate?: string | null
    bornplace?: string | null
    deceaseddate?: string | null
    deceasedplace?: string | null
    education?: string | null
    moviestext?: string | null
    comicstext?: string | null
    othertext?: string | null
    photofilename?: string | null
    photocomment?: string | null
    photosource?: string | null
    personrefs?: string | null
  }

  export type inducks_personUpdateManyMutationInput = {
    personcode?: StringFieldUpdateOperationsInput | string
    nationalitycountrycode?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    official?: NullableEnuminducks_person_officialFieldUpdateOperationsInput | $Enums.inducks_person_official | null
    personcomment?: NullableStringFieldUpdateOperationsInput | string | null
    unknownstudiomember?: NullableEnuminducks_person_unknownstudiomemberFieldUpdateOperationsInput | $Enums.inducks_person_unknownstudiomember | null
    isfake?: NullableEnuminducks_person_isfakeFieldUpdateOperationsInput | $Enums.inducks_person_isfake | null
    numberofindexedissues?: NullableIntFieldUpdateOperationsInput | number | null
    birthname?: NullableStringFieldUpdateOperationsInput | string | null
    borndate?: NullableStringFieldUpdateOperationsInput | string | null
    bornplace?: NullableStringFieldUpdateOperationsInput | string | null
    deceaseddate?: NullableStringFieldUpdateOperationsInput | string | null
    deceasedplace?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    moviestext?: NullableStringFieldUpdateOperationsInput | string | null
    comicstext?: NullableStringFieldUpdateOperationsInput | string | null
    othertext?: NullableStringFieldUpdateOperationsInput | string | null
    photofilename?: NullableStringFieldUpdateOperationsInput | string | null
    photocomment?: NullableStringFieldUpdateOperationsInput | string | null
    photosource?: NullableStringFieldUpdateOperationsInput | string | null
    personrefs?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_personUncheckedUpdateManyInput = {
    personcode?: StringFieldUpdateOperationsInput | string
    nationalitycountrycode?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    official?: NullableEnuminducks_person_officialFieldUpdateOperationsInput | $Enums.inducks_person_official | null
    personcomment?: NullableStringFieldUpdateOperationsInput | string | null
    unknownstudiomember?: NullableEnuminducks_person_unknownstudiomemberFieldUpdateOperationsInput | $Enums.inducks_person_unknownstudiomember | null
    isfake?: NullableEnuminducks_person_isfakeFieldUpdateOperationsInput | $Enums.inducks_person_isfake | null
    numberofindexedissues?: NullableIntFieldUpdateOperationsInput | number | null
    birthname?: NullableStringFieldUpdateOperationsInput | string | null
    borndate?: NullableStringFieldUpdateOperationsInput | string | null
    bornplace?: NullableStringFieldUpdateOperationsInput | string | null
    deceaseddate?: NullableStringFieldUpdateOperationsInput | string | null
    deceasedplace?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    moviestext?: NullableStringFieldUpdateOperationsInput | string | null
    comicstext?: NullableStringFieldUpdateOperationsInput | string | null
    othertext?: NullableStringFieldUpdateOperationsInput | string | null
    photofilename?: NullableStringFieldUpdateOperationsInput | string | null
    photocomment?: NullableStringFieldUpdateOperationsInput | string | null
    photosource?: NullableStringFieldUpdateOperationsInput | string | null
    personrefs?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_personurlCreateInput = {
    personcode: string
    sitecode: string
    url?: string | null
  }

  export type inducks_personurlUncheckedCreateInput = {
    personcode: string
    sitecode: string
    url?: string | null
  }

  export type inducks_personurlUpdateInput = {
    personcode?: StringFieldUpdateOperationsInput | string
    sitecode?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_personurlUncheckedUpdateInput = {
    personcode?: StringFieldUpdateOperationsInput | string
    sitecode?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_personurlCreateManyInput = {
    personcode: string
    sitecode: string
    url?: string | null
  }

  export type inducks_personurlUpdateManyMutationInput = {
    personcode?: StringFieldUpdateOperationsInput | string
    sitecode?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_personurlUncheckedUpdateManyInput = {
    personcode?: StringFieldUpdateOperationsInput | string
    sitecode?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_publicationCreateInput = {
    publicationcode: string
    countrycode?: string | null
    languagecode?: string | null
    title?: string | null
    size?: string | null
    publicationcomment?: string | null
    circulation?: string | null
    numbersarefake?: $Enums.inducks_publication_numbersarefake | null
    error?: $Enums.inducks_publication_error | null
    locked?: $Enums.inducks_publication_locked | null
    inxforbidden?: $Enums.inducks_publication_inxforbidden | null
    inputfilecode?: number | null
    maintenanceteamcode?: string | null
  }

  export type inducks_publicationUncheckedCreateInput = {
    publicationcode: string
    countrycode?: string | null
    languagecode?: string | null
    title?: string | null
    size?: string | null
    publicationcomment?: string | null
    circulation?: string | null
    numbersarefake?: $Enums.inducks_publication_numbersarefake | null
    error?: $Enums.inducks_publication_error | null
    locked?: $Enums.inducks_publication_locked | null
    inxforbidden?: $Enums.inducks_publication_inxforbidden | null
    inputfilecode?: number | null
    maintenanceteamcode?: string | null
  }

  export type inducks_publicationUpdateInput = {
    publicationcode?: StringFieldUpdateOperationsInput | string
    countrycode?: NullableStringFieldUpdateOperationsInput | string | null
    languagecode?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    publicationcomment?: NullableStringFieldUpdateOperationsInput | string | null
    circulation?: NullableStringFieldUpdateOperationsInput | string | null
    numbersarefake?: NullableEnuminducks_publication_numbersarefakeFieldUpdateOperationsInput | $Enums.inducks_publication_numbersarefake | null
    error?: NullableEnuminducks_publication_errorFieldUpdateOperationsInput | $Enums.inducks_publication_error | null
    locked?: NullableEnuminducks_publication_lockedFieldUpdateOperationsInput | $Enums.inducks_publication_locked | null
    inxforbidden?: NullableEnuminducks_publication_inxforbiddenFieldUpdateOperationsInput | $Enums.inducks_publication_inxforbidden | null
    inputfilecode?: NullableIntFieldUpdateOperationsInput | number | null
    maintenanceteamcode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_publicationUncheckedUpdateInput = {
    publicationcode?: StringFieldUpdateOperationsInput | string
    countrycode?: NullableStringFieldUpdateOperationsInput | string | null
    languagecode?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    publicationcomment?: NullableStringFieldUpdateOperationsInput | string | null
    circulation?: NullableStringFieldUpdateOperationsInput | string | null
    numbersarefake?: NullableEnuminducks_publication_numbersarefakeFieldUpdateOperationsInput | $Enums.inducks_publication_numbersarefake | null
    error?: NullableEnuminducks_publication_errorFieldUpdateOperationsInput | $Enums.inducks_publication_error | null
    locked?: NullableEnuminducks_publication_lockedFieldUpdateOperationsInput | $Enums.inducks_publication_locked | null
    inxforbidden?: NullableEnuminducks_publication_inxforbiddenFieldUpdateOperationsInput | $Enums.inducks_publication_inxforbidden | null
    inputfilecode?: NullableIntFieldUpdateOperationsInput | number | null
    maintenanceteamcode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_publicationCreateManyInput = {
    publicationcode: string
    countrycode?: string | null
    languagecode?: string | null
    title?: string | null
    size?: string | null
    publicationcomment?: string | null
    circulation?: string | null
    numbersarefake?: $Enums.inducks_publication_numbersarefake | null
    error?: $Enums.inducks_publication_error | null
    locked?: $Enums.inducks_publication_locked | null
    inxforbidden?: $Enums.inducks_publication_inxforbidden | null
    inputfilecode?: number | null
    maintenanceteamcode?: string | null
  }

  export type inducks_publicationUpdateManyMutationInput = {
    publicationcode?: StringFieldUpdateOperationsInput | string
    countrycode?: NullableStringFieldUpdateOperationsInput | string | null
    languagecode?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    publicationcomment?: NullableStringFieldUpdateOperationsInput | string | null
    circulation?: NullableStringFieldUpdateOperationsInput | string | null
    numbersarefake?: NullableEnuminducks_publication_numbersarefakeFieldUpdateOperationsInput | $Enums.inducks_publication_numbersarefake | null
    error?: NullableEnuminducks_publication_errorFieldUpdateOperationsInput | $Enums.inducks_publication_error | null
    locked?: NullableEnuminducks_publication_lockedFieldUpdateOperationsInput | $Enums.inducks_publication_locked | null
    inxforbidden?: NullableEnuminducks_publication_inxforbiddenFieldUpdateOperationsInput | $Enums.inducks_publication_inxforbidden | null
    inputfilecode?: NullableIntFieldUpdateOperationsInput | number | null
    maintenanceteamcode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_publicationUncheckedUpdateManyInput = {
    publicationcode?: StringFieldUpdateOperationsInput | string
    countrycode?: NullableStringFieldUpdateOperationsInput | string | null
    languagecode?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    publicationcomment?: NullableStringFieldUpdateOperationsInput | string | null
    circulation?: NullableStringFieldUpdateOperationsInput | string | null
    numbersarefake?: NullableEnuminducks_publication_numbersarefakeFieldUpdateOperationsInput | $Enums.inducks_publication_numbersarefake | null
    error?: NullableEnuminducks_publication_errorFieldUpdateOperationsInput | $Enums.inducks_publication_error | null
    locked?: NullableEnuminducks_publication_lockedFieldUpdateOperationsInput | $Enums.inducks_publication_locked | null
    inxforbidden?: NullableEnuminducks_publication_inxforbiddenFieldUpdateOperationsInput | $Enums.inducks_publication_inxforbidden | null
    inputfilecode?: NullableIntFieldUpdateOperationsInput | number | null
    maintenanceteamcode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_publicationcategoryCreateInput = {
    publicationcode: string
    category?: string | null
  }

  export type inducks_publicationcategoryUncheckedCreateInput = {
    publicationcode: string
    category?: string | null
  }

  export type inducks_publicationcategoryUpdateInput = {
    publicationcode?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_publicationcategoryUncheckedUpdateInput = {
    publicationcode?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_publicationcategoryCreateManyInput = {
    publicationcode: string
    category?: string | null
  }

  export type inducks_publicationcategoryUpdateManyMutationInput = {
    publicationcode?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_publicationcategoryUncheckedUpdateManyInput = {
    publicationcode?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_publicationnameCreateInput = {
    publicationcode: string
    publicationname?: string | null
  }

  export type inducks_publicationnameUncheckedCreateInput = {
    publicationcode: string
    publicationname?: string | null
  }

  export type inducks_publicationnameUpdateInput = {
    publicationcode?: StringFieldUpdateOperationsInput | string
    publicationname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_publicationnameUncheckedUpdateInput = {
    publicationcode?: StringFieldUpdateOperationsInput | string
    publicationname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_publicationnameCreateManyInput = {
    publicationcode: string
    publicationname?: string | null
  }

  export type inducks_publicationnameUpdateManyMutationInput = {
    publicationcode?: StringFieldUpdateOperationsInput | string
    publicationname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_publicationnameUncheckedUpdateManyInput = {
    publicationcode?: StringFieldUpdateOperationsInput | string
    publicationname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_publicationurlCreateInput = {
    publicationcode: string
    sitecode: string
    url?: string | null
  }

  export type inducks_publicationurlUncheckedCreateInput = {
    publicationcode: string
    sitecode: string
    url?: string | null
  }

  export type inducks_publicationurlUpdateInput = {
    publicationcode?: StringFieldUpdateOperationsInput | string
    sitecode?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_publicationurlUncheckedUpdateInput = {
    publicationcode?: StringFieldUpdateOperationsInput | string
    sitecode?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_publicationurlCreateManyInput = {
    publicationcode: string
    sitecode: string
    url?: string | null
  }

  export type inducks_publicationurlUpdateManyMutationInput = {
    publicationcode?: StringFieldUpdateOperationsInput | string
    sitecode?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_publicationurlUncheckedUpdateManyInput = {
    publicationcode?: StringFieldUpdateOperationsInput | string
    sitecode?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_publisherCreateInput = {
    publisherid: string
    publishername?: string | null
  }

  export type inducks_publisherUncheckedCreateInput = {
    publisherid: string
    publishername?: string | null
  }

  export type inducks_publisherUpdateInput = {
    publisherid?: StringFieldUpdateOperationsInput | string
    publishername?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_publisherUncheckedUpdateInput = {
    publisherid?: StringFieldUpdateOperationsInput | string
    publishername?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_publisherCreateManyInput = {
    publisherid: string
    publishername?: string | null
  }

  export type inducks_publisherUpdateManyMutationInput = {
    publisherid?: StringFieldUpdateOperationsInput | string
    publishername?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_publisherUncheckedUpdateManyInput = {
    publisherid?: StringFieldUpdateOperationsInput | string
    publishername?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_publishingjobCreateInput = {
    publisherid: string
    issuecode: string
    publishingjobcomment?: string | null
  }

  export type inducks_publishingjobUncheckedCreateInput = {
    publisherid: string
    issuecode: string
    publishingjobcomment?: string | null
  }

  export type inducks_publishingjobUpdateInput = {
    publisherid?: StringFieldUpdateOperationsInput | string
    issuecode?: StringFieldUpdateOperationsInput | string
    publishingjobcomment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_publishingjobUncheckedUpdateInput = {
    publisherid?: StringFieldUpdateOperationsInput | string
    issuecode?: StringFieldUpdateOperationsInput | string
    publishingjobcomment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_publishingjobCreateManyInput = {
    publisherid: string
    issuecode: string
    publishingjobcomment?: string | null
  }

  export type inducks_publishingjobUpdateManyMutationInput = {
    publisherid?: StringFieldUpdateOperationsInput | string
    issuecode?: StringFieldUpdateOperationsInput | string
    publishingjobcomment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_publishingjobUncheckedUpdateManyInput = {
    publisherid?: StringFieldUpdateOperationsInput | string
    issuecode?: StringFieldUpdateOperationsInput | string
    publishingjobcomment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_referencereasonCreateInput = {
    referencereasonid: number
    referencereasontext?: string | null
  }

  export type inducks_referencereasonUncheckedCreateInput = {
    referencereasonid: number
    referencereasontext?: string | null
  }

  export type inducks_referencereasonUpdateInput = {
    referencereasonid?: IntFieldUpdateOperationsInput | number
    referencereasontext?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_referencereasonUncheckedUpdateInput = {
    referencereasonid?: IntFieldUpdateOperationsInput | number
    referencereasontext?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_referencereasonCreateManyInput = {
    referencereasonid: number
    referencereasontext?: string | null
  }

  export type inducks_referencereasonUpdateManyMutationInput = {
    referencereasonid?: IntFieldUpdateOperationsInput | number
    referencereasontext?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_referencereasonUncheckedUpdateManyInput = {
    referencereasonid?: IntFieldUpdateOperationsInput | number
    referencereasontext?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_referencereasonnameCreateInput = {
    referencereasonid: number
    languagecode: string
    referencereasontranslation?: string | null
  }

  export type inducks_referencereasonnameUncheckedCreateInput = {
    referencereasonid: number
    languagecode: string
    referencereasontranslation?: string | null
  }

  export type inducks_referencereasonnameUpdateInput = {
    referencereasonid?: IntFieldUpdateOperationsInput | number
    languagecode?: StringFieldUpdateOperationsInput | string
    referencereasontranslation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_referencereasonnameUncheckedUpdateInput = {
    referencereasonid?: IntFieldUpdateOperationsInput | number
    languagecode?: StringFieldUpdateOperationsInput | string
    referencereasontranslation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_referencereasonnameCreateManyInput = {
    referencereasonid: number
    languagecode: string
    referencereasontranslation?: string | null
  }

  export type inducks_referencereasonnameUpdateManyMutationInput = {
    referencereasonid?: IntFieldUpdateOperationsInput | number
    languagecode?: StringFieldUpdateOperationsInput | string
    referencereasontranslation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_referencereasonnameUncheckedUpdateManyInput = {
    referencereasonid?: IntFieldUpdateOperationsInput | number
    languagecode?: StringFieldUpdateOperationsInput | string
    referencereasontranslation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_siteCreateInput = {
    sitecode: string
    urlbase?: string | null
    images?: $Enums.inducks_site_images | null
    sitename?: string | null
    sitelogo?: string | null
    properties?: string | null
  }

  export type inducks_siteUncheckedCreateInput = {
    sitecode: string
    urlbase?: string | null
    images?: $Enums.inducks_site_images | null
    sitename?: string | null
    sitelogo?: string | null
    properties?: string | null
  }

  export type inducks_siteUpdateInput = {
    sitecode?: StringFieldUpdateOperationsInput | string
    urlbase?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableEnuminducks_site_imagesFieldUpdateOperationsInput | $Enums.inducks_site_images | null
    sitename?: NullableStringFieldUpdateOperationsInput | string | null
    sitelogo?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_siteUncheckedUpdateInput = {
    sitecode?: StringFieldUpdateOperationsInput | string
    urlbase?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableEnuminducks_site_imagesFieldUpdateOperationsInput | $Enums.inducks_site_images | null
    sitename?: NullableStringFieldUpdateOperationsInput | string | null
    sitelogo?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_siteCreateManyInput = {
    sitecode: string
    urlbase?: string | null
    images?: $Enums.inducks_site_images | null
    sitename?: string | null
    sitelogo?: string | null
    properties?: string | null
  }

  export type inducks_siteUpdateManyMutationInput = {
    sitecode?: StringFieldUpdateOperationsInput | string
    urlbase?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableEnuminducks_site_imagesFieldUpdateOperationsInput | $Enums.inducks_site_images | null
    sitename?: NullableStringFieldUpdateOperationsInput | string | null
    sitelogo?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_siteUncheckedUpdateManyInput = {
    sitecode?: StringFieldUpdateOperationsInput | string
    urlbase?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableEnuminducks_site_imagesFieldUpdateOperationsInput | $Enums.inducks_site_images | null
    sitename?: NullableStringFieldUpdateOperationsInput | string | null
    sitelogo?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_statcharactercharacterCreateInput = {
    charactercode: string
    cocharactercode?: string | null
    total: number
    yearrange?: string | null
  }

  export type inducks_statcharactercharacterUncheckedCreateInput = {
    charactercode: string
    cocharactercode?: string | null
    total: number
    yearrange?: string | null
  }

  export type inducks_statcharactercharacterUpdateInput = {
    charactercode?: StringFieldUpdateOperationsInput | string
    cocharactercode?: NullableStringFieldUpdateOperationsInput | string | null
    total?: IntFieldUpdateOperationsInput | number
    yearrange?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_statcharactercharacterUncheckedUpdateInput = {
    charactercode?: StringFieldUpdateOperationsInput | string
    cocharactercode?: NullableStringFieldUpdateOperationsInput | string | null
    total?: IntFieldUpdateOperationsInput | number
    yearrange?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_statcharactercharacterCreateManyInput = {
    charactercode: string
    cocharactercode?: string | null
    total: number
    yearrange?: string | null
  }

  export type inducks_statcharactercharacterUpdateManyMutationInput = {
    charactercode?: StringFieldUpdateOperationsInput | string
    cocharactercode?: NullableStringFieldUpdateOperationsInput | string | null
    total?: IntFieldUpdateOperationsInput | number
    yearrange?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_statcharactercharacterUncheckedUpdateManyInput = {
    charactercode?: StringFieldUpdateOperationsInput | string
    cocharactercode?: NullableStringFieldUpdateOperationsInput | string | null
    total?: IntFieldUpdateOperationsInput | number
    yearrange?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_statcharactercountryCreateInput = {
    charactercode: string
    countrycode: string
    total?: number | null
  }

  export type inducks_statcharactercountryUncheckedCreateInput = {
    charactercode: string
    countrycode: string
    total?: number | null
  }

  export type inducks_statcharactercountryUpdateInput = {
    charactercode?: StringFieldUpdateOperationsInput | string
    countrycode?: StringFieldUpdateOperationsInput | string
    total?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type inducks_statcharactercountryUncheckedUpdateInput = {
    charactercode?: StringFieldUpdateOperationsInput | string
    countrycode?: StringFieldUpdateOperationsInput | string
    total?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type inducks_statcharactercountryCreateManyInput = {
    charactercode: string
    countrycode: string
    total?: number | null
  }

  export type inducks_statcharactercountryUpdateManyMutationInput = {
    charactercode?: StringFieldUpdateOperationsInput | string
    countrycode?: StringFieldUpdateOperationsInput | string
    total?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type inducks_statcharactercountryUncheckedUpdateManyInput = {
    charactercode?: StringFieldUpdateOperationsInput | string
    countrycode?: StringFieldUpdateOperationsInput | string
    total?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type inducks_statcharacterstoryCreateInput = {
    charactercode: string
    storyheadercode: string
    total?: number | null
    yearrange?: string | null
  }

  export type inducks_statcharacterstoryUncheckedCreateInput = {
    charactercode: string
    storyheadercode: string
    total?: number | null
    yearrange?: string | null
  }

  export type inducks_statcharacterstoryUpdateInput = {
    charactercode?: StringFieldUpdateOperationsInput | string
    storyheadercode?: StringFieldUpdateOperationsInput | string
    total?: NullableIntFieldUpdateOperationsInput | number | null
    yearrange?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_statcharacterstoryUncheckedUpdateInput = {
    charactercode?: StringFieldUpdateOperationsInput | string
    storyheadercode?: StringFieldUpdateOperationsInput | string
    total?: NullableIntFieldUpdateOperationsInput | number | null
    yearrange?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_statcharacterstoryCreateManyInput = {
    charactercode: string
    storyheadercode: string
    total?: number | null
    yearrange?: string | null
  }

  export type inducks_statcharacterstoryUpdateManyMutationInput = {
    charactercode?: StringFieldUpdateOperationsInput | string
    storyheadercode?: StringFieldUpdateOperationsInput | string
    total?: NullableIntFieldUpdateOperationsInput | number | null
    yearrange?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_statcharacterstoryUncheckedUpdateManyInput = {
    charactercode?: StringFieldUpdateOperationsInput | string
    storyheadercode?: StringFieldUpdateOperationsInput | string
    total?: NullableIntFieldUpdateOperationsInput | number | null
    yearrange?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_statpersoncharacterCreateInput = {
    personcode: string
    charactercode?: string | null
    total: number
    yearrange?: string | null
  }

  export type inducks_statpersoncharacterUncheckedCreateInput = {
    personcode: string
    charactercode?: string | null
    total: number
    yearrange?: string | null
  }

  export type inducks_statpersoncharacterUpdateInput = {
    personcode?: StringFieldUpdateOperationsInput | string
    charactercode?: NullableStringFieldUpdateOperationsInput | string | null
    total?: IntFieldUpdateOperationsInput | number
    yearrange?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_statpersoncharacterUncheckedUpdateInput = {
    personcode?: StringFieldUpdateOperationsInput | string
    charactercode?: NullableStringFieldUpdateOperationsInput | string | null
    total?: IntFieldUpdateOperationsInput | number
    yearrange?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_statpersoncharacterCreateManyInput = {
    personcode: string
    charactercode?: string | null
    total: number
    yearrange?: string | null
  }

  export type inducks_statpersoncharacterUpdateManyMutationInput = {
    personcode?: StringFieldUpdateOperationsInput | string
    charactercode?: NullableStringFieldUpdateOperationsInput | string | null
    total?: IntFieldUpdateOperationsInput | number
    yearrange?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_statpersoncharacterUncheckedUpdateManyInput = {
    personcode?: StringFieldUpdateOperationsInput | string
    charactercode?: NullableStringFieldUpdateOperationsInput | string | null
    total?: IntFieldUpdateOperationsInput | number
    yearrange?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_statpersoncountryCreateInput = {
    personcode: string
    countrycode: string
    total?: number | null
  }

  export type inducks_statpersoncountryUncheckedCreateInput = {
    personcode: string
    countrycode: string
    total?: number | null
  }

  export type inducks_statpersoncountryUpdateInput = {
    personcode?: StringFieldUpdateOperationsInput | string
    countrycode?: StringFieldUpdateOperationsInput | string
    total?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type inducks_statpersoncountryUncheckedUpdateInput = {
    personcode?: StringFieldUpdateOperationsInput | string
    countrycode?: StringFieldUpdateOperationsInput | string
    total?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type inducks_statpersoncountryCreateManyInput = {
    personcode: string
    countrycode: string
    total?: number | null
  }

  export type inducks_statpersoncountryUpdateManyMutationInput = {
    personcode?: StringFieldUpdateOperationsInput | string
    countrycode?: StringFieldUpdateOperationsInput | string
    total?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type inducks_statpersoncountryUncheckedUpdateManyInput = {
    personcode?: StringFieldUpdateOperationsInput | string
    countrycode?: StringFieldUpdateOperationsInput | string
    total?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type inducks_statpersonpersonCreateInput = {
    personcode: string
    copersoncode?: string | null
    total: number
    yearrange?: string | null
  }

  export type inducks_statpersonpersonUncheckedCreateInput = {
    personcode: string
    copersoncode?: string | null
    total: number
    yearrange?: string | null
  }

  export type inducks_statpersonpersonUpdateInput = {
    personcode?: StringFieldUpdateOperationsInput | string
    copersoncode?: NullableStringFieldUpdateOperationsInput | string | null
    total?: IntFieldUpdateOperationsInput | number
    yearrange?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_statpersonpersonUncheckedUpdateInput = {
    personcode?: StringFieldUpdateOperationsInput | string
    copersoncode?: NullableStringFieldUpdateOperationsInput | string | null
    total?: IntFieldUpdateOperationsInput | number
    yearrange?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_statpersonpersonCreateManyInput = {
    personcode: string
    copersoncode?: string | null
    total: number
    yearrange?: string | null
  }

  export type inducks_statpersonpersonUpdateManyMutationInput = {
    personcode?: StringFieldUpdateOperationsInput | string
    copersoncode?: NullableStringFieldUpdateOperationsInput | string | null
    total?: IntFieldUpdateOperationsInput | number
    yearrange?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_statpersonpersonUncheckedUpdateManyInput = {
    personcode?: StringFieldUpdateOperationsInput | string
    copersoncode?: NullableStringFieldUpdateOperationsInput | string | null
    total?: IntFieldUpdateOperationsInput | number
    yearrange?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_statpersonstoryCreateInput = {
    personcode: string
    storyheadercode: string
    total?: number | null
    yearrange?: string | null
  }

  export type inducks_statpersonstoryUncheckedCreateInput = {
    personcode: string
    storyheadercode: string
    total?: number | null
    yearrange?: string | null
  }

  export type inducks_statpersonstoryUpdateInput = {
    personcode?: StringFieldUpdateOperationsInput | string
    storyheadercode?: StringFieldUpdateOperationsInput | string
    total?: NullableIntFieldUpdateOperationsInput | number | null
    yearrange?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_statpersonstoryUncheckedUpdateInput = {
    personcode?: StringFieldUpdateOperationsInput | string
    storyheadercode?: StringFieldUpdateOperationsInput | string
    total?: NullableIntFieldUpdateOperationsInput | number | null
    yearrange?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_statpersonstoryCreateManyInput = {
    personcode: string
    storyheadercode: string
    total?: number | null
    yearrange?: string | null
  }

  export type inducks_statpersonstoryUpdateManyMutationInput = {
    personcode?: StringFieldUpdateOperationsInput | string
    storyheadercode?: StringFieldUpdateOperationsInput | string
    total?: NullableIntFieldUpdateOperationsInput | number | null
    yearrange?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_statpersonstoryUncheckedUpdateManyInput = {
    personcode?: StringFieldUpdateOperationsInput | string
    storyheadercode?: StringFieldUpdateOperationsInput | string
    total?: NullableIntFieldUpdateOperationsInput | number | null
    yearrange?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_storyCreateInput = {
    storycode: string
    originalstoryversioncode?: string | null
    creationdate?: string | null
    firstpublicationdate?: string | null
    endpublicationdate?: string | null
    title?: string | null
    usedifferentcode?: string | null
    storycomment?: string | null
    error?: $Enums.inducks_story_error | null
    repcountrysummary?: string | null
    storyparts?: number | null
    locked?: $Enums.inducks_story_locked | null
    inputfilecode?: number | null
    issuecodeofstoryitem?: string | null
    maintenanceteamcode?: string | null
    storyheadercode?: string | null
  }

  export type inducks_storyUncheckedCreateInput = {
    storycode: string
    originalstoryversioncode?: string | null
    creationdate?: string | null
    firstpublicationdate?: string | null
    endpublicationdate?: string | null
    title?: string | null
    usedifferentcode?: string | null
    storycomment?: string | null
    error?: $Enums.inducks_story_error | null
    repcountrysummary?: string | null
    storyparts?: number | null
    locked?: $Enums.inducks_story_locked | null
    inputfilecode?: number | null
    issuecodeofstoryitem?: string | null
    maintenanceteamcode?: string | null
    storyheadercode?: string | null
  }

  export type inducks_storyUpdateInput = {
    storycode?: StringFieldUpdateOperationsInput | string
    originalstoryversioncode?: NullableStringFieldUpdateOperationsInput | string | null
    creationdate?: NullableStringFieldUpdateOperationsInput | string | null
    firstpublicationdate?: NullableStringFieldUpdateOperationsInput | string | null
    endpublicationdate?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    usedifferentcode?: NullableStringFieldUpdateOperationsInput | string | null
    storycomment?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableEnuminducks_story_errorFieldUpdateOperationsInput | $Enums.inducks_story_error | null
    repcountrysummary?: NullableStringFieldUpdateOperationsInput | string | null
    storyparts?: NullableIntFieldUpdateOperationsInput | number | null
    locked?: NullableEnuminducks_story_lockedFieldUpdateOperationsInput | $Enums.inducks_story_locked | null
    inputfilecode?: NullableIntFieldUpdateOperationsInput | number | null
    issuecodeofstoryitem?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceteamcode?: NullableStringFieldUpdateOperationsInput | string | null
    storyheadercode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_storyUncheckedUpdateInput = {
    storycode?: StringFieldUpdateOperationsInput | string
    originalstoryversioncode?: NullableStringFieldUpdateOperationsInput | string | null
    creationdate?: NullableStringFieldUpdateOperationsInput | string | null
    firstpublicationdate?: NullableStringFieldUpdateOperationsInput | string | null
    endpublicationdate?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    usedifferentcode?: NullableStringFieldUpdateOperationsInput | string | null
    storycomment?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableEnuminducks_story_errorFieldUpdateOperationsInput | $Enums.inducks_story_error | null
    repcountrysummary?: NullableStringFieldUpdateOperationsInput | string | null
    storyparts?: NullableIntFieldUpdateOperationsInput | number | null
    locked?: NullableEnuminducks_story_lockedFieldUpdateOperationsInput | $Enums.inducks_story_locked | null
    inputfilecode?: NullableIntFieldUpdateOperationsInput | number | null
    issuecodeofstoryitem?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceteamcode?: NullableStringFieldUpdateOperationsInput | string | null
    storyheadercode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_storyCreateManyInput = {
    storycode: string
    originalstoryversioncode?: string | null
    creationdate?: string | null
    firstpublicationdate?: string | null
    endpublicationdate?: string | null
    title?: string | null
    usedifferentcode?: string | null
    storycomment?: string | null
    error?: $Enums.inducks_story_error | null
    repcountrysummary?: string | null
    storyparts?: number | null
    locked?: $Enums.inducks_story_locked | null
    inputfilecode?: number | null
    issuecodeofstoryitem?: string | null
    maintenanceteamcode?: string | null
    storyheadercode?: string | null
  }

  export type inducks_storyUpdateManyMutationInput = {
    storycode?: StringFieldUpdateOperationsInput | string
    originalstoryversioncode?: NullableStringFieldUpdateOperationsInput | string | null
    creationdate?: NullableStringFieldUpdateOperationsInput | string | null
    firstpublicationdate?: NullableStringFieldUpdateOperationsInput | string | null
    endpublicationdate?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    usedifferentcode?: NullableStringFieldUpdateOperationsInput | string | null
    storycomment?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableEnuminducks_story_errorFieldUpdateOperationsInput | $Enums.inducks_story_error | null
    repcountrysummary?: NullableStringFieldUpdateOperationsInput | string | null
    storyparts?: NullableIntFieldUpdateOperationsInput | number | null
    locked?: NullableEnuminducks_story_lockedFieldUpdateOperationsInput | $Enums.inducks_story_locked | null
    inputfilecode?: NullableIntFieldUpdateOperationsInput | number | null
    issuecodeofstoryitem?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceteamcode?: NullableStringFieldUpdateOperationsInput | string | null
    storyheadercode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_storyUncheckedUpdateManyInput = {
    storycode?: StringFieldUpdateOperationsInput | string
    originalstoryversioncode?: NullableStringFieldUpdateOperationsInput | string | null
    creationdate?: NullableStringFieldUpdateOperationsInput | string | null
    firstpublicationdate?: NullableStringFieldUpdateOperationsInput | string | null
    endpublicationdate?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    usedifferentcode?: NullableStringFieldUpdateOperationsInput | string | null
    storycomment?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableEnuminducks_story_errorFieldUpdateOperationsInput | $Enums.inducks_story_error | null
    repcountrysummary?: NullableStringFieldUpdateOperationsInput | string | null
    storyparts?: NullableIntFieldUpdateOperationsInput | number | null
    locked?: NullableEnuminducks_story_lockedFieldUpdateOperationsInput | $Enums.inducks_story_locked | null
    inputfilecode?: NullableIntFieldUpdateOperationsInput | number | null
    issuecodeofstoryitem?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceteamcode?: NullableStringFieldUpdateOperationsInput | string | null
    storyheadercode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_storycodesCreateInput = {
    storycode: string
    alternativecode: string
    unpackedcode?: string | null
    codecomment?: string | null
  }

  export type inducks_storycodesUncheckedCreateInput = {
    storycode: string
    alternativecode: string
    unpackedcode?: string | null
    codecomment?: string | null
  }

  export type inducks_storycodesUpdateInput = {
    storycode?: StringFieldUpdateOperationsInput | string
    alternativecode?: StringFieldUpdateOperationsInput | string
    unpackedcode?: NullableStringFieldUpdateOperationsInput | string | null
    codecomment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_storycodesUncheckedUpdateInput = {
    storycode?: StringFieldUpdateOperationsInput | string
    alternativecode?: StringFieldUpdateOperationsInput | string
    unpackedcode?: NullableStringFieldUpdateOperationsInput | string | null
    codecomment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_storycodesCreateManyInput = {
    storycode: string
    alternativecode: string
    unpackedcode?: string | null
    codecomment?: string | null
  }

  export type inducks_storycodesUpdateManyMutationInput = {
    storycode?: StringFieldUpdateOperationsInput | string
    alternativecode?: StringFieldUpdateOperationsInput | string
    unpackedcode?: NullableStringFieldUpdateOperationsInput | string | null
    codecomment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_storycodesUncheckedUpdateManyInput = {
    storycode?: StringFieldUpdateOperationsInput | string
    alternativecode?: StringFieldUpdateOperationsInput | string
    unpackedcode?: NullableStringFieldUpdateOperationsInput | string | null
    codecomment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_storydescriptionCreateInput = {
    storyversioncode: string
    languagecode: string
    desctext?: string | null
  }

  export type inducks_storydescriptionUncheckedCreateInput = {
    storyversioncode: string
    languagecode: string
    desctext?: string | null
  }

  export type inducks_storydescriptionUpdateInput = {
    storyversioncode?: StringFieldUpdateOperationsInput | string
    languagecode?: StringFieldUpdateOperationsInput | string
    desctext?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_storydescriptionUncheckedUpdateInput = {
    storyversioncode?: StringFieldUpdateOperationsInput | string
    languagecode?: StringFieldUpdateOperationsInput | string
    desctext?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_storydescriptionCreateManyInput = {
    storyversioncode: string
    languagecode: string
    desctext?: string | null
  }

  export type inducks_storydescriptionUpdateManyMutationInput = {
    storyversioncode?: StringFieldUpdateOperationsInput | string
    languagecode?: StringFieldUpdateOperationsInput | string
    desctext?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_storydescriptionUncheckedUpdateManyInput = {
    storyversioncode?: StringFieldUpdateOperationsInput | string
    languagecode?: StringFieldUpdateOperationsInput | string
    desctext?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_storyheaderCreateInput = {
    storyheadercode: string
    level: string
    title?: string | null
    storyheadercomment?: string | null
    countrycode?: string | null
  }

  export type inducks_storyheaderUncheckedCreateInput = {
    storyheadercode: string
    level: string
    title?: string | null
    storyheadercomment?: string | null
    countrycode?: string | null
  }

  export type inducks_storyheaderUpdateInput = {
    storyheadercode?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    storyheadercomment?: NullableStringFieldUpdateOperationsInput | string | null
    countrycode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_storyheaderUncheckedUpdateInput = {
    storyheadercode?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    storyheadercomment?: NullableStringFieldUpdateOperationsInput | string | null
    countrycode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_storyheaderCreateManyInput = {
    storyheadercode: string
    level: string
    title?: string | null
    storyheadercomment?: string | null
    countrycode?: string | null
  }

  export type inducks_storyheaderUpdateManyMutationInput = {
    storyheadercode?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    storyheadercomment?: NullableStringFieldUpdateOperationsInput | string | null
    countrycode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_storyheaderUncheckedUpdateManyInput = {
    storyheadercode?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    storyheadercomment?: NullableStringFieldUpdateOperationsInput | string | null
    countrycode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_storyjobCreateInput = {
    storyversioncode: string
    personcode: string
    plotwritartink: string
    storyjobcomment?: string | null
    indirect?: $Enums.inducks_storyjob_indirect | null
    doubt?: $Enums.inducks_storyjob_doubt | null
  }

  export type inducks_storyjobUncheckedCreateInput = {
    storyversioncode: string
    personcode: string
    plotwritartink: string
    storyjobcomment?: string | null
    indirect?: $Enums.inducks_storyjob_indirect | null
    doubt?: $Enums.inducks_storyjob_doubt | null
  }

  export type inducks_storyjobUpdateInput = {
    storyversioncode?: StringFieldUpdateOperationsInput | string
    personcode?: StringFieldUpdateOperationsInput | string
    plotwritartink?: StringFieldUpdateOperationsInput | string
    storyjobcomment?: NullableStringFieldUpdateOperationsInput | string | null
    indirect?: NullableEnuminducks_storyjob_indirectFieldUpdateOperationsInput | $Enums.inducks_storyjob_indirect | null
    doubt?: NullableEnuminducks_storyjob_doubtFieldUpdateOperationsInput | $Enums.inducks_storyjob_doubt | null
  }

  export type inducks_storyjobUncheckedUpdateInput = {
    storyversioncode?: StringFieldUpdateOperationsInput | string
    personcode?: StringFieldUpdateOperationsInput | string
    plotwritartink?: StringFieldUpdateOperationsInput | string
    storyjobcomment?: NullableStringFieldUpdateOperationsInput | string | null
    indirect?: NullableEnuminducks_storyjob_indirectFieldUpdateOperationsInput | $Enums.inducks_storyjob_indirect | null
    doubt?: NullableEnuminducks_storyjob_doubtFieldUpdateOperationsInput | $Enums.inducks_storyjob_doubt | null
  }

  export type inducks_storyjobCreateManyInput = {
    storyversioncode: string
    personcode: string
    plotwritartink: string
    storyjobcomment?: string | null
    indirect?: $Enums.inducks_storyjob_indirect | null
    doubt?: $Enums.inducks_storyjob_doubt | null
  }

  export type inducks_storyjobUpdateManyMutationInput = {
    storyversioncode?: StringFieldUpdateOperationsInput | string
    personcode?: StringFieldUpdateOperationsInput | string
    plotwritartink?: StringFieldUpdateOperationsInput | string
    storyjobcomment?: NullableStringFieldUpdateOperationsInput | string | null
    indirect?: NullableEnuminducks_storyjob_indirectFieldUpdateOperationsInput | $Enums.inducks_storyjob_indirect | null
    doubt?: NullableEnuminducks_storyjob_doubtFieldUpdateOperationsInput | $Enums.inducks_storyjob_doubt | null
  }

  export type inducks_storyjobUncheckedUpdateManyInput = {
    storyversioncode?: StringFieldUpdateOperationsInput | string
    personcode?: StringFieldUpdateOperationsInput | string
    plotwritartink?: StringFieldUpdateOperationsInput | string
    storyjobcomment?: NullableStringFieldUpdateOperationsInput | string | null
    indirect?: NullableEnuminducks_storyjob_indirectFieldUpdateOperationsInput | $Enums.inducks_storyjob_indirect | null
    doubt?: NullableEnuminducks_storyjob_doubtFieldUpdateOperationsInput | $Enums.inducks_storyjob_doubt | null
  }

  export type inducks_storyreferenceCreateInput = {
    fromstorycode: string
    tostorycode: string
    referencereasonid?: number | null
  }

  export type inducks_storyreferenceUncheckedCreateInput = {
    fromstorycode: string
    tostorycode: string
    referencereasonid?: number | null
  }

  export type inducks_storyreferenceUpdateInput = {
    fromstorycode?: StringFieldUpdateOperationsInput | string
    tostorycode?: StringFieldUpdateOperationsInput | string
    referencereasonid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type inducks_storyreferenceUncheckedUpdateInput = {
    fromstorycode?: StringFieldUpdateOperationsInput | string
    tostorycode?: StringFieldUpdateOperationsInput | string
    referencereasonid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type inducks_storyreferenceCreateManyInput = {
    fromstorycode: string
    tostorycode: string
    referencereasonid?: number | null
  }

  export type inducks_storyreferenceUpdateManyMutationInput = {
    fromstorycode?: StringFieldUpdateOperationsInput | string
    tostorycode?: StringFieldUpdateOperationsInput | string
    referencereasonid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type inducks_storyreferenceUncheckedUpdateManyInput = {
    fromstorycode?: StringFieldUpdateOperationsInput | string
    tostorycode?: StringFieldUpdateOperationsInput | string
    referencereasonid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type inducks_storysubseriesCreateInput = {
    storycode: string
    subseriescode: string
    storysubseriescomment?: string | null
  }

  export type inducks_storysubseriesUncheckedCreateInput = {
    storycode: string
    subseriescode: string
    storysubseriescomment?: string | null
  }

  export type inducks_storysubseriesUpdateInput = {
    storycode?: StringFieldUpdateOperationsInput | string
    subseriescode?: StringFieldUpdateOperationsInput | string
    storysubseriescomment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_storysubseriesUncheckedUpdateInput = {
    storycode?: StringFieldUpdateOperationsInput | string
    subseriescode?: StringFieldUpdateOperationsInput | string
    storysubseriescomment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_storysubseriesCreateManyInput = {
    storycode: string
    subseriescode: string
    storysubseriescomment?: string | null
  }

  export type inducks_storysubseriesUpdateManyMutationInput = {
    storycode?: StringFieldUpdateOperationsInput | string
    subseriescode?: StringFieldUpdateOperationsInput | string
    storysubseriescomment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_storysubseriesUncheckedUpdateManyInput = {
    storycode?: StringFieldUpdateOperationsInput | string
    subseriescode?: StringFieldUpdateOperationsInput | string
    storysubseriescomment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_storyurlCreateInput = {
    storycode: string
    sitecode: string
    url?: string | null
  }

  export type inducks_storyurlUncheckedCreateInput = {
    storycode: string
    sitecode: string
    url?: string | null
  }

  export type inducks_storyurlUpdateInput = {
    storycode?: StringFieldUpdateOperationsInput | string
    sitecode?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_storyurlUncheckedUpdateInput = {
    storycode?: StringFieldUpdateOperationsInput | string
    sitecode?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_storyurlCreateManyInput = {
    storycode: string
    sitecode: string
    url?: string | null
  }

  export type inducks_storyurlUpdateManyMutationInput = {
    storycode?: StringFieldUpdateOperationsInput | string
    sitecode?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_storyurlUncheckedUpdateManyInput = {
    storycode?: StringFieldUpdateOperationsInput | string
    sitecode?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_storyversionCreateInput = {
    storyversioncode: string
    storycode?: string | null
    entirepages?: number | null
    brokenpagenumerator?: number | null
    brokenpagedenominator?: number | null
    brokenpageunspecified?: $Enums.inducks_storyversion_brokenpageunspecified | null
    kind?: string | null
    rowsperpage?: number | null
    columnsperpage?: number | null
    appisxapp?: $Enums.inducks_storyversion_appisxapp | null
    what?: string | null
    appsummary?: string | null
    plotsummary?: string | null
    writsummary?: string | null
    artsummary?: string | null
    inksummary?: string | null
    creatorrefsummary?: string | null
    keywordsummary?: string | null
    estimatedpanels?: number | null
  }

  export type inducks_storyversionUncheckedCreateInput = {
    storyversioncode: string
    storycode?: string | null
    entirepages?: number | null
    brokenpagenumerator?: number | null
    brokenpagedenominator?: number | null
    brokenpageunspecified?: $Enums.inducks_storyversion_brokenpageunspecified | null
    kind?: string | null
    rowsperpage?: number | null
    columnsperpage?: number | null
    appisxapp?: $Enums.inducks_storyversion_appisxapp | null
    what?: string | null
    appsummary?: string | null
    plotsummary?: string | null
    writsummary?: string | null
    artsummary?: string | null
    inksummary?: string | null
    creatorrefsummary?: string | null
    keywordsummary?: string | null
    estimatedpanels?: number | null
  }

  export type inducks_storyversionUpdateInput = {
    storyversioncode?: StringFieldUpdateOperationsInput | string
    storycode?: NullableStringFieldUpdateOperationsInput | string | null
    entirepages?: NullableIntFieldUpdateOperationsInput | number | null
    brokenpagenumerator?: NullableIntFieldUpdateOperationsInput | number | null
    brokenpagedenominator?: NullableIntFieldUpdateOperationsInput | number | null
    brokenpageunspecified?: NullableEnuminducks_storyversion_brokenpageunspecifiedFieldUpdateOperationsInput | $Enums.inducks_storyversion_brokenpageunspecified | null
    kind?: NullableStringFieldUpdateOperationsInput | string | null
    rowsperpage?: NullableIntFieldUpdateOperationsInput | number | null
    columnsperpage?: NullableIntFieldUpdateOperationsInput | number | null
    appisxapp?: NullableEnuminducks_storyversion_appisxappFieldUpdateOperationsInput | $Enums.inducks_storyversion_appisxapp | null
    what?: NullableStringFieldUpdateOperationsInput | string | null
    appsummary?: NullableStringFieldUpdateOperationsInput | string | null
    plotsummary?: NullableStringFieldUpdateOperationsInput | string | null
    writsummary?: NullableStringFieldUpdateOperationsInput | string | null
    artsummary?: NullableStringFieldUpdateOperationsInput | string | null
    inksummary?: NullableStringFieldUpdateOperationsInput | string | null
    creatorrefsummary?: NullableStringFieldUpdateOperationsInput | string | null
    keywordsummary?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedpanels?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type inducks_storyversionUncheckedUpdateInput = {
    storyversioncode?: StringFieldUpdateOperationsInput | string
    storycode?: NullableStringFieldUpdateOperationsInput | string | null
    entirepages?: NullableIntFieldUpdateOperationsInput | number | null
    brokenpagenumerator?: NullableIntFieldUpdateOperationsInput | number | null
    brokenpagedenominator?: NullableIntFieldUpdateOperationsInput | number | null
    brokenpageunspecified?: NullableEnuminducks_storyversion_brokenpageunspecifiedFieldUpdateOperationsInput | $Enums.inducks_storyversion_brokenpageunspecified | null
    kind?: NullableStringFieldUpdateOperationsInput | string | null
    rowsperpage?: NullableIntFieldUpdateOperationsInput | number | null
    columnsperpage?: NullableIntFieldUpdateOperationsInput | number | null
    appisxapp?: NullableEnuminducks_storyversion_appisxappFieldUpdateOperationsInput | $Enums.inducks_storyversion_appisxapp | null
    what?: NullableStringFieldUpdateOperationsInput | string | null
    appsummary?: NullableStringFieldUpdateOperationsInput | string | null
    plotsummary?: NullableStringFieldUpdateOperationsInput | string | null
    writsummary?: NullableStringFieldUpdateOperationsInput | string | null
    artsummary?: NullableStringFieldUpdateOperationsInput | string | null
    inksummary?: NullableStringFieldUpdateOperationsInput | string | null
    creatorrefsummary?: NullableStringFieldUpdateOperationsInput | string | null
    keywordsummary?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedpanels?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type inducks_storyversionCreateManyInput = {
    storyversioncode: string
    storycode?: string | null
    entirepages?: number | null
    brokenpagenumerator?: number | null
    brokenpagedenominator?: number | null
    brokenpageunspecified?: $Enums.inducks_storyversion_brokenpageunspecified | null
    kind?: string | null
    rowsperpage?: number | null
    columnsperpage?: number | null
    appisxapp?: $Enums.inducks_storyversion_appisxapp | null
    what?: string | null
    appsummary?: string | null
    plotsummary?: string | null
    writsummary?: string | null
    artsummary?: string | null
    inksummary?: string | null
    creatorrefsummary?: string | null
    keywordsummary?: string | null
    estimatedpanels?: number | null
  }

  export type inducks_storyversionUpdateManyMutationInput = {
    storyversioncode?: StringFieldUpdateOperationsInput | string
    storycode?: NullableStringFieldUpdateOperationsInput | string | null
    entirepages?: NullableIntFieldUpdateOperationsInput | number | null
    brokenpagenumerator?: NullableIntFieldUpdateOperationsInput | number | null
    brokenpagedenominator?: NullableIntFieldUpdateOperationsInput | number | null
    brokenpageunspecified?: NullableEnuminducks_storyversion_brokenpageunspecifiedFieldUpdateOperationsInput | $Enums.inducks_storyversion_brokenpageunspecified | null
    kind?: NullableStringFieldUpdateOperationsInput | string | null
    rowsperpage?: NullableIntFieldUpdateOperationsInput | number | null
    columnsperpage?: NullableIntFieldUpdateOperationsInput | number | null
    appisxapp?: NullableEnuminducks_storyversion_appisxappFieldUpdateOperationsInput | $Enums.inducks_storyversion_appisxapp | null
    what?: NullableStringFieldUpdateOperationsInput | string | null
    appsummary?: NullableStringFieldUpdateOperationsInput | string | null
    plotsummary?: NullableStringFieldUpdateOperationsInput | string | null
    writsummary?: NullableStringFieldUpdateOperationsInput | string | null
    artsummary?: NullableStringFieldUpdateOperationsInput | string | null
    inksummary?: NullableStringFieldUpdateOperationsInput | string | null
    creatorrefsummary?: NullableStringFieldUpdateOperationsInput | string | null
    keywordsummary?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedpanels?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type inducks_storyversionUncheckedUpdateManyInput = {
    storyversioncode?: StringFieldUpdateOperationsInput | string
    storycode?: NullableStringFieldUpdateOperationsInput | string | null
    entirepages?: NullableIntFieldUpdateOperationsInput | number | null
    brokenpagenumerator?: NullableIntFieldUpdateOperationsInput | number | null
    brokenpagedenominator?: NullableIntFieldUpdateOperationsInput | number | null
    brokenpageunspecified?: NullableEnuminducks_storyversion_brokenpageunspecifiedFieldUpdateOperationsInput | $Enums.inducks_storyversion_brokenpageunspecified | null
    kind?: NullableStringFieldUpdateOperationsInput | string | null
    rowsperpage?: NullableIntFieldUpdateOperationsInput | number | null
    columnsperpage?: NullableIntFieldUpdateOperationsInput | number | null
    appisxapp?: NullableEnuminducks_storyversion_appisxappFieldUpdateOperationsInput | $Enums.inducks_storyversion_appisxapp | null
    what?: NullableStringFieldUpdateOperationsInput | string | null
    appsummary?: NullableStringFieldUpdateOperationsInput | string | null
    plotsummary?: NullableStringFieldUpdateOperationsInput | string | null
    writsummary?: NullableStringFieldUpdateOperationsInput | string | null
    artsummary?: NullableStringFieldUpdateOperationsInput | string | null
    inksummary?: NullableStringFieldUpdateOperationsInput | string | null
    creatorrefsummary?: NullableStringFieldUpdateOperationsInput | string | null
    keywordsummary?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedpanels?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type inducks_storyversion_nofulltextCreateInput = {
    storyversioncode: string
    storycode?: string | null
    entirepages?: number | null
    brokenpagenumerator?: number | null
    brokenpagedenominator?: number | null
    brokenpageunspecified?: $Enums.inducks_storyversion_nofulltext_brokenpageunspecified | null
    kind?: string | null
    rowsperpage?: number | null
    columnsperpage?: number | null
    appisxapp?: $Enums.inducks_storyversion_nofulltext_appisxapp | null
    what?: string | null
    appsummary?: string | null
    plotsummary?: string | null
    writsummary?: string | null
    artsummary?: string | null
    inksummary?: string | null
    creatorrefsummary?: string | null
    keywordsummary?: string | null
    estimatedpanels?: number | null
  }

  export type inducks_storyversion_nofulltextUncheckedCreateInput = {
    storyversioncode: string
    storycode?: string | null
    entirepages?: number | null
    brokenpagenumerator?: number | null
    brokenpagedenominator?: number | null
    brokenpageunspecified?: $Enums.inducks_storyversion_nofulltext_brokenpageunspecified | null
    kind?: string | null
    rowsperpage?: number | null
    columnsperpage?: number | null
    appisxapp?: $Enums.inducks_storyversion_nofulltext_appisxapp | null
    what?: string | null
    appsummary?: string | null
    plotsummary?: string | null
    writsummary?: string | null
    artsummary?: string | null
    inksummary?: string | null
    creatorrefsummary?: string | null
    keywordsummary?: string | null
    estimatedpanels?: number | null
  }

  export type inducks_storyversion_nofulltextUpdateInput = {
    storyversioncode?: StringFieldUpdateOperationsInput | string
    storycode?: NullableStringFieldUpdateOperationsInput | string | null
    entirepages?: NullableIntFieldUpdateOperationsInput | number | null
    brokenpagenumerator?: NullableIntFieldUpdateOperationsInput | number | null
    brokenpagedenominator?: NullableIntFieldUpdateOperationsInput | number | null
    brokenpageunspecified?: NullableEnuminducks_storyversion_nofulltext_brokenpageunspecifiedFieldUpdateOperationsInput | $Enums.inducks_storyversion_nofulltext_brokenpageunspecified | null
    kind?: NullableStringFieldUpdateOperationsInput | string | null
    rowsperpage?: NullableIntFieldUpdateOperationsInput | number | null
    columnsperpage?: NullableIntFieldUpdateOperationsInput | number | null
    appisxapp?: NullableEnuminducks_storyversion_nofulltext_appisxappFieldUpdateOperationsInput | $Enums.inducks_storyversion_nofulltext_appisxapp | null
    what?: NullableStringFieldUpdateOperationsInput | string | null
    appsummary?: NullableStringFieldUpdateOperationsInput | string | null
    plotsummary?: NullableStringFieldUpdateOperationsInput | string | null
    writsummary?: NullableStringFieldUpdateOperationsInput | string | null
    artsummary?: NullableStringFieldUpdateOperationsInput | string | null
    inksummary?: NullableStringFieldUpdateOperationsInput | string | null
    creatorrefsummary?: NullableStringFieldUpdateOperationsInput | string | null
    keywordsummary?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedpanels?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type inducks_storyversion_nofulltextUncheckedUpdateInput = {
    storyversioncode?: StringFieldUpdateOperationsInput | string
    storycode?: NullableStringFieldUpdateOperationsInput | string | null
    entirepages?: NullableIntFieldUpdateOperationsInput | number | null
    brokenpagenumerator?: NullableIntFieldUpdateOperationsInput | number | null
    brokenpagedenominator?: NullableIntFieldUpdateOperationsInput | number | null
    brokenpageunspecified?: NullableEnuminducks_storyversion_nofulltext_brokenpageunspecifiedFieldUpdateOperationsInput | $Enums.inducks_storyversion_nofulltext_brokenpageunspecified | null
    kind?: NullableStringFieldUpdateOperationsInput | string | null
    rowsperpage?: NullableIntFieldUpdateOperationsInput | number | null
    columnsperpage?: NullableIntFieldUpdateOperationsInput | number | null
    appisxapp?: NullableEnuminducks_storyversion_nofulltext_appisxappFieldUpdateOperationsInput | $Enums.inducks_storyversion_nofulltext_appisxapp | null
    what?: NullableStringFieldUpdateOperationsInput | string | null
    appsummary?: NullableStringFieldUpdateOperationsInput | string | null
    plotsummary?: NullableStringFieldUpdateOperationsInput | string | null
    writsummary?: NullableStringFieldUpdateOperationsInput | string | null
    artsummary?: NullableStringFieldUpdateOperationsInput | string | null
    inksummary?: NullableStringFieldUpdateOperationsInput | string | null
    creatorrefsummary?: NullableStringFieldUpdateOperationsInput | string | null
    keywordsummary?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedpanels?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type inducks_storyversion_nofulltextCreateManyInput = {
    storyversioncode: string
    storycode?: string | null
    entirepages?: number | null
    brokenpagenumerator?: number | null
    brokenpagedenominator?: number | null
    brokenpageunspecified?: $Enums.inducks_storyversion_nofulltext_brokenpageunspecified | null
    kind?: string | null
    rowsperpage?: number | null
    columnsperpage?: number | null
    appisxapp?: $Enums.inducks_storyversion_nofulltext_appisxapp | null
    what?: string | null
    appsummary?: string | null
    plotsummary?: string | null
    writsummary?: string | null
    artsummary?: string | null
    inksummary?: string | null
    creatorrefsummary?: string | null
    keywordsummary?: string | null
    estimatedpanels?: number | null
  }

  export type inducks_storyversion_nofulltextUpdateManyMutationInput = {
    storyversioncode?: StringFieldUpdateOperationsInput | string
    storycode?: NullableStringFieldUpdateOperationsInput | string | null
    entirepages?: NullableIntFieldUpdateOperationsInput | number | null
    brokenpagenumerator?: NullableIntFieldUpdateOperationsInput | number | null
    brokenpagedenominator?: NullableIntFieldUpdateOperationsInput | number | null
    brokenpageunspecified?: NullableEnuminducks_storyversion_nofulltext_brokenpageunspecifiedFieldUpdateOperationsInput | $Enums.inducks_storyversion_nofulltext_brokenpageunspecified | null
    kind?: NullableStringFieldUpdateOperationsInput | string | null
    rowsperpage?: NullableIntFieldUpdateOperationsInput | number | null
    columnsperpage?: NullableIntFieldUpdateOperationsInput | number | null
    appisxapp?: NullableEnuminducks_storyversion_nofulltext_appisxappFieldUpdateOperationsInput | $Enums.inducks_storyversion_nofulltext_appisxapp | null
    what?: NullableStringFieldUpdateOperationsInput | string | null
    appsummary?: NullableStringFieldUpdateOperationsInput | string | null
    plotsummary?: NullableStringFieldUpdateOperationsInput | string | null
    writsummary?: NullableStringFieldUpdateOperationsInput | string | null
    artsummary?: NullableStringFieldUpdateOperationsInput | string | null
    inksummary?: NullableStringFieldUpdateOperationsInput | string | null
    creatorrefsummary?: NullableStringFieldUpdateOperationsInput | string | null
    keywordsummary?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedpanels?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type inducks_storyversion_nofulltextUncheckedUpdateManyInput = {
    storyversioncode?: StringFieldUpdateOperationsInput | string
    storycode?: NullableStringFieldUpdateOperationsInput | string | null
    entirepages?: NullableIntFieldUpdateOperationsInput | number | null
    brokenpagenumerator?: NullableIntFieldUpdateOperationsInput | number | null
    brokenpagedenominator?: NullableIntFieldUpdateOperationsInput | number | null
    brokenpageunspecified?: NullableEnuminducks_storyversion_nofulltext_brokenpageunspecifiedFieldUpdateOperationsInput | $Enums.inducks_storyversion_nofulltext_brokenpageunspecified | null
    kind?: NullableStringFieldUpdateOperationsInput | string | null
    rowsperpage?: NullableIntFieldUpdateOperationsInput | number | null
    columnsperpage?: NullableIntFieldUpdateOperationsInput | number | null
    appisxapp?: NullableEnuminducks_storyversion_nofulltext_appisxappFieldUpdateOperationsInput | $Enums.inducks_storyversion_nofulltext_appisxapp | null
    what?: NullableStringFieldUpdateOperationsInput | string | null
    appsummary?: NullableStringFieldUpdateOperationsInput | string | null
    plotsummary?: NullableStringFieldUpdateOperationsInput | string | null
    writsummary?: NullableStringFieldUpdateOperationsInput | string | null
    artsummary?: NullableStringFieldUpdateOperationsInput | string | null
    inksummary?: NullableStringFieldUpdateOperationsInput | string | null
    creatorrefsummary?: NullableStringFieldUpdateOperationsInput | string | null
    keywordsummary?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedpanels?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type inducks_studioCreateInput = {
    studiocode: string
    countrycode?: string | null
    studioname?: string | null
    city?: string | null
    description?: string | null
    othertext?: string | null
    photofilename?: string | null
    photocomment?: string | null
    photosource?: string | null
    studiorefs?: string | null
  }

  export type inducks_studioUncheckedCreateInput = {
    studiocode: string
    countrycode?: string | null
    studioname?: string | null
    city?: string | null
    description?: string | null
    othertext?: string | null
    photofilename?: string | null
    photocomment?: string | null
    photosource?: string | null
    studiorefs?: string | null
  }

  export type inducks_studioUpdateInput = {
    studiocode?: StringFieldUpdateOperationsInput | string
    countrycode?: NullableStringFieldUpdateOperationsInput | string | null
    studioname?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    othertext?: NullableStringFieldUpdateOperationsInput | string | null
    photofilename?: NullableStringFieldUpdateOperationsInput | string | null
    photocomment?: NullableStringFieldUpdateOperationsInput | string | null
    photosource?: NullableStringFieldUpdateOperationsInput | string | null
    studiorefs?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_studioUncheckedUpdateInput = {
    studiocode?: StringFieldUpdateOperationsInput | string
    countrycode?: NullableStringFieldUpdateOperationsInput | string | null
    studioname?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    othertext?: NullableStringFieldUpdateOperationsInput | string | null
    photofilename?: NullableStringFieldUpdateOperationsInput | string | null
    photocomment?: NullableStringFieldUpdateOperationsInput | string | null
    photosource?: NullableStringFieldUpdateOperationsInput | string | null
    studiorefs?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_studioCreateManyInput = {
    studiocode: string
    countrycode?: string | null
    studioname?: string | null
    city?: string | null
    description?: string | null
    othertext?: string | null
    photofilename?: string | null
    photocomment?: string | null
    photosource?: string | null
    studiorefs?: string | null
  }

  export type inducks_studioUpdateManyMutationInput = {
    studiocode?: StringFieldUpdateOperationsInput | string
    countrycode?: NullableStringFieldUpdateOperationsInput | string | null
    studioname?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    othertext?: NullableStringFieldUpdateOperationsInput | string | null
    photofilename?: NullableStringFieldUpdateOperationsInput | string | null
    photocomment?: NullableStringFieldUpdateOperationsInput | string | null
    photosource?: NullableStringFieldUpdateOperationsInput | string | null
    studiorefs?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_studioUncheckedUpdateManyInput = {
    studiocode?: StringFieldUpdateOperationsInput | string
    countrycode?: NullableStringFieldUpdateOperationsInput | string | null
    studioname?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    othertext?: NullableStringFieldUpdateOperationsInput | string | null
    photofilename?: NullableStringFieldUpdateOperationsInput | string | null
    photocomment?: NullableStringFieldUpdateOperationsInput | string | null
    photosource?: NullableStringFieldUpdateOperationsInput | string | null
    studiorefs?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_studioworkCreateInput = {
    studiocode: string
    personcode: string
  }

  export type inducks_studioworkUncheckedCreateInput = {
    studiocode: string
    personcode: string
  }

  export type inducks_studioworkUpdateInput = {
    studiocode?: StringFieldUpdateOperationsInput | string
    personcode?: StringFieldUpdateOperationsInput | string
  }

  export type inducks_studioworkUncheckedUpdateInput = {
    studiocode?: StringFieldUpdateOperationsInput | string
    personcode?: StringFieldUpdateOperationsInput | string
  }

  export type inducks_studioworkCreateManyInput = {
    studiocode: string
    personcode: string
  }

  export type inducks_studioworkUpdateManyMutationInput = {
    studiocode?: StringFieldUpdateOperationsInput | string
    personcode?: StringFieldUpdateOperationsInput | string
  }

  export type inducks_studioworkUncheckedUpdateManyInput = {
    studiocode?: StringFieldUpdateOperationsInput | string
    personcode?: StringFieldUpdateOperationsInput | string
  }

  export type inducks_subseriesCreateInput = {
    subseriescode: string
    subseriesname?: string | null
    official?: $Enums.inducks_subseries_official | null
    subseriescomment?: string | null
    subseriescategory?: string | null
  }

  export type inducks_subseriesUncheckedCreateInput = {
    subseriescode: string
    subseriesname?: string | null
    official?: $Enums.inducks_subseries_official | null
    subseriescomment?: string | null
    subseriescategory?: string | null
  }

  export type inducks_subseriesUpdateInput = {
    subseriescode?: StringFieldUpdateOperationsInput | string
    subseriesname?: NullableStringFieldUpdateOperationsInput | string | null
    official?: NullableEnuminducks_subseries_officialFieldUpdateOperationsInput | $Enums.inducks_subseries_official | null
    subseriescomment?: NullableStringFieldUpdateOperationsInput | string | null
    subseriescategory?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_subseriesUncheckedUpdateInput = {
    subseriescode?: StringFieldUpdateOperationsInput | string
    subseriesname?: NullableStringFieldUpdateOperationsInput | string | null
    official?: NullableEnuminducks_subseries_officialFieldUpdateOperationsInput | $Enums.inducks_subseries_official | null
    subseriescomment?: NullableStringFieldUpdateOperationsInput | string | null
    subseriescategory?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_subseriesCreateManyInput = {
    subseriescode: string
    subseriesname?: string | null
    official?: $Enums.inducks_subseries_official | null
    subseriescomment?: string | null
    subseriescategory?: string | null
  }

  export type inducks_subseriesUpdateManyMutationInput = {
    subseriescode?: StringFieldUpdateOperationsInput | string
    subseriesname?: NullableStringFieldUpdateOperationsInput | string | null
    official?: NullableEnuminducks_subseries_officialFieldUpdateOperationsInput | $Enums.inducks_subseries_official | null
    subseriescomment?: NullableStringFieldUpdateOperationsInput | string | null
    subseriescategory?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_subseriesUncheckedUpdateManyInput = {
    subseriescode?: StringFieldUpdateOperationsInput | string
    subseriesname?: NullableStringFieldUpdateOperationsInput | string | null
    official?: NullableEnuminducks_subseries_officialFieldUpdateOperationsInput | $Enums.inducks_subseries_official | null
    subseriescomment?: NullableStringFieldUpdateOperationsInput | string | null
    subseriescategory?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_subseriesnameCreateInput = {
    subseriescode: string
    languagecode: string
    subseriesname?: string | null
    preferred?: $Enums.inducks_subseriesname_preferred | null
    subseriesnamecomment?: string | null
  }

  export type inducks_subseriesnameUncheckedCreateInput = {
    subseriescode: string
    languagecode: string
    subseriesname?: string | null
    preferred?: $Enums.inducks_subseriesname_preferred | null
    subseriesnamecomment?: string | null
  }

  export type inducks_subseriesnameUpdateInput = {
    subseriescode?: StringFieldUpdateOperationsInput | string
    languagecode?: StringFieldUpdateOperationsInput | string
    subseriesname?: NullableStringFieldUpdateOperationsInput | string | null
    preferred?: NullableEnuminducks_subseriesname_preferredFieldUpdateOperationsInput | $Enums.inducks_subseriesname_preferred | null
    subseriesnamecomment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_subseriesnameUncheckedUpdateInput = {
    subseriescode?: StringFieldUpdateOperationsInput | string
    languagecode?: StringFieldUpdateOperationsInput | string
    subseriesname?: NullableStringFieldUpdateOperationsInput | string | null
    preferred?: NullableEnuminducks_subseriesname_preferredFieldUpdateOperationsInput | $Enums.inducks_subseriesname_preferred | null
    subseriesnamecomment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_subseriesnameCreateManyInput = {
    subseriescode: string
    languagecode: string
    subseriesname?: string | null
    preferred?: $Enums.inducks_subseriesname_preferred | null
    subseriesnamecomment?: string | null
  }

  export type inducks_subseriesnameUpdateManyMutationInput = {
    subseriescode?: StringFieldUpdateOperationsInput | string
    languagecode?: StringFieldUpdateOperationsInput | string
    subseriesname?: NullableStringFieldUpdateOperationsInput | string | null
    preferred?: NullableEnuminducks_subseriesname_preferredFieldUpdateOperationsInput | $Enums.inducks_subseriesname_preferred | null
    subseriesnamecomment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_subseriesnameUncheckedUpdateManyInput = {
    subseriescode?: StringFieldUpdateOperationsInput | string
    languagecode?: StringFieldUpdateOperationsInput | string
    subseriesname?: NullableStringFieldUpdateOperationsInput | string | null
    preferred?: NullableEnuminducks_subseriesname_preferredFieldUpdateOperationsInput | $Enums.inducks_subseriesname_preferred | null
    subseriesnamecomment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_substoryCreateInput = {
    storycode: string
    originalstoryversioncode?: string | null
    superstorycode?: string | null
    part?: string | null
    firstpublicationdate?: string | null
    title?: string | null
    substorycomment?: string | null
    error?: $Enums.inducks_substory_error | null
    locked?: $Enums.inducks_substory_locked | null
    inputfilecode?: number | null
    maintenanceteamcode?: string | null
  }

  export type inducks_substoryUncheckedCreateInput = {
    storycode: string
    originalstoryversioncode?: string | null
    superstorycode?: string | null
    part?: string | null
    firstpublicationdate?: string | null
    title?: string | null
    substorycomment?: string | null
    error?: $Enums.inducks_substory_error | null
    locked?: $Enums.inducks_substory_locked | null
    inputfilecode?: number | null
    maintenanceteamcode?: string | null
  }

  export type inducks_substoryUpdateInput = {
    storycode?: StringFieldUpdateOperationsInput | string
    originalstoryversioncode?: NullableStringFieldUpdateOperationsInput | string | null
    superstorycode?: NullableStringFieldUpdateOperationsInput | string | null
    part?: NullableStringFieldUpdateOperationsInput | string | null
    firstpublicationdate?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    substorycomment?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableEnuminducks_substory_errorFieldUpdateOperationsInput | $Enums.inducks_substory_error | null
    locked?: NullableEnuminducks_substory_lockedFieldUpdateOperationsInput | $Enums.inducks_substory_locked | null
    inputfilecode?: NullableIntFieldUpdateOperationsInput | number | null
    maintenanceteamcode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_substoryUncheckedUpdateInput = {
    storycode?: StringFieldUpdateOperationsInput | string
    originalstoryversioncode?: NullableStringFieldUpdateOperationsInput | string | null
    superstorycode?: NullableStringFieldUpdateOperationsInput | string | null
    part?: NullableStringFieldUpdateOperationsInput | string | null
    firstpublicationdate?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    substorycomment?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableEnuminducks_substory_errorFieldUpdateOperationsInput | $Enums.inducks_substory_error | null
    locked?: NullableEnuminducks_substory_lockedFieldUpdateOperationsInput | $Enums.inducks_substory_locked | null
    inputfilecode?: NullableIntFieldUpdateOperationsInput | number | null
    maintenanceteamcode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_substoryCreateManyInput = {
    storycode: string
    originalstoryversioncode?: string | null
    superstorycode?: string | null
    part?: string | null
    firstpublicationdate?: string | null
    title?: string | null
    substorycomment?: string | null
    error?: $Enums.inducks_substory_error | null
    locked?: $Enums.inducks_substory_locked | null
    inputfilecode?: number | null
    maintenanceteamcode?: string | null
  }

  export type inducks_substoryUpdateManyMutationInput = {
    storycode?: StringFieldUpdateOperationsInput | string
    originalstoryversioncode?: NullableStringFieldUpdateOperationsInput | string | null
    superstorycode?: NullableStringFieldUpdateOperationsInput | string | null
    part?: NullableStringFieldUpdateOperationsInput | string | null
    firstpublicationdate?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    substorycomment?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableEnuminducks_substory_errorFieldUpdateOperationsInput | $Enums.inducks_substory_error | null
    locked?: NullableEnuminducks_substory_lockedFieldUpdateOperationsInput | $Enums.inducks_substory_locked | null
    inputfilecode?: NullableIntFieldUpdateOperationsInput | number | null
    maintenanceteamcode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_substoryUncheckedUpdateManyInput = {
    storycode?: StringFieldUpdateOperationsInput | string
    originalstoryversioncode?: NullableStringFieldUpdateOperationsInput | string | null
    superstorycode?: NullableStringFieldUpdateOperationsInput | string | null
    part?: NullableStringFieldUpdateOperationsInput | string | null
    firstpublicationdate?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    substorycomment?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableEnuminducks_substory_errorFieldUpdateOperationsInput | $Enums.inducks_substory_error | null
    locked?: NullableEnuminducks_substory_lockedFieldUpdateOperationsInput | $Enums.inducks_substory_locked | null
    inputfilecode?: NullableIntFieldUpdateOperationsInput | number | null
    maintenanceteamcode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_teamCreateInput = {
    teamcode: string
    teamdescriptionname?: string | null
    teamshortname?: string | null
  }

  export type inducks_teamUncheckedCreateInput = {
    teamcode: string
    teamdescriptionname?: string | null
    teamshortname?: string | null
  }

  export type inducks_teamUpdateInput = {
    teamcode?: StringFieldUpdateOperationsInput | string
    teamdescriptionname?: NullableStringFieldUpdateOperationsInput | string | null
    teamshortname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_teamUncheckedUpdateInput = {
    teamcode?: StringFieldUpdateOperationsInput | string
    teamdescriptionname?: NullableStringFieldUpdateOperationsInput | string | null
    teamshortname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_teamCreateManyInput = {
    teamcode: string
    teamdescriptionname?: string | null
    teamshortname?: string | null
  }

  export type inducks_teamUpdateManyMutationInput = {
    teamcode?: StringFieldUpdateOperationsInput | string
    teamdescriptionname?: NullableStringFieldUpdateOperationsInput | string | null
    teamshortname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_teamUncheckedUpdateManyInput = {
    teamcode?: StringFieldUpdateOperationsInput | string
    teamdescriptionname?: NullableStringFieldUpdateOperationsInput | string | null
    teamshortname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_teammemberCreateInput = {
    teamcode: string
    personcode?: string | null
  }

  export type inducks_teammemberUncheckedCreateInput = {
    teamcode: string
    personcode?: string | null
  }

  export type inducks_teammemberUpdateInput = {
    teamcode?: StringFieldUpdateOperationsInput | string
    personcode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_teammemberUncheckedUpdateInput = {
    teamcode?: StringFieldUpdateOperationsInput | string
    personcode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_teammemberCreateManyInput = {
    teamcode: string
    personcode?: string | null
  }

  export type inducks_teammemberUpdateManyMutationInput = {
    teamcode?: StringFieldUpdateOperationsInput | string
    personcode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_teammemberUncheckedUpdateManyInput = {
    teamcode?: StringFieldUpdateOperationsInput | string
    personcode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_ucrelationCreateInput = {
    universecode: string
    charactercode: string
  }

  export type inducks_ucrelationUncheckedCreateInput = {
    universecode: string
    charactercode: string
  }

  export type inducks_ucrelationUpdateInput = {
    universecode?: StringFieldUpdateOperationsInput | string
    charactercode?: StringFieldUpdateOperationsInput | string
  }

  export type inducks_ucrelationUncheckedUpdateInput = {
    universecode?: StringFieldUpdateOperationsInput | string
    charactercode?: StringFieldUpdateOperationsInput | string
  }

  export type inducks_ucrelationCreateManyInput = {
    universecode: string
    charactercode: string
  }

  export type inducks_ucrelationUpdateManyMutationInput = {
    universecode?: StringFieldUpdateOperationsInput | string
    charactercode?: StringFieldUpdateOperationsInput | string
  }

  export type inducks_ucrelationUncheckedUpdateManyInput = {
    universecode?: StringFieldUpdateOperationsInput | string
    charactercode?: StringFieldUpdateOperationsInput | string
  }

  export type inducks_universeCreateInput = {
    universecode: string
    universecomment?: string | null
  }

  export type inducks_universeUncheckedCreateInput = {
    universecode: string
    universecomment?: string | null
  }

  export type inducks_universeUpdateInput = {
    universecode?: StringFieldUpdateOperationsInput | string
    universecomment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_universeUncheckedUpdateInput = {
    universecode?: StringFieldUpdateOperationsInput | string
    universecomment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_universeCreateManyInput = {
    universecode: string
    universecomment?: string | null
  }

  export type inducks_universeUpdateManyMutationInput = {
    universecode?: StringFieldUpdateOperationsInput | string
    universecomment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_universeUncheckedUpdateManyInput = {
    universecode?: StringFieldUpdateOperationsInput | string
    universecomment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_universenameCreateInput = {
    universecode: string
    languagecode: string
    universename?: string | null
  }

  export type inducks_universenameUncheckedCreateInput = {
    universecode: string
    languagecode: string
    universename?: string | null
  }

  export type inducks_universenameUpdateInput = {
    universecode?: StringFieldUpdateOperationsInput | string
    languagecode?: StringFieldUpdateOperationsInput | string
    universename?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_universenameUncheckedUpdateInput = {
    universecode?: StringFieldUpdateOperationsInput | string
    languagecode?: StringFieldUpdateOperationsInput | string
    universename?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_universenameCreateManyInput = {
    universecode: string
    languagecode: string
    universename?: string | null
  }

  export type inducks_universenameUpdateManyMutationInput = {
    universecode?: StringFieldUpdateOperationsInput | string
    languagecode?: StringFieldUpdateOperationsInput | string
    universename?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inducks_universenameUncheckedUpdateManyInput = {
    universecode?: StringFieldUpdateOperationsInput | string
    languagecode?: StringFieldUpdateOperationsInput | string
    universename?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type numeros_cptCreateInput = {
    Pays: string
    Magazine: string
    publicationcode: string
    Numero: string
    Cpt?: number | null
  }

  export type numeros_cptUncheckedCreateInput = {
    Pays: string
    Magazine: string
    publicationcode: string
    Numero: string
    Cpt?: number | null
  }

  export type numeros_cptUpdateInput = {
    Pays?: StringFieldUpdateOperationsInput | string
    Magazine?: StringFieldUpdateOperationsInput | string
    publicationcode?: StringFieldUpdateOperationsInput | string
    Numero?: StringFieldUpdateOperationsInput | string
    Cpt?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type numeros_cptUncheckedUpdateInput = {
    Pays?: StringFieldUpdateOperationsInput | string
    Magazine?: StringFieldUpdateOperationsInput | string
    publicationcode?: StringFieldUpdateOperationsInput | string
    Numero?: StringFieldUpdateOperationsInput | string
    Cpt?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type numeros_cptCreateManyInput = {
    Pays: string
    Magazine: string
    publicationcode: string
    Numero: string
    Cpt?: number | null
  }

  export type numeros_cptUpdateManyMutationInput = {
    Pays?: StringFieldUpdateOperationsInput | string
    Magazine?: StringFieldUpdateOperationsInput | string
    publicationcode?: StringFieldUpdateOperationsInput | string
    Numero?: StringFieldUpdateOperationsInput | string
    Cpt?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type numeros_cptUncheckedUpdateManyInput = {
    Pays?: StringFieldUpdateOperationsInput | string
    Magazine?: StringFieldUpdateOperationsInput | string
    publicationcode?: StringFieldUpdateOperationsInput | string
    Numero?: StringFieldUpdateOperationsInput | string
    Cpt?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type datasets_entryurlsCountOrderByAggregateInput = {
    id?: SortOrder
    dataset_id?: SortOrder
    sitecode_url?: SortOrder
  }

  export type datasets_entryurlsAvgOrderByAggregateInput = {
    id?: SortOrder
    dataset_id?: SortOrder
  }

  export type datasets_entryurlsMaxOrderByAggregateInput = {
    id?: SortOrder
    dataset_id?: SortOrder
    sitecode_url?: SortOrder
  }

  export type datasets_entryurlsMinOrderByAggregateInput = {
    id?: SortOrder
    dataset_id?: SortOrder
    sitecode_url?: SortOrder
  }

  export type datasets_entryurlsSumOrderByAggregateInput = {
    id?: SortOrder
    dataset_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type Enuminducks_appearance_doubtNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_appearance_doubt | Enuminducks_appearance_doubtFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_appearance_doubt[] | null
    notIn?: $Enums.inducks_appearance_doubt[] | null
    not?: NestedEnuminducks_appearance_doubtNullableFilter<$PrismaModel> | $Enums.inducks_appearance_doubt | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type inducks_appearanceStoryversioncodeCharactercodeCompoundUniqueInput = {
    storyversioncode: string
    charactercode: string
  }

  export type inducks_appearanceCountOrderByAggregateInput = {
    storyversioncode?: SortOrder
    charactercode?: SortOrder
    number?: SortOrder
    appearancecomment?: SortOrder
    doubt?: SortOrder
  }

  export type inducks_appearanceAvgOrderByAggregateInput = {
    number?: SortOrder
  }

  export type inducks_appearanceMaxOrderByAggregateInput = {
    storyversioncode?: SortOrder
    charactercode?: SortOrder
    number?: SortOrder
    appearancecomment?: SortOrder
    doubt?: SortOrder
  }

  export type inducks_appearanceMinOrderByAggregateInput = {
    storyversioncode?: SortOrder
    charactercode?: SortOrder
    number?: SortOrder
    appearancecomment?: SortOrder
    doubt?: SortOrder
  }

  export type inducks_appearanceSumOrderByAggregateInput = {
    number?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type Enuminducks_appearance_doubtNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_appearance_doubt | Enuminducks_appearance_doubtFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_appearance_doubt[] | null
    notIn?: $Enums.inducks_appearance_doubt[] | null
    not?: NestedEnuminducks_appearance_doubtNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_appearance_doubt | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_appearance_doubtNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_appearance_doubtNullableFilter<$PrismaModel>
  }

  export type Enuminducks_character_officialNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_character_official | Enuminducks_character_officialFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_character_official[] | null
    notIn?: $Enums.inducks_character_official[] | null
    not?: NestedEnuminducks_character_officialNullableFilter<$PrismaModel> | $Enums.inducks_character_official | null
  }

  export type Enuminducks_character_onetimeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_character_onetime | Enuminducks_character_onetimeFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_character_onetime[] | null
    notIn?: $Enums.inducks_character_onetime[] | null
    not?: NestedEnuminducks_character_onetimeNullableFilter<$PrismaModel> | $Enums.inducks_character_onetime | null
  }

  export type Enuminducks_character_heroonlyNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_character_heroonly | Enuminducks_character_heroonlyFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_character_heroonly[] | null
    notIn?: $Enums.inducks_character_heroonly[] | null
    not?: NestedEnuminducks_character_heroonlyNullableFilter<$PrismaModel> | $Enums.inducks_character_heroonly | null
  }

  export type inducks_characterCountOrderByAggregateInput = {
    charactercode?: SortOrder
    charactername?: SortOrder
    official?: SortOrder
    onetime?: SortOrder
    heroonly?: SortOrder
    charactercomment?: SortOrder
  }

  export type inducks_characterMaxOrderByAggregateInput = {
    charactercode?: SortOrder
    charactername?: SortOrder
    official?: SortOrder
    onetime?: SortOrder
    heroonly?: SortOrder
    charactercomment?: SortOrder
  }

  export type inducks_characterMinOrderByAggregateInput = {
    charactercode?: SortOrder
    charactername?: SortOrder
    official?: SortOrder
    onetime?: SortOrder
    heroonly?: SortOrder
    charactercomment?: SortOrder
  }

  export type Enuminducks_character_officialNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_character_official | Enuminducks_character_officialFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_character_official[] | null
    notIn?: $Enums.inducks_character_official[] | null
    not?: NestedEnuminducks_character_officialNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_character_official | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_character_officialNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_character_officialNullableFilter<$PrismaModel>
  }

  export type Enuminducks_character_onetimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_character_onetime | Enuminducks_character_onetimeFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_character_onetime[] | null
    notIn?: $Enums.inducks_character_onetime[] | null
    not?: NestedEnuminducks_character_onetimeNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_character_onetime | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_character_onetimeNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_character_onetimeNullableFilter<$PrismaModel>
  }

  export type Enuminducks_character_heroonlyNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_character_heroonly | Enuminducks_character_heroonlyFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_character_heroonly[] | null
    notIn?: $Enums.inducks_character_heroonly[] | null
    not?: NestedEnuminducks_character_heroonlyNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_character_heroonly | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_character_heroonlyNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_character_heroonlyNullableFilter<$PrismaModel>
  }

  export type inducks_characteraliasCountOrderByAggregateInput = {
    charactercode?: SortOrder
    charactername?: SortOrder
  }

  export type inducks_characteraliasMaxOrderByAggregateInput = {
    charactercode?: SortOrder
    charactername?: SortOrder
  }

  export type inducks_characteraliasMinOrderByAggregateInput = {
    charactercode?: SortOrder
    charactername?: SortOrder
  }

  export type inducks_characterdetailCountOrderByAggregateInput = {
    charactername?: SortOrder
    charactercode?: SortOrder
    number?: SortOrder
  }

  export type inducks_characterdetailAvgOrderByAggregateInput = {
    number?: SortOrder
  }

  export type inducks_characterdetailMaxOrderByAggregateInput = {
    charactername?: SortOrder
    charactercode?: SortOrder
    number?: SortOrder
  }

  export type inducks_characterdetailMinOrderByAggregateInput = {
    charactername?: SortOrder
    charactercode?: SortOrder
    number?: SortOrder
  }

  export type inducks_characterdetailSumOrderByAggregateInput = {
    number?: SortOrder
  }

  export type Enuminducks_charactername_preferredNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_charactername_preferred | Enuminducks_charactername_preferredFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_charactername_preferred[] | null
    notIn?: $Enums.inducks_charactername_preferred[] | null
    not?: NestedEnuminducks_charactername_preferredNullableFilter<$PrismaModel> | $Enums.inducks_charactername_preferred | null
  }

  export type inducks_characternameCharactercodeLanguagecodeCharacternameCompoundUniqueInput = {
    charactercode: string
    languagecode: string
    charactername: string
  }

  export type inducks_characternameCountOrderByAggregateInput = {
    charactercode?: SortOrder
    languagecode?: SortOrder
    charactername?: SortOrder
    preferred?: SortOrder
    characternamecomment?: SortOrder
  }

  export type inducks_characternameMaxOrderByAggregateInput = {
    charactercode?: SortOrder
    languagecode?: SortOrder
    charactername?: SortOrder
    preferred?: SortOrder
    characternamecomment?: SortOrder
  }

  export type inducks_characternameMinOrderByAggregateInput = {
    charactercode?: SortOrder
    languagecode?: SortOrder
    charactername?: SortOrder
    preferred?: SortOrder
    characternamecomment?: SortOrder
  }

  export type Enuminducks_charactername_preferredNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_charactername_preferred | Enuminducks_charactername_preferredFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_charactername_preferred[] | null
    notIn?: $Enums.inducks_charactername_preferred[] | null
    not?: NestedEnuminducks_charactername_preferredNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_charactername_preferred | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_charactername_preferredNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_charactername_preferredNullableFilter<$PrismaModel>
  }

  export type Enuminducks_characterreference_isgroupofcharactersNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_characterreference_isgroupofcharacters | Enuminducks_characterreference_isgroupofcharactersFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_characterreference_isgroupofcharacters[] | null
    notIn?: $Enums.inducks_characterreference_isgroupofcharacters[] | null
    not?: NestedEnuminducks_characterreference_isgroupofcharactersNullableFilter<$PrismaModel> | $Enums.inducks_characterreference_isgroupofcharacters | null
  }

  export type inducks_characterreferenceFromcharactercodeTocharactercodeCompoundUniqueInput = {
    fromcharactercode: string
    tocharactercode: string
  }

  export type inducks_characterreferenceCountOrderByAggregateInput = {
    fromcharactercode?: SortOrder
    tocharactercode?: SortOrder
    isgroupofcharacters?: SortOrder
  }

  export type inducks_characterreferenceMaxOrderByAggregateInput = {
    fromcharactercode?: SortOrder
    tocharactercode?: SortOrder
    isgroupofcharacters?: SortOrder
  }

  export type inducks_characterreferenceMinOrderByAggregateInput = {
    fromcharactercode?: SortOrder
    tocharactercode?: SortOrder
    isgroupofcharacters?: SortOrder
  }

  export type Enuminducks_characterreference_isgroupofcharactersNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_characterreference_isgroupofcharacters | Enuminducks_characterreference_isgroupofcharactersFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_characterreference_isgroupofcharacters[] | null
    notIn?: $Enums.inducks_characterreference_isgroupofcharacters[] | null
    not?: NestedEnuminducks_characterreference_isgroupofcharactersNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_characterreference_isgroupofcharacters | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_characterreference_isgroupofcharactersNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_characterreference_isgroupofcharactersNullableFilter<$PrismaModel>
  }

  export type inducks_characterurlCharactercodeSitecodeCompoundUniqueInput = {
    charactercode: string
    sitecode: string
  }

  export type inducks_characterurlCountOrderByAggregateInput = {
    charactercode?: SortOrder
    sitecode?: SortOrder
    url?: SortOrder
  }

  export type inducks_characterurlMaxOrderByAggregateInput = {
    charactercode?: SortOrder
    sitecode?: SortOrder
    url?: SortOrder
  }

  export type inducks_characterurlMinOrderByAggregateInput = {
    charactercode?: SortOrder
    sitecode?: SortOrder
    url?: SortOrder
  }

  export type inducks_countryCountOrderByAggregateInput = {
    countrycode?: SortOrder
    countryname?: SortOrder
    defaultlanguage?: SortOrder
    defaultmaintenanceteam?: SortOrder
  }

  export type inducks_countryMaxOrderByAggregateInput = {
    countrycode?: SortOrder
    countryname?: SortOrder
    defaultlanguage?: SortOrder
    defaultmaintenanceteam?: SortOrder
  }

  export type inducks_countryMinOrderByAggregateInput = {
    countrycode?: SortOrder
    countryname?: SortOrder
    defaultlanguage?: SortOrder
    defaultmaintenanceteam?: SortOrder
  }

  export type inducks_countrynameCountrycodeLanguagecodeCompoundUniqueInput = {
    countrycode: string
    languagecode: string
  }

  export type inducks_countrynameCountOrderByAggregateInput = {
    countrycode?: SortOrder
    languagecode?: SortOrder
    countryname?: SortOrder
  }

  export type inducks_countrynameMaxOrderByAggregateInput = {
    countrycode?: SortOrder
    languagecode?: SortOrder
    countryname?: SortOrder
  }

  export type inducks_countrynameMinOrderByAggregateInput = {
    countrycode?: SortOrder
    languagecode?: SortOrder
    countryname?: SortOrder
  }

  export type inducks_currencyCountOrderByAggregateInput = {
    currencycode?: SortOrder
    currencyname?: SortOrder
  }

  export type inducks_currencyMaxOrderByAggregateInput = {
    currencycode?: SortOrder
    currencyname?: SortOrder
  }

  export type inducks_currencyMinOrderByAggregateInput = {
    currencycode?: SortOrder
    currencyname?: SortOrder
  }

  export type inducks_currencynameCurrencycodeLanguagecodeCompoundUniqueInput = {
    currencycode: string
    languagecode: string
  }

  export type inducks_currencynameCountOrderByAggregateInput = {
    currencycode?: SortOrder
    languagecode?: SortOrder
    shortcurrencyname?: SortOrder
    longcurrencyname?: SortOrder
  }

  export type inducks_currencynameMaxOrderByAggregateInput = {
    currencycode?: SortOrder
    languagecode?: SortOrder
    shortcurrencyname?: SortOrder
    longcurrencyname?: SortOrder
  }

  export type inducks_currencynameMinOrderByAggregateInput = {
    currencycode?: SortOrder
    languagecode?: SortOrder
    shortcurrencyname?: SortOrder
    longcurrencyname?: SortOrder
  }

  export type Enuminducks_entry_reallytitleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_reallytitle | Enuminducks_entry_reallytitleFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_reallytitle[] | null
    notIn?: $Enums.inducks_entry_reallytitle[] | null
    not?: NestedEnuminducks_entry_reallytitleNullableFilter<$PrismaModel> | $Enums.inducks_entry_reallytitle | null
  }

  export type Enuminducks_entry_mirroredNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_mirrored | Enuminducks_entry_mirroredFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_mirrored[] | null
    notIn?: $Enums.inducks_entry_mirrored[] | null
    not?: NestedEnuminducks_entry_mirroredNullableFilter<$PrismaModel> | $Enums.inducks_entry_mirrored | null
  }

  export type Enuminducks_entry_sidewaysNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_sideways | Enuminducks_entry_sidewaysFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_sideways[] | null
    notIn?: $Enums.inducks_entry_sideways[] | null
    not?: NestedEnuminducks_entry_sidewaysNullableFilter<$PrismaModel> | $Enums.inducks_entry_sideways | null
  }

  export type Enuminducks_entry_identificationuncertainNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_identificationuncertain | Enuminducks_entry_identificationuncertainFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_identificationuncertain[] | null
    notIn?: $Enums.inducks_entry_identificationuncertain[] | null
    not?: NestedEnuminducks_entry_identificationuncertainNullableFilter<$PrismaModel> | $Enums.inducks_entry_identificationuncertain | null
  }

  export type Enuminducks_entry_errorNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_error | Enuminducks_entry_errorFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_error[] | null
    notIn?: $Enums.inducks_entry_error[] | null
    not?: NestedEnuminducks_entry_errorNullableFilter<$PrismaModel> | $Enums.inducks_entry_error | null
  }

  export type inducks_entryCountOrderByAggregateInput = {
    entrycode?: SortOrder
    issuecode?: SortOrder
    storyversioncode?: SortOrder
    languagecode?: SortOrder
    includedinentrycode?: SortOrder
    position?: SortOrder
    printedcode?: SortOrder
    guessedcode?: SortOrder
    title?: SortOrder
    reallytitle?: SortOrder
    printedhero?: SortOrder
    changes?: SortOrder
    cut?: SortOrder
    minorchanges?: SortOrder
    missingpanels?: SortOrder
    mirrored?: SortOrder
    sideways?: SortOrder
    startdate?: SortOrder
    enddate?: SortOrder
    identificationuncertain?: SortOrder
    alsoreprint?: SortOrder
    part?: SortOrder
    entrycomment?: SortOrder
    error?: SortOrder
  }

  export type inducks_entryMaxOrderByAggregateInput = {
    entrycode?: SortOrder
    issuecode?: SortOrder
    storyversioncode?: SortOrder
    languagecode?: SortOrder
    includedinentrycode?: SortOrder
    position?: SortOrder
    printedcode?: SortOrder
    guessedcode?: SortOrder
    title?: SortOrder
    reallytitle?: SortOrder
    printedhero?: SortOrder
    changes?: SortOrder
    cut?: SortOrder
    minorchanges?: SortOrder
    missingpanels?: SortOrder
    mirrored?: SortOrder
    sideways?: SortOrder
    startdate?: SortOrder
    enddate?: SortOrder
    identificationuncertain?: SortOrder
    alsoreprint?: SortOrder
    part?: SortOrder
    entrycomment?: SortOrder
    error?: SortOrder
  }

  export type inducks_entryMinOrderByAggregateInput = {
    entrycode?: SortOrder
    issuecode?: SortOrder
    storyversioncode?: SortOrder
    languagecode?: SortOrder
    includedinentrycode?: SortOrder
    position?: SortOrder
    printedcode?: SortOrder
    guessedcode?: SortOrder
    title?: SortOrder
    reallytitle?: SortOrder
    printedhero?: SortOrder
    changes?: SortOrder
    cut?: SortOrder
    minorchanges?: SortOrder
    missingpanels?: SortOrder
    mirrored?: SortOrder
    sideways?: SortOrder
    startdate?: SortOrder
    enddate?: SortOrder
    identificationuncertain?: SortOrder
    alsoreprint?: SortOrder
    part?: SortOrder
    entrycomment?: SortOrder
    error?: SortOrder
  }

  export type Enuminducks_entry_reallytitleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_reallytitle | Enuminducks_entry_reallytitleFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_reallytitle[] | null
    notIn?: $Enums.inducks_entry_reallytitle[] | null
    not?: NestedEnuminducks_entry_reallytitleNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_entry_reallytitle | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_entry_reallytitleNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_entry_reallytitleNullableFilter<$PrismaModel>
  }

  export type Enuminducks_entry_mirroredNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_mirrored | Enuminducks_entry_mirroredFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_mirrored[] | null
    notIn?: $Enums.inducks_entry_mirrored[] | null
    not?: NestedEnuminducks_entry_mirroredNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_entry_mirrored | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_entry_mirroredNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_entry_mirroredNullableFilter<$PrismaModel>
  }

  export type Enuminducks_entry_sidewaysNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_sideways | Enuminducks_entry_sidewaysFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_sideways[] | null
    notIn?: $Enums.inducks_entry_sideways[] | null
    not?: NestedEnuminducks_entry_sidewaysNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_entry_sideways | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_entry_sidewaysNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_entry_sidewaysNullableFilter<$PrismaModel>
  }

  export type Enuminducks_entry_identificationuncertainNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_identificationuncertain | Enuminducks_entry_identificationuncertainFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_identificationuncertain[] | null
    notIn?: $Enums.inducks_entry_identificationuncertain[] | null
    not?: NestedEnuminducks_entry_identificationuncertainNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_entry_identificationuncertain | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_entry_identificationuncertainNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_entry_identificationuncertainNullableFilter<$PrismaModel>
  }

  export type Enuminducks_entry_errorNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_error | Enuminducks_entry_errorFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_error[] | null
    notIn?: $Enums.inducks_entry_error[] | null
    not?: NestedEnuminducks_entry_errorNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_entry_error | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_entry_errorNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_entry_errorNullableFilter<$PrismaModel>
  }

  export type Enuminducks_entry_nofulltext_reallytitleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_nofulltext_reallytitle | Enuminducks_entry_nofulltext_reallytitleFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_nofulltext_reallytitle[] | null
    notIn?: $Enums.inducks_entry_nofulltext_reallytitle[] | null
    not?: NestedEnuminducks_entry_nofulltext_reallytitleNullableFilter<$PrismaModel> | $Enums.inducks_entry_nofulltext_reallytitle | null
  }

  export type Enuminducks_entry_nofulltext_mirroredNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_nofulltext_mirrored | Enuminducks_entry_nofulltext_mirroredFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_nofulltext_mirrored[] | null
    notIn?: $Enums.inducks_entry_nofulltext_mirrored[] | null
    not?: NestedEnuminducks_entry_nofulltext_mirroredNullableFilter<$PrismaModel> | $Enums.inducks_entry_nofulltext_mirrored | null
  }

  export type Enuminducks_entry_nofulltext_sidewaysNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_nofulltext_sideways | Enuminducks_entry_nofulltext_sidewaysFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_nofulltext_sideways[] | null
    notIn?: $Enums.inducks_entry_nofulltext_sideways[] | null
    not?: NestedEnuminducks_entry_nofulltext_sidewaysNullableFilter<$PrismaModel> | $Enums.inducks_entry_nofulltext_sideways | null
  }

  export type Enuminducks_entry_nofulltext_identificationuncertainNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_nofulltext_identificationuncertain | Enuminducks_entry_nofulltext_identificationuncertainFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_nofulltext_identificationuncertain[] | null
    notIn?: $Enums.inducks_entry_nofulltext_identificationuncertain[] | null
    not?: NestedEnuminducks_entry_nofulltext_identificationuncertainNullableFilter<$PrismaModel> | $Enums.inducks_entry_nofulltext_identificationuncertain | null
  }

  export type Enuminducks_entry_nofulltext_errorNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_nofulltext_error | Enuminducks_entry_nofulltext_errorFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_nofulltext_error[] | null
    notIn?: $Enums.inducks_entry_nofulltext_error[] | null
    not?: NestedEnuminducks_entry_nofulltext_errorNullableFilter<$PrismaModel> | $Enums.inducks_entry_nofulltext_error | null
  }

  export type inducks_entry_nofulltextCountOrderByAggregateInput = {
    entrycode?: SortOrder
    issuecode?: SortOrder
    storyversioncode?: SortOrder
    languagecode?: SortOrder
    includedinentrycode?: SortOrder
    position?: SortOrder
    printedcode?: SortOrder
    guessedcode?: SortOrder
    title?: SortOrder
    reallytitle?: SortOrder
    printedhero?: SortOrder
    changes?: SortOrder
    cut?: SortOrder
    minorchanges?: SortOrder
    missingpanels?: SortOrder
    mirrored?: SortOrder
    sideways?: SortOrder
    startdate?: SortOrder
    enddate?: SortOrder
    identificationuncertain?: SortOrder
    alsoreprint?: SortOrder
    part?: SortOrder
    entrycomment?: SortOrder
    error?: SortOrder
  }

  export type inducks_entry_nofulltextMaxOrderByAggregateInput = {
    entrycode?: SortOrder
    issuecode?: SortOrder
    storyversioncode?: SortOrder
    languagecode?: SortOrder
    includedinentrycode?: SortOrder
    position?: SortOrder
    printedcode?: SortOrder
    guessedcode?: SortOrder
    title?: SortOrder
    reallytitle?: SortOrder
    printedhero?: SortOrder
    changes?: SortOrder
    cut?: SortOrder
    minorchanges?: SortOrder
    missingpanels?: SortOrder
    mirrored?: SortOrder
    sideways?: SortOrder
    startdate?: SortOrder
    enddate?: SortOrder
    identificationuncertain?: SortOrder
    alsoreprint?: SortOrder
    part?: SortOrder
    entrycomment?: SortOrder
    error?: SortOrder
  }

  export type inducks_entry_nofulltextMinOrderByAggregateInput = {
    entrycode?: SortOrder
    issuecode?: SortOrder
    storyversioncode?: SortOrder
    languagecode?: SortOrder
    includedinentrycode?: SortOrder
    position?: SortOrder
    printedcode?: SortOrder
    guessedcode?: SortOrder
    title?: SortOrder
    reallytitle?: SortOrder
    printedhero?: SortOrder
    changes?: SortOrder
    cut?: SortOrder
    minorchanges?: SortOrder
    missingpanels?: SortOrder
    mirrored?: SortOrder
    sideways?: SortOrder
    startdate?: SortOrder
    enddate?: SortOrder
    identificationuncertain?: SortOrder
    alsoreprint?: SortOrder
    part?: SortOrder
    entrycomment?: SortOrder
    error?: SortOrder
  }

  export type Enuminducks_entry_nofulltext_reallytitleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_nofulltext_reallytitle | Enuminducks_entry_nofulltext_reallytitleFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_nofulltext_reallytitle[] | null
    notIn?: $Enums.inducks_entry_nofulltext_reallytitle[] | null
    not?: NestedEnuminducks_entry_nofulltext_reallytitleNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_entry_nofulltext_reallytitle | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_entry_nofulltext_reallytitleNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_entry_nofulltext_reallytitleNullableFilter<$PrismaModel>
  }

  export type Enuminducks_entry_nofulltext_mirroredNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_nofulltext_mirrored | Enuminducks_entry_nofulltext_mirroredFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_nofulltext_mirrored[] | null
    notIn?: $Enums.inducks_entry_nofulltext_mirrored[] | null
    not?: NestedEnuminducks_entry_nofulltext_mirroredNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_entry_nofulltext_mirrored | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_entry_nofulltext_mirroredNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_entry_nofulltext_mirroredNullableFilter<$PrismaModel>
  }

  export type Enuminducks_entry_nofulltext_sidewaysNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_nofulltext_sideways | Enuminducks_entry_nofulltext_sidewaysFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_nofulltext_sideways[] | null
    notIn?: $Enums.inducks_entry_nofulltext_sideways[] | null
    not?: NestedEnuminducks_entry_nofulltext_sidewaysNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_entry_nofulltext_sideways | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_entry_nofulltext_sidewaysNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_entry_nofulltext_sidewaysNullableFilter<$PrismaModel>
  }

  export type Enuminducks_entry_nofulltext_identificationuncertainNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_nofulltext_identificationuncertain | Enuminducks_entry_nofulltext_identificationuncertainFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_nofulltext_identificationuncertain[] | null
    notIn?: $Enums.inducks_entry_nofulltext_identificationuncertain[] | null
    not?: NestedEnuminducks_entry_nofulltext_identificationuncertainNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_entry_nofulltext_identificationuncertain | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_entry_nofulltext_identificationuncertainNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_entry_nofulltext_identificationuncertainNullableFilter<$PrismaModel>
  }

  export type Enuminducks_entry_nofulltext_errorNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_nofulltext_error | Enuminducks_entry_nofulltext_errorFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_nofulltext_error[] | null
    notIn?: $Enums.inducks_entry_nofulltext_error[] | null
    not?: NestedEnuminducks_entry_nofulltext_errorNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_entry_nofulltext_error | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_entry_nofulltext_errorNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_entry_nofulltext_errorNullableFilter<$PrismaModel>
  }

  export type inducks_entrycharacternameEntrycodeCharactercodeCompoundUniqueInput = {
    entrycode: string
    charactercode: string
  }

  export type inducks_entrycharacternameCountOrderByAggregateInput = {
    entrycode?: SortOrder
    charactercode?: SortOrder
    charactername?: SortOrder
  }

  export type inducks_entrycharacternameMaxOrderByAggregateInput = {
    entrycode?: SortOrder
    charactercode?: SortOrder
    charactername?: SortOrder
  }

  export type inducks_entrycharacternameMinOrderByAggregateInput = {
    entrycode?: SortOrder
    charactercode?: SortOrder
    charactername?: SortOrder
  }

  export type Enuminducks_entryjob_doubtNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entryjob_doubt | Enuminducks_entryjob_doubtFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entryjob_doubt[] | null
    notIn?: $Enums.inducks_entryjob_doubt[] | null
    not?: NestedEnuminducks_entryjob_doubtNullableFilter<$PrismaModel> | $Enums.inducks_entryjob_doubt | null
  }

  export type inducks_entryjobEntrycodePersoncodeTransletcolCompoundUniqueInput = {
    entrycode: string
    personcode: string
    transletcol: string
  }

  export type inducks_entryjobCountOrderByAggregateInput = {
    entrycode?: SortOrder
    personcode?: SortOrder
    transletcol?: SortOrder
    entryjobcomment?: SortOrder
    doubt?: SortOrder
  }

  export type inducks_entryjobMaxOrderByAggregateInput = {
    entrycode?: SortOrder
    personcode?: SortOrder
    transletcol?: SortOrder
    entryjobcomment?: SortOrder
    doubt?: SortOrder
  }

  export type inducks_entryjobMinOrderByAggregateInput = {
    entrycode?: SortOrder
    personcode?: SortOrder
    transletcol?: SortOrder
    entryjobcomment?: SortOrder
    doubt?: SortOrder
  }

  export type Enuminducks_entryjob_doubtNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entryjob_doubt | Enuminducks_entryjob_doubtFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entryjob_doubt[] | null
    notIn?: $Enums.inducks_entryjob_doubt[] | null
    not?: NestedEnuminducks_entryjob_doubtNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_entryjob_doubt | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_entryjob_doubtNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_entryjob_doubtNullableFilter<$PrismaModel>
  }

  export type Enuminducks_entryurl_publicNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entryurl_public | Enuminducks_entryurl_publicFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entryurl_public[] | null
    notIn?: $Enums.inducks_entryurl_public[] | null
    not?: NestedEnuminducks_entryurl_publicNullableFilter<$PrismaModel> | $Enums.inducks_entryurl_public | null
  }

  export type inducks_entryurlCountOrderByAggregateInput = {
    entrycode?: SortOrder
    sitecode?: SortOrder
    pagenumber?: SortOrder
    url?: SortOrder
    storycode?: SortOrder
    public?: SortOrder
    id?: SortOrder
  }

  export type inducks_entryurlAvgOrderByAggregateInput = {
    pagenumber?: SortOrder
    id?: SortOrder
  }

  export type inducks_entryurlMaxOrderByAggregateInput = {
    entrycode?: SortOrder
    sitecode?: SortOrder
    pagenumber?: SortOrder
    url?: SortOrder
    storycode?: SortOrder
    public?: SortOrder
    id?: SortOrder
  }

  export type inducks_entryurlMinOrderByAggregateInput = {
    entrycode?: SortOrder
    sitecode?: SortOrder
    pagenumber?: SortOrder
    url?: SortOrder
    storycode?: SortOrder
    public?: SortOrder
    id?: SortOrder
  }

  export type inducks_entryurlSumOrderByAggregateInput = {
    pagenumber?: SortOrder
    id?: SortOrder
  }

  export type Enuminducks_entryurl_publicNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entryurl_public | Enuminducks_entryurl_publicFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entryurl_public[] | null
    notIn?: $Enums.inducks_entryurl_public[] | null
    not?: NestedEnuminducks_entryurl_publicNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_entryurl_public | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_entryurl_publicNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_entryurl_publicNullableFilter<$PrismaModel>
  }

  export type inducks_equivIssuecodeEquividCompoundUniqueInput = {
    issuecode: string
    equivid: number
  }

  export type inducks_equivCountOrderByAggregateInput = {
    issuecode?: SortOrder
    equivid?: SortOrder
    equivcomment?: SortOrder
  }

  export type inducks_equivAvgOrderByAggregateInput = {
    equivid?: SortOrder
  }

  export type inducks_equivMaxOrderByAggregateInput = {
    issuecode?: SortOrder
    equivid?: SortOrder
    equivcomment?: SortOrder
  }

  export type inducks_equivMinOrderByAggregateInput = {
    issuecode?: SortOrder
    equivid?: SortOrder
    equivcomment?: SortOrder
  }

  export type inducks_equivSumOrderByAggregateInput = {
    equivid?: SortOrder
  }

  export type Enuminducks_herocharacter_doubtNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_herocharacter_doubt | Enuminducks_herocharacter_doubtFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_herocharacter_doubt[] | null
    notIn?: $Enums.inducks_herocharacter_doubt[] | null
    not?: NestedEnuminducks_herocharacter_doubtNullableFilter<$PrismaModel> | $Enums.inducks_herocharacter_doubt | null
  }

  export type inducks_herocharacterStorycodeCharactercodeCompoundUniqueInput = {
    storycode: string
    charactercode: string
  }

  export type inducks_herocharacterCountOrderByAggregateInput = {
    storycode?: SortOrder
    charactercode?: SortOrder
    number?: SortOrder
    doubt?: SortOrder
  }

  export type inducks_herocharacterAvgOrderByAggregateInput = {
    number?: SortOrder
  }

  export type inducks_herocharacterMaxOrderByAggregateInput = {
    storycode?: SortOrder
    charactercode?: SortOrder
    number?: SortOrder
    doubt?: SortOrder
  }

  export type inducks_herocharacterMinOrderByAggregateInput = {
    storycode?: SortOrder
    charactercode?: SortOrder
    number?: SortOrder
    doubt?: SortOrder
  }

  export type inducks_herocharacterSumOrderByAggregateInput = {
    number?: SortOrder
  }

  export type Enuminducks_herocharacter_doubtNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_herocharacter_doubt | Enuminducks_herocharacter_doubtFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_herocharacter_doubt[] | null
    notIn?: $Enums.inducks_herocharacter_doubt[] | null
    not?: NestedEnuminducks_herocharacter_doubtNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_herocharacter_doubt | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_herocharacter_doubtNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_herocharacter_doubtNullableFilter<$PrismaModel>
  }

  export type Enuminducks_inputfile_lockedNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_inputfile_locked | Enuminducks_inputfile_lockedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_inputfile_locked[] | null
    notIn?: $Enums.inducks_inputfile_locked[] | null
    not?: NestedEnuminducks_inputfile_lockedNullableFilter<$PrismaModel> | $Enums.inducks_inputfile_locked | null
  }

  export type Enuminducks_inputfile_secundaryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_inputfile_secundary | Enuminducks_inputfile_secundaryFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_inputfile_secundary[] | null
    notIn?: $Enums.inducks_inputfile_secundary[] | null
    not?: NestedEnuminducks_inputfile_secundaryNullableFilter<$PrismaModel> | $Enums.inducks_inputfile_secundary | null
  }

  export type inducks_inputfileCountOrderByAggregateInput = {
    inputfilecode?: SortOrder
    path?: SortOrder
    filename?: SortOrder
    layout?: SortOrder
    locked?: SortOrder
    maintenanceteamcode?: SortOrder
    countrycode?: SortOrder
    languagecode?: SortOrder
    producercode?: SortOrder
    secundary?: SortOrder
  }

  export type inducks_inputfileAvgOrderByAggregateInput = {
    inputfilecode?: SortOrder
  }

  export type inducks_inputfileMaxOrderByAggregateInput = {
    inputfilecode?: SortOrder
    path?: SortOrder
    filename?: SortOrder
    layout?: SortOrder
    locked?: SortOrder
    maintenanceteamcode?: SortOrder
    countrycode?: SortOrder
    languagecode?: SortOrder
    producercode?: SortOrder
    secundary?: SortOrder
  }

  export type inducks_inputfileMinOrderByAggregateInput = {
    inputfilecode?: SortOrder
    path?: SortOrder
    filename?: SortOrder
    layout?: SortOrder
    locked?: SortOrder
    maintenanceteamcode?: SortOrder
    countrycode?: SortOrder
    languagecode?: SortOrder
    producercode?: SortOrder
    secundary?: SortOrder
  }

  export type inducks_inputfileSumOrderByAggregateInput = {
    inputfilecode?: SortOrder
  }

  export type Enuminducks_inputfile_lockedNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_inputfile_locked | Enuminducks_inputfile_lockedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_inputfile_locked[] | null
    notIn?: $Enums.inducks_inputfile_locked[] | null
    not?: NestedEnuminducks_inputfile_lockedNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_inputfile_locked | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_inputfile_lockedNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_inputfile_lockedNullableFilter<$PrismaModel>
  }

  export type Enuminducks_inputfile_secundaryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_inputfile_secundary | Enuminducks_inputfile_secundaryFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_inputfile_secundary[] | null
    notIn?: $Enums.inducks_inputfile_secundary[] | null
    not?: NestedEnuminducks_inputfile_secundaryNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_inputfile_secundary | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_inputfile_secundaryNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_inputfile_secundaryNullableFilter<$PrismaModel>
  }

  export type Enuminducks_issue_fullyindexedNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_issue_fullyindexed | Enuminducks_issue_fullyindexedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_issue_fullyindexed[] | null
    notIn?: $Enums.inducks_issue_fullyindexed[] | null
    not?: NestedEnuminducks_issue_fullyindexedNullableFilter<$PrismaModel> | $Enums.inducks_issue_fullyindexed | null
  }

  export type Enuminducks_issue_errorNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_issue_error | Enuminducks_issue_errorFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_issue_error[] | null
    notIn?: $Enums.inducks_issue_error[] | null
    not?: NestedEnuminducks_issue_errorNullableFilter<$PrismaModel> | $Enums.inducks_issue_error | null
  }

  export type Enuminducks_issue_lockedNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_issue_locked | Enuminducks_issue_lockedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_issue_locked[] | null
    notIn?: $Enums.inducks_issue_locked[] | null
    not?: NestedEnuminducks_issue_lockedNullableFilter<$PrismaModel> | $Enums.inducks_issue_locked | null
  }

  export type Enuminducks_issue_inxforbiddenNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_issue_inxforbidden | Enuminducks_issue_inxforbiddenFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_issue_inxforbidden[] | null
    notIn?: $Enums.inducks_issue_inxforbidden[] | null
    not?: NestedEnuminducks_issue_inxforbiddenNullableFilter<$PrismaModel> | $Enums.inducks_issue_inxforbidden | null
  }

  export type inducks_issueCountOrderByAggregateInput = {
    issuecode?: SortOrder
    issuerangecode?: SortOrder
    publicationcode?: SortOrder
    issuenumber?: SortOrder
    title?: SortOrder
    size?: SortOrder
    pages?: SortOrder
    price?: SortOrder
    printrun?: SortOrder
    attached?: SortOrder
    oldestdate?: SortOrder
    fullyindexed?: SortOrder
    issuecomment?: SortOrder
    error?: SortOrder
    filledoldestdate?: SortOrder
    locked?: SortOrder
    inxforbidden?: SortOrder
    inputfilecode?: SortOrder
    maintenanceteamcode?: SortOrder
  }

  export type inducks_issueAvgOrderByAggregateInput = {
    inputfilecode?: SortOrder
  }

  export type inducks_issueMaxOrderByAggregateInput = {
    issuecode?: SortOrder
    issuerangecode?: SortOrder
    publicationcode?: SortOrder
    issuenumber?: SortOrder
    title?: SortOrder
    size?: SortOrder
    pages?: SortOrder
    price?: SortOrder
    printrun?: SortOrder
    attached?: SortOrder
    oldestdate?: SortOrder
    fullyindexed?: SortOrder
    issuecomment?: SortOrder
    error?: SortOrder
    filledoldestdate?: SortOrder
    locked?: SortOrder
    inxforbidden?: SortOrder
    inputfilecode?: SortOrder
    maintenanceteamcode?: SortOrder
  }

  export type inducks_issueMinOrderByAggregateInput = {
    issuecode?: SortOrder
    issuerangecode?: SortOrder
    publicationcode?: SortOrder
    issuenumber?: SortOrder
    title?: SortOrder
    size?: SortOrder
    pages?: SortOrder
    price?: SortOrder
    printrun?: SortOrder
    attached?: SortOrder
    oldestdate?: SortOrder
    fullyindexed?: SortOrder
    issuecomment?: SortOrder
    error?: SortOrder
    filledoldestdate?: SortOrder
    locked?: SortOrder
    inxforbidden?: SortOrder
    inputfilecode?: SortOrder
    maintenanceteamcode?: SortOrder
  }

  export type inducks_issueSumOrderByAggregateInput = {
    inputfilecode?: SortOrder
  }

  export type Enuminducks_issue_fullyindexedNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_issue_fullyindexed | Enuminducks_issue_fullyindexedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_issue_fullyindexed[] | null
    notIn?: $Enums.inducks_issue_fullyindexed[] | null
    not?: NestedEnuminducks_issue_fullyindexedNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_issue_fullyindexed | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_issue_fullyindexedNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_issue_fullyindexedNullableFilter<$PrismaModel>
  }

  export type Enuminducks_issue_errorNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_issue_error | Enuminducks_issue_errorFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_issue_error[] | null
    notIn?: $Enums.inducks_issue_error[] | null
    not?: NestedEnuminducks_issue_errorNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_issue_error | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_issue_errorNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_issue_errorNullableFilter<$PrismaModel>
  }

  export type Enuminducks_issue_lockedNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_issue_locked | Enuminducks_issue_lockedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_issue_locked[] | null
    notIn?: $Enums.inducks_issue_locked[] | null
    not?: NestedEnuminducks_issue_lockedNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_issue_locked | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_issue_lockedNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_issue_lockedNullableFilter<$PrismaModel>
  }

  export type Enuminducks_issue_inxforbiddenNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_issue_inxforbidden | Enuminducks_issue_inxforbiddenFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_issue_inxforbidden[] | null
    notIn?: $Enums.inducks_issue_inxforbidden[] | null
    not?: NestedEnuminducks_issue_inxforbiddenNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_issue_inxforbidden | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_issue_inxforbiddenNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_issue_inxforbiddenNullableFilter<$PrismaModel>
  }

  export type inducks_issuecollectingCollectingissuecodeCollectedissuecodeCompoundUniqueInput = {
    collectingissuecode: string
    collectedissuecode: string
  }

  export type inducks_issuecollectingCountOrderByAggregateInput = {
    collectingissuecode?: SortOrder
    collectedissuecode?: SortOrder
  }

  export type inducks_issuecollectingMaxOrderByAggregateInput = {
    collectingissuecode?: SortOrder
    collectedissuecode?: SortOrder
  }

  export type inducks_issuecollectingMinOrderByAggregateInput = {
    collectingissuecode?: SortOrder
    collectedissuecode?: SortOrder
  }

  export type Enuminducks_issuedate_doubtNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_issuedate_doubt | Enuminducks_issuedate_doubtFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_issuedate_doubt[] | null
    notIn?: $Enums.inducks_issuedate_doubt[] | null
    not?: NestedEnuminducks_issuedate_doubtNullableFilter<$PrismaModel> | $Enums.inducks_issuedate_doubt | null
  }

  export type inducks_issuedateIssuecodeDateCompoundUniqueInput = {
    issuecode: string
    date: string
  }

  export type inducks_issuedateCountOrderByAggregateInput = {
    issuecode?: SortOrder
    date?: SortOrder
    kindofdate?: SortOrder
    doubt?: SortOrder
  }

  export type inducks_issuedateMaxOrderByAggregateInput = {
    issuecode?: SortOrder
    date?: SortOrder
    kindofdate?: SortOrder
    doubt?: SortOrder
  }

  export type inducks_issuedateMinOrderByAggregateInput = {
    issuecode?: SortOrder
    date?: SortOrder
    kindofdate?: SortOrder
    doubt?: SortOrder
  }

  export type Enuminducks_issuedate_doubtNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_issuedate_doubt | Enuminducks_issuedate_doubtFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_issuedate_doubt[] | null
    notIn?: $Enums.inducks_issuedate_doubt[] | null
    not?: NestedEnuminducks_issuedate_doubtNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_issuedate_doubt | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_issuedate_doubtNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_issuedate_doubtNullableFilter<$PrismaModel>
  }

  export type Enuminducks_issuejob_doubtNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_issuejob_doubt | Enuminducks_issuejob_doubtFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_issuejob_doubt[] | null
    notIn?: $Enums.inducks_issuejob_doubt[] | null
    not?: NestedEnuminducks_issuejob_doubtNullableFilter<$PrismaModel> | $Enums.inducks_issuejob_doubt | null
  }

  export type inducks_issuejobIssuecodePersoncodeInxtransletcolCompoundUniqueInput = {
    issuecode: string
    personcode: string
    inxtransletcol: string
  }

  export type inducks_issuejobCountOrderByAggregateInput = {
    issuecode?: SortOrder
    personcode?: SortOrder
    inxtransletcol?: SortOrder
    issuejobcomment?: SortOrder
    doubt?: SortOrder
  }

  export type inducks_issuejobMaxOrderByAggregateInput = {
    issuecode?: SortOrder
    personcode?: SortOrder
    inxtransletcol?: SortOrder
    issuejobcomment?: SortOrder
    doubt?: SortOrder
  }

  export type inducks_issuejobMinOrderByAggregateInput = {
    issuecode?: SortOrder
    personcode?: SortOrder
    inxtransletcol?: SortOrder
    issuejobcomment?: SortOrder
    doubt?: SortOrder
  }

  export type Enuminducks_issuejob_doubtNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_issuejob_doubt | Enuminducks_issuejob_doubtFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_issuejob_doubt[] | null
    notIn?: $Enums.inducks_issuejob_doubt[] | null
    not?: NestedEnuminducks_issuejob_doubtNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_issuejob_doubt | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_issuejob_doubtNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_issuejob_doubtNullableFilter<$PrismaModel>
  }

  export type inducks_issuepriceIssuecodeAmountCompoundUniqueInput = {
    issuecode: string
    amount: string
  }

  export type inducks_issuepriceCountOrderByAggregateInput = {
    issuecode?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    comment?: SortOrder
    sequencenumber?: SortOrder
  }

  export type inducks_issuepriceAvgOrderByAggregateInput = {
    sequencenumber?: SortOrder
  }

  export type inducks_issuepriceMaxOrderByAggregateInput = {
    issuecode?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    comment?: SortOrder
    sequencenumber?: SortOrder
  }

  export type inducks_issuepriceMinOrderByAggregateInput = {
    issuecode?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    comment?: SortOrder
    sequencenumber?: SortOrder
  }

  export type inducks_issuepriceSumOrderByAggregateInput = {
    sequencenumber?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type inducks_issuequotationCountOrderByAggregateInput = {
    ID?: SortOrder
    publicationcode?: SortOrder
    issuenumber?: SortOrder
    estimationmin?: SortOrder
    estimationmax?: SortOrder
    scrapedate?: SortOrder
    source?: SortOrder
    issuecode?: SortOrder
  }

  export type inducks_issuequotationAvgOrderByAggregateInput = {
    ID?: SortOrder
    estimationmin?: SortOrder
    estimationmax?: SortOrder
  }

  export type inducks_issuequotationMaxOrderByAggregateInput = {
    ID?: SortOrder
    publicationcode?: SortOrder
    issuenumber?: SortOrder
    estimationmin?: SortOrder
    estimationmax?: SortOrder
    scrapedate?: SortOrder
    source?: SortOrder
    issuecode?: SortOrder
  }

  export type inducks_issuequotationMinOrderByAggregateInput = {
    ID?: SortOrder
    publicationcode?: SortOrder
    issuenumber?: SortOrder
    estimationmin?: SortOrder
    estimationmax?: SortOrder
    scrapedate?: SortOrder
    source?: SortOrder
    issuecode?: SortOrder
  }

  export type inducks_issuequotationSumOrderByAggregateInput = {
    ID?: SortOrder
    estimationmin?: SortOrder
    estimationmax?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type Enuminducks_issuerange_numbersarefakeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_issuerange_numbersarefake | Enuminducks_issuerange_numbersarefakeFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_issuerange_numbersarefake[] | null
    notIn?: $Enums.inducks_issuerange_numbersarefake[] | null
    not?: NestedEnuminducks_issuerange_numbersarefakeNullableFilter<$PrismaModel> | $Enums.inducks_issuerange_numbersarefake | null
  }

  export type Enuminducks_issuerange_errorNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_issuerange_error | Enuminducks_issuerange_errorFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_issuerange_error[] | null
    notIn?: $Enums.inducks_issuerange_error[] | null
    not?: NestedEnuminducks_issuerange_errorNullableFilter<$PrismaModel> | $Enums.inducks_issuerange_error | null
  }

  export type inducks_issuerangeCountOrderByAggregateInput = {
    issuerangecode?: SortOrder
    publicationcode?: SortOrder
    title?: SortOrder
    circulation?: SortOrder
    issuerangecomment?: SortOrder
    numbersarefake?: SortOrder
    error?: SortOrder
  }

  export type inducks_issuerangeMaxOrderByAggregateInput = {
    issuerangecode?: SortOrder
    publicationcode?: SortOrder
    title?: SortOrder
    circulation?: SortOrder
    issuerangecomment?: SortOrder
    numbersarefake?: SortOrder
    error?: SortOrder
  }

  export type inducks_issuerangeMinOrderByAggregateInput = {
    issuerangecode?: SortOrder
    publicationcode?: SortOrder
    title?: SortOrder
    circulation?: SortOrder
    issuerangecomment?: SortOrder
    numbersarefake?: SortOrder
    error?: SortOrder
  }

  export type Enuminducks_issuerange_numbersarefakeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_issuerange_numbersarefake | Enuminducks_issuerange_numbersarefakeFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_issuerange_numbersarefake[] | null
    notIn?: $Enums.inducks_issuerange_numbersarefake[] | null
    not?: NestedEnuminducks_issuerange_numbersarefakeNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_issuerange_numbersarefake | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_issuerange_numbersarefakeNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_issuerange_numbersarefakeNullableFilter<$PrismaModel>
  }

  export type Enuminducks_issuerange_errorNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_issuerange_error | Enuminducks_issuerange_errorFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_issuerange_error[] | null
    notIn?: $Enums.inducks_issuerange_error[] | null
    not?: NestedEnuminducks_issuerange_errorNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_issuerange_error | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_issuerange_errorNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_issuerange_errorNullableFilter<$PrismaModel>
  }

  export type inducks_issueurlIssuecodeSitecodeCompoundUniqueInput = {
    issuecode: string
    sitecode: string
  }

  export type inducks_issueurlCountOrderByAggregateInput = {
    issuecode?: SortOrder
    sitecode?: SortOrder
    url?: SortOrder
  }

  export type inducks_issueurlMaxOrderByAggregateInput = {
    issuecode?: SortOrder
    sitecode?: SortOrder
    url?: SortOrder
  }

  export type inducks_issueurlMinOrderByAggregateInput = {
    issuecode?: SortOrder
    sitecode?: SortOrder
    url?: SortOrder
  }

  export type inducks_languageCountOrderByAggregateInput = {
    languagecode?: SortOrder
    defaultlanguagecode?: SortOrder
    languagename?: SortOrder
  }

  export type inducks_languageMaxOrderByAggregateInput = {
    languagecode?: SortOrder
    defaultlanguagecode?: SortOrder
    languagename?: SortOrder
  }

  export type inducks_languageMinOrderByAggregateInput = {
    languagecode?: SortOrder
    defaultlanguagecode?: SortOrder
    languagename?: SortOrder
  }

  export type inducks_languagenameDesclanguagecodeLanguagecodeCompoundUniqueInput = {
    desclanguagecode: string
    languagecode: string
  }

  export type inducks_languagenameCountOrderByAggregateInput = {
    desclanguagecode?: SortOrder
    languagecode?: SortOrder
    languagename?: SortOrder
  }

  export type inducks_languagenameMaxOrderByAggregateInput = {
    desclanguagecode?: SortOrder
    languagecode?: SortOrder
    languagename?: SortOrder
  }

  export type inducks_languagenameMinOrderByAggregateInput = {
    desclanguagecode?: SortOrder
    languagecode?: SortOrder
    languagename?: SortOrder
  }

  export type Enuminducks_log_markedNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_log_marked | Enuminducks_log_markedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_log_marked[] | null
    notIn?: $Enums.inducks_log_marked[] | null
    not?: NestedEnuminducks_log_markedNullableFilter<$PrismaModel> | $Enums.inducks_log_marked | null
  }

  export type inducks_logCountOrderByAggregateInput = {
    number?: SortOrder
    logkey?: SortOrder
    storycode?: SortOrder
    logid?: SortOrder
    logtype?: SortOrder
    par1?: SortOrder
    par2?: SortOrder
    par3?: SortOrder
    marked?: SortOrder
    inputfilecode?: SortOrder
    maintenanceteamcode?: SortOrder
  }

  export type inducks_logAvgOrderByAggregateInput = {
    number?: SortOrder
    inputfilecode?: SortOrder
  }

  export type inducks_logMaxOrderByAggregateInput = {
    number?: SortOrder
    logkey?: SortOrder
    storycode?: SortOrder
    logid?: SortOrder
    logtype?: SortOrder
    par1?: SortOrder
    par2?: SortOrder
    par3?: SortOrder
    marked?: SortOrder
    inputfilecode?: SortOrder
    maintenanceteamcode?: SortOrder
  }

  export type inducks_logMinOrderByAggregateInput = {
    number?: SortOrder
    logkey?: SortOrder
    storycode?: SortOrder
    logid?: SortOrder
    logtype?: SortOrder
    par1?: SortOrder
    par2?: SortOrder
    par3?: SortOrder
    marked?: SortOrder
    inputfilecode?: SortOrder
    maintenanceteamcode?: SortOrder
  }

  export type inducks_logSumOrderByAggregateInput = {
    number?: SortOrder
    inputfilecode?: SortOrder
  }

  export type Enuminducks_log_markedNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_log_marked | Enuminducks_log_markedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_log_marked[] | null
    notIn?: $Enums.inducks_log_marked[] | null
    not?: NestedEnuminducks_log_markedNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_log_marked | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_log_markedNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_log_markedNullableFilter<$PrismaModel>
  }

  export type inducks_logdataCountOrderByAggregateInput = {
    logid?: SortOrder
    category?: SortOrder
    logtext?: SortOrder
  }

  export type inducks_logdataAvgOrderByAggregateInput = {
    category?: SortOrder
  }

  export type inducks_logdataMaxOrderByAggregateInput = {
    logid?: SortOrder
    category?: SortOrder
    logtext?: SortOrder
  }

  export type inducks_logdataMinOrderByAggregateInput = {
    logid?: SortOrder
    category?: SortOrder
    logtext?: SortOrder
  }

  export type inducks_logdataSumOrderByAggregateInput = {
    category?: SortOrder
  }

  export type Enuminducks_logocharacter_reallyintitleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_logocharacter_reallyintitle | Enuminducks_logocharacter_reallyintitleFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_logocharacter_reallyintitle[] | null
    notIn?: $Enums.inducks_logocharacter_reallyintitle[] | null
    not?: NestedEnuminducks_logocharacter_reallyintitleNullableFilter<$PrismaModel> | $Enums.inducks_logocharacter_reallyintitle | null
  }

  export type inducks_logocharacterEntrycodeCharactercodeCompoundUniqueInput = {
    entrycode: string
    charactercode: string
  }

  export type inducks_logocharacterCountOrderByAggregateInput = {
    entrycode?: SortOrder
    charactercode?: SortOrder
    reallyintitle?: SortOrder
    number?: SortOrder
    logocharactercomment?: SortOrder
  }

  export type inducks_logocharacterAvgOrderByAggregateInput = {
    number?: SortOrder
  }

  export type inducks_logocharacterMaxOrderByAggregateInput = {
    entrycode?: SortOrder
    charactercode?: SortOrder
    reallyintitle?: SortOrder
    number?: SortOrder
    logocharactercomment?: SortOrder
  }

  export type inducks_logocharacterMinOrderByAggregateInput = {
    entrycode?: SortOrder
    charactercode?: SortOrder
    reallyintitle?: SortOrder
    number?: SortOrder
    logocharactercomment?: SortOrder
  }

  export type inducks_logocharacterSumOrderByAggregateInput = {
    number?: SortOrder
  }

  export type Enuminducks_logocharacter_reallyintitleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_logocharacter_reallyintitle | Enuminducks_logocharacter_reallyintitleFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_logocharacter_reallyintitle[] | null
    notIn?: $Enums.inducks_logocharacter_reallyintitle[] | null
    not?: NestedEnuminducks_logocharacter_reallyintitleNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_logocharacter_reallyintitle | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_logocharacter_reallyintitleNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_logocharacter_reallyintitleNullableFilter<$PrismaModel>
  }

  export type Enuminducks_movie_lockedNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_movie_locked | Enuminducks_movie_lockedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_movie_locked[] | null
    notIn?: $Enums.inducks_movie_locked[] | null
    not?: NestedEnuminducks_movie_lockedNullableFilter<$PrismaModel> | $Enums.inducks_movie_locked | null
  }

  export type inducks_movieCountOrderByAggregateInput = {
    moviecode?: SortOrder
    title?: SortOrder
    moviecomment?: SortOrder
    appsummary?: SortOrder
    moviejobsummary?: SortOrder
    locked?: SortOrder
    inputfilecode?: SortOrder
    maintenanceteamcode?: SortOrder
    aka?: SortOrder
    creationdate?: SortOrder
    moviedescription?: SortOrder
    distributor?: SortOrder
    genre?: SortOrder
    orderer?: SortOrder
    publicationdate?: SortOrder
    source?: SortOrder
    tim?: SortOrder
  }

  export type inducks_movieAvgOrderByAggregateInput = {
    inputfilecode?: SortOrder
  }

  export type inducks_movieMaxOrderByAggregateInput = {
    moviecode?: SortOrder
    title?: SortOrder
    moviecomment?: SortOrder
    appsummary?: SortOrder
    moviejobsummary?: SortOrder
    locked?: SortOrder
    inputfilecode?: SortOrder
    maintenanceteamcode?: SortOrder
    aka?: SortOrder
    creationdate?: SortOrder
    moviedescription?: SortOrder
    distributor?: SortOrder
    genre?: SortOrder
    orderer?: SortOrder
    publicationdate?: SortOrder
    source?: SortOrder
    tim?: SortOrder
  }

  export type inducks_movieMinOrderByAggregateInput = {
    moviecode?: SortOrder
    title?: SortOrder
    moviecomment?: SortOrder
    appsummary?: SortOrder
    moviejobsummary?: SortOrder
    locked?: SortOrder
    inputfilecode?: SortOrder
    maintenanceteamcode?: SortOrder
    aka?: SortOrder
    creationdate?: SortOrder
    moviedescription?: SortOrder
    distributor?: SortOrder
    genre?: SortOrder
    orderer?: SortOrder
    publicationdate?: SortOrder
    source?: SortOrder
    tim?: SortOrder
  }

  export type inducks_movieSumOrderByAggregateInput = {
    inputfilecode?: SortOrder
  }

  export type Enuminducks_movie_lockedNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_movie_locked | Enuminducks_movie_lockedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_movie_locked[] | null
    notIn?: $Enums.inducks_movie_locked[] | null
    not?: NestedEnuminducks_movie_lockedNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_movie_locked | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_movie_lockedNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_movie_lockedNullableFilter<$PrismaModel>
  }

  export type Enuminducks_moviecharacter_istitlecharacterNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_moviecharacter_istitlecharacter | Enuminducks_moviecharacter_istitlecharacterFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_moviecharacter_istitlecharacter[] | null
    notIn?: $Enums.inducks_moviecharacter_istitlecharacter[] | null
    not?: NestedEnuminducks_moviecharacter_istitlecharacterNullableFilter<$PrismaModel> | $Enums.inducks_moviecharacter_istitlecharacter | null
  }

  export type inducks_moviecharacterMoviecodeCharactercodeCompoundUniqueInput = {
    moviecode: string
    charactercode: string
  }

  export type inducks_moviecharacterCountOrderByAggregateInput = {
    moviecode?: SortOrder
    charactercode?: SortOrder
    istitlecharacter?: SortOrder
  }

  export type inducks_moviecharacterMaxOrderByAggregateInput = {
    moviecode?: SortOrder
    charactercode?: SortOrder
    istitlecharacter?: SortOrder
  }

  export type inducks_moviecharacterMinOrderByAggregateInput = {
    moviecode?: SortOrder
    charactercode?: SortOrder
    istitlecharacter?: SortOrder
  }

  export type Enuminducks_moviecharacter_istitlecharacterNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_moviecharacter_istitlecharacter | Enuminducks_moviecharacter_istitlecharacterFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_moviecharacter_istitlecharacter[] | null
    notIn?: $Enums.inducks_moviecharacter_istitlecharacter[] | null
    not?: NestedEnuminducks_moviecharacter_istitlecharacterNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_moviecharacter_istitlecharacter | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_moviecharacter_istitlecharacterNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_moviecharacter_istitlecharacterNullableFilter<$PrismaModel>
  }

  export type Enuminducks_moviejob_indirectNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_moviejob_indirect | Enuminducks_moviejob_indirectFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_moviejob_indirect[] | null
    notIn?: $Enums.inducks_moviejob_indirect[] | null
    not?: NestedEnuminducks_moviejob_indirectNullableFilter<$PrismaModel> | $Enums.inducks_moviejob_indirect | null
  }

  export type Enuminducks_moviejob_doubtNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_moviejob_doubt | Enuminducks_moviejob_doubtFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_moviejob_doubt[] | null
    notIn?: $Enums.inducks_moviejob_doubt[] | null
    not?: NestedEnuminducks_moviejob_doubtNullableFilter<$PrismaModel> | $Enums.inducks_moviejob_doubt | null
  }

  export type inducks_moviejobMoviecodePersoncodeRoleCompoundUniqueInput = {
    moviecode: string
    personcode: string
    role: string
  }

  export type inducks_moviejobCountOrderByAggregateInput = {
    moviecode?: SortOrder
    personcode?: SortOrder
    role?: SortOrder
    moviejobcomment?: SortOrder
    indirect?: SortOrder
    doubt?: SortOrder
  }

  export type inducks_moviejobMaxOrderByAggregateInput = {
    moviecode?: SortOrder
    personcode?: SortOrder
    role?: SortOrder
    moviejobcomment?: SortOrder
    indirect?: SortOrder
    doubt?: SortOrder
  }

  export type inducks_moviejobMinOrderByAggregateInput = {
    moviecode?: SortOrder
    personcode?: SortOrder
    role?: SortOrder
    moviejobcomment?: SortOrder
    indirect?: SortOrder
    doubt?: SortOrder
  }

  export type Enuminducks_moviejob_indirectNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_moviejob_indirect | Enuminducks_moviejob_indirectFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_moviejob_indirect[] | null
    notIn?: $Enums.inducks_moviejob_indirect[] | null
    not?: NestedEnuminducks_moviejob_indirectNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_moviejob_indirect | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_moviejob_indirectNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_moviejob_indirectNullableFilter<$PrismaModel>
  }

  export type Enuminducks_moviejob_doubtNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_moviejob_doubt | Enuminducks_moviejob_doubtFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_moviejob_doubt[] | null
    notIn?: $Enums.inducks_moviejob_doubt[] | null
    not?: NestedEnuminducks_moviejob_doubtNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_moviejob_doubt | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_moviejob_doubtNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_moviejob_doubtNullableFilter<$PrismaModel>
  }

  export type Enuminducks_moviereference_frommovietostoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_moviereference_frommovietostory | Enuminducks_moviereference_frommovietostoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_moviereference_frommovietostory[] | null
    notIn?: $Enums.inducks_moviereference_frommovietostory[] | null
    not?: NestedEnuminducks_moviereference_frommovietostoryNullableFilter<$PrismaModel> | $Enums.inducks_moviereference_frommovietostory | null
  }

  export type inducks_moviereferenceStorycodeMoviecodeCompoundUniqueInput = {
    storycode: string
    moviecode: string
  }

  export type inducks_moviereferenceCountOrderByAggregateInput = {
    storycode?: SortOrder
    moviecode?: SortOrder
    referencereasonid?: SortOrder
    frommovietostory?: SortOrder
  }

  export type inducks_moviereferenceAvgOrderByAggregateInput = {
    referencereasonid?: SortOrder
  }

  export type inducks_moviereferenceMaxOrderByAggregateInput = {
    storycode?: SortOrder
    moviecode?: SortOrder
    referencereasonid?: SortOrder
    frommovietostory?: SortOrder
  }

  export type inducks_moviereferenceMinOrderByAggregateInput = {
    storycode?: SortOrder
    moviecode?: SortOrder
    referencereasonid?: SortOrder
    frommovietostory?: SortOrder
  }

  export type inducks_moviereferenceSumOrderByAggregateInput = {
    referencereasonid?: SortOrder
  }

  export type Enuminducks_moviereference_frommovietostoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_moviereference_frommovietostory | Enuminducks_moviereference_frommovietostoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_moviereference_frommovietostory[] | null
    notIn?: $Enums.inducks_moviereference_frommovietostory[] | null
    not?: NestedEnuminducks_moviereference_frommovietostoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_moviereference_frommovietostory | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_moviereference_frommovietostoryNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_moviereference_frommovietostoryNullableFilter<$PrismaModel>
  }

  export type Enuminducks_person_officialNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_person_official | Enuminducks_person_officialFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_person_official[] | null
    notIn?: $Enums.inducks_person_official[] | null
    not?: NestedEnuminducks_person_officialNullableFilter<$PrismaModel> | $Enums.inducks_person_official | null
  }

  export type Enuminducks_person_unknownstudiomemberNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_person_unknownstudiomember | Enuminducks_person_unknownstudiomemberFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_person_unknownstudiomember[] | null
    notIn?: $Enums.inducks_person_unknownstudiomember[] | null
    not?: NestedEnuminducks_person_unknownstudiomemberNullableFilter<$PrismaModel> | $Enums.inducks_person_unknownstudiomember | null
  }

  export type Enuminducks_person_isfakeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_person_isfake | Enuminducks_person_isfakeFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_person_isfake[] | null
    notIn?: $Enums.inducks_person_isfake[] | null
    not?: NestedEnuminducks_person_isfakeNullableFilter<$PrismaModel> | $Enums.inducks_person_isfake | null
  }

  export type inducks_personCountOrderByAggregateInput = {
    personcode?: SortOrder
    nationalitycountrycode?: SortOrder
    fullname?: SortOrder
    official?: SortOrder
    personcomment?: SortOrder
    unknownstudiomember?: SortOrder
    isfake?: SortOrder
    numberofindexedissues?: SortOrder
    birthname?: SortOrder
    borndate?: SortOrder
    bornplace?: SortOrder
    deceaseddate?: SortOrder
    deceasedplace?: SortOrder
    education?: SortOrder
    moviestext?: SortOrder
    comicstext?: SortOrder
    othertext?: SortOrder
    photofilename?: SortOrder
    photocomment?: SortOrder
    photosource?: SortOrder
    personrefs?: SortOrder
  }

  export type inducks_personAvgOrderByAggregateInput = {
    numberofindexedissues?: SortOrder
  }

  export type inducks_personMaxOrderByAggregateInput = {
    personcode?: SortOrder
    nationalitycountrycode?: SortOrder
    fullname?: SortOrder
    official?: SortOrder
    personcomment?: SortOrder
    unknownstudiomember?: SortOrder
    isfake?: SortOrder
    numberofindexedissues?: SortOrder
    birthname?: SortOrder
    borndate?: SortOrder
    bornplace?: SortOrder
    deceaseddate?: SortOrder
    deceasedplace?: SortOrder
    education?: SortOrder
    moviestext?: SortOrder
    comicstext?: SortOrder
    othertext?: SortOrder
    photofilename?: SortOrder
    photocomment?: SortOrder
    photosource?: SortOrder
    personrefs?: SortOrder
  }

  export type inducks_personMinOrderByAggregateInput = {
    personcode?: SortOrder
    nationalitycountrycode?: SortOrder
    fullname?: SortOrder
    official?: SortOrder
    personcomment?: SortOrder
    unknownstudiomember?: SortOrder
    isfake?: SortOrder
    numberofindexedissues?: SortOrder
    birthname?: SortOrder
    borndate?: SortOrder
    bornplace?: SortOrder
    deceaseddate?: SortOrder
    deceasedplace?: SortOrder
    education?: SortOrder
    moviestext?: SortOrder
    comicstext?: SortOrder
    othertext?: SortOrder
    photofilename?: SortOrder
    photocomment?: SortOrder
    photosource?: SortOrder
    personrefs?: SortOrder
  }

  export type inducks_personSumOrderByAggregateInput = {
    numberofindexedissues?: SortOrder
  }

  export type Enuminducks_person_officialNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_person_official | Enuminducks_person_officialFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_person_official[] | null
    notIn?: $Enums.inducks_person_official[] | null
    not?: NestedEnuminducks_person_officialNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_person_official | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_person_officialNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_person_officialNullableFilter<$PrismaModel>
  }

  export type Enuminducks_person_unknownstudiomemberNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_person_unknownstudiomember | Enuminducks_person_unknownstudiomemberFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_person_unknownstudiomember[] | null
    notIn?: $Enums.inducks_person_unknownstudiomember[] | null
    not?: NestedEnuminducks_person_unknownstudiomemberNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_person_unknownstudiomember | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_person_unknownstudiomemberNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_person_unknownstudiomemberNullableFilter<$PrismaModel>
  }

  export type Enuminducks_person_isfakeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_person_isfake | Enuminducks_person_isfakeFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_person_isfake[] | null
    notIn?: $Enums.inducks_person_isfake[] | null
    not?: NestedEnuminducks_person_isfakeNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_person_isfake | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_person_isfakeNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_person_isfakeNullableFilter<$PrismaModel>
  }

  export type inducks_personurlPersoncodeSitecodeCompoundUniqueInput = {
    personcode: string
    sitecode: string
  }

  export type inducks_personurlCountOrderByAggregateInput = {
    personcode?: SortOrder
    sitecode?: SortOrder
    url?: SortOrder
  }

  export type inducks_personurlMaxOrderByAggregateInput = {
    personcode?: SortOrder
    sitecode?: SortOrder
    url?: SortOrder
  }

  export type inducks_personurlMinOrderByAggregateInput = {
    personcode?: SortOrder
    sitecode?: SortOrder
    url?: SortOrder
  }

  export type Enuminducks_publication_numbersarefakeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_publication_numbersarefake | Enuminducks_publication_numbersarefakeFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_publication_numbersarefake[] | null
    notIn?: $Enums.inducks_publication_numbersarefake[] | null
    not?: NestedEnuminducks_publication_numbersarefakeNullableFilter<$PrismaModel> | $Enums.inducks_publication_numbersarefake | null
  }

  export type Enuminducks_publication_errorNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_publication_error | Enuminducks_publication_errorFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_publication_error[] | null
    notIn?: $Enums.inducks_publication_error[] | null
    not?: NestedEnuminducks_publication_errorNullableFilter<$PrismaModel> | $Enums.inducks_publication_error | null
  }

  export type Enuminducks_publication_lockedNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_publication_locked | Enuminducks_publication_lockedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_publication_locked[] | null
    notIn?: $Enums.inducks_publication_locked[] | null
    not?: NestedEnuminducks_publication_lockedNullableFilter<$PrismaModel> | $Enums.inducks_publication_locked | null
  }

  export type Enuminducks_publication_inxforbiddenNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_publication_inxforbidden | Enuminducks_publication_inxforbiddenFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_publication_inxforbidden[] | null
    notIn?: $Enums.inducks_publication_inxforbidden[] | null
    not?: NestedEnuminducks_publication_inxforbiddenNullableFilter<$PrismaModel> | $Enums.inducks_publication_inxforbidden | null
  }

  export type inducks_publicationCountOrderByAggregateInput = {
    publicationcode?: SortOrder
    countrycode?: SortOrder
    languagecode?: SortOrder
    title?: SortOrder
    size?: SortOrder
    publicationcomment?: SortOrder
    circulation?: SortOrder
    numbersarefake?: SortOrder
    error?: SortOrder
    locked?: SortOrder
    inxforbidden?: SortOrder
    inputfilecode?: SortOrder
    maintenanceteamcode?: SortOrder
  }

  export type inducks_publicationAvgOrderByAggregateInput = {
    inputfilecode?: SortOrder
  }

  export type inducks_publicationMaxOrderByAggregateInput = {
    publicationcode?: SortOrder
    countrycode?: SortOrder
    languagecode?: SortOrder
    title?: SortOrder
    size?: SortOrder
    publicationcomment?: SortOrder
    circulation?: SortOrder
    numbersarefake?: SortOrder
    error?: SortOrder
    locked?: SortOrder
    inxforbidden?: SortOrder
    inputfilecode?: SortOrder
    maintenanceteamcode?: SortOrder
  }

  export type inducks_publicationMinOrderByAggregateInput = {
    publicationcode?: SortOrder
    countrycode?: SortOrder
    languagecode?: SortOrder
    title?: SortOrder
    size?: SortOrder
    publicationcomment?: SortOrder
    circulation?: SortOrder
    numbersarefake?: SortOrder
    error?: SortOrder
    locked?: SortOrder
    inxforbidden?: SortOrder
    inputfilecode?: SortOrder
    maintenanceteamcode?: SortOrder
  }

  export type inducks_publicationSumOrderByAggregateInput = {
    inputfilecode?: SortOrder
  }

  export type Enuminducks_publication_numbersarefakeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_publication_numbersarefake | Enuminducks_publication_numbersarefakeFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_publication_numbersarefake[] | null
    notIn?: $Enums.inducks_publication_numbersarefake[] | null
    not?: NestedEnuminducks_publication_numbersarefakeNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_publication_numbersarefake | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_publication_numbersarefakeNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_publication_numbersarefakeNullableFilter<$PrismaModel>
  }

  export type Enuminducks_publication_errorNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_publication_error | Enuminducks_publication_errorFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_publication_error[] | null
    notIn?: $Enums.inducks_publication_error[] | null
    not?: NestedEnuminducks_publication_errorNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_publication_error | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_publication_errorNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_publication_errorNullableFilter<$PrismaModel>
  }

  export type Enuminducks_publication_lockedNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_publication_locked | Enuminducks_publication_lockedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_publication_locked[] | null
    notIn?: $Enums.inducks_publication_locked[] | null
    not?: NestedEnuminducks_publication_lockedNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_publication_locked | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_publication_lockedNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_publication_lockedNullableFilter<$PrismaModel>
  }

  export type Enuminducks_publication_inxforbiddenNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_publication_inxforbidden | Enuminducks_publication_inxforbiddenFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_publication_inxforbidden[] | null
    notIn?: $Enums.inducks_publication_inxforbidden[] | null
    not?: NestedEnuminducks_publication_inxforbiddenNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_publication_inxforbidden | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_publication_inxforbiddenNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_publication_inxforbiddenNullableFilter<$PrismaModel>
  }

  export type inducks_publicationcategoryCountOrderByAggregateInput = {
    publicationcode?: SortOrder
    category?: SortOrder
  }

  export type inducks_publicationcategoryMaxOrderByAggregateInput = {
    publicationcode?: SortOrder
    category?: SortOrder
  }

  export type inducks_publicationcategoryMinOrderByAggregateInput = {
    publicationcode?: SortOrder
    category?: SortOrder
  }

  export type inducks_publicationnameCountOrderByAggregateInput = {
    publicationcode?: SortOrder
    publicationname?: SortOrder
  }

  export type inducks_publicationnameMaxOrderByAggregateInput = {
    publicationcode?: SortOrder
    publicationname?: SortOrder
  }

  export type inducks_publicationnameMinOrderByAggregateInput = {
    publicationcode?: SortOrder
    publicationname?: SortOrder
  }

  export type inducks_publicationurlPublicationcodeSitecodeCompoundUniqueInput = {
    publicationcode: string
    sitecode: string
  }

  export type inducks_publicationurlCountOrderByAggregateInput = {
    publicationcode?: SortOrder
    sitecode?: SortOrder
    url?: SortOrder
  }

  export type inducks_publicationurlMaxOrderByAggregateInput = {
    publicationcode?: SortOrder
    sitecode?: SortOrder
    url?: SortOrder
  }

  export type inducks_publicationurlMinOrderByAggregateInput = {
    publicationcode?: SortOrder
    sitecode?: SortOrder
    url?: SortOrder
  }

  export type inducks_publisherCountOrderByAggregateInput = {
    publisherid?: SortOrder
    publishername?: SortOrder
  }

  export type inducks_publisherMaxOrderByAggregateInput = {
    publisherid?: SortOrder
    publishername?: SortOrder
  }

  export type inducks_publisherMinOrderByAggregateInput = {
    publisherid?: SortOrder
    publishername?: SortOrder
  }

  export type inducks_publishingjobPublisheridIssuecodeCompoundUniqueInput = {
    publisherid: string
    issuecode: string
  }

  export type inducks_publishingjobCountOrderByAggregateInput = {
    publisherid?: SortOrder
    issuecode?: SortOrder
    publishingjobcomment?: SortOrder
  }

  export type inducks_publishingjobMaxOrderByAggregateInput = {
    publisherid?: SortOrder
    issuecode?: SortOrder
    publishingjobcomment?: SortOrder
  }

  export type inducks_publishingjobMinOrderByAggregateInput = {
    publisherid?: SortOrder
    issuecode?: SortOrder
    publishingjobcomment?: SortOrder
  }

  export type inducks_referencereasonCountOrderByAggregateInput = {
    referencereasonid?: SortOrder
    referencereasontext?: SortOrder
  }

  export type inducks_referencereasonAvgOrderByAggregateInput = {
    referencereasonid?: SortOrder
  }

  export type inducks_referencereasonMaxOrderByAggregateInput = {
    referencereasonid?: SortOrder
    referencereasontext?: SortOrder
  }

  export type inducks_referencereasonMinOrderByAggregateInput = {
    referencereasonid?: SortOrder
    referencereasontext?: SortOrder
  }

  export type inducks_referencereasonSumOrderByAggregateInput = {
    referencereasonid?: SortOrder
  }

  export type inducks_referencereasonnameReferencereasonidLanguagecodeCompoundUniqueInput = {
    referencereasonid: number
    languagecode: string
  }

  export type inducks_referencereasonnameCountOrderByAggregateInput = {
    referencereasonid?: SortOrder
    languagecode?: SortOrder
    referencereasontranslation?: SortOrder
  }

  export type inducks_referencereasonnameAvgOrderByAggregateInput = {
    referencereasonid?: SortOrder
  }

  export type inducks_referencereasonnameMaxOrderByAggregateInput = {
    referencereasonid?: SortOrder
    languagecode?: SortOrder
    referencereasontranslation?: SortOrder
  }

  export type inducks_referencereasonnameMinOrderByAggregateInput = {
    referencereasonid?: SortOrder
    languagecode?: SortOrder
    referencereasontranslation?: SortOrder
  }

  export type inducks_referencereasonnameSumOrderByAggregateInput = {
    referencereasonid?: SortOrder
  }

  export type Enuminducks_site_imagesNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_site_images | Enuminducks_site_imagesFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_site_images[] | null
    notIn?: $Enums.inducks_site_images[] | null
    not?: NestedEnuminducks_site_imagesNullableFilter<$PrismaModel> | $Enums.inducks_site_images | null
  }

  export type inducks_siteCountOrderByAggregateInput = {
    sitecode?: SortOrder
    urlbase?: SortOrder
    images?: SortOrder
    sitename?: SortOrder
    sitelogo?: SortOrder
    properties?: SortOrder
  }

  export type inducks_siteMaxOrderByAggregateInput = {
    sitecode?: SortOrder
    urlbase?: SortOrder
    images?: SortOrder
    sitename?: SortOrder
    sitelogo?: SortOrder
    properties?: SortOrder
  }

  export type inducks_siteMinOrderByAggregateInput = {
    sitecode?: SortOrder
    urlbase?: SortOrder
    images?: SortOrder
    sitename?: SortOrder
    sitelogo?: SortOrder
    properties?: SortOrder
  }

  export type Enuminducks_site_imagesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_site_images | Enuminducks_site_imagesFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_site_images[] | null
    notIn?: $Enums.inducks_site_images[] | null
    not?: NestedEnuminducks_site_imagesNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_site_images | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_site_imagesNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_site_imagesNullableFilter<$PrismaModel>
  }

  export type inducks_statcharactercharacterCharactercodeTotalCompoundUniqueInput = {
    charactercode: string
    total: number
  }

  export type inducks_statcharactercharacterCountOrderByAggregateInput = {
    charactercode?: SortOrder
    cocharactercode?: SortOrder
    total?: SortOrder
    yearrange?: SortOrder
  }

  export type inducks_statcharactercharacterAvgOrderByAggregateInput = {
    total?: SortOrder
  }

  export type inducks_statcharactercharacterMaxOrderByAggregateInput = {
    charactercode?: SortOrder
    cocharactercode?: SortOrder
    total?: SortOrder
    yearrange?: SortOrder
  }

  export type inducks_statcharactercharacterMinOrderByAggregateInput = {
    charactercode?: SortOrder
    cocharactercode?: SortOrder
    total?: SortOrder
    yearrange?: SortOrder
  }

  export type inducks_statcharactercharacterSumOrderByAggregateInput = {
    total?: SortOrder
  }

  export type inducks_statcharactercountryCharactercodeCountrycodeCompoundUniqueInput = {
    charactercode: string
    countrycode: string
  }

  export type inducks_statcharactercountryCountOrderByAggregateInput = {
    charactercode?: SortOrder
    countrycode?: SortOrder
    total?: SortOrder
  }

  export type inducks_statcharactercountryAvgOrderByAggregateInput = {
    total?: SortOrder
  }

  export type inducks_statcharactercountryMaxOrderByAggregateInput = {
    charactercode?: SortOrder
    countrycode?: SortOrder
    total?: SortOrder
  }

  export type inducks_statcharactercountryMinOrderByAggregateInput = {
    charactercode?: SortOrder
    countrycode?: SortOrder
    total?: SortOrder
  }

  export type inducks_statcharactercountrySumOrderByAggregateInput = {
    total?: SortOrder
  }

  export type inducks_statcharacterstoryCharactercodeStoryheadercodeCompoundUniqueInput = {
    charactercode: string
    storyheadercode: string
  }

  export type inducks_statcharacterstoryCountOrderByAggregateInput = {
    charactercode?: SortOrder
    storyheadercode?: SortOrder
    total?: SortOrder
    yearrange?: SortOrder
  }

  export type inducks_statcharacterstoryAvgOrderByAggregateInput = {
    total?: SortOrder
  }

  export type inducks_statcharacterstoryMaxOrderByAggregateInput = {
    charactercode?: SortOrder
    storyheadercode?: SortOrder
    total?: SortOrder
    yearrange?: SortOrder
  }

  export type inducks_statcharacterstoryMinOrderByAggregateInput = {
    charactercode?: SortOrder
    storyheadercode?: SortOrder
    total?: SortOrder
    yearrange?: SortOrder
  }

  export type inducks_statcharacterstorySumOrderByAggregateInput = {
    total?: SortOrder
  }

  export type inducks_statpersoncharacterPersoncodeTotalCompoundUniqueInput = {
    personcode: string
    total: number
  }

  export type inducks_statpersoncharacterCountOrderByAggregateInput = {
    personcode?: SortOrder
    charactercode?: SortOrder
    total?: SortOrder
    yearrange?: SortOrder
  }

  export type inducks_statpersoncharacterAvgOrderByAggregateInput = {
    total?: SortOrder
  }

  export type inducks_statpersoncharacterMaxOrderByAggregateInput = {
    personcode?: SortOrder
    charactercode?: SortOrder
    total?: SortOrder
    yearrange?: SortOrder
  }

  export type inducks_statpersoncharacterMinOrderByAggregateInput = {
    personcode?: SortOrder
    charactercode?: SortOrder
    total?: SortOrder
    yearrange?: SortOrder
  }

  export type inducks_statpersoncharacterSumOrderByAggregateInput = {
    total?: SortOrder
  }

  export type inducks_statpersoncountryPersoncodeCountrycodeCompoundUniqueInput = {
    personcode: string
    countrycode: string
  }

  export type inducks_statpersoncountryCountOrderByAggregateInput = {
    personcode?: SortOrder
    countrycode?: SortOrder
    total?: SortOrder
  }

  export type inducks_statpersoncountryAvgOrderByAggregateInput = {
    total?: SortOrder
  }

  export type inducks_statpersoncountryMaxOrderByAggregateInput = {
    personcode?: SortOrder
    countrycode?: SortOrder
    total?: SortOrder
  }

  export type inducks_statpersoncountryMinOrderByAggregateInput = {
    personcode?: SortOrder
    countrycode?: SortOrder
    total?: SortOrder
  }

  export type inducks_statpersoncountrySumOrderByAggregateInput = {
    total?: SortOrder
  }

  export type inducks_statpersonpersonPersoncodeTotalCompoundUniqueInput = {
    personcode: string
    total: number
  }

  export type inducks_statpersonpersonCountOrderByAggregateInput = {
    personcode?: SortOrder
    copersoncode?: SortOrder
    total?: SortOrder
    yearrange?: SortOrder
  }

  export type inducks_statpersonpersonAvgOrderByAggregateInput = {
    total?: SortOrder
  }

  export type inducks_statpersonpersonMaxOrderByAggregateInput = {
    personcode?: SortOrder
    copersoncode?: SortOrder
    total?: SortOrder
    yearrange?: SortOrder
  }

  export type inducks_statpersonpersonMinOrderByAggregateInput = {
    personcode?: SortOrder
    copersoncode?: SortOrder
    total?: SortOrder
    yearrange?: SortOrder
  }

  export type inducks_statpersonpersonSumOrderByAggregateInput = {
    total?: SortOrder
  }

  export type inducks_statpersonstoryPersoncodeStoryheadercodeCompoundUniqueInput = {
    personcode: string
    storyheadercode: string
  }

  export type inducks_statpersonstoryCountOrderByAggregateInput = {
    personcode?: SortOrder
    storyheadercode?: SortOrder
    total?: SortOrder
    yearrange?: SortOrder
  }

  export type inducks_statpersonstoryAvgOrderByAggregateInput = {
    total?: SortOrder
  }

  export type inducks_statpersonstoryMaxOrderByAggregateInput = {
    personcode?: SortOrder
    storyheadercode?: SortOrder
    total?: SortOrder
    yearrange?: SortOrder
  }

  export type inducks_statpersonstoryMinOrderByAggregateInput = {
    personcode?: SortOrder
    storyheadercode?: SortOrder
    total?: SortOrder
    yearrange?: SortOrder
  }

  export type inducks_statpersonstorySumOrderByAggregateInput = {
    total?: SortOrder
  }

  export type Enuminducks_story_errorNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_story_error | Enuminducks_story_errorFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_story_error[] | null
    notIn?: $Enums.inducks_story_error[] | null
    not?: NestedEnuminducks_story_errorNullableFilter<$PrismaModel> | $Enums.inducks_story_error | null
  }

  export type Enuminducks_story_lockedNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_story_locked | Enuminducks_story_lockedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_story_locked[] | null
    notIn?: $Enums.inducks_story_locked[] | null
    not?: NestedEnuminducks_story_lockedNullableFilter<$PrismaModel> | $Enums.inducks_story_locked | null
  }

  export type inducks_storyCountOrderByAggregateInput = {
    storycode?: SortOrder
    originalstoryversioncode?: SortOrder
    creationdate?: SortOrder
    firstpublicationdate?: SortOrder
    endpublicationdate?: SortOrder
    title?: SortOrder
    usedifferentcode?: SortOrder
    storycomment?: SortOrder
    error?: SortOrder
    repcountrysummary?: SortOrder
    storyparts?: SortOrder
    locked?: SortOrder
    inputfilecode?: SortOrder
    issuecodeofstoryitem?: SortOrder
    maintenanceteamcode?: SortOrder
    storyheadercode?: SortOrder
  }

  export type inducks_storyAvgOrderByAggregateInput = {
    storyparts?: SortOrder
    inputfilecode?: SortOrder
  }

  export type inducks_storyMaxOrderByAggregateInput = {
    storycode?: SortOrder
    originalstoryversioncode?: SortOrder
    creationdate?: SortOrder
    firstpublicationdate?: SortOrder
    endpublicationdate?: SortOrder
    title?: SortOrder
    usedifferentcode?: SortOrder
    storycomment?: SortOrder
    error?: SortOrder
    repcountrysummary?: SortOrder
    storyparts?: SortOrder
    locked?: SortOrder
    inputfilecode?: SortOrder
    issuecodeofstoryitem?: SortOrder
    maintenanceteamcode?: SortOrder
    storyheadercode?: SortOrder
  }

  export type inducks_storyMinOrderByAggregateInput = {
    storycode?: SortOrder
    originalstoryversioncode?: SortOrder
    creationdate?: SortOrder
    firstpublicationdate?: SortOrder
    endpublicationdate?: SortOrder
    title?: SortOrder
    usedifferentcode?: SortOrder
    storycomment?: SortOrder
    error?: SortOrder
    repcountrysummary?: SortOrder
    storyparts?: SortOrder
    locked?: SortOrder
    inputfilecode?: SortOrder
    issuecodeofstoryitem?: SortOrder
    maintenanceteamcode?: SortOrder
    storyheadercode?: SortOrder
  }

  export type inducks_storySumOrderByAggregateInput = {
    storyparts?: SortOrder
    inputfilecode?: SortOrder
  }

  export type Enuminducks_story_errorNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_story_error | Enuminducks_story_errorFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_story_error[] | null
    notIn?: $Enums.inducks_story_error[] | null
    not?: NestedEnuminducks_story_errorNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_story_error | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_story_errorNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_story_errorNullableFilter<$PrismaModel>
  }

  export type Enuminducks_story_lockedNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_story_locked | Enuminducks_story_lockedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_story_locked[] | null
    notIn?: $Enums.inducks_story_locked[] | null
    not?: NestedEnuminducks_story_lockedNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_story_locked | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_story_lockedNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_story_lockedNullableFilter<$PrismaModel>
  }

  export type inducks_storycodesStorycodeAlternativecodeCompoundUniqueInput = {
    storycode: string
    alternativecode: string
  }

  export type inducks_storycodesCountOrderByAggregateInput = {
    storycode?: SortOrder
    alternativecode?: SortOrder
    unpackedcode?: SortOrder
    codecomment?: SortOrder
  }

  export type inducks_storycodesMaxOrderByAggregateInput = {
    storycode?: SortOrder
    alternativecode?: SortOrder
    unpackedcode?: SortOrder
    codecomment?: SortOrder
  }

  export type inducks_storycodesMinOrderByAggregateInput = {
    storycode?: SortOrder
    alternativecode?: SortOrder
    unpackedcode?: SortOrder
    codecomment?: SortOrder
  }

  export type inducks_storydescriptionStoryversioncodeLanguagecodeCompoundUniqueInput = {
    storyversioncode: string
    languagecode: string
  }

  export type inducks_storydescriptionCountOrderByAggregateInput = {
    storyversioncode?: SortOrder
    languagecode?: SortOrder
    desctext?: SortOrder
  }

  export type inducks_storydescriptionMaxOrderByAggregateInput = {
    storyversioncode?: SortOrder
    languagecode?: SortOrder
    desctext?: SortOrder
  }

  export type inducks_storydescriptionMinOrderByAggregateInput = {
    storyversioncode?: SortOrder
    languagecode?: SortOrder
    desctext?: SortOrder
  }

  export type inducks_storyheaderStoryheadercodeLevelCompoundUniqueInput = {
    storyheadercode: string
    level: string
  }

  export type inducks_storyheaderCountOrderByAggregateInput = {
    storyheadercode?: SortOrder
    level?: SortOrder
    title?: SortOrder
    storyheadercomment?: SortOrder
    countrycode?: SortOrder
  }

  export type inducks_storyheaderMaxOrderByAggregateInput = {
    storyheadercode?: SortOrder
    level?: SortOrder
    title?: SortOrder
    storyheadercomment?: SortOrder
    countrycode?: SortOrder
  }

  export type inducks_storyheaderMinOrderByAggregateInput = {
    storyheadercode?: SortOrder
    level?: SortOrder
    title?: SortOrder
    storyheadercomment?: SortOrder
    countrycode?: SortOrder
  }

  export type Enuminducks_storyjob_indirectNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_storyjob_indirect | Enuminducks_storyjob_indirectFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_storyjob_indirect[] | null
    notIn?: $Enums.inducks_storyjob_indirect[] | null
    not?: NestedEnuminducks_storyjob_indirectNullableFilter<$PrismaModel> | $Enums.inducks_storyjob_indirect | null
  }

  export type Enuminducks_storyjob_doubtNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_storyjob_doubt | Enuminducks_storyjob_doubtFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_storyjob_doubt[] | null
    notIn?: $Enums.inducks_storyjob_doubt[] | null
    not?: NestedEnuminducks_storyjob_doubtNullableFilter<$PrismaModel> | $Enums.inducks_storyjob_doubt | null
  }

  export type inducks_storyjobStoryversioncodePersoncodePlotwritartinkCompoundUniqueInput = {
    storyversioncode: string
    personcode: string
    plotwritartink: string
  }

  export type inducks_storyjobCountOrderByAggregateInput = {
    storyversioncode?: SortOrder
    personcode?: SortOrder
    plotwritartink?: SortOrder
    storyjobcomment?: SortOrder
    indirect?: SortOrder
    doubt?: SortOrder
  }

  export type inducks_storyjobMaxOrderByAggregateInput = {
    storyversioncode?: SortOrder
    personcode?: SortOrder
    plotwritartink?: SortOrder
    storyjobcomment?: SortOrder
    indirect?: SortOrder
    doubt?: SortOrder
  }

  export type inducks_storyjobMinOrderByAggregateInput = {
    storyversioncode?: SortOrder
    personcode?: SortOrder
    plotwritartink?: SortOrder
    storyjobcomment?: SortOrder
    indirect?: SortOrder
    doubt?: SortOrder
  }

  export type Enuminducks_storyjob_indirectNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_storyjob_indirect | Enuminducks_storyjob_indirectFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_storyjob_indirect[] | null
    notIn?: $Enums.inducks_storyjob_indirect[] | null
    not?: NestedEnuminducks_storyjob_indirectNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_storyjob_indirect | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_storyjob_indirectNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_storyjob_indirectNullableFilter<$PrismaModel>
  }

  export type Enuminducks_storyjob_doubtNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_storyjob_doubt | Enuminducks_storyjob_doubtFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_storyjob_doubt[] | null
    notIn?: $Enums.inducks_storyjob_doubt[] | null
    not?: NestedEnuminducks_storyjob_doubtNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_storyjob_doubt | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_storyjob_doubtNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_storyjob_doubtNullableFilter<$PrismaModel>
  }

  export type inducks_storyreferenceFromstorycodeTostorycodeCompoundUniqueInput = {
    fromstorycode: string
    tostorycode: string
  }

  export type inducks_storyreferenceCountOrderByAggregateInput = {
    fromstorycode?: SortOrder
    tostorycode?: SortOrder
    referencereasonid?: SortOrder
  }

  export type inducks_storyreferenceAvgOrderByAggregateInput = {
    referencereasonid?: SortOrder
  }

  export type inducks_storyreferenceMaxOrderByAggregateInput = {
    fromstorycode?: SortOrder
    tostorycode?: SortOrder
    referencereasonid?: SortOrder
  }

  export type inducks_storyreferenceMinOrderByAggregateInput = {
    fromstorycode?: SortOrder
    tostorycode?: SortOrder
    referencereasonid?: SortOrder
  }

  export type inducks_storyreferenceSumOrderByAggregateInput = {
    referencereasonid?: SortOrder
  }

  export type inducks_storysubseriesStorycodeSubseriescodeCompoundUniqueInput = {
    storycode: string
    subseriescode: string
  }

  export type inducks_storysubseriesCountOrderByAggregateInput = {
    storycode?: SortOrder
    subseriescode?: SortOrder
    storysubseriescomment?: SortOrder
  }

  export type inducks_storysubseriesMaxOrderByAggregateInput = {
    storycode?: SortOrder
    subseriescode?: SortOrder
    storysubseriescomment?: SortOrder
  }

  export type inducks_storysubseriesMinOrderByAggregateInput = {
    storycode?: SortOrder
    subseriescode?: SortOrder
    storysubseriescomment?: SortOrder
  }

  export type inducks_storyurlStorycodeSitecodeCompoundUniqueInput = {
    storycode: string
    sitecode: string
  }

  export type inducks_storyurlCountOrderByAggregateInput = {
    storycode?: SortOrder
    sitecode?: SortOrder
    url?: SortOrder
  }

  export type inducks_storyurlMaxOrderByAggregateInput = {
    storycode?: SortOrder
    sitecode?: SortOrder
    url?: SortOrder
  }

  export type inducks_storyurlMinOrderByAggregateInput = {
    storycode?: SortOrder
    sitecode?: SortOrder
    url?: SortOrder
  }

  export type Enuminducks_storyversion_brokenpageunspecifiedNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_storyversion_brokenpageunspecified | Enuminducks_storyversion_brokenpageunspecifiedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_storyversion_brokenpageunspecified[] | null
    notIn?: $Enums.inducks_storyversion_brokenpageunspecified[] | null
    not?: NestedEnuminducks_storyversion_brokenpageunspecifiedNullableFilter<$PrismaModel> | $Enums.inducks_storyversion_brokenpageunspecified | null
  }

  export type Enuminducks_storyversion_appisxappNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_storyversion_appisxapp | Enuminducks_storyversion_appisxappFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_storyversion_appisxapp[] | null
    notIn?: $Enums.inducks_storyversion_appisxapp[] | null
    not?: NestedEnuminducks_storyversion_appisxappNullableFilter<$PrismaModel> | $Enums.inducks_storyversion_appisxapp | null
  }

  export type inducks_storyversionCountOrderByAggregateInput = {
    storyversioncode?: SortOrder
    storycode?: SortOrder
    entirepages?: SortOrder
    brokenpagenumerator?: SortOrder
    brokenpagedenominator?: SortOrder
    brokenpageunspecified?: SortOrder
    kind?: SortOrder
    rowsperpage?: SortOrder
    columnsperpage?: SortOrder
    appisxapp?: SortOrder
    what?: SortOrder
    appsummary?: SortOrder
    plotsummary?: SortOrder
    writsummary?: SortOrder
    artsummary?: SortOrder
    inksummary?: SortOrder
    creatorrefsummary?: SortOrder
    keywordsummary?: SortOrder
    estimatedpanels?: SortOrder
  }

  export type inducks_storyversionAvgOrderByAggregateInput = {
    entirepages?: SortOrder
    brokenpagenumerator?: SortOrder
    brokenpagedenominator?: SortOrder
    rowsperpage?: SortOrder
    columnsperpage?: SortOrder
    estimatedpanels?: SortOrder
  }

  export type inducks_storyversionMaxOrderByAggregateInput = {
    storyversioncode?: SortOrder
    storycode?: SortOrder
    entirepages?: SortOrder
    brokenpagenumerator?: SortOrder
    brokenpagedenominator?: SortOrder
    brokenpageunspecified?: SortOrder
    kind?: SortOrder
    rowsperpage?: SortOrder
    columnsperpage?: SortOrder
    appisxapp?: SortOrder
    what?: SortOrder
    appsummary?: SortOrder
    plotsummary?: SortOrder
    writsummary?: SortOrder
    artsummary?: SortOrder
    inksummary?: SortOrder
    creatorrefsummary?: SortOrder
    keywordsummary?: SortOrder
    estimatedpanels?: SortOrder
  }

  export type inducks_storyversionMinOrderByAggregateInput = {
    storyversioncode?: SortOrder
    storycode?: SortOrder
    entirepages?: SortOrder
    brokenpagenumerator?: SortOrder
    brokenpagedenominator?: SortOrder
    brokenpageunspecified?: SortOrder
    kind?: SortOrder
    rowsperpage?: SortOrder
    columnsperpage?: SortOrder
    appisxapp?: SortOrder
    what?: SortOrder
    appsummary?: SortOrder
    plotsummary?: SortOrder
    writsummary?: SortOrder
    artsummary?: SortOrder
    inksummary?: SortOrder
    creatorrefsummary?: SortOrder
    keywordsummary?: SortOrder
    estimatedpanels?: SortOrder
  }

  export type inducks_storyversionSumOrderByAggregateInput = {
    entirepages?: SortOrder
    brokenpagenumerator?: SortOrder
    brokenpagedenominator?: SortOrder
    rowsperpage?: SortOrder
    columnsperpage?: SortOrder
    estimatedpanels?: SortOrder
  }

  export type Enuminducks_storyversion_brokenpageunspecifiedNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_storyversion_brokenpageunspecified | Enuminducks_storyversion_brokenpageunspecifiedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_storyversion_brokenpageunspecified[] | null
    notIn?: $Enums.inducks_storyversion_brokenpageunspecified[] | null
    not?: NestedEnuminducks_storyversion_brokenpageunspecifiedNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_storyversion_brokenpageunspecified | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_storyversion_brokenpageunspecifiedNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_storyversion_brokenpageunspecifiedNullableFilter<$PrismaModel>
  }

  export type Enuminducks_storyversion_appisxappNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_storyversion_appisxapp | Enuminducks_storyversion_appisxappFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_storyversion_appisxapp[] | null
    notIn?: $Enums.inducks_storyversion_appisxapp[] | null
    not?: NestedEnuminducks_storyversion_appisxappNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_storyversion_appisxapp | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_storyversion_appisxappNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_storyversion_appisxappNullableFilter<$PrismaModel>
  }

  export type Enuminducks_storyversion_nofulltext_brokenpageunspecifiedNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_storyversion_nofulltext_brokenpageunspecified | Enuminducks_storyversion_nofulltext_brokenpageunspecifiedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_storyversion_nofulltext_brokenpageunspecified[] | null
    notIn?: $Enums.inducks_storyversion_nofulltext_brokenpageunspecified[] | null
    not?: NestedEnuminducks_storyversion_nofulltext_brokenpageunspecifiedNullableFilter<$PrismaModel> | $Enums.inducks_storyversion_nofulltext_brokenpageunspecified | null
  }

  export type Enuminducks_storyversion_nofulltext_appisxappNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_storyversion_nofulltext_appisxapp | Enuminducks_storyversion_nofulltext_appisxappFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_storyversion_nofulltext_appisxapp[] | null
    notIn?: $Enums.inducks_storyversion_nofulltext_appisxapp[] | null
    not?: NestedEnuminducks_storyversion_nofulltext_appisxappNullableFilter<$PrismaModel> | $Enums.inducks_storyversion_nofulltext_appisxapp | null
  }

  export type inducks_storyversion_nofulltextCountOrderByAggregateInput = {
    storyversioncode?: SortOrder
    storycode?: SortOrder
    entirepages?: SortOrder
    brokenpagenumerator?: SortOrder
    brokenpagedenominator?: SortOrder
    brokenpageunspecified?: SortOrder
    kind?: SortOrder
    rowsperpage?: SortOrder
    columnsperpage?: SortOrder
    appisxapp?: SortOrder
    what?: SortOrder
    appsummary?: SortOrder
    plotsummary?: SortOrder
    writsummary?: SortOrder
    artsummary?: SortOrder
    inksummary?: SortOrder
    creatorrefsummary?: SortOrder
    keywordsummary?: SortOrder
    estimatedpanels?: SortOrder
  }

  export type inducks_storyversion_nofulltextAvgOrderByAggregateInput = {
    entirepages?: SortOrder
    brokenpagenumerator?: SortOrder
    brokenpagedenominator?: SortOrder
    rowsperpage?: SortOrder
    columnsperpage?: SortOrder
    estimatedpanels?: SortOrder
  }

  export type inducks_storyversion_nofulltextMaxOrderByAggregateInput = {
    storyversioncode?: SortOrder
    storycode?: SortOrder
    entirepages?: SortOrder
    brokenpagenumerator?: SortOrder
    brokenpagedenominator?: SortOrder
    brokenpageunspecified?: SortOrder
    kind?: SortOrder
    rowsperpage?: SortOrder
    columnsperpage?: SortOrder
    appisxapp?: SortOrder
    what?: SortOrder
    appsummary?: SortOrder
    plotsummary?: SortOrder
    writsummary?: SortOrder
    artsummary?: SortOrder
    inksummary?: SortOrder
    creatorrefsummary?: SortOrder
    keywordsummary?: SortOrder
    estimatedpanels?: SortOrder
  }

  export type inducks_storyversion_nofulltextMinOrderByAggregateInput = {
    storyversioncode?: SortOrder
    storycode?: SortOrder
    entirepages?: SortOrder
    brokenpagenumerator?: SortOrder
    brokenpagedenominator?: SortOrder
    brokenpageunspecified?: SortOrder
    kind?: SortOrder
    rowsperpage?: SortOrder
    columnsperpage?: SortOrder
    appisxapp?: SortOrder
    what?: SortOrder
    appsummary?: SortOrder
    plotsummary?: SortOrder
    writsummary?: SortOrder
    artsummary?: SortOrder
    inksummary?: SortOrder
    creatorrefsummary?: SortOrder
    keywordsummary?: SortOrder
    estimatedpanels?: SortOrder
  }

  export type inducks_storyversion_nofulltextSumOrderByAggregateInput = {
    entirepages?: SortOrder
    brokenpagenumerator?: SortOrder
    brokenpagedenominator?: SortOrder
    rowsperpage?: SortOrder
    columnsperpage?: SortOrder
    estimatedpanels?: SortOrder
  }

  export type Enuminducks_storyversion_nofulltext_brokenpageunspecifiedNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_storyversion_nofulltext_brokenpageunspecified | Enuminducks_storyversion_nofulltext_brokenpageunspecifiedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_storyversion_nofulltext_brokenpageunspecified[] | null
    notIn?: $Enums.inducks_storyversion_nofulltext_brokenpageunspecified[] | null
    not?: NestedEnuminducks_storyversion_nofulltext_brokenpageunspecifiedNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_storyversion_nofulltext_brokenpageunspecified | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_storyversion_nofulltext_brokenpageunspecifiedNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_storyversion_nofulltext_brokenpageunspecifiedNullableFilter<$PrismaModel>
  }

  export type Enuminducks_storyversion_nofulltext_appisxappNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_storyversion_nofulltext_appisxapp | Enuminducks_storyversion_nofulltext_appisxappFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_storyversion_nofulltext_appisxapp[] | null
    notIn?: $Enums.inducks_storyversion_nofulltext_appisxapp[] | null
    not?: NestedEnuminducks_storyversion_nofulltext_appisxappNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_storyversion_nofulltext_appisxapp | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_storyversion_nofulltext_appisxappNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_storyversion_nofulltext_appisxappNullableFilter<$PrismaModel>
  }

  export type inducks_studioCountOrderByAggregateInput = {
    studiocode?: SortOrder
    countrycode?: SortOrder
    studioname?: SortOrder
    city?: SortOrder
    description?: SortOrder
    othertext?: SortOrder
    photofilename?: SortOrder
    photocomment?: SortOrder
    photosource?: SortOrder
    studiorefs?: SortOrder
  }

  export type inducks_studioMaxOrderByAggregateInput = {
    studiocode?: SortOrder
    countrycode?: SortOrder
    studioname?: SortOrder
    city?: SortOrder
    description?: SortOrder
    othertext?: SortOrder
    photofilename?: SortOrder
    photocomment?: SortOrder
    photosource?: SortOrder
    studiorefs?: SortOrder
  }

  export type inducks_studioMinOrderByAggregateInput = {
    studiocode?: SortOrder
    countrycode?: SortOrder
    studioname?: SortOrder
    city?: SortOrder
    description?: SortOrder
    othertext?: SortOrder
    photofilename?: SortOrder
    photocomment?: SortOrder
    photosource?: SortOrder
    studiorefs?: SortOrder
  }

  export type inducks_studioworkStudiocodePersoncodeCompoundUniqueInput = {
    studiocode: string
    personcode: string
  }

  export type inducks_studioworkCountOrderByAggregateInput = {
    studiocode?: SortOrder
    personcode?: SortOrder
  }

  export type inducks_studioworkMaxOrderByAggregateInput = {
    studiocode?: SortOrder
    personcode?: SortOrder
  }

  export type inducks_studioworkMinOrderByAggregateInput = {
    studiocode?: SortOrder
    personcode?: SortOrder
  }

  export type Enuminducks_subseries_officialNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_subseries_official | Enuminducks_subseries_officialFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_subseries_official[] | null
    notIn?: $Enums.inducks_subseries_official[] | null
    not?: NestedEnuminducks_subseries_officialNullableFilter<$PrismaModel> | $Enums.inducks_subseries_official | null
  }

  export type inducks_subseriesCountOrderByAggregateInput = {
    subseriescode?: SortOrder
    subseriesname?: SortOrder
    official?: SortOrder
    subseriescomment?: SortOrder
    subseriescategory?: SortOrder
  }

  export type inducks_subseriesMaxOrderByAggregateInput = {
    subseriescode?: SortOrder
    subseriesname?: SortOrder
    official?: SortOrder
    subseriescomment?: SortOrder
    subseriescategory?: SortOrder
  }

  export type inducks_subseriesMinOrderByAggregateInput = {
    subseriescode?: SortOrder
    subseriesname?: SortOrder
    official?: SortOrder
    subseriescomment?: SortOrder
    subseriescategory?: SortOrder
  }

  export type Enuminducks_subseries_officialNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_subseries_official | Enuminducks_subseries_officialFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_subseries_official[] | null
    notIn?: $Enums.inducks_subseries_official[] | null
    not?: NestedEnuminducks_subseries_officialNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_subseries_official | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_subseries_officialNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_subseries_officialNullableFilter<$PrismaModel>
  }

  export type Enuminducks_subseriesname_preferredNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_subseriesname_preferred | Enuminducks_subseriesname_preferredFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_subseriesname_preferred[] | null
    notIn?: $Enums.inducks_subseriesname_preferred[] | null
    not?: NestedEnuminducks_subseriesname_preferredNullableFilter<$PrismaModel> | $Enums.inducks_subseriesname_preferred | null
  }

  export type inducks_subseriesnameSubseriescodeLanguagecodeCompoundUniqueInput = {
    subseriescode: string
    languagecode: string
  }

  export type inducks_subseriesnameCountOrderByAggregateInput = {
    subseriescode?: SortOrder
    languagecode?: SortOrder
    subseriesname?: SortOrder
    preferred?: SortOrder
    subseriesnamecomment?: SortOrder
  }

  export type inducks_subseriesnameMaxOrderByAggregateInput = {
    subseriescode?: SortOrder
    languagecode?: SortOrder
    subseriesname?: SortOrder
    preferred?: SortOrder
    subseriesnamecomment?: SortOrder
  }

  export type inducks_subseriesnameMinOrderByAggregateInput = {
    subseriescode?: SortOrder
    languagecode?: SortOrder
    subseriesname?: SortOrder
    preferred?: SortOrder
    subseriesnamecomment?: SortOrder
  }

  export type Enuminducks_subseriesname_preferredNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_subseriesname_preferred | Enuminducks_subseriesname_preferredFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_subseriesname_preferred[] | null
    notIn?: $Enums.inducks_subseriesname_preferred[] | null
    not?: NestedEnuminducks_subseriesname_preferredNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_subseriesname_preferred | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_subseriesname_preferredNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_subseriesname_preferredNullableFilter<$PrismaModel>
  }

  export type Enuminducks_substory_errorNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_substory_error | Enuminducks_substory_errorFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_substory_error[] | null
    notIn?: $Enums.inducks_substory_error[] | null
    not?: NestedEnuminducks_substory_errorNullableFilter<$PrismaModel> | $Enums.inducks_substory_error | null
  }

  export type Enuminducks_substory_lockedNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_substory_locked | Enuminducks_substory_lockedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_substory_locked[] | null
    notIn?: $Enums.inducks_substory_locked[] | null
    not?: NestedEnuminducks_substory_lockedNullableFilter<$PrismaModel> | $Enums.inducks_substory_locked | null
  }

  export type inducks_substoryCountOrderByAggregateInput = {
    storycode?: SortOrder
    originalstoryversioncode?: SortOrder
    superstorycode?: SortOrder
    part?: SortOrder
    firstpublicationdate?: SortOrder
    title?: SortOrder
    substorycomment?: SortOrder
    error?: SortOrder
    locked?: SortOrder
    inputfilecode?: SortOrder
    maintenanceteamcode?: SortOrder
  }

  export type inducks_substoryAvgOrderByAggregateInput = {
    inputfilecode?: SortOrder
  }

  export type inducks_substoryMaxOrderByAggregateInput = {
    storycode?: SortOrder
    originalstoryversioncode?: SortOrder
    superstorycode?: SortOrder
    part?: SortOrder
    firstpublicationdate?: SortOrder
    title?: SortOrder
    substorycomment?: SortOrder
    error?: SortOrder
    locked?: SortOrder
    inputfilecode?: SortOrder
    maintenanceteamcode?: SortOrder
  }

  export type inducks_substoryMinOrderByAggregateInput = {
    storycode?: SortOrder
    originalstoryversioncode?: SortOrder
    superstorycode?: SortOrder
    part?: SortOrder
    firstpublicationdate?: SortOrder
    title?: SortOrder
    substorycomment?: SortOrder
    error?: SortOrder
    locked?: SortOrder
    inputfilecode?: SortOrder
    maintenanceteamcode?: SortOrder
  }

  export type inducks_substorySumOrderByAggregateInput = {
    inputfilecode?: SortOrder
  }

  export type Enuminducks_substory_errorNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_substory_error | Enuminducks_substory_errorFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_substory_error[] | null
    notIn?: $Enums.inducks_substory_error[] | null
    not?: NestedEnuminducks_substory_errorNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_substory_error | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_substory_errorNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_substory_errorNullableFilter<$PrismaModel>
  }

  export type Enuminducks_substory_lockedNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_substory_locked | Enuminducks_substory_lockedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_substory_locked[] | null
    notIn?: $Enums.inducks_substory_locked[] | null
    not?: NestedEnuminducks_substory_lockedNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_substory_locked | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_substory_lockedNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_substory_lockedNullableFilter<$PrismaModel>
  }

  export type inducks_teamCountOrderByAggregateInput = {
    teamcode?: SortOrder
    teamdescriptionname?: SortOrder
    teamshortname?: SortOrder
  }

  export type inducks_teamMaxOrderByAggregateInput = {
    teamcode?: SortOrder
    teamdescriptionname?: SortOrder
    teamshortname?: SortOrder
  }

  export type inducks_teamMinOrderByAggregateInput = {
    teamcode?: SortOrder
    teamdescriptionname?: SortOrder
    teamshortname?: SortOrder
  }

  export type inducks_teammemberCountOrderByAggregateInput = {
    teamcode?: SortOrder
    personcode?: SortOrder
  }

  export type inducks_teammemberMaxOrderByAggregateInput = {
    teamcode?: SortOrder
    personcode?: SortOrder
  }

  export type inducks_teammemberMinOrderByAggregateInput = {
    teamcode?: SortOrder
    personcode?: SortOrder
  }

  export type inducks_ucrelationUniversecodeCharactercodeCompoundUniqueInput = {
    universecode: string
    charactercode: string
  }

  export type inducks_ucrelationCountOrderByAggregateInput = {
    universecode?: SortOrder
    charactercode?: SortOrder
  }

  export type inducks_ucrelationMaxOrderByAggregateInput = {
    universecode?: SortOrder
    charactercode?: SortOrder
  }

  export type inducks_ucrelationMinOrderByAggregateInput = {
    universecode?: SortOrder
    charactercode?: SortOrder
  }

  export type inducks_universeCountOrderByAggregateInput = {
    universecode?: SortOrder
    universecomment?: SortOrder
  }

  export type inducks_universeMaxOrderByAggregateInput = {
    universecode?: SortOrder
    universecomment?: SortOrder
  }

  export type inducks_universeMinOrderByAggregateInput = {
    universecode?: SortOrder
    universecomment?: SortOrder
  }

  export type inducks_universenameUniversecodeLanguagecodeCompoundUniqueInput = {
    universecode: string
    languagecode: string
  }

  export type inducks_universenameCountOrderByAggregateInput = {
    universecode?: SortOrder
    languagecode?: SortOrder
    universename?: SortOrder
  }

  export type inducks_universenameMaxOrderByAggregateInput = {
    universecode?: SortOrder
    languagecode?: SortOrder
    universename?: SortOrder
  }

  export type inducks_universenameMinOrderByAggregateInput = {
    universecode?: SortOrder
    languagecode?: SortOrder
    universename?: SortOrder
  }

  export type numeros_cptPublicationcodeNumeroCompoundUniqueInput = {
    publicationcode: string
    Numero: string
  }

  export type numeros_cptCountOrderByAggregateInput = {
    Pays?: SortOrder
    Magazine?: SortOrder
    publicationcode?: SortOrder
    Numero?: SortOrder
    Cpt?: SortOrder
  }

  export type numeros_cptAvgOrderByAggregateInput = {
    Cpt?: SortOrder
  }

  export type numeros_cptMaxOrderByAggregateInput = {
    Pays?: SortOrder
    Magazine?: SortOrder
    publicationcode?: SortOrder
    Numero?: SortOrder
    Cpt?: SortOrder
  }

  export type numeros_cptMinOrderByAggregateInput = {
    Pays?: SortOrder
    Magazine?: SortOrder
    publicationcode?: SortOrder
    Numero?: SortOrder
    Cpt?: SortOrder
  }

  export type numeros_cptSumOrderByAggregateInput = {
    Cpt?: SortOrder
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableEnuminducks_appearance_doubtFieldUpdateOperationsInput = {
    set?: $Enums.inducks_appearance_doubt | null
  }

  export type NullableEnuminducks_character_officialFieldUpdateOperationsInput = {
    set?: $Enums.inducks_character_official | null
  }

  export type NullableEnuminducks_character_onetimeFieldUpdateOperationsInput = {
    set?: $Enums.inducks_character_onetime | null
  }

  export type NullableEnuminducks_character_heroonlyFieldUpdateOperationsInput = {
    set?: $Enums.inducks_character_heroonly | null
  }

  export type NullableEnuminducks_charactername_preferredFieldUpdateOperationsInput = {
    set?: $Enums.inducks_charactername_preferred | null
  }

  export type NullableEnuminducks_characterreference_isgroupofcharactersFieldUpdateOperationsInput = {
    set?: $Enums.inducks_characterreference_isgroupofcharacters | null
  }

  export type NullableEnuminducks_entry_reallytitleFieldUpdateOperationsInput = {
    set?: $Enums.inducks_entry_reallytitle | null
  }

  export type NullableEnuminducks_entry_mirroredFieldUpdateOperationsInput = {
    set?: $Enums.inducks_entry_mirrored | null
  }

  export type NullableEnuminducks_entry_sidewaysFieldUpdateOperationsInput = {
    set?: $Enums.inducks_entry_sideways | null
  }

  export type NullableEnuminducks_entry_identificationuncertainFieldUpdateOperationsInput = {
    set?: $Enums.inducks_entry_identificationuncertain | null
  }

  export type NullableEnuminducks_entry_errorFieldUpdateOperationsInput = {
    set?: $Enums.inducks_entry_error | null
  }

  export type NullableEnuminducks_entry_nofulltext_reallytitleFieldUpdateOperationsInput = {
    set?: $Enums.inducks_entry_nofulltext_reallytitle | null
  }

  export type NullableEnuminducks_entry_nofulltext_mirroredFieldUpdateOperationsInput = {
    set?: $Enums.inducks_entry_nofulltext_mirrored | null
  }

  export type NullableEnuminducks_entry_nofulltext_sidewaysFieldUpdateOperationsInput = {
    set?: $Enums.inducks_entry_nofulltext_sideways | null
  }

  export type NullableEnuminducks_entry_nofulltext_identificationuncertainFieldUpdateOperationsInput = {
    set?: $Enums.inducks_entry_nofulltext_identificationuncertain | null
  }

  export type NullableEnuminducks_entry_nofulltext_errorFieldUpdateOperationsInput = {
    set?: $Enums.inducks_entry_nofulltext_error | null
  }

  export type NullableEnuminducks_entryjob_doubtFieldUpdateOperationsInput = {
    set?: $Enums.inducks_entryjob_doubt | null
  }

  export type NullableEnuminducks_entryurl_publicFieldUpdateOperationsInput = {
    set?: $Enums.inducks_entryurl_public | null
  }

  export type NullableEnuminducks_herocharacter_doubtFieldUpdateOperationsInput = {
    set?: $Enums.inducks_herocharacter_doubt | null
  }

  export type NullableEnuminducks_inputfile_lockedFieldUpdateOperationsInput = {
    set?: $Enums.inducks_inputfile_locked | null
  }

  export type NullableEnuminducks_inputfile_secundaryFieldUpdateOperationsInput = {
    set?: $Enums.inducks_inputfile_secundary | null
  }

  export type NullableEnuminducks_issue_fullyindexedFieldUpdateOperationsInput = {
    set?: $Enums.inducks_issue_fullyindexed | null
  }

  export type NullableEnuminducks_issue_errorFieldUpdateOperationsInput = {
    set?: $Enums.inducks_issue_error | null
  }

  export type NullableEnuminducks_issue_lockedFieldUpdateOperationsInput = {
    set?: $Enums.inducks_issue_locked | null
  }

  export type NullableEnuminducks_issue_inxforbiddenFieldUpdateOperationsInput = {
    set?: $Enums.inducks_issue_inxforbidden | null
  }

  export type NullableEnuminducks_issuedate_doubtFieldUpdateOperationsInput = {
    set?: $Enums.inducks_issuedate_doubt | null
  }

  export type NullableEnuminducks_issuejob_doubtFieldUpdateOperationsInput = {
    set?: $Enums.inducks_issuejob_doubt | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableEnuminducks_issuerange_numbersarefakeFieldUpdateOperationsInput = {
    set?: $Enums.inducks_issuerange_numbersarefake | null
  }

  export type NullableEnuminducks_issuerange_errorFieldUpdateOperationsInput = {
    set?: $Enums.inducks_issuerange_error | null
  }

  export type NullableEnuminducks_log_markedFieldUpdateOperationsInput = {
    set?: $Enums.inducks_log_marked | null
  }

  export type NullableEnuminducks_logocharacter_reallyintitleFieldUpdateOperationsInput = {
    set?: $Enums.inducks_logocharacter_reallyintitle | null
  }

  export type NullableEnuminducks_movie_lockedFieldUpdateOperationsInput = {
    set?: $Enums.inducks_movie_locked | null
  }

  export type NullableEnuminducks_moviecharacter_istitlecharacterFieldUpdateOperationsInput = {
    set?: $Enums.inducks_moviecharacter_istitlecharacter | null
  }

  export type NullableEnuminducks_moviejob_indirectFieldUpdateOperationsInput = {
    set?: $Enums.inducks_moviejob_indirect | null
  }

  export type NullableEnuminducks_moviejob_doubtFieldUpdateOperationsInput = {
    set?: $Enums.inducks_moviejob_doubt | null
  }

  export type NullableEnuminducks_moviereference_frommovietostoryFieldUpdateOperationsInput = {
    set?: $Enums.inducks_moviereference_frommovietostory | null
  }

  export type NullableEnuminducks_person_officialFieldUpdateOperationsInput = {
    set?: $Enums.inducks_person_official | null
  }

  export type NullableEnuminducks_person_unknownstudiomemberFieldUpdateOperationsInput = {
    set?: $Enums.inducks_person_unknownstudiomember | null
  }

  export type NullableEnuminducks_person_isfakeFieldUpdateOperationsInput = {
    set?: $Enums.inducks_person_isfake | null
  }

  export type NullableEnuminducks_publication_numbersarefakeFieldUpdateOperationsInput = {
    set?: $Enums.inducks_publication_numbersarefake | null
  }

  export type NullableEnuminducks_publication_errorFieldUpdateOperationsInput = {
    set?: $Enums.inducks_publication_error | null
  }

  export type NullableEnuminducks_publication_lockedFieldUpdateOperationsInput = {
    set?: $Enums.inducks_publication_locked | null
  }

  export type NullableEnuminducks_publication_inxforbiddenFieldUpdateOperationsInput = {
    set?: $Enums.inducks_publication_inxforbidden | null
  }

  export type NullableEnuminducks_site_imagesFieldUpdateOperationsInput = {
    set?: $Enums.inducks_site_images | null
  }

  export type NullableEnuminducks_story_errorFieldUpdateOperationsInput = {
    set?: $Enums.inducks_story_error | null
  }

  export type NullableEnuminducks_story_lockedFieldUpdateOperationsInput = {
    set?: $Enums.inducks_story_locked | null
  }

  export type NullableEnuminducks_storyjob_indirectFieldUpdateOperationsInput = {
    set?: $Enums.inducks_storyjob_indirect | null
  }

  export type NullableEnuminducks_storyjob_doubtFieldUpdateOperationsInput = {
    set?: $Enums.inducks_storyjob_doubt | null
  }

  export type NullableEnuminducks_storyversion_brokenpageunspecifiedFieldUpdateOperationsInput = {
    set?: $Enums.inducks_storyversion_brokenpageunspecified | null
  }

  export type NullableEnuminducks_storyversion_appisxappFieldUpdateOperationsInput = {
    set?: $Enums.inducks_storyversion_appisxapp | null
  }

  export type NullableEnuminducks_storyversion_nofulltext_brokenpageunspecifiedFieldUpdateOperationsInput = {
    set?: $Enums.inducks_storyversion_nofulltext_brokenpageunspecified | null
  }

  export type NullableEnuminducks_storyversion_nofulltext_appisxappFieldUpdateOperationsInput = {
    set?: $Enums.inducks_storyversion_nofulltext_appisxapp | null
  }

  export type NullableEnuminducks_subseries_officialFieldUpdateOperationsInput = {
    set?: $Enums.inducks_subseries_official | null
  }

  export type NullableEnuminducks_subseriesname_preferredFieldUpdateOperationsInput = {
    set?: $Enums.inducks_subseriesname_preferred | null
  }

  export type NullableEnuminducks_substory_errorFieldUpdateOperationsInput = {
    set?: $Enums.inducks_substory_error | null
  }

  export type NullableEnuminducks_substory_lockedFieldUpdateOperationsInput = {
    set?: $Enums.inducks_substory_locked | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnuminducks_appearance_doubtNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_appearance_doubt | Enuminducks_appearance_doubtFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_appearance_doubt[] | null
    notIn?: $Enums.inducks_appearance_doubt[] | null
    not?: NestedEnuminducks_appearance_doubtNullableFilter<$PrismaModel> | $Enums.inducks_appearance_doubt | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_appearance_doubtNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_appearance_doubt | Enuminducks_appearance_doubtFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_appearance_doubt[] | null
    notIn?: $Enums.inducks_appearance_doubt[] | null
    not?: NestedEnuminducks_appearance_doubtNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_appearance_doubt | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_appearance_doubtNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_appearance_doubtNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_character_officialNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_character_official | Enuminducks_character_officialFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_character_official[] | null
    notIn?: $Enums.inducks_character_official[] | null
    not?: NestedEnuminducks_character_officialNullableFilter<$PrismaModel> | $Enums.inducks_character_official | null
  }

  export type NestedEnuminducks_character_onetimeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_character_onetime | Enuminducks_character_onetimeFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_character_onetime[] | null
    notIn?: $Enums.inducks_character_onetime[] | null
    not?: NestedEnuminducks_character_onetimeNullableFilter<$PrismaModel> | $Enums.inducks_character_onetime | null
  }

  export type NestedEnuminducks_character_heroonlyNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_character_heroonly | Enuminducks_character_heroonlyFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_character_heroonly[] | null
    notIn?: $Enums.inducks_character_heroonly[] | null
    not?: NestedEnuminducks_character_heroonlyNullableFilter<$PrismaModel> | $Enums.inducks_character_heroonly | null
  }

  export type NestedEnuminducks_character_officialNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_character_official | Enuminducks_character_officialFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_character_official[] | null
    notIn?: $Enums.inducks_character_official[] | null
    not?: NestedEnuminducks_character_officialNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_character_official | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_character_officialNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_character_officialNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_character_onetimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_character_onetime | Enuminducks_character_onetimeFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_character_onetime[] | null
    notIn?: $Enums.inducks_character_onetime[] | null
    not?: NestedEnuminducks_character_onetimeNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_character_onetime | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_character_onetimeNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_character_onetimeNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_character_heroonlyNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_character_heroonly | Enuminducks_character_heroonlyFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_character_heroonly[] | null
    notIn?: $Enums.inducks_character_heroonly[] | null
    not?: NestedEnuminducks_character_heroonlyNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_character_heroonly | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_character_heroonlyNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_character_heroonlyNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_charactername_preferredNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_charactername_preferred | Enuminducks_charactername_preferredFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_charactername_preferred[] | null
    notIn?: $Enums.inducks_charactername_preferred[] | null
    not?: NestedEnuminducks_charactername_preferredNullableFilter<$PrismaModel> | $Enums.inducks_charactername_preferred | null
  }

  export type NestedEnuminducks_charactername_preferredNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_charactername_preferred | Enuminducks_charactername_preferredFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_charactername_preferred[] | null
    notIn?: $Enums.inducks_charactername_preferred[] | null
    not?: NestedEnuminducks_charactername_preferredNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_charactername_preferred | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_charactername_preferredNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_charactername_preferredNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_characterreference_isgroupofcharactersNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_characterreference_isgroupofcharacters | Enuminducks_characterreference_isgroupofcharactersFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_characterreference_isgroupofcharacters[] | null
    notIn?: $Enums.inducks_characterreference_isgroupofcharacters[] | null
    not?: NestedEnuminducks_characterreference_isgroupofcharactersNullableFilter<$PrismaModel> | $Enums.inducks_characterreference_isgroupofcharacters | null
  }

  export type NestedEnuminducks_characterreference_isgroupofcharactersNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_characterreference_isgroupofcharacters | Enuminducks_characterreference_isgroupofcharactersFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_characterreference_isgroupofcharacters[] | null
    notIn?: $Enums.inducks_characterreference_isgroupofcharacters[] | null
    not?: NestedEnuminducks_characterreference_isgroupofcharactersNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_characterreference_isgroupofcharacters | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_characterreference_isgroupofcharactersNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_characterreference_isgroupofcharactersNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_entry_reallytitleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_reallytitle | Enuminducks_entry_reallytitleFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_reallytitle[] | null
    notIn?: $Enums.inducks_entry_reallytitle[] | null
    not?: NestedEnuminducks_entry_reallytitleNullableFilter<$PrismaModel> | $Enums.inducks_entry_reallytitle | null
  }

  export type NestedEnuminducks_entry_mirroredNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_mirrored | Enuminducks_entry_mirroredFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_mirrored[] | null
    notIn?: $Enums.inducks_entry_mirrored[] | null
    not?: NestedEnuminducks_entry_mirroredNullableFilter<$PrismaModel> | $Enums.inducks_entry_mirrored | null
  }

  export type NestedEnuminducks_entry_sidewaysNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_sideways | Enuminducks_entry_sidewaysFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_sideways[] | null
    notIn?: $Enums.inducks_entry_sideways[] | null
    not?: NestedEnuminducks_entry_sidewaysNullableFilter<$PrismaModel> | $Enums.inducks_entry_sideways | null
  }

  export type NestedEnuminducks_entry_identificationuncertainNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_identificationuncertain | Enuminducks_entry_identificationuncertainFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_identificationuncertain[] | null
    notIn?: $Enums.inducks_entry_identificationuncertain[] | null
    not?: NestedEnuminducks_entry_identificationuncertainNullableFilter<$PrismaModel> | $Enums.inducks_entry_identificationuncertain | null
  }

  export type NestedEnuminducks_entry_errorNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_error | Enuminducks_entry_errorFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_error[] | null
    notIn?: $Enums.inducks_entry_error[] | null
    not?: NestedEnuminducks_entry_errorNullableFilter<$PrismaModel> | $Enums.inducks_entry_error | null
  }

  export type NestedEnuminducks_entry_reallytitleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_reallytitle | Enuminducks_entry_reallytitleFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_reallytitle[] | null
    notIn?: $Enums.inducks_entry_reallytitle[] | null
    not?: NestedEnuminducks_entry_reallytitleNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_entry_reallytitle | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_entry_reallytitleNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_entry_reallytitleNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_entry_mirroredNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_mirrored | Enuminducks_entry_mirroredFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_mirrored[] | null
    notIn?: $Enums.inducks_entry_mirrored[] | null
    not?: NestedEnuminducks_entry_mirroredNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_entry_mirrored | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_entry_mirroredNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_entry_mirroredNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_entry_sidewaysNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_sideways | Enuminducks_entry_sidewaysFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_sideways[] | null
    notIn?: $Enums.inducks_entry_sideways[] | null
    not?: NestedEnuminducks_entry_sidewaysNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_entry_sideways | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_entry_sidewaysNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_entry_sidewaysNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_entry_identificationuncertainNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_identificationuncertain | Enuminducks_entry_identificationuncertainFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_identificationuncertain[] | null
    notIn?: $Enums.inducks_entry_identificationuncertain[] | null
    not?: NestedEnuminducks_entry_identificationuncertainNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_entry_identificationuncertain | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_entry_identificationuncertainNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_entry_identificationuncertainNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_entry_errorNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_error | Enuminducks_entry_errorFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_error[] | null
    notIn?: $Enums.inducks_entry_error[] | null
    not?: NestedEnuminducks_entry_errorNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_entry_error | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_entry_errorNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_entry_errorNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_entry_nofulltext_reallytitleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_nofulltext_reallytitle | Enuminducks_entry_nofulltext_reallytitleFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_nofulltext_reallytitle[] | null
    notIn?: $Enums.inducks_entry_nofulltext_reallytitle[] | null
    not?: NestedEnuminducks_entry_nofulltext_reallytitleNullableFilter<$PrismaModel> | $Enums.inducks_entry_nofulltext_reallytitle | null
  }

  export type NestedEnuminducks_entry_nofulltext_mirroredNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_nofulltext_mirrored | Enuminducks_entry_nofulltext_mirroredFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_nofulltext_mirrored[] | null
    notIn?: $Enums.inducks_entry_nofulltext_mirrored[] | null
    not?: NestedEnuminducks_entry_nofulltext_mirroredNullableFilter<$PrismaModel> | $Enums.inducks_entry_nofulltext_mirrored | null
  }

  export type NestedEnuminducks_entry_nofulltext_sidewaysNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_nofulltext_sideways | Enuminducks_entry_nofulltext_sidewaysFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_nofulltext_sideways[] | null
    notIn?: $Enums.inducks_entry_nofulltext_sideways[] | null
    not?: NestedEnuminducks_entry_nofulltext_sidewaysNullableFilter<$PrismaModel> | $Enums.inducks_entry_nofulltext_sideways | null
  }

  export type NestedEnuminducks_entry_nofulltext_identificationuncertainNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_nofulltext_identificationuncertain | Enuminducks_entry_nofulltext_identificationuncertainFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_nofulltext_identificationuncertain[] | null
    notIn?: $Enums.inducks_entry_nofulltext_identificationuncertain[] | null
    not?: NestedEnuminducks_entry_nofulltext_identificationuncertainNullableFilter<$PrismaModel> | $Enums.inducks_entry_nofulltext_identificationuncertain | null
  }

  export type NestedEnuminducks_entry_nofulltext_errorNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_nofulltext_error | Enuminducks_entry_nofulltext_errorFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_nofulltext_error[] | null
    notIn?: $Enums.inducks_entry_nofulltext_error[] | null
    not?: NestedEnuminducks_entry_nofulltext_errorNullableFilter<$PrismaModel> | $Enums.inducks_entry_nofulltext_error | null
  }

  export type NestedEnuminducks_entry_nofulltext_reallytitleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_nofulltext_reallytitle | Enuminducks_entry_nofulltext_reallytitleFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_nofulltext_reallytitle[] | null
    notIn?: $Enums.inducks_entry_nofulltext_reallytitle[] | null
    not?: NestedEnuminducks_entry_nofulltext_reallytitleNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_entry_nofulltext_reallytitle | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_entry_nofulltext_reallytitleNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_entry_nofulltext_reallytitleNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_entry_nofulltext_mirroredNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_nofulltext_mirrored | Enuminducks_entry_nofulltext_mirroredFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_nofulltext_mirrored[] | null
    notIn?: $Enums.inducks_entry_nofulltext_mirrored[] | null
    not?: NestedEnuminducks_entry_nofulltext_mirroredNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_entry_nofulltext_mirrored | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_entry_nofulltext_mirroredNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_entry_nofulltext_mirroredNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_entry_nofulltext_sidewaysNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_nofulltext_sideways | Enuminducks_entry_nofulltext_sidewaysFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_nofulltext_sideways[] | null
    notIn?: $Enums.inducks_entry_nofulltext_sideways[] | null
    not?: NestedEnuminducks_entry_nofulltext_sidewaysNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_entry_nofulltext_sideways | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_entry_nofulltext_sidewaysNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_entry_nofulltext_sidewaysNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_entry_nofulltext_identificationuncertainNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_nofulltext_identificationuncertain | Enuminducks_entry_nofulltext_identificationuncertainFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_nofulltext_identificationuncertain[] | null
    notIn?: $Enums.inducks_entry_nofulltext_identificationuncertain[] | null
    not?: NestedEnuminducks_entry_nofulltext_identificationuncertainNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_entry_nofulltext_identificationuncertain | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_entry_nofulltext_identificationuncertainNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_entry_nofulltext_identificationuncertainNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_entry_nofulltext_errorNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entry_nofulltext_error | Enuminducks_entry_nofulltext_errorFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entry_nofulltext_error[] | null
    notIn?: $Enums.inducks_entry_nofulltext_error[] | null
    not?: NestedEnuminducks_entry_nofulltext_errorNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_entry_nofulltext_error | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_entry_nofulltext_errorNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_entry_nofulltext_errorNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_entryjob_doubtNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entryjob_doubt | Enuminducks_entryjob_doubtFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entryjob_doubt[] | null
    notIn?: $Enums.inducks_entryjob_doubt[] | null
    not?: NestedEnuminducks_entryjob_doubtNullableFilter<$PrismaModel> | $Enums.inducks_entryjob_doubt | null
  }

  export type NestedEnuminducks_entryjob_doubtNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entryjob_doubt | Enuminducks_entryjob_doubtFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entryjob_doubt[] | null
    notIn?: $Enums.inducks_entryjob_doubt[] | null
    not?: NestedEnuminducks_entryjob_doubtNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_entryjob_doubt | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_entryjob_doubtNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_entryjob_doubtNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_entryurl_publicNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entryurl_public | Enuminducks_entryurl_publicFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entryurl_public[] | null
    notIn?: $Enums.inducks_entryurl_public[] | null
    not?: NestedEnuminducks_entryurl_publicNullableFilter<$PrismaModel> | $Enums.inducks_entryurl_public | null
  }

  export type NestedEnuminducks_entryurl_publicNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_entryurl_public | Enuminducks_entryurl_publicFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_entryurl_public[] | null
    notIn?: $Enums.inducks_entryurl_public[] | null
    not?: NestedEnuminducks_entryurl_publicNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_entryurl_public | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_entryurl_publicNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_entryurl_publicNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_herocharacter_doubtNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_herocharacter_doubt | Enuminducks_herocharacter_doubtFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_herocharacter_doubt[] | null
    notIn?: $Enums.inducks_herocharacter_doubt[] | null
    not?: NestedEnuminducks_herocharacter_doubtNullableFilter<$PrismaModel> | $Enums.inducks_herocharacter_doubt | null
  }

  export type NestedEnuminducks_herocharacter_doubtNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_herocharacter_doubt | Enuminducks_herocharacter_doubtFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_herocharacter_doubt[] | null
    notIn?: $Enums.inducks_herocharacter_doubt[] | null
    not?: NestedEnuminducks_herocharacter_doubtNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_herocharacter_doubt | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_herocharacter_doubtNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_herocharacter_doubtNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_inputfile_lockedNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_inputfile_locked | Enuminducks_inputfile_lockedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_inputfile_locked[] | null
    notIn?: $Enums.inducks_inputfile_locked[] | null
    not?: NestedEnuminducks_inputfile_lockedNullableFilter<$PrismaModel> | $Enums.inducks_inputfile_locked | null
  }

  export type NestedEnuminducks_inputfile_secundaryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_inputfile_secundary | Enuminducks_inputfile_secundaryFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_inputfile_secundary[] | null
    notIn?: $Enums.inducks_inputfile_secundary[] | null
    not?: NestedEnuminducks_inputfile_secundaryNullableFilter<$PrismaModel> | $Enums.inducks_inputfile_secundary | null
  }

  export type NestedEnuminducks_inputfile_lockedNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_inputfile_locked | Enuminducks_inputfile_lockedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_inputfile_locked[] | null
    notIn?: $Enums.inducks_inputfile_locked[] | null
    not?: NestedEnuminducks_inputfile_lockedNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_inputfile_locked | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_inputfile_lockedNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_inputfile_lockedNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_inputfile_secundaryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_inputfile_secundary | Enuminducks_inputfile_secundaryFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_inputfile_secundary[] | null
    notIn?: $Enums.inducks_inputfile_secundary[] | null
    not?: NestedEnuminducks_inputfile_secundaryNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_inputfile_secundary | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_inputfile_secundaryNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_inputfile_secundaryNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_issue_fullyindexedNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_issue_fullyindexed | Enuminducks_issue_fullyindexedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_issue_fullyindexed[] | null
    notIn?: $Enums.inducks_issue_fullyindexed[] | null
    not?: NestedEnuminducks_issue_fullyindexedNullableFilter<$PrismaModel> | $Enums.inducks_issue_fullyindexed | null
  }

  export type NestedEnuminducks_issue_errorNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_issue_error | Enuminducks_issue_errorFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_issue_error[] | null
    notIn?: $Enums.inducks_issue_error[] | null
    not?: NestedEnuminducks_issue_errorNullableFilter<$PrismaModel> | $Enums.inducks_issue_error | null
  }

  export type NestedEnuminducks_issue_lockedNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_issue_locked | Enuminducks_issue_lockedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_issue_locked[] | null
    notIn?: $Enums.inducks_issue_locked[] | null
    not?: NestedEnuminducks_issue_lockedNullableFilter<$PrismaModel> | $Enums.inducks_issue_locked | null
  }

  export type NestedEnuminducks_issue_inxforbiddenNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_issue_inxforbidden | Enuminducks_issue_inxforbiddenFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_issue_inxforbidden[] | null
    notIn?: $Enums.inducks_issue_inxforbidden[] | null
    not?: NestedEnuminducks_issue_inxforbiddenNullableFilter<$PrismaModel> | $Enums.inducks_issue_inxforbidden | null
  }

  export type NestedEnuminducks_issue_fullyindexedNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_issue_fullyindexed | Enuminducks_issue_fullyindexedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_issue_fullyindexed[] | null
    notIn?: $Enums.inducks_issue_fullyindexed[] | null
    not?: NestedEnuminducks_issue_fullyindexedNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_issue_fullyindexed | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_issue_fullyindexedNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_issue_fullyindexedNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_issue_errorNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_issue_error | Enuminducks_issue_errorFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_issue_error[] | null
    notIn?: $Enums.inducks_issue_error[] | null
    not?: NestedEnuminducks_issue_errorNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_issue_error | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_issue_errorNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_issue_errorNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_issue_lockedNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_issue_locked | Enuminducks_issue_lockedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_issue_locked[] | null
    notIn?: $Enums.inducks_issue_locked[] | null
    not?: NestedEnuminducks_issue_lockedNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_issue_locked | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_issue_lockedNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_issue_lockedNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_issue_inxforbiddenNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_issue_inxforbidden | Enuminducks_issue_inxforbiddenFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_issue_inxforbidden[] | null
    notIn?: $Enums.inducks_issue_inxforbidden[] | null
    not?: NestedEnuminducks_issue_inxforbiddenNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_issue_inxforbidden | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_issue_inxforbiddenNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_issue_inxforbiddenNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_issuedate_doubtNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_issuedate_doubt | Enuminducks_issuedate_doubtFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_issuedate_doubt[] | null
    notIn?: $Enums.inducks_issuedate_doubt[] | null
    not?: NestedEnuminducks_issuedate_doubtNullableFilter<$PrismaModel> | $Enums.inducks_issuedate_doubt | null
  }

  export type NestedEnuminducks_issuedate_doubtNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_issuedate_doubt | Enuminducks_issuedate_doubtFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_issuedate_doubt[] | null
    notIn?: $Enums.inducks_issuedate_doubt[] | null
    not?: NestedEnuminducks_issuedate_doubtNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_issuedate_doubt | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_issuedate_doubtNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_issuedate_doubtNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_issuejob_doubtNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_issuejob_doubt | Enuminducks_issuejob_doubtFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_issuejob_doubt[] | null
    notIn?: $Enums.inducks_issuejob_doubt[] | null
    not?: NestedEnuminducks_issuejob_doubtNullableFilter<$PrismaModel> | $Enums.inducks_issuejob_doubt | null
  }

  export type NestedEnuminducks_issuejob_doubtNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_issuejob_doubt | Enuminducks_issuejob_doubtFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_issuejob_doubt[] | null
    notIn?: $Enums.inducks_issuejob_doubt[] | null
    not?: NestedEnuminducks_issuejob_doubtNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_issuejob_doubt | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_issuejob_doubtNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_issuejob_doubtNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_issuerange_numbersarefakeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_issuerange_numbersarefake | Enuminducks_issuerange_numbersarefakeFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_issuerange_numbersarefake[] | null
    notIn?: $Enums.inducks_issuerange_numbersarefake[] | null
    not?: NestedEnuminducks_issuerange_numbersarefakeNullableFilter<$PrismaModel> | $Enums.inducks_issuerange_numbersarefake | null
  }

  export type NestedEnuminducks_issuerange_errorNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_issuerange_error | Enuminducks_issuerange_errorFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_issuerange_error[] | null
    notIn?: $Enums.inducks_issuerange_error[] | null
    not?: NestedEnuminducks_issuerange_errorNullableFilter<$PrismaModel> | $Enums.inducks_issuerange_error | null
  }

  export type NestedEnuminducks_issuerange_numbersarefakeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_issuerange_numbersarefake | Enuminducks_issuerange_numbersarefakeFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_issuerange_numbersarefake[] | null
    notIn?: $Enums.inducks_issuerange_numbersarefake[] | null
    not?: NestedEnuminducks_issuerange_numbersarefakeNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_issuerange_numbersarefake | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_issuerange_numbersarefakeNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_issuerange_numbersarefakeNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_issuerange_errorNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_issuerange_error | Enuminducks_issuerange_errorFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_issuerange_error[] | null
    notIn?: $Enums.inducks_issuerange_error[] | null
    not?: NestedEnuminducks_issuerange_errorNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_issuerange_error | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_issuerange_errorNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_issuerange_errorNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_log_markedNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_log_marked | Enuminducks_log_markedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_log_marked[] | null
    notIn?: $Enums.inducks_log_marked[] | null
    not?: NestedEnuminducks_log_markedNullableFilter<$PrismaModel> | $Enums.inducks_log_marked | null
  }

  export type NestedEnuminducks_log_markedNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_log_marked | Enuminducks_log_markedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_log_marked[] | null
    notIn?: $Enums.inducks_log_marked[] | null
    not?: NestedEnuminducks_log_markedNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_log_marked | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_log_markedNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_log_markedNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_logocharacter_reallyintitleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_logocharacter_reallyintitle | Enuminducks_logocharacter_reallyintitleFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_logocharacter_reallyintitle[] | null
    notIn?: $Enums.inducks_logocharacter_reallyintitle[] | null
    not?: NestedEnuminducks_logocharacter_reallyintitleNullableFilter<$PrismaModel> | $Enums.inducks_logocharacter_reallyintitle | null
  }

  export type NestedEnuminducks_logocharacter_reallyintitleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_logocharacter_reallyintitle | Enuminducks_logocharacter_reallyintitleFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_logocharacter_reallyintitle[] | null
    notIn?: $Enums.inducks_logocharacter_reallyintitle[] | null
    not?: NestedEnuminducks_logocharacter_reallyintitleNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_logocharacter_reallyintitle | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_logocharacter_reallyintitleNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_logocharacter_reallyintitleNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_movie_lockedNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_movie_locked | Enuminducks_movie_lockedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_movie_locked[] | null
    notIn?: $Enums.inducks_movie_locked[] | null
    not?: NestedEnuminducks_movie_lockedNullableFilter<$PrismaModel> | $Enums.inducks_movie_locked | null
  }

  export type NestedEnuminducks_movie_lockedNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_movie_locked | Enuminducks_movie_lockedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_movie_locked[] | null
    notIn?: $Enums.inducks_movie_locked[] | null
    not?: NestedEnuminducks_movie_lockedNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_movie_locked | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_movie_lockedNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_movie_lockedNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_moviecharacter_istitlecharacterNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_moviecharacter_istitlecharacter | Enuminducks_moviecharacter_istitlecharacterFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_moviecharacter_istitlecharacter[] | null
    notIn?: $Enums.inducks_moviecharacter_istitlecharacter[] | null
    not?: NestedEnuminducks_moviecharacter_istitlecharacterNullableFilter<$PrismaModel> | $Enums.inducks_moviecharacter_istitlecharacter | null
  }

  export type NestedEnuminducks_moviecharacter_istitlecharacterNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_moviecharacter_istitlecharacter | Enuminducks_moviecharacter_istitlecharacterFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_moviecharacter_istitlecharacter[] | null
    notIn?: $Enums.inducks_moviecharacter_istitlecharacter[] | null
    not?: NestedEnuminducks_moviecharacter_istitlecharacterNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_moviecharacter_istitlecharacter | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_moviecharacter_istitlecharacterNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_moviecharacter_istitlecharacterNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_moviejob_indirectNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_moviejob_indirect | Enuminducks_moviejob_indirectFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_moviejob_indirect[] | null
    notIn?: $Enums.inducks_moviejob_indirect[] | null
    not?: NestedEnuminducks_moviejob_indirectNullableFilter<$PrismaModel> | $Enums.inducks_moviejob_indirect | null
  }

  export type NestedEnuminducks_moviejob_doubtNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_moviejob_doubt | Enuminducks_moviejob_doubtFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_moviejob_doubt[] | null
    notIn?: $Enums.inducks_moviejob_doubt[] | null
    not?: NestedEnuminducks_moviejob_doubtNullableFilter<$PrismaModel> | $Enums.inducks_moviejob_doubt | null
  }

  export type NestedEnuminducks_moviejob_indirectNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_moviejob_indirect | Enuminducks_moviejob_indirectFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_moviejob_indirect[] | null
    notIn?: $Enums.inducks_moviejob_indirect[] | null
    not?: NestedEnuminducks_moviejob_indirectNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_moviejob_indirect | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_moviejob_indirectNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_moviejob_indirectNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_moviejob_doubtNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_moviejob_doubt | Enuminducks_moviejob_doubtFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_moviejob_doubt[] | null
    notIn?: $Enums.inducks_moviejob_doubt[] | null
    not?: NestedEnuminducks_moviejob_doubtNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_moviejob_doubt | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_moviejob_doubtNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_moviejob_doubtNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_moviereference_frommovietostoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_moviereference_frommovietostory | Enuminducks_moviereference_frommovietostoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_moviereference_frommovietostory[] | null
    notIn?: $Enums.inducks_moviereference_frommovietostory[] | null
    not?: NestedEnuminducks_moviereference_frommovietostoryNullableFilter<$PrismaModel> | $Enums.inducks_moviereference_frommovietostory | null
  }

  export type NestedEnuminducks_moviereference_frommovietostoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_moviereference_frommovietostory | Enuminducks_moviereference_frommovietostoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_moviereference_frommovietostory[] | null
    notIn?: $Enums.inducks_moviereference_frommovietostory[] | null
    not?: NestedEnuminducks_moviereference_frommovietostoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_moviereference_frommovietostory | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_moviereference_frommovietostoryNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_moviereference_frommovietostoryNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_person_officialNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_person_official | Enuminducks_person_officialFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_person_official[] | null
    notIn?: $Enums.inducks_person_official[] | null
    not?: NestedEnuminducks_person_officialNullableFilter<$PrismaModel> | $Enums.inducks_person_official | null
  }

  export type NestedEnuminducks_person_unknownstudiomemberNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_person_unknownstudiomember | Enuminducks_person_unknownstudiomemberFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_person_unknownstudiomember[] | null
    notIn?: $Enums.inducks_person_unknownstudiomember[] | null
    not?: NestedEnuminducks_person_unknownstudiomemberNullableFilter<$PrismaModel> | $Enums.inducks_person_unknownstudiomember | null
  }

  export type NestedEnuminducks_person_isfakeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_person_isfake | Enuminducks_person_isfakeFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_person_isfake[] | null
    notIn?: $Enums.inducks_person_isfake[] | null
    not?: NestedEnuminducks_person_isfakeNullableFilter<$PrismaModel> | $Enums.inducks_person_isfake | null
  }

  export type NestedEnuminducks_person_officialNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_person_official | Enuminducks_person_officialFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_person_official[] | null
    notIn?: $Enums.inducks_person_official[] | null
    not?: NestedEnuminducks_person_officialNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_person_official | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_person_officialNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_person_officialNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_person_unknownstudiomemberNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_person_unknownstudiomember | Enuminducks_person_unknownstudiomemberFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_person_unknownstudiomember[] | null
    notIn?: $Enums.inducks_person_unknownstudiomember[] | null
    not?: NestedEnuminducks_person_unknownstudiomemberNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_person_unknownstudiomember | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_person_unknownstudiomemberNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_person_unknownstudiomemberNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_person_isfakeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_person_isfake | Enuminducks_person_isfakeFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_person_isfake[] | null
    notIn?: $Enums.inducks_person_isfake[] | null
    not?: NestedEnuminducks_person_isfakeNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_person_isfake | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_person_isfakeNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_person_isfakeNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_publication_numbersarefakeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_publication_numbersarefake | Enuminducks_publication_numbersarefakeFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_publication_numbersarefake[] | null
    notIn?: $Enums.inducks_publication_numbersarefake[] | null
    not?: NestedEnuminducks_publication_numbersarefakeNullableFilter<$PrismaModel> | $Enums.inducks_publication_numbersarefake | null
  }

  export type NestedEnuminducks_publication_errorNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_publication_error | Enuminducks_publication_errorFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_publication_error[] | null
    notIn?: $Enums.inducks_publication_error[] | null
    not?: NestedEnuminducks_publication_errorNullableFilter<$PrismaModel> | $Enums.inducks_publication_error | null
  }

  export type NestedEnuminducks_publication_lockedNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_publication_locked | Enuminducks_publication_lockedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_publication_locked[] | null
    notIn?: $Enums.inducks_publication_locked[] | null
    not?: NestedEnuminducks_publication_lockedNullableFilter<$PrismaModel> | $Enums.inducks_publication_locked | null
  }

  export type NestedEnuminducks_publication_inxforbiddenNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_publication_inxforbidden | Enuminducks_publication_inxforbiddenFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_publication_inxforbidden[] | null
    notIn?: $Enums.inducks_publication_inxforbidden[] | null
    not?: NestedEnuminducks_publication_inxforbiddenNullableFilter<$PrismaModel> | $Enums.inducks_publication_inxforbidden | null
  }

  export type NestedEnuminducks_publication_numbersarefakeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_publication_numbersarefake | Enuminducks_publication_numbersarefakeFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_publication_numbersarefake[] | null
    notIn?: $Enums.inducks_publication_numbersarefake[] | null
    not?: NestedEnuminducks_publication_numbersarefakeNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_publication_numbersarefake | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_publication_numbersarefakeNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_publication_numbersarefakeNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_publication_errorNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_publication_error | Enuminducks_publication_errorFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_publication_error[] | null
    notIn?: $Enums.inducks_publication_error[] | null
    not?: NestedEnuminducks_publication_errorNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_publication_error | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_publication_errorNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_publication_errorNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_publication_lockedNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_publication_locked | Enuminducks_publication_lockedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_publication_locked[] | null
    notIn?: $Enums.inducks_publication_locked[] | null
    not?: NestedEnuminducks_publication_lockedNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_publication_locked | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_publication_lockedNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_publication_lockedNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_publication_inxforbiddenNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_publication_inxforbidden | Enuminducks_publication_inxforbiddenFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_publication_inxforbidden[] | null
    notIn?: $Enums.inducks_publication_inxforbidden[] | null
    not?: NestedEnuminducks_publication_inxforbiddenNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_publication_inxforbidden | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_publication_inxforbiddenNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_publication_inxforbiddenNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_site_imagesNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_site_images | Enuminducks_site_imagesFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_site_images[] | null
    notIn?: $Enums.inducks_site_images[] | null
    not?: NestedEnuminducks_site_imagesNullableFilter<$PrismaModel> | $Enums.inducks_site_images | null
  }

  export type NestedEnuminducks_site_imagesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_site_images | Enuminducks_site_imagesFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_site_images[] | null
    notIn?: $Enums.inducks_site_images[] | null
    not?: NestedEnuminducks_site_imagesNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_site_images | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_site_imagesNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_site_imagesNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_story_errorNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_story_error | Enuminducks_story_errorFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_story_error[] | null
    notIn?: $Enums.inducks_story_error[] | null
    not?: NestedEnuminducks_story_errorNullableFilter<$PrismaModel> | $Enums.inducks_story_error | null
  }

  export type NestedEnuminducks_story_lockedNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_story_locked | Enuminducks_story_lockedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_story_locked[] | null
    notIn?: $Enums.inducks_story_locked[] | null
    not?: NestedEnuminducks_story_lockedNullableFilter<$PrismaModel> | $Enums.inducks_story_locked | null
  }

  export type NestedEnuminducks_story_errorNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_story_error | Enuminducks_story_errorFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_story_error[] | null
    notIn?: $Enums.inducks_story_error[] | null
    not?: NestedEnuminducks_story_errorNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_story_error | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_story_errorNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_story_errorNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_story_lockedNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_story_locked | Enuminducks_story_lockedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_story_locked[] | null
    notIn?: $Enums.inducks_story_locked[] | null
    not?: NestedEnuminducks_story_lockedNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_story_locked | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_story_lockedNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_story_lockedNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_storyjob_indirectNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_storyjob_indirect | Enuminducks_storyjob_indirectFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_storyjob_indirect[] | null
    notIn?: $Enums.inducks_storyjob_indirect[] | null
    not?: NestedEnuminducks_storyjob_indirectNullableFilter<$PrismaModel> | $Enums.inducks_storyjob_indirect | null
  }

  export type NestedEnuminducks_storyjob_doubtNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_storyjob_doubt | Enuminducks_storyjob_doubtFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_storyjob_doubt[] | null
    notIn?: $Enums.inducks_storyjob_doubt[] | null
    not?: NestedEnuminducks_storyjob_doubtNullableFilter<$PrismaModel> | $Enums.inducks_storyjob_doubt | null
  }

  export type NestedEnuminducks_storyjob_indirectNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_storyjob_indirect | Enuminducks_storyjob_indirectFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_storyjob_indirect[] | null
    notIn?: $Enums.inducks_storyjob_indirect[] | null
    not?: NestedEnuminducks_storyjob_indirectNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_storyjob_indirect | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_storyjob_indirectNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_storyjob_indirectNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_storyjob_doubtNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_storyjob_doubt | Enuminducks_storyjob_doubtFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_storyjob_doubt[] | null
    notIn?: $Enums.inducks_storyjob_doubt[] | null
    not?: NestedEnuminducks_storyjob_doubtNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_storyjob_doubt | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_storyjob_doubtNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_storyjob_doubtNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_storyversion_brokenpageunspecifiedNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_storyversion_brokenpageunspecified | Enuminducks_storyversion_brokenpageunspecifiedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_storyversion_brokenpageunspecified[] | null
    notIn?: $Enums.inducks_storyversion_brokenpageunspecified[] | null
    not?: NestedEnuminducks_storyversion_brokenpageunspecifiedNullableFilter<$PrismaModel> | $Enums.inducks_storyversion_brokenpageunspecified | null
  }

  export type NestedEnuminducks_storyversion_appisxappNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_storyversion_appisxapp | Enuminducks_storyversion_appisxappFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_storyversion_appisxapp[] | null
    notIn?: $Enums.inducks_storyversion_appisxapp[] | null
    not?: NestedEnuminducks_storyversion_appisxappNullableFilter<$PrismaModel> | $Enums.inducks_storyversion_appisxapp | null
  }

  export type NestedEnuminducks_storyversion_brokenpageunspecifiedNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_storyversion_brokenpageunspecified | Enuminducks_storyversion_brokenpageunspecifiedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_storyversion_brokenpageunspecified[] | null
    notIn?: $Enums.inducks_storyversion_brokenpageunspecified[] | null
    not?: NestedEnuminducks_storyversion_brokenpageunspecifiedNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_storyversion_brokenpageunspecified | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_storyversion_brokenpageunspecifiedNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_storyversion_brokenpageunspecifiedNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_storyversion_appisxappNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_storyversion_appisxapp | Enuminducks_storyversion_appisxappFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_storyversion_appisxapp[] | null
    notIn?: $Enums.inducks_storyversion_appisxapp[] | null
    not?: NestedEnuminducks_storyversion_appisxappNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_storyversion_appisxapp | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_storyversion_appisxappNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_storyversion_appisxappNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_storyversion_nofulltext_brokenpageunspecifiedNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_storyversion_nofulltext_brokenpageunspecified | Enuminducks_storyversion_nofulltext_brokenpageunspecifiedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_storyversion_nofulltext_brokenpageunspecified[] | null
    notIn?: $Enums.inducks_storyversion_nofulltext_brokenpageunspecified[] | null
    not?: NestedEnuminducks_storyversion_nofulltext_brokenpageunspecifiedNullableFilter<$PrismaModel> | $Enums.inducks_storyversion_nofulltext_brokenpageunspecified | null
  }

  export type NestedEnuminducks_storyversion_nofulltext_appisxappNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_storyversion_nofulltext_appisxapp | Enuminducks_storyversion_nofulltext_appisxappFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_storyversion_nofulltext_appisxapp[] | null
    notIn?: $Enums.inducks_storyversion_nofulltext_appisxapp[] | null
    not?: NestedEnuminducks_storyversion_nofulltext_appisxappNullableFilter<$PrismaModel> | $Enums.inducks_storyversion_nofulltext_appisxapp | null
  }

  export type NestedEnuminducks_storyversion_nofulltext_brokenpageunspecifiedNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_storyversion_nofulltext_brokenpageunspecified | Enuminducks_storyversion_nofulltext_brokenpageunspecifiedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_storyversion_nofulltext_brokenpageunspecified[] | null
    notIn?: $Enums.inducks_storyversion_nofulltext_brokenpageunspecified[] | null
    not?: NestedEnuminducks_storyversion_nofulltext_brokenpageunspecifiedNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_storyversion_nofulltext_brokenpageunspecified | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_storyversion_nofulltext_brokenpageunspecifiedNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_storyversion_nofulltext_brokenpageunspecifiedNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_storyversion_nofulltext_appisxappNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_storyversion_nofulltext_appisxapp | Enuminducks_storyversion_nofulltext_appisxappFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_storyversion_nofulltext_appisxapp[] | null
    notIn?: $Enums.inducks_storyversion_nofulltext_appisxapp[] | null
    not?: NestedEnuminducks_storyversion_nofulltext_appisxappNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_storyversion_nofulltext_appisxapp | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_storyversion_nofulltext_appisxappNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_storyversion_nofulltext_appisxappNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_subseries_officialNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_subseries_official | Enuminducks_subseries_officialFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_subseries_official[] | null
    notIn?: $Enums.inducks_subseries_official[] | null
    not?: NestedEnuminducks_subseries_officialNullableFilter<$PrismaModel> | $Enums.inducks_subseries_official | null
  }

  export type NestedEnuminducks_subseries_officialNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_subseries_official | Enuminducks_subseries_officialFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_subseries_official[] | null
    notIn?: $Enums.inducks_subseries_official[] | null
    not?: NestedEnuminducks_subseries_officialNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_subseries_official | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_subseries_officialNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_subseries_officialNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_subseriesname_preferredNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_subseriesname_preferred | Enuminducks_subseriesname_preferredFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_subseriesname_preferred[] | null
    notIn?: $Enums.inducks_subseriesname_preferred[] | null
    not?: NestedEnuminducks_subseriesname_preferredNullableFilter<$PrismaModel> | $Enums.inducks_subseriesname_preferred | null
  }

  export type NestedEnuminducks_subseriesname_preferredNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_subseriesname_preferred | Enuminducks_subseriesname_preferredFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_subseriesname_preferred[] | null
    notIn?: $Enums.inducks_subseriesname_preferred[] | null
    not?: NestedEnuminducks_subseriesname_preferredNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_subseriesname_preferred | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_subseriesname_preferredNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_subseriesname_preferredNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_substory_errorNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_substory_error | Enuminducks_substory_errorFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_substory_error[] | null
    notIn?: $Enums.inducks_substory_error[] | null
    not?: NestedEnuminducks_substory_errorNullableFilter<$PrismaModel> | $Enums.inducks_substory_error | null
  }

  export type NestedEnuminducks_substory_lockedNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_substory_locked | Enuminducks_substory_lockedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_substory_locked[] | null
    notIn?: $Enums.inducks_substory_locked[] | null
    not?: NestedEnuminducks_substory_lockedNullableFilter<$PrismaModel> | $Enums.inducks_substory_locked | null
  }

  export type NestedEnuminducks_substory_errorNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_substory_error | Enuminducks_substory_errorFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_substory_error[] | null
    notIn?: $Enums.inducks_substory_error[] | null
    not?: NestedEnuminducks_substory_errorNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_substory_error | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_substory_errorNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_substory_errorNullableFilter<$PrismaModel>
  }

  export type NestedEnuminducks_substory_lockedNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.inducks_substory_locked | Enuminducks_substory_lockedFieldRefInput<$PrismaModel> | null
    in?: $Enums.inducks_substory_locked[] | null
    notIn?: $Enums.inducks_substory_locked[] | null
    not?: NestedEnuminducks_substory_lockedNullableWithAggregatesFilter<$PrismaModel> | $Enums.inducks_substory_locked | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnuminducks_substory_lockedNullableFilter<$PrismaModel>
    _max?: NestedEnuminducks_substory_lockedNullableFilter<$PrismaModel>
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use datasets_entryurlsDefaultArgs instead
     */
    export type datasets_entryurlsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = datasets_entryurlsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_appearanceDefaultArgs instead
     */
    export type inducks_appearanceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_appearanceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_characterDefaultArgs instead
     */
    export type inducks_characterArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_characterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_characteraliasDefaultArgs instead
     */
    export type inducks_characteraliasArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_characteraliasDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_characterdetailDefaultArgs instead
     */
    export type inducks_characterdetailArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_characterdetailDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_characternameDefaultArgs instead
     */
    export type inducks_characternameArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_characternameDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_characterreferenceDefaultArgs instead
     */
    export type inducks_characterreferenceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_characterreferenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_characterurlDefaultArgs instead
     */
    export type inducks_characterurlArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_characterurlDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_countryDefaultArgs instead
     */
    export type inducks_countryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_countryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_countrynameDefaultArgs instead
     */
    export type inducks_countrynameArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_countrynameDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_currencyDefaultArgs instead
     */
    export type inducks_currencyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_currencyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_currencynameDefaultArgs instead
     */
    export type inducks_currencynameArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_currencynameDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_entryDefaultArgs instead
     */
    export type inducks_entryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_entryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_entry_nofulltextDefaultArgs instead
     */
    export type inducks_entry_nofulltextArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_entry_nofulltextDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_entrycharacternameDefaultArgs instead
     */
    export type inducks_entrycharacternameArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_entrycharacternameDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_entryjobDefaultArgs instead
     */
    export type inducks_entryjobArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_entryjobDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_entryurlDefaultArgs instead
     */
    export type inducks_entryurlArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_entryurlDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_equivDefaultArgs instead
     */
    export type inducks_equivArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_equivDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_herocharacterDefaultArgs instead
     */
    export type inducks_herocharacterArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_herocharacterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_inputfileDefaultArgs instead
     */
    export type inducks_inputfileArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_inputfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_issueDefaultArgs instead
     */
    export type inducks_issueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_issueDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_issuecollectingDefaultArgs instead
     */
    export type inducks_issuecollectingArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_issuecollectingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_issuedateDefaultArgs instead
     */
    export type inducks_issuedateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_issuedateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_issuejobDefaultArgs instead
     */
    export type inducks_issuejobArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_issuejobDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_issuepriceDefaultArgs instead
     */
    export type inducks_issuepriceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_issuepriceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_issuequotationDefaultArgs instead
     */
    export type inducks_issuequotationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_issuequotationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_issuerangeDefaultArgs instead
     */
    export type inducks_issuerangeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_issuerangeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_issueurlDefaultArgs instead
     */
    export type inducks_issueurlArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_issueurlDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_languageDefaultArgs instead
     */
    export type inducks_languageArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_languageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_languagenameDefaultArgs instead
     */
    export type inducks_languagenameArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_languagenameDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_logDefaultArgs instead
     */
    export type inducks_logArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_logDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_logdataDefaultArgs instead
     */
    export type inducks_logdataArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_logdataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_logocharacterDefaultArgs instead
     */
    export type inducks_logocharacterArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_logocharacterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_movieDefaultArgs instead
     */
    export type inducks_movieArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_movieDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_moviecharacterDefaultArgs instead
     */
    export type inducks_moviecharacterArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_moviecharacterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_moviejobDefaultArgs instead
     */
    export type inducks_moviejobArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_moviejobDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_moviereferenceDefaultArgs instead
     */
    export type inducks_moviereferenceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_moviereferenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_personDefaultArgs instead
     */
    export type inducks_personArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_personDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_personurlDefaultArgs instead
     */
    export type inducks_personurlArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_personurlDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_publicationDefaultArgs instead
     */
    export type inducks_publicationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_publicationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_publicationcategoryDefaultArgs instead
     */
    export type inducks_publicationcategoryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_publicationcategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_publicationnameDefaultArgs instead
     */
    export type inducks_publicationnameArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_publicationnameDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_publicationurlDefaultArgs instead
     */
    export type inducks_publicationurlArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_publicationurlDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_publisherDefaultArgs instead
     */
    export type inducks_publisherArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_publisherDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_publishingjobDefaultArgs instead
     */
    export type inducks_publishingjobArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_publishingjobDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_referencereasonDefaultArgs instead
     */
    export type inducks_referencereasonArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_referencereasonDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_referencereasonnameDefaultArgs instead
     */
    export type inducks_referencereasonnameArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_referencereasonnameDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_siteDefaultArgs instead
     */
    export type inducks_siteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_siteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_statcharactercharacterDefaultArgs instead
     */
    export type inducks_statcharactercharacterArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_statcharactercharacterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_statcharactercountryDefaultArgs instead
     */
    export type inducks_statcharactercountryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_statcharactercountryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_statcharacterstoryDefaultArgs instead
     */
    export type inducks_statcharacterstoryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_statcharacterstoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_statpersoncharacterDefaultArgs instead
     */
    export type inducks_statpersoncharacterArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_statpersoncharacterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_statpersoncountryDefaultArgs instead
     */
    export type inducks_statpersoncountryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_statpersoncountryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_statpersonpersonDefaultArgs instead
     */
    export type inducks_statpersonpersonArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_statpersonpersonDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_statpersonstoryDefaultArgs instead
     */
    export type inducks_statpersonstoryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_statpersonstoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_storyDefaultArgs instead
     */
    export type inducks_storyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_storyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_storycodesDefaultArgs instead
     */
    export type inducks_storycodesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_storycodesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_storydescriptionDefaultArgs instead
     */
    export type inducks_storydescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_storydescriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_storyheaderDefaultArgs instead
     */
    export type inducks_storyheaderArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_storyheaderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_storyjobDefaultArgs instead
     */
    export type inducks_storyjobArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_storyjobDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_storyreferenceDefaultArgs instead
     */
    export type inducks_storyreferenceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_storyreferenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_storysubseriesDefaultArgs instead
     */
    export type inducks_storysubseriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_storysubseriesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_storyurlDefaultArgs instead
     */
    export type inducks_storyurlArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_storyurlDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_storyversionDefaultArgs instead
     */
    export type inducks_storyversionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_storyversionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_storyversion_nofulltextDefaultArgs instead
     */
    export type inducks_storyversion_nofulltextArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_storyversion_nofulltextDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_studioDefaultArgs instead
     */
    export type inducks_studioArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_studioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_studioworkDefaultArgs instead
     */
    export type inducks_studioworkArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_studioworkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_subseriesDefaultArgs instead
     */
    export type inducks_subseriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_subseriesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_subseriesnameDefaultArgs instead
     */
    export type inducks_subseriesnameArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_subseriesnameDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_substoryDefaultArgs instead
     */
    export type inducks_substoryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_substoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_teamDefaultArgs instead
     */
    export type inducks_teamArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_teamDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_teammemberDefaultArgs instead
     */
    export type inducks_teammemberArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_teammemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_ucrelationDefaultArgs instead
     */
    export type inducks_ucrelationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_ucrelationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_universeDefaultArgs instead
     */
    export type inducks_universeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_universeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inducks_universenameDefaultArgs instead
     */
    export type inducks_universenameArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = inducks_universenameDefaultArgs<ExtArgs>
    /**
     * @deprecated Use numeros_cptDefaultArgs instead
     */
    export type numeros_cptArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = numeros_cptDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}